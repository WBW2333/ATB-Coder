[
    {
        "id": 1,
        "title": "Two Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**",
            "follow_up": "Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?"
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[2,7,11,15],9",
                "output": "[0,1]"
            },
            {
                "input": "[3,2,4],6",
                "output": "[1,2]"
            },
            {
                "input": "[3,3],6",
                "output": "[0,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "python": "\n    ```python\ndef twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "js": "\n    ```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    "
    },
    {
        "id": 2,
        "title": "Palindrome Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 121\n**Output:** true\n**Explanation:** 121 reads as 121 from left to right and from right to left.\n\n",
                "**Example 2:**\n\n**Input:** x = -121\n**Output:** false\n**Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** x = 10\n**Output:** false\n**Explanation:** Reads 01 from right to left. Therefore it is not a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without converting the integer to a string?"
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "121",
                "output": "true"
            },
            {
                "input": "-121",
                "output": "false"
            },
            {
                "input": "10",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "python": "\n    ```python\ndef is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "c++": "\n    ```cpp\nbool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    "
    },
    {
        "id": 3,
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"III \"\n**Output:** 3\n**Explanation:** III = 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"LVIII \"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"MCMXCIV \"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"III\"",
                "output": "3"
            },
            {
                "input": "\"LVIII\"",
                "output": "58"
            },
            {
                "input": "\"MCMXCIV\"",
                "output": "1994"
            }
        ],
        "java": "\n    ```java\npublic int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "python": "\n    ```python\ndef roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "c++": "\n    ```cpp\nint romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "js": "\n    ```javascript\nfunction romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    "
    },
    {
        "id": 4,
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\" \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"flower \", \"flow \", \"flight \"\\]\n**Output:**  \"fl \"\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"dog \", \"racecar \", \"car \"\\]\n**Output:**  \" \"\n**Explanation:** There is no common prefix among the input strings."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Trie"
        ],
        "example": [
            {
                "input": "[\"flower\",\"flow\",\"flight\"]",
                "output": "\"fl\""
            },
            {
                "input": "[\"dog\",\"racecar\",\"car\"]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; ++j) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "python": "\n    ```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "js": "\n    ```javascript\nfunction longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n\n    for (let i = 0; i < strs[0].length; ++i) {\n        const c = strs[0][i];\n        for (let j = 1; j < strs.length; ++j) {\n            if (i === strs[j].length || strs[j][i] !== c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    "
    },
    {
        "id": 5,
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"() \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"()\\[\\]{} \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"(\\] \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of parentheses only `'()[]{}'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"()\"",
                "output": "true"
            },
            {
                "input": "\"()[]{}\"",
                "output": "true"
            },
            {
                "input": "\"(",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.peek() != '(') return false;\n            if (c == '}' && stack.peek() != '{') return false;\n            if (c == ']' && stack.peek() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "python": "\n    ```python\ndef is_valid(s: str) -> bool:\n    stack = []\n\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        else:\n            if not stack:\n                return False\n            if c == ')' and stack[-1] != '(':\n                return False\n            if c == '}' and stack[-1] != '{':\n                return False\n            if c == ']' and stack[-1] != '[':\n                return False\n            stack.pop()\n\n    return not stack\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "c++": "\n    ```cpp\nbool isValid(std::string s) {\n    std::stack<char> stack;\n\n    for (char c : s) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.top() != '(') return false;\n            if (c == '}' && stack.top() != '{') return false;\n            if (c == ']' && stack.top() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "js": "\n    ```javascript\nfunction isValid(s) {\n    const stack = [];\n\n    for (const c of s) {\n        if (c === '(' || c === '{' || c === '[') {\n            stack.push(c);\n        } else {\n            if (!stack.length) return false;\n            if (c === ')' && stack[stack.length - 1] !== '(') return false;\n            if (c === '}' && stack[stack.length - 1] !== '{') return false;\n            if (c === ']' && stack[stack.length - 1] !== '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.length === 0;\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    "
    },
    {
        "id": 6,
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn _the head of the merged linked list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** list1 = \\[1,2,4\\], list2 = \\[1,3,4\\]\n**Output:** \\[1,1,2,3,4,4\\]\n\n",
                "**Example 2:**\n\n**Input:** list1 = \\[\\], list2 = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** list1 = \\[\\], list2 = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in both lists is in the range `[0, 50]`.\n*   `-100 <= Node.val <= 100`\n*   Both `list1` and `list2` are sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,4],[1,3,4]",
                "output": "[1,1,2,3,4,4]"
            },
            {
                "input": "[],[]",
                "output": "[]"
            },
            {
                "input": "[],[0]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list1 == null) return list2;\n    if (list2 == null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n         \ndef merge_two_lists(list1, list2):\n    if list1 is None:\n        return list2\n    if list2 is None:\n        return list1\n\n    if list1.val < list2.val:\n        list1.next = merge_two_lists(list1.next, list2)\n        return list1\n    else:\n        list2.next = merge_two_lists(list1, list2.next)\n        return list2\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    ",
        "c++": "\n    ```cpp\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (list1 == nullptr) return list2;\n    if (list2 == nullptr) return list1;\n\n    if (list1->val < list2->val) {\n        list1->next = mergeTwoLists(list1->next, list2);\n        return list1;\n    } else {\n        list2->next = mergeTwoLists(list1, list2->next);\n        return list2;\n    }\n}\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    ",
        "js": "\n    ```javascript\nfunction ListNode(val, next) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n}\n\nfunction mergeTwoLists(list1, list2) {\n    if (list1 === null) return list2;\n    if (list2 === null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    "
    },
    {
        "id": 7,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.\n\nConsider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** 2, nums = \\[1,2,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,2,2,3,3,4\\]\n**Output:** 5, nums = \\[0,1,2,3,4,\\_,\\_,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-100 <= nums[i] <= 100`\n*   `nums` is sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[1,1,2]",
                "output": "2,nums=[1,2,_]"
            },
            {
                "input": "[0,0,1,1,1,2,2,3,3,4]",
                "output": "5,nums=[0,1,2,3,4,_,_,_,_,_]"
            }
        ],
        "java": "\n    ```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "python": "\n    ```python\ndef removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "c++": "\n    ```cpp\nint removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.size(); j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "js": "\n    ```javascript\nfunction removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    let i = 0;\n    for (let j = 1; j < nums.length; j++) {\n        if (nums[j] !== nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    "
    },
    {
        "id": 8,
        "title": "Remove Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint val = ...; // Value to remove\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,2,3\\], val = 3\n**Output:** 2, nums = \\[2,2,\\_,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,2,2,3,0,4,2\\], val = 2\n**Output:** 5, nums = \\[0,1,4,0,3,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 100`\n*   `0 <= nums[i] <= 50`\n*   `0 <= val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[3,2,2,3],3",
                "output": "2,nums=[2,2,_,_]"
            },
            {
                "input": "[0,1,2,2,3,0,4,2],2",
                "output": "5,nums=[0,1,4,0,3,_,_,_]"
            }
        ],
        "java": "\n    ```java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "python": "\n    ```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "c++": "\n    ```cpp\nint removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "js": "\n    ```javascript\nfunction removeElement(nums, val) {\n    let i = 0;\n    for (let j = 0; j < nums.length; j++) {\n        if (nums[j] !== val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    "
    },
    {
        "id": 9,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.",
            "examples": [
                "**Example 1:**\n\n**Input:** haystack =  \"sadbutsad \", needle =  \"sad \"\n**Output:** 0\n**Explanation:**  \"sad \" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\n",
                "**Example 2:**\n\n**Input:** haystack =  \"leetcode \", needle =  \"leeto \"\n**Output:** -1\n**Explanation:**  \"leeto \" did not occur in  \"leetcode \", so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= haystack.length, needle.length <= 104`\n*   `haystack` and `needle` consist of only lowercase English characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"sadbutsad\",\"sad\"",
                "output": "0"
            },
            {
                "input": "\"leetcode\",\"leeto\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    \n    int index = haystack.indexOf(needle);\n    return index;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "python": "\n    ```python\ndef strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "c++": "\n    ```cpp\nint strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n\n    size_t pos = haystack.find(needle);\n    if(pos != string::npos)\n        return pos;\n    return -1;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "js": "\n    ```javascript\nfunction strStr(haystack, needle) {\n    if (needle === '') return 0;\n\n    let index = haystack.indexOf(needle);\n    return index;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    "
    },
    {
        "id": 10,
        "title": "Search Insert Position",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 5\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 2\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 7\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` contains **distinct** values sorted in **ascending** order.\n*   `-104 <= target <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[1,3,5,6],5",
                "output": "2"
            },
            {
                "input": "[1,3,5,6],2",
                "output": "1"
            },
            {
                "input": "[1,3,5,6],7",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "python": "\n    ```python\ndef searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "c++": "\n    ```cpp\nint searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "js": "\n    ```javascript\nfunction searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    "
    },
    {
        "id": 11,
        "title": "Length of Last Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello World \"\n**Output:** 5\n**Explanation:** The last word is  \"World \" with length 5.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"   fly me   to   the moon   \"\n**Output:** 4\n**Explanation:** The last word is  \"moon \" with length 4.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"luffy is still joyboy \"\n**Output:** 6\n**Explanation:** The last word is  \"joyboy \" with length 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only English letters and spaces `' '`.\n*   There will be at least one word in `s`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"HelloWorld\"",
                "output": "5"
            },
            {
                "input": "\"flymetothemoon\"",
                "output": "4"
            },
            {
                "input": "\"luffyisstilljoyboy\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "python": "\n    ```python\ndef length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    "
    },
    {
        "id": 12,
        "title": "Plus One",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits = \\[1,2,3\\]\n**Output:** \\[1,2,4\\]\n**Explanation:** The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be \\[1,2,4\\].\n\n",
                "**Example 2:**\n\n**Input:** digits = \\[4,3,2,1\\]\n**Output:** \\[4,3,2,2\\]\n**Explanation:** The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be \\[4,3,2,2\\].\n\n",
                "**Example 3:**\n\n**Input:** digits = \\[9\\]\n**Output:** \\[1,0\\]\n**Explanation:** The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be \\[1,0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= digits.length <= 100`\n*   `0 <= digits[i] <= 9`\n*   `digits` does not contain any leading `0`'s.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "[1,2,4]"
            },
            {
                "input": "[4,3,2,1]",
                "output": "[4,3,2,2]"
            },
            {
                "input": "[9]",
                "output": "[1,0]"
            }
        ],
        "java": "\n    ```java\npublic int[] plusOne(int[] digits) {\n    int n = digits.length;\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    int[] newDigits = new int[n + 1];\n    newDigits[0] = 1;\n    return newDigits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "python": "\n    ```python\ndef plusOne(digits: List[int]) -> List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n\n    digits.insert(0, 1)\n    return digits\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> plusOne(std::vector<int>& digits) {\n    int n = digits.size();\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "js": "\n    ```javascript\nfunction plusOne(digits) {\n    let n = digits.length;\n\n    for(let i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.unshift(1);\n    return digits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    "
    },
    {
        "id": 13,
        "title": "Add Binary",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two binary strings `a` and `b`, return _their sum as a binary string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = \"11\", b = \"1\"\n**Output:** \"100\"\n\n",
                "**Example 2:**\n\n**Input:** a = \"1010\", b = \"1011\"\n**Output:** \"10101\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a.length, b.length <= 104`\n*   `a` and `b` consist only of `'0'` or `'1'` characters.\n*   Each string does not contain leading zeros except for the zero itself.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Bit Manipulation",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"11\",\"1\"",
                "output": "\"100\""
            },
            {
                "input": "\"1010\",\"1011\"",
                "output": "\"10101\""
            }
        ],
        "java": "\n    ```java\npublic String addBinary(String a, String b) {\n    StringBuilder result = new StringBuilder();\n    int i = a.length() - 1, j = b.length() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry != 0) {\n        if (i >= 0) carry += a.charAt(i--) - '0';\n        if (j >= 0) carry += b.charAt(j--) - '0';\n        result.insert(0, carry % 2);\n        carry /= 2;\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "python": "\n    ```python\ndef addBinary(a: str, b: str) -> str:\n    result, carry, i, j = \"\", 0, len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        if i >= 0:\n            carry += int(a[i])\n            i -= 1\n        if j >= 0:\n            carry += int(b[j])\n            j -= 1\n        result = str(carry % 2) + result\n        carry //= 2\n    return result\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "c++": "\n    ```cpp\nstd::string addBinary(std::string a, std::string b) {\n    std::string result = \"\";\n    int i = a.size() - 1, j = b.size() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += a[i--] - '0';\n        if (j >= 0) carry += b[j--] - '0';\n        result = char(carry % 2 + '0') + result;\n        carry /= 2;\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "js": "\n    ```javascript\nfunction addBinary(a, b) {\n    let result = \"\";\n    let i = a.length - 1, j = b.length - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += parseInt(a[i--], 10);\n        if (j >= 0) carry += parseInt(b[j--], 10);\n        result = (carry % 2) + result;\n        carry = Math.floor(carry / 2);\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    "
    },
    {
        "id": 14,
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "content": {
            "problem": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 45`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "2",
                "output": "2"
            },
            {
                "input": "3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "python": "\n    ```python\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "c++": "\n    ```cpp\nint climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "js": "\n    ```javascript\nfunction climbStairs(n) {\n    if(n <= 2) return n;\n    let a = 1, b = 2, c;\n    for(let i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    "
    },
    {
        "id": 15,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a sorted linked list, _delete all duplicates such that each element appears only once_. Return _the linked list **sorted** as well_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,1,2\\]\n**Output:** \\[1,2\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,1,2,3,3\\]\n**Output:** \\[1,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 300]`.\n*   `-100 <= Node.val <= 100`\n*   The list is guaranteed to be **sorted** in ascending order.",
            "follow_up": null
        },
        "tag": [
            "Linked List"
        ],
        "example": [
            {
                "input": "[1,1,2]",
                "output": "[1,2]"
            },
            {
                "input": "[1,1,2,3,3]",
                "output": "[1,2,3]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode current = head;\n    while (current != null && current.next != null) {\n        if (current.next.val == current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef delete_duplicates(head):\n    current = head\n    while current and current.next:\n        if current.next.val == current.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* deleteDuplicates(ListNode* head) {\n    ListNode* current = head;\n    while (current && current->next) {\n        if (current->next->val == current->val) {\n            ListNode* temp = current->next;\n            current->next = temp->next;\n            delete temp;\n        } else {\n            current = current->next;\n        }\n    }\n    return head;\n}\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction deleteDuplicates(head) {\n    let current = head;\n    while (current && current.next) {\n        if (current.next.val === current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    "
    },
    {
        "id": 16,
        "title": "Merge Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\n\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
            ],
            "constraints": "**Constraints:**\n\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n\n**",
            "follow_up": "Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3,0,0,0],3,[2,5,6],3",
                "output": "[1,2,2,3,5,6]"
            },
            {
                "input": "[1],1,[],0",
                "output": "[1]"
            },
            {
                "input": "[0],0,[1],1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "python": "\n    ```python\ndef merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "c++": "\n    ```cpp\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "js": "\n    ```javascript\nfunction merge(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    "
    },
    {
        "id": 17,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the inorder traversal of its nodes' values_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,3,2\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,3]",
                "output": "[1,3,2]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    inorderTraversalHelper(root, result);\n    return result;\n}\n\nprivate void inorderTraversalHelper(TreeNode root, List<Integer> result) {\n    if (root == null) {\n        return;\n    }\n    inorderTraversalHelper(root.left, result);\n    result.add(root.val);\n    inorderTraversalHelper(root.right, result);\n}\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversalHelper(root, result):\n    if not root:\n        return\n    inorderTraversalHelper(root.left, result)\n    result.append(root.val)\n    inorderTraversalHelper(root.right, result)\n\ndef inorderTraversal(root):\n    result = []\n    inorderTraversalHelper(root, result)\n    return result\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvoid inorderTraversalHelper(TreeNode* root, vector<int>& result) {\n    if (!root) return;\n    inorderTraversalHelper(root->left, result);\n    result.push_back(root->val);\n    inorderTraversalHelper(root->right, result);\n}\n\nvector<int> inorderTraversal(TreeNode* root){\n    vector<int> result;\n    inorderTraversalHelper(root, result);\n    return result;\n}\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null){\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorderTraversalHelper(root, result) {\n    if (!root) return;\n    inorderTraversalHelper(root.left, result);\n    result.push(root.val);\n    inorderTraversalHelper(root.right, result);\n}\n\nfunction inorderTraversal(root) {\n    let result = [];\n    inorderTraversalHelper(root, result);\n    return result;\n}\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    "
    },
    {
        "id": 18,
        "title": "Same Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
            "examples": [
                "**Example 1:**\n\n**Input:** p = \\[1,2,3\\], q = \\[1,2,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** p = \\[1,2\\], q = \\[1,null,2\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** p = \\[1,2,1\\], q = \\[1,1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 100]`.\n*   `-104 <= Node.val <= 104`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3],[1,2,3]",
                "output": "true"
            },
            {
                "input": "[1,2],[1,null,2]",
                "output": "false"
            },
            {
                "input": "[1,2,1],[1,1,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) {\n        return true;\n    }\n    if (p == null || q == null) {\n        return false;\n    }\n    if (p.val != q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p == nullptr && q == nullptr) {\n        return true;\n    }\n    if (p == nullptr || q == nullptr) {\n        return false;\n    }\n    if (p->val != q->val) {\n        return false;\n    }\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isSameTree(p, q) {\n    if (p === null && q === null) {\n        return true;\n    }\n    if (p === null || q === null) {\n        return false;\n    }\n    if (p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    "
    },
    {
        "id": 19,
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,2,3,4,4,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,2,null,3,null,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Could you solve it both recursively and iteratively?"
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,2,3,4,4,3]",
                "output": "true"
            },
            {
                "input": "[1,2,2,null,3,null,3]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isSymmetric(TreeNode root) {\n    return checkSymmetry(root, root);\n}\n\npublic boolean checkSymmetry(TreeNode node1, TreeNode node2) {\n    if (node1 == null && node2 == null) return true;\n    if (node1 == null || node2 == null) return false;\n    return (node1.val == node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "python": "\n    ```python\ndef isSymmetric(root):\n    return checkSymmetry(root, root)\n\ndef checkSymmetry(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "c++": "\n    ```cpp\nbool isSymmetric(TreeNode* root) {\n    return checkSymmetry(root, root);\n}\n\nbool checkSymmetry(TreeNode* node1, TreeNode* node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1->val == node2->val) && checkSymmetry(node1->right, node2->left) && checkSymmetry(node1->left, node2->right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "js": "\n    ```javascript\nfunction isSymmetric(root) {\n    return checkSymmetry(root, root);\n}\n\nfunction checkSymmetry(node1, node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1.val === node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    "
    },
    {
        "id": 20,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "3"
            },
            {
                "input": "[1,null,2]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "python": "\n    ```python\ndef maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "c++": "\n    ```cpp\nint maxDepth(TreeNode* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "js": "\n    ```javascript\nfunction maxDepth(root) {\n    if (root === null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    "
    },
    {
        "id": 21,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a_ **_height-balanced_** _binary search tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-10,-3,0,5,9\\]\n**Output:** \\[0,-3,9,-10,null,5\\]\n**Explanation:** \\[0,-10,5,null,-3,null,9\\] is also accepted:\n \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3\\]\n**Output:** \\[3,1\\]\n**Explanation:** \\[1,null,3\\] and \\[3,1\\] are both height-balanced BSTs."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in a **strictly increasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[-10,-3,0,5,9]",
                "output": "[0,-3,9,-10,null,5]"
            },
            {
                "input": "[1,3]",
                "output": "[3,1]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return sortedArrayToBST(nums, 0, nums.length - 1);\n}\n\nprivate TreeNode sortedArrayToBST(int[] nums, int start, int end) {\n    if (start > end) return null;\n\n    int mid = start + (end - start) / 2;\n    TreeNode node = new TreeNode(nums[mid]);\n    node.left = sortedArrayToBST(nums, start, mid - 1);\n    node.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sorted_array_to_bst(nums):\n    def helper(start, end):\n        if start > end:\n            return None\n\n        mid = start + (end - start) // 2\n        node = TreeNode(nums[mid])\n        node.left = helper(start, mid - 1)\n        node.right = helper(mid + 1, end)\n\n        return node\n\n    return helper(0, len(nums) - 1)\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* sortedArrayToBST(std::vector<int>& nums, int start, int end) {\n    if (start > end) return nullptr;\n\n    int mid = start + (end - start) / 2;\n    TreeNode* node = new TreeNode(nums[mid]);\n    node->left = sortedArrayToBST(nums, start, mid - 1);\n    node->right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n\nTreeNode* sortedArrayToBST(std::vector<int>& nums) {\n    return sortedArrayToBST(nums, 0, nums.size() - 1);\n}\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction sortedArrayToBST(nums, start = 0, end = nums.length - 1) {\n    if (start > end) return null;\n\n    let mid = start + Math.floor((end - start) / 2);\n    let node = new TreeNode(nums[mid]);\n    node.left = sortedArrayToBST(nums, start, mid - 1);\n    node.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    "
    },
    {
        "id": 22,
        "title": "Balanced Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary tree, determine if it is **height-balanced**.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,2,3,3,null,null,4,4\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-104 <= Node.val <= 104`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "true"
            },
            {
                "input": "[1,2,2,3,3,null,null,4,4]",
                "output": "false"
            },
            {
                "input": "[]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int getHeight(TreeNode node) {\n    if (node == null) return 0;\n    int leftHeight = getHeight(node.left);\n    int rightHeight = getHeight(node.right);\n    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\npublic boolean isBalanced(TreeNode root) {\n    return getHeight(root) != -1;\n}\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef getHeight(node):\n    if not node:\n        return 0\n    left_height = getHeight(node.left)\n    right_height = getHeight(node.right)\n    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n        return -1\n    return 1 + max(left_height, right_height)\n\ndef isBalanced(root):\n    return getHeight(root) != -1\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint getHeight(TreeNode* node) {\n    if (!node) return 0;\n    int leftHeight = getHeight(node->left);\n    int rightHeight = getHeight(node->right);\n    if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + max(leftHeight, rightHeight);\n}\n\nbool isBalanced(TreeNode* root) {\n    return getHeight(root) != -1;\n}\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction getHeight(node) {\n    if (!node) return 0;\n    let leftHeight = getHeight(node.left);\n    let rightHeight = getHeight(node.right);\n    if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\nfunction isBalanced(root) {\n    return getHeight(root) !== -1;\n}\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    "
    },
    {
        "id": 23,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n**Note:** A leaf is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "2"
            },
            {
                "input": "[2,null,3,null,4,null,5,null,6]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minDepth(TreeNode root) {\n    if (root == null) return 0;\n    int left = minDepth(root.left);\n    int right = minDepth(root.right);\n    return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "python": "\n    ```python\ndef minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "c++": "\n    ```cpp\nint minDepth(TreeNode* root) {\n    if (!root) return 0;\n    int left = minDepth(root->left);\n    int right = minDepth(root->right);\n    return (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "js": "\n    ```javascript\nfunction minDepth(root) {\n    if (!root) return 0;\n    let left = minDepth(root.left);\n    let right = minDepth(root.right);\n    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    "
    },
    {
        "id": 24,
        "title": "Path Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\n\nA **leaf** is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[5,4,8,11,null,13,4,7,2,null,null,null,1],22",
                "output": "true"
            },
            {
                "input": "[1,2,3],5",
                "output": "false"
            },
            {
                "input": "[],0",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n    if (root.left == null && root.right == null) return targetSum - root.val == 0;\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return targetSum - root.val == 0\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nbool hasPathSum(TreeNode* root, int targetSum) {\n    if (!root) return false;\n    if (!root->left && !root->right) return targetSum - root->val == 0;\n    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\n}\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction hasPathSum(root, targetSum) {\n    if (!root) return false;\n    if (!root.left && !root.right) return targetSum - root.val === 0;\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    "
    },
    {
        "id": 25,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[7,1,5,3,6,4]",
                "output": "5"
            },
            {
                "input": "[7,6,4,3,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    "
    },
    {
        "id": 26,
        "title": "Valid Palindrome",
        "difficulty": "Easy",
        "content": {
            "problem": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"A man, a plan, a canal: Panama \"\n**Output:** true\n**Explanation:**  \"amanaplanacanalpanama \" is a palindrome.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"race a car \"\n**Output:** false\n**Explanation:**  \"raceacar \" is not a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"  \"\n**Output:** true\n**Explanation:** s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"Aman,",
                "output": "true"
            },
            {
                "input": "\"raceacar\"",
                "output": "false"
            },
            {
                "input": "\"\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isPalindrome(String s) {\n    StringBuilder cleaned = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            cleaned.append(Character.toLowerCase(c));\n        }\n    }\n    int left = 0, right = cleaned.length() - 1;\n    while (left < right) {\n        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "python": "\n    ```python\ndef isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\n\nbool isPalindrome(std::string s) {\n    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(s) {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    let left = 0, right = cleaned.length - 1;\n    while (left < right) {\n        if (cleaned[left++] !== cleaned[right--]) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    "
    },
    {
        "id": 27,
        "title": "Single Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,2,1\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,1,2,1,2\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`\n*   Each element in the array appears twice except for one element which appears only once.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[2,2,1]",
                "output": "1"
            },
            {
                "input": "[4,1,2,1,2]",
                "output": "4"
            },
            {
                "input": "[1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int singleNumber(int[] nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "python": "\n    ```python\ndef singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "c++": "\n    ```cpp\nint singleNumber(vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "js": "\n    ```javascript\nfunction singleNumber(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    "
    },
    {
        "id": 28,
        "title": "Linked List Cycle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n\n",
                "**Example 3:**\n\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list."
            ],
            "constraints": "**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**",
            "follow_up": "Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?"
        },
        "tag": [
            "Hash Table",
            "Linked List",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[3,2,0,-4],1",
                "output": "true"
            },
            {
                "input": "[1,2],0",
                "output": "true"
            },
            {
                "input": "[1],-1",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "python": "\n    ```python\ndef hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool hasCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "js": "\n    ```javascript\nfunction hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    "
    },
    {
        "id": 29,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,3]",
                "output": "[1,2,3]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    \n    if (root == null) {\n        return result;\n    }\n    \n    result.add(root.val);\n    result.addAll(preorderTraversal(root.left));\n    result.addAll(preorderTraversal(root.right));\n \n    return result;\n}\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef preorderTraversal(root):\n    if root is None:\n        return []\n        \n    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<int> preorderTraversal(TreeNode* root) {\n    std::vector<int> result;\n    if (root == nullptr) {\n        return result;\n    }\n    \n    result.push_back(root->val);\n    std::vector<int> left = preorderTraversal(root->left);\n    std::vector<int> right = preorderTraversal(root->right);\n    \n    result.insert(result.end(), left.begin(), left.end());\n    result.insert(result.end(), right.begin(), right.end());\n    \n    return result;\n}\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction preorderTraversal(root) {\n    if (!root) {\n        return [];\n    }\n    \n    let result = [root.val];\n    result = result.concat(preorderTraversal(root.left));\n    result = result.concat(preorderTraversal(root.right));\n    \n    return result;\n}\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    "
    },
    {
        "id": 30,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the postorder traversal of its nodes' values_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[3,2,1\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of the nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,3]",
                "output": "[3,2,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Stack<TreeNode> s = new Stack<>();\n\n    if (root == null) return result;\n\n    s.push(root);\n    while (!s.isEmpty()) {\n        TreeNode current = s.pop();\n        result.add(0, current.val);\n        if (current.left != null) s.push(current.left);\n        if (current.right != null) s.push(current.right);\n    }\n\n    return result;\n}\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef postorderTraversal(root):\n    if not root:\n        return []\n\n    result = []\n    s = [root]\n    while s:\n        current = s.pop()\n        result.insert(0, current.val)\n        if current.left:\n            s.append(current.left)\n        if current.right:\n            s.append(current.right)\n\n    return result\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> postorderTraversal(TreeNode* root) {\n    vector<int> result;\n    stack<TreeNode*> s;\n\n    if (!root) return result;\n\n    s.push(root);\n    while (!s.empty()) {\n        TreeNode *current = s.top();\n        s.pop();\n        result.insert(result.begin(), current->val);\n        if (current->left) s.push(current->left);\n        if (current->right) s.push(current->right);\n    }\n\n    return result;\n}\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction postorderTraversal(root) {\n    if (!root) {\n        return [];\n    }\n\n    let result = [];\n    let s = [root];\n    while (s.length) {\n        let current = s.pop();\n        result.unshift(current.val);\n        if (current.left) {\n            s.push(current.left);\n        }\n        if (current.right) {\n            s.push(current.right);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    "
    },
    {
        "id": 31,
        "title": "Intersection of Two Linked Lists",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the heads of two singly linked-lists `headA` and `headB`, return _the node at which the two lists intersect_. If the two linked lists have no intersection at all, return `null`.\n\nFor example, the following two linked lists begin to intersect at node `c1`:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n**Note** that the linked lists must **retain their original structure** after the function returns.\n\n**Custom Judge:**\n\nThe inputs to the **judge** are given as follows (your program is **not** given these inputs):\n\n*   `intersectVal` - The value of the node where the intersection occurs. This is `0` if there is no intersected node.\n*   `listA` - The first linked list.\n*   `listB` - The second linked list.\n*   `skipA` - The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.\n*   `skipB` - The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, `headA` and `headB` to your program. If you correctly return the intersected node, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** intersectVal = 8, listA = \\[4,1,8,4,5\\], listB = \\[5,6,1,8,4,5\\], skipA = 2, skipB = 3\n**Output:** Intersected at '8'\n**Explanation:** The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as \\[4,1,8,4,5\\]. From the head of B, it reads as \\[5,6,1,8,4,5\\]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n\n",
                "**Example 2:**\n\n**Input:** intersectVal = 2, listA = \\[1,9,1,2,4\\], listB = \\[3,2,4\\], skipA = 3, skipB = 1\n**Output:** Intersected at '2'\n**Explanation:** The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as \\[1,9,1,2,4\\]. From the head of B, it reads as \\[3,2,4\\]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n",
                "**Example 3:**\n\n**Input:** intersectVal = 0, listA = \\[2,6,4\\], listB = \\[1,5\\], skipA = 3, skipB = 2\n**Output:** No intersection\n**Explanation:** From the head of A, it reads as \\[2,6,4\\]. From the head of B, it reads as \\[1,5\\]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes of `listA` is in the `m`.\n*   The number of nodes of `listB` is in the `n`.\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= Node.val <= 105`\n*   `0 <= skipA < m`\n*   `0 <= skipB < n`\n*   `intersectVal` is `0` if `listA` and `listB` do not intersect.\n*   `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.\n\n**",
            "follow_up": "Follow up:** Could you write a solution that runs in `O(m + n)` time and use only `O(1)` memory?"
        },
        "tag": [
            "Hash Table",
            "Linked List",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "8,[4,1,8,4,5],[5,6,1,8,4,5],2,3",
                "output": "Intersectedat'8'"
            },
            {
                "input": "2,[1,9,1,2,4],[3,2,4],3,1",
                "output": "Intersectedat'2'"
            },
            {
                "input": "0,[2,6,4],[1,5],3,2",
                "output": "Nointersection"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n        next = null;\n    }\n}\n\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode pA = headA, pB = headB;\n    while (pA != pB) {\n        pA = pA != null ? pA.next : headB;\n        pB = pB != null ? pB.next : headA;\n    }\n    return pA;\n}\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef getIntersectionNode(headA, headB):\n    pA, pB = headA, headB\n    while pA is not pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    return pA\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode *pA = headA, *pB = headB;\n    while (pA != pB) {\n        pA = pA ? pA->next : headB;\n        pB = pB ? pB->next : headA;\n    }\n    return pA;\n}\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction getIntersectionNode(headA, headB) {\n    let pA = headA, pB = headB;\n    while (pA !== pB) {\n        pA = pA !== null ? pA.next : headB;\n        pB = pB !== null ? pB.next : headA;\n    }\n    return pA;\n}\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    "
    },
    {
        "id": 32,
        "title": "Excel Sheet Column Title",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `columnNumber`, return _its corresponding column title as it appears in an Excel sheet_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
            "examples": [
                "**Example 1:**\n\n**Input:** columnNumber = 1\n**Output:**  \"A \"\n\n",
                "**Example 2:**\n\n**Input:** columnNumber = 28\n**Output:**  \"AB \"\n\n",
                "**Example 3:**\n\n**Input:** columnNumber = 701\n**Output:**  \"ZY \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= columnNumber <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "1",
                "output": "\"A\""
            },
            {
                "input": "28",
                "output": "\"AB\""
            },
            {
                "input": "701",
                "output": "\"ZY\""
            }
        ],
        "java": "\n    ```java\npublic String convertToTitle(int columnNumber) {\n    StringBuilder result = new StringBuilder();\n    while (columnNumber > 0) {\n        columnNumber--;\n        result.insert(0, (char) ('A' + columnNumber % 26));\n        columnNumber /= 26;\n    }\n    return result.toString();\n}\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "python": "\n    ```python\ndef convert_to_title(columnNumber: int) -> str:\n    result = \"\"\n    while columnNumber:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string convertToTitle(int columnNumber) {\n    std::string result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = (char)(columnNumber % 26 + 'A') + result;\n        columnNumber /= 26;\n    }\n    return result;\n}\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "js": "\n    ```javascript\nfunction convertToTitle(columnNumber) {\n    let result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt(0)) + result;\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    "
    },
    {
        "id": 33,
        "title": "Majority Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `n / 2` times. You may assume that the majority element always exists in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,1,1,1,2,2\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**",
            "follow_up": "Follow-up:** Could you solve the problem in linear time and in `O(1)` space?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[3,2,3]",
                "output": "3"
            },
            {
                "input": "[2,2,1,1,1,2,2]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int majorityElement(int[] nums) {\n    int count = 0;\n    Integer candidate = null;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "python": "\n    ```python\ndef majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "c++": "\n    ```cpp\nint majorityElement(vector<int>& nums) {\n    int count = 0;\n    int candidate;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "js": "\n    ```javascript\nfunction majorityElement(nums) {\n    let count = 0;\n    let candidate = null;\n\n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        count += (num === candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    "
    },
    {
        "id": 34,
        "title": "Excel Sheet Column Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return _its corresponding column number_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
            "examples": [
                "**Example 1:**\n\n**Input:** columnTitle =  \"A \"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** columnTitle =  \"AB \"\n**Output:** 28\n\n",
                "**Example 3:**\n\n**Input:** columnTitle =  \"ZY \"\n**Output:** 701"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= columnTitle.length <= 7`\n*   `columnTitle` consists only of uppercase English letters.\n*   `columnTitle` is in the range `[ \"A \", \"FXSHRXW \"]`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"A\"",
                "output": "1"
            },
            {
                "input": "\"AB\"",
                "output": "28"
            },
            {
                "input": "\"ZY\"",
                "output": "701"
            }
        ],
        "java": "\n    ```java\npublic int titleToNumber(String columnTitle) {\n    int result = 0;\n    for (char c : columnTitle.toCharArray()) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "python": "\n    ```python\ndef title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "c++": "\n    ```cpp\nint titleToNumber(string columnTitle) {\n    int result = 0;\n    for (char c : columnTitle) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "js": "\n    ```javascript\nfunction titleToNumber(columnTitle) {\n    let result = 0;\n    for (let c of columnTitle) {\n        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    "
    },
    {
        "id": 35,
        "title": "Reverse Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Reverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n\n",
                "**Example 2:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:**   3221225471 (10111111111111111111111111111111)\n**Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**."
            ],
            "constraints": "**Constraints:**\n\n*   The input must be a **binary string** of length `32`\n\n**",
            "follow_up": "Follow up:** If this function is called many times, how would you optimize it?"
        },
        "tag": [
            "Divide and Conquer",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "00000010100101000001111010011100",
                "output": "964176192(00111001011110000010100101000000)"
            },
            {
                "input": "11111111111111111111111111111101",
                "output": "3221225471(10111111111111111111111111111111)"
            }
        ],
        "java": "\n    ```java\npublic int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "python": "\n    ```python\ndef reverse_bits(n: int) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "c++": "\n    ```cpp\nunsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "js": "\n    ```javascript\nfunction reverseBits(n) {\n    let res = 0;\n    for (let i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res >>> 0;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    "
    },
    {
        "id": 36,
        "title": "Number of 1 Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 00000000000000000000000000001011\n**Output:** 3\n**Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n\n",
                "**Example 2:**\n\n**Input:** n = 00000000000000000000000010000000\n**Output:** 1\n**Explanation:** The input binary string **00000000000000000000000010000000** has a total of one '1' bit.\n\n",
                "**Example 3:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:** 31\n**Explanation:** The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits."
            ],
            "constraints": "**Constraints:**\n\n*   The input must be a **binary string** of length `32`.\n\n**",
            "follow_up": "Follow up:** If this function is called many times, how would you optimize it?"
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "00000000000000000000000000001011",
                "output": "3"
            },
            {
                "input": "00000000000000000000000010000000",
                "output": "1"
            },
            {
                "input": "11111111111111111111111111111101",
                "output": "31"
            }
        ],
        "java": "\n    ```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "python": "\n    ```python\ndef hamming_weight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "c++": "\n    ```cpp\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "js": "\n    ```javascript\nfunction hammingWeight(n) {\n    let count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    "
    },
    {
        "id": 37,
        "title": "Happy Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Write an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 19\n**Output:** true\n**Explanation:**\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "19",
                "output": "true"
            },
            {
                "input": "2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\npublic boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "python": "\n    ```python\ndef get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "c++": "\n    ```cpp\nint getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "js": "\n    ```javascript\nfunction getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n, fast = getNext(n);\n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast === 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    "
    },
    {
        "id": 38,
        "title": "Remove Linked List Elements",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return _the new head_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,6,3,4,5,6\\], val = 6\n**Output:** \\[1,2,3,4,5\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[\\], val = 1\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** head = \\[7,7,7,7\\], val = 7\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 104]`.\n*   `1 <= Node.val <= 50`\n*   `0 <= val <= 50`",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,6,3,4,5,6],6",
                "output": "[1,2,3,4,5]"
            },
            {
                "input": "[],1",
                "output": "[]"
            },
            {
                "input": "[7,7,7,7],7",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode removeElements(ListNode head, int val) {\n    ListNode sentinel = new ListNode(0);\n    sentinel.next = head;\n    ListNode prev = sentinel, curr = head;\n\n    while (curr != null) {\n        if (curr.val == val) {\n            prev.next = curr.next;\n        } else {\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n\n    return sentinel.next;\n}\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_elements(head, val):\n    sentinel = ListNode(0)\n    sentinel.next = head\n    prev, curr = sentinel, head\n\n    while curr:\n        if curr.val == val:\n            prev.next = curr.next\n        else:\n            prev = curr\n        curr = curr.next\n\n    return sentinel.next\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* removeElements(ListNode* head, int val) {\n    ListNode** current = &head;\n\n    while (*current != NULL) {\n        if ((*current)->val == val) {\n            ListNode* next = (*current)->next;\n            delete *current;\n            *current = next;\n        } else {\n            current = &(*current)->next;\n        }\n    }\n\n    return head;\n}\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction removeElements(head, val) {\n    let sentinel = new ListNode(0);\n    sentinel.next = head;\n    let prev = sentinel, curr = head;\n\n    while (curr !== null) {\n        if (curr.val === val) {\n            prev.next = curr.next;\n        } else {\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n\n    return sentinel.next;\n}\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    "
    },
    {
        "id": 39,
        "title": "Isomorphic Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"egg\", t = \"add\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"foo\", t = \"bar\"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s = \"paper\", t = \"title\"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `t.length == s.length`\n*   `s` and `t` consist of any valid ascii character.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"egg\",\"add\"",
                "output": "true"
            },
            {
                "input": "\"foo\",\"bar\"",
                "output": "false"
            },
            {
                "input": "\"paper\",\"title\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "python": "\n    ```python\ndef is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "js": "\n    ```javascript\nfunction isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    "
    },
    {
        "id": 40,
        "title": "Reverse Linked List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[5,4,3,2,1\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** \\[2,1\\]\n\n",
                "**Example 3:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n\n**",
            "follow_up": "Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?"
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5]",
                "output": "[5,4,3,2,1]"
            },
            {
                "input": "[1,2]",
                "output": "[2,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n}\n\npublic ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode current = head;\n    ListNode next = null;\n    while (current != null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n};\n\nListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    ListNode* next = nullptr;\n    while (current != nullptr) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseList(head) {\n    let prev = null;\n    let current = head;\n    let next = null;\n    while (current !== null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    "
    },
    {
        "id": 41,
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,3,3,4,3,2,4,2\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3,1]",
                "output": "true"
            },
            {
                "input": "[1,2,3,4]",
                "output": "false"
            },
            {
                "input": "[1,1,1,3,3,4,3,2,4,2]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction containsDuplicate(nums) {\n    const set = new Set();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    "
    },
    {
        "id": 42,
        "title": "Contains Duplicate II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return `true` _if there are two **distinct indices**_ `i` _and_ `j` _in the array such that_ `nums[i] == nums[j]` _and_ `abs(i - j) <= k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], k = 3\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1\\], k = 1\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,1,2,3\\], k = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `0 <= k <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[1,2,3,1],3",
                "output": "true"
            },
            {
                "input": "[1,0,1,1],1",
                "output": "true"
            },
            {
                "input": "[1,2,3,1,2,3],2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.put(nums[i], i);\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "python": "\n    ```python\ndef containsNearbyDuplicate(nums, k):\n    value_index_map = {}\n    for i, num in enumerate(nums):\n        if num in value_index_map and i - value_index_map[num] <= k:\n            return True\n        value_index_map[num] = i\n    return False\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "c++": "\n    ```cpp\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int, int> valueIndexMap;\n    for (int i = 0; i < nums.size(); i++) {\n        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {\n            return true;\n        }\n        valueIndexMap[nums[i]] = i;\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "js": "\n    ```javascript\nfunction containsNearbyDuplicate(nums, k) {\n    const valueIndexMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (valueIndexMap.has(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.set(nums[i], i);\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    "
    },
    {
        "id": 43,
        "title": "Implement Stack using Queues",
        "difficulty": "Easy",
        "content": {
            "problem": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).\n\nImplement the `MyStack` class:\n\n*   `void push(int x)` Pushes element x to the top of the stack.\n*   `int pop()` Removes the element on the top of the stack and returns it.\n*   `int top()` Returns the element on the top of the stack.\n*   `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.\n\n**Notes:**\n\n*   You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.\n*   Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyStack \",  \"push \",  \"push \",  \"top \",  \"pop \",  \"empty \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 2, 2, false\\]\n\n**Explanation**\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= x <= 9`\n*   At most `100` calls will be made to `push`, `pop`, `top`, and `empty`.\n*   All the calls to `pop` and `top` are valid.\n\n**",
            "follow_up": "Follow-up:** Can you implement the stack using only one queue?"
        },
        "tag": [
            "Stack",
            "Design",
            "Queue"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,2,2,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass MyStack {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n\n    public void push(int x) {\n        q2.add(x);\n        while (!q1.isEmpty()) {\n            q2.add(q1.remove());\n        }\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n\n    public int pop() {\n        return q1.remove();\n    }\n\n    public int top() {\n        return q1.peek();\n    }\n\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n\nclass MyStack {\npublic:\n    std::queue<int> q1, q2;\n\n    void push(int x) {\n        q2.push(x);\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        std::swap(q1, q2);\n    }\n\n    int pop() {\n        int top = q1.front();\n        q1.pop();\n        return top;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n};\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    ",
        "js": "\n    ```javascript\nclass MyStack {\n    constructor() {\n        this.q1 = [];\n        this.q2 = [];\n    }\n\n    push(x) {\n        this.q2.push(x);\n        while (this.q1.length > 0) {\n            this.q2.push(this.q1.shift());\n        }\n        [this.q1, this.q2] = [this.q2, this.q1];\n    }\n\n    pop() {\n        return this.q1.shift();\n    }\n\n    top() {\n        return this.q1[0];\n    }\n\n    empty() {\n        return this.q1.length === 0;\n    }\n}\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    "
    },
    {
        "id": 44,
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, invert the tree, and return _its root_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3,6,9\\]\n**Output:** \\[4,7,2,9,6,3,1\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,3,1\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[4,2,7,1,3,6,9]",
                "output": "[4,7,2,9,6,3,1]"
            },
            {
                "input": "[2,1,3]",
                "output": "[2,3,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode invertTree(TreeNode root) {\n    if (root == null) {\n        return null;\n    }    \n    TreeNode temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    return root;\n}\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invert_tree(root):\n    if root is None:\n        return None\n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* invertTree(TreeNode* root) {\n    if (root == nullptr) {\n        return nullptr;\n    }    \n    TreeNode* temp = root->left;\n    root->left = invertTree(root->right);\n    root->right = invertTree(temp);\n    return root;\n}\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction invertTree(root) {\n    if (root === null) {\n        return null;\n    }\n    let temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    return root;\n}\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    "
    },
    {
        "id": 45,
        "title": "Summary Ranges",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **sorted unique** integer array `nums`.\n\nA **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive).\n\nReturn _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,4,5,7\\]\n**Output:** \\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n**Explanation:** The ranges are:\n\\[0,2\\] -->  \"0->2 \"\n\\[4,5\\] -->  \"4->5 \"\n\\[7,7\\] -->  \"7 \"\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,2,3,4,6,8,9\\]\n**Output:** \\[ \"0 \", \"2->4 \", \"6 \", \"8->9 \"\\]\n**Explanation:** The ranges are:\n\\[0,0\\] -->  \"0 \"\n\\[2,4\\] -->  \"2->4 \"\n\\[6,6\\] -->  \"6 \"\n\\[8,9\\] -->  \"8->9 \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 20`\n*   `-231 <= nums[i] <= 231 - 1`\n*   All the values of `nums` are **unique**.\n*   `nums` is sorted in ascending order.",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[0,1,2,4,5,7]",
                "output": "[\"0->2\",\"4->5\",\"7\"]"
            },
            {
                "input": "[0,2,3,4,6,8,9]",
                "output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums) {\n    List<String> result = new ArrayList<>();\n    int n = nums.length;\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.add(Integer.toString(start));\n            else\n                result.add(start + \"->\" + nums[i-1]);\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.add(Integer.toString(start));\n    else\n        result.add(start + \"->\" + nums[n-1]);\n\n    return result;\n}\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums) {\n    std::vector<std::string> result;\n    int n = nums.size();\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.push_back(std::to_string(start));\n            else\n                result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i-1]));\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.push_back(std::to_string(start));\n    else\n        result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[n-1]));\n\n    return result;\n}\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    ",
        "js": "\n    ```javascript\nfunction findRanges(nums) {\n    const result = [];\n    const n = nums.length;\n    if (n === 0) return result;\n\n    let start = nums[0];\n    for (let i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1] + 1) {\n            if (start === nums[i - 1])\n                result.push(`${start}`);\n            else\n                result.push(`${start}->${nums[i - 1]}`);\n            start = nums[i];\n        }\n    }\n\n    if (start === nums[n - 1])\n        result.push(`${start}`);\n    else\n        result.push(`${start}->${nums[n - 1]}`);\n\n    return result;\n}\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    "
    },
    {
        "id": 46,
        "title": "Power of Two",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of two. Otherwise, return `false`_.\n\nAn integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 20 = 1\n\n",
                "**Example 2:**\n\n**Input:** n = 16\n**Output:** true\n**Explanation:** 24 = 16\n\n",
                "**Example 3:**\n\n**Input:** n = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "tag": [
            "Math",
            "Bit Manipulation",
            "Recursion"
        ],
        "example": [
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "16",
                "output": "true"
            },
            {
                "input": "3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "python": "\n    ```python\ndef is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "js": "\n    ```javascript\nfunction isPowerOfTwo(n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    "
    },
    {
        "id": 47,
        "title": "Implement Queue using Stacks",
        "difficulty": "Easy",
        "content": {
            "problem": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n*   `void push(int x)` Pushes element x to the back of the queue.\n*   `int pop()` Removes the element from the front of the queue and returns it.\n*   `int peek()` Returns the element at the front of the queue.\n*   `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n**Notes:**\n\n*   You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n*   Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyQueue \",  \"push \",  \"push \",  \"peek \",  \"pop \",  \"empty \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 1, 1, false\\]\n\n**Explanation**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: \\[1\\]\nmyQueue.push(2); // queue is: \\[1, 2\\] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is \\[2\\]\nmyQueue.empty(); // return false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= x <= 9`\n*   At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.\n*   All the calls to `pop` and `peek` are valid.\n\n**",
            "follow_up": "Follow-up:** Can you implement the queue such that each operation is **[amortized](https://en.wikipedia.org/wiki/Amortized_analysis)** `O(1)` time complexity? In other words, performing `n` operations will take overall `O(n)` time even if one of those operations may take longer."
        },
        "tag": [
            "Stack",
            "Design",
            "Queue"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,1,1,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    ",
        "python": "\n    ```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    ",
        "c++": "\n    ```cpp\nclass MyQueue {\npublic:\n    stack<int> stack1, stack2;\n\n    MyQueue() {\n    }\n\n    void push(int x) {\n        stack1.push(x);\n    }\n\n    int pop() {\n        if (stack2.empty()) {\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        int top_element = stack2.top();\n        stack2.pop();\n        return top_element;\n    }\n\n    int peek() {\n        if (stack2.empty()) {\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        return stack2.top();\n    }\n\n    bool empty() {\n        return stack1.empty() && stack2.empty();\n    }\n};\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    ",
        "js": "\n    ```javascript\nclass MyQueue {\n    constructor() {\n        this.stack1 = [];\n        this.stack2 = [];\n    }\n\n    push(x) {\n        this.stack1.push(x);\n    }\n\n    pop() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n        return this.stack2.pop();\n    }\n\n    peek() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty() {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n}\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    "
    },
    {
        "id": 48,
        "title": "Palindrome Linked List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a singly linked list, return `true` _if it is a_ _palindrome_ _or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,2,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 105]`.\n*   `0 <= Node.val <= 9`\n\n**",
            "follow_up": "Follow up:** Could you do it in `O(n)` time and `O(1)` space?"
        },
        "tag": [
            "Linked List",
            "Two Pointers",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,2,1]",
                "output": "true"
            },
            {
                "input": "[1,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic boolean isPalindrome(ListNode head) {\n    if (head == null || head.next == null) return true;\n\n    ListNode fast = head, slow = head, prev = null;\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        ListNode temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    \n    if (fast != null) slow = slow.next;\n\n    while (prev != null && prev.val == slow.val) {\n        prev = prev.next;\n        slow = slow.next;\n    }\n\n    return prev == null;\n}\n```\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef isPalindrome(head):\n    if not head or not head.next:\n        return True\n\n    fast, slow, prev = head, head, None\n    while fast and fast.next:\n        fast = fast.next.next\n        temp = slow.next\n        slow.next = prev\n        prev = slow\n        slow = temp\n\n    if fast:\n        slow = slow.next\n\n    while prev and prev.val == slow.val:\n        prev = prev.next\n        slow = slow.next\n\n    return prev == None\n```\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nbool isPalindrome(ListNode* head) {\n    if (!head || !head->next) return true;\n\n    ListNode *fast = head, *slow = head, *prev = NULL;\n    while (fast && fast->next) {\n        fast = fast->next->next;\n        ListNode *temp = slow->next;\n        slow->next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    \n    if (fast) slow = slow->next;\n\n    while (prev && prev->val == slow->val) {\n        prev = prev->next;\n        slow = slow->next;\n    }\n\n    return prev == NULL;\n}\n```\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next) {\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    }\n}\n\nfunction isPalindrome(head) {\n    if (!head || !head.next) return true;\n\n    let fast = head, slow = head, prev = null;\n    while (fast && fast.next) {\n        fast = fast.next.next;\n        let temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n\n    if (fast) slow = slow.next;\n\n    while (prev && prev.val === slow.val) {\n        prev = prev.next;\n        slow = slow.next;\n    }\n\n    return prev === null;\n}\n```\n\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    "
    },
    {
        "id": 49,
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"anagram\", t = \"nagaram\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"rat\", t = \"car\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 5 * 104`\n*   `s` and `t` consist of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?"
        },
        "tag": [
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"anagram\",\"nagaram\"",
                "output": "true"
            },
            {
                "input": "\"rat\",\"car\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isAnagram(String s, String t) {\n    if(s.length() != t.length())\n        return false;\n\n    int[] counts = new int[26];\n    for(char c : s.toCharArray())\n        counts[c - 'a']++;\n\n    for(char c : t.toCharArray()) {\n        if(counts[c - 'a'] == 0)\n            return false;\n        counts[c - 'a']--;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "python": "\n    ```python\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n\n    for c in t:\n        if c not in counts or counts[c] == 0:\n            return False\n        counts[c] -= 1\n\n    return True\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "c++": "\n    ```cpp\nbool isAnagram(std::string s, std::string t) {\n    if(s.size() != t.size())\n        return false;\n    \n    std::unordered_map<char, int> counts;\n    for(char c : s)\n        counts[c]++;\n        \n    for(char c : t) {\n        if(counts[c] == 0)\n            return false;\n        counts[c]--;\n    }\n    \n    return true;\n}\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "js": "\n    ```javascript\nfunction isAnagram(s, t) {\n    if (s.length !== t.length)\n        return false;\n\n    const counts = {};\n    for (let c of s)\n        counts[c] = (counts[c] || 0) + 1;\n\n    for (let c of t) {\n        if (counts[c] === 0 || !counts[c])\n            return false;\n        counts[c]--;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    "
    },
    {
        "id": 50,
        "title": "Binary Tree Paths",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _all root-to-leaf paths in **any order**_.\n\nA **leaf** is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,null,5\\]\n**Output:** \\[ \"1->2->5 \", \"1->3 \"\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[ \"1 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,null,5]",
                "output": "[\"1->2->5\",\"1->3\"]"
            },
            {
                "input": "[1]",
                "output": "[\"1\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> paths = new ArrayList<>();\n    if (root == null) {\n        return paths;\n    }\n    if (root.left == null && root.right == null) {\n        paths.add(Integer.toString(root.val));\n        return paths;\n    }\n    for (String path : binaryTreePaths(root.left)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    for (String path : binaryTreePaths(root.right)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    return paths;\n}\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef binary_tree_paths(root: TreeNode):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    paths = []\n    for path in binary_tree_paths(root.left):\n        paths.append(str(root.val) + \"->\" + path)\n    for path in binary_tree_paths(root.right):\n        paths.append(str(root.val) + \"->\" + path)\n    return paths\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::string> binaryTreePaths(TreeNode* root) {\n    std::vector<std::string> paths;\n    if (!root)\n        return paths;\n    if (!root->left && !root->right) {\n        paths.push_back(std::to_string(root->val));\n        return paths;\n    }\n    for (const std::string &path : binaryTreePaths(root->left)) {\n      paths.push_back(std::to_string(root->val) + \"->\" + path);\n    }\n    for (const std::string &path : binaryTreePaths(root->right)) {\n      paths.push_back(std::to_string(root->val) + \"->\" + path);\n    }\n    return paths;\n}\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction binaryTreePaths(root) {\n    if (!root) {\n        return [];\n    }\n    if (!root.left && !root.right) {\n        return [`${root.val}`];\n    }\n    let paths = [];\n    for (let path of binaryTreePaths(root.left)) {\n        paths.push(`${root.val}->${path}`);\n    }\n    for (let path of binaryTreePaths(root.right)) {\n        paths.push(`${root.val}->${path}`);\n    }\n    return paths;\n}\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    "
    },
    {
        "id": 51,
        "title": "Add Digits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 38\n**Output:** 2\n**Explanation:** The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it.\n\n",
                "**Example 2:**\n\n**Input:** num = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you do it without any loop/recursion in `O(1)` runtime?"
        },
        "tag": [
            "Math",
            "Simulation",
            "Number Theory"
        ],
        "example": [
            {
                "input": "38",
                "output": "2"
            },
            {
                "input": "0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "python": "\n    ```python\ndef addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "c++": "\n    ```cpp\nint addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "js": "\n    ```javascript\nfunction addDigits(num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    "
    },
    {
        "id": 52,
        "title": "Ugly Number",
        "difficulty": "Easy",
        "content": {
            "problem": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6\n**Output:** true\n**Explanation:** 6 = 2 \\* 3\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n",
                "**Example 3:**\n\n**Input:** n = 14\n**Output:** false\n**Explanation:** 14 is not ugly since it includes the prime factor 7."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "6",
                "output": "true"
            },
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "14",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "python": "\n    ```python\ndef is_ugly(n: int) -> bool:\n    if n <= 0:\n        return False\n    for factor in [2, 3, 5]:\n        while n % factor == 0:\n            n //= factor\n    return n == 1\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "c++": "\n    ```cpp\nbool isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "js": "\n    ```javascript\nfunction isUgly(n) {\n    if (n <= 0) return false;\n    while (n % 2 === 0) n /= 2;\n    while (n % 3 === 0) n /= 3;\n    while (n % 5 === 0) n /= 5;\n    return n === 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    "
    },
    {
        "id": 53,
        "title": "Missing Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n\n**",
            "follow_up": "Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Bit Manipulation",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,0,1]",
                "output": "2"
            },
            {
                "input": "[0,1]",
                "output": "2"
            },
            {
                "input": "[9,6,4,2,3,5,7,0,1]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int missingNumber(int[] nums) {\n    int n = nums.length;\n    int expectedSum = (n * (n + 1)) / 2;\n    int actualSum = 0;\n    for (int num : nums) {\n        actualSum += num;\n    }\n    return expectedSum - actualSum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "python": "\n    ```python\ndef missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "c++": "\n    ```cpp\nint missingNumber(vector<int>& nums) {\n    int n = nums.size();\n    int expected_sum = (n * (n + 1)) / 2;\n    int actual_sum = 0;\n    for (int num : nums) {\n        actual_sum += num;\n    }\n    return expected_sum - actual_sum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "js": "\n    ```javascript\nfunction missingNumber(nums) {\n    const n = nums.length;\n    const expectedSum = (n * (n + 1)) / 2;\n    const actualSum = nums.reduce((acc, num) => acc + num, 0);\n    return expectedSum - actualSum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    "
    },
    {
        "id": 54,
        "title": "First Bad Version",
        "difficulty": "Easy",
        "content": {
            "problem": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Binary Search",
            "Interactive"
        ],
        "example": [
            {
                "input": "5,4",
                "output": "4"
            },
            {
                "input": "1,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "python": "\n    ```python\ndef first_bad_version(n):\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "c++": "\n    ```cpp\nint firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "js": "\n    ```javascript\nfunction firstBadVersion(n) {\n    let left = 1;\n    let right = n;\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    "
    },
    {
        "id": 55,
        "title": "Move Zeroes",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n\n**Note** that you must do this in-place without making a copy of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,0,3,12\\]\n**Output:** \\[1,3,12,0,0\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you minimize the total number of operations done?"
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[0,1,0,3,12]",
                "output": "[1,3,12,0,0]"
            },
            {
                "input": "[0]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\npublic void moveZeroes(int[] nums) {\n    int index = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "python": "\n    ```python\ndef moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "c++": "\n    ```cpp\nvoid moveZeroes(vector<int>& nums) {\n    int index = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "js": "\n    ```javascript\nfunction moveZeroes(nums) {\n    let index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (let i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    "
    },
    {
        "id": 56,
        "title": "Word Pattern",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat dog \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat fish \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** pattern =  \"aaaa \", s =  \"dog cat cat dog \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pattern.length <= 300`\n*   `pattern` contains only lower-case English letters.\n*   `1 <= s.length <= 3000`\n*   `s` contains only lowercase English letters and spaces `' '`.\n*   `s` **does not contain** any leading or trailing spaces.\n*   All the words in `s` are separated by a **single space**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"abba\",\"dogcatcatdog\"",
                "output": "true"
            },
            {
                "input": "\"abba\",\"dogcatcatfish\"",
                "output": "false"
            },
            {
                "input": "\"aaaa\",\"dogcatcatdog\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    if (pattern.length() != words.length) return false;\n\n    Map<Character, String> charMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        String word = words[i];\n        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {\n            charMap.put(c, word);\n            wordMap.put(word, c);\n        } else {\n            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "python": "\n    ```python\ndef word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_map, word_map = {}, {}\n    for c, word in zip(pattern, words):\n        if c not in char_map and word not in word_map:\n            char_map[c] = word\n            word_map[word] = c\n        else:\n            if char_map.get(c) != word or word_map.get(word) != c:\n                return False\n\n    return True\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nbool wordPattern(string pattern, string s) {\n    unordered_map<char, string> char_map;\n    unordered_map<string, char> word_map;\n    stringstream ss(s);\n\n    int i = 0;\n    for (string word; ss >> word; ++i) {\n        if (i == pattern.size()) return false;\n        char c = pattern[i];\n        if (char_map.count(c) == 0 && word_map.count(word) == 0) {\n            char_map[c] = word;\n            word_map[word] = c;\n        } else {\n            if (char_map[c] != word || word_map[word] != c) return false;\n        }\n    }\n\n    return i == pattern.size();\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "js": "\n    ```javascript\nfunction wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const charMap = new Map();\n    const wordMap = new Map();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const c = pattern[i];\n        const word = words[i];\n        if (!charMap.has(c) && !wordMap.has(word)) {\n            charMap.set(c, word);\n            wordMap.set(word, c);\n        } else {\n            if (charMap.get(c) !== word || wordMap.get(word) !== c) return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    "
    },
    {
        "id": 57,
        "title": "Nim Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are playing the following Nim Game with your friend:\n\n*   Initially, there is a heap of stones on the table.\n*   You and your friend will alternate taking turns, and **you go first**.\n*   On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n*   The one who removes the last stone is the winner.\n\nGiven `n`, the number of stones in the heap, return `true` _if you can win the game assuming both you and your friend play optimally, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** false\n**Explanation:** These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Brainteaser",
            "Game Theory"
        ],
        "example": [
            {
                "input": "4",
                "output": "false"
            },
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "2",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean canWinNim(int n) {\n    return n % 4 != 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "python": "\n    ```python\ndef canWinNim(n):\n    return n % 4 != 0\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "c++": "\n    ```cpp\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "js": "\n    ```javascript\nfunction canWinNim(n) {\n    return n % 4 !== 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    "
    },
    {
        "id": 58,
        "title": "Power of Three",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of three. Otherwise, return `false`_.\n\nAn integer `n` is a power of three, if there exists an integer `x` such that `n == 3x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 27\n**Output:** true\n**Explanation:** 27 = 33\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** false\n**Explanation:** There is no x where 3x = 0.\n\n",
                "**Example 3:**\n\n**Input:** n = -1\n**Output:** false\n**Explanation:** There is no x where 3x = (-1)."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "tag": [
            "Math",
            "Recursion"
        ],
        "example": [
            {
                "input": "27",
                "output": "true"
            },
            {
                "input": "0",
                "output": "false"
            },
            {
                "input": "-1",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "python": "\n    ```python\ndef is_power_of_three(n: int) -> bool:\n    if n < 1:\n        return False\n    \n    while n % 3 == 0:\n        n //= 3\n    \n    return n == 1\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "js": "\n    ```javascript\nfunction isPowerOfThree(n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    \n    return n === 1;\n}\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    "
    },
    {
        "id": 59,
        "title": "Counting Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,1\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[0,1,1,2,1,2\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 105`\n\n**",
            "follow_up": "Follow up:**\n\n*   It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?\n*   Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?"
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "2",
                "output": "[0,1,1]"
            },
            {
                "input": "5",
                "output": "[0,1,1,2,1,2]"
            }
        ],
        "java": "\n    ```java\npublic int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "python": "\n    ```python\ndef countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    vector<int> ans(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "js": "\n    ```javascript\nfunction countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    "
    },
    {
        "id": 60,
        "title": "Power of Four",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of four. Otherwise, return `false`_.\n\nAn integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 16\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "tag": [
            "Math",
            "Bit Manipulation",
            "Recursion"
        ],
        "example": [
            {
                "input": "16",
                "output": "true"
            },
            {
                "input": "5",
                "output": "false"
            },
            {
                "input": "1",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "python": "\n    ```python\ndef isPowerOfFour(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "js": "\n    ```javascript\nfunction isPowerOfFour(n) {\n    if (n <= 0) return false;\n    while (n % 4 === 0) {\n        n = Math.floor(n / 4);\n    }\n    return n === 1;\n}\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    "
    },
    {
        "id": 61,
        "title": "Reverse String",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function that reverses a string. The input string is given as an array of characters `s`.\n\nYou must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \\[\"h\",\"e\",\"l\",\"l\",\"o\"\\]\n**Output:** \\[\"o\",\"l\",\"l\",\"e\",\"h\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \\[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"\\]\n**Output:** \\[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a [printable ascii character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
            },
            {
                "input": "[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
                "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"
            }
        ],
        "java": "\n    ```java\npublic void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left++] = s[right];\n        s[right--] = temp;\n    }\n}\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "python": "\n    ```python\ndef reverseString(s: List[str]) -> None:\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left, right = left + 1, right - 1\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "c++": "\n    ```cpp\nvoid reverseString(vector<char>& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        swap(s[left++], s[right--]);\n    }\n}\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "js": "\n    ```javascript\nfunction reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    "
    },
    {
        "id": 62,
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in both lower and upper cases, more than once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"hello\"\n**Output:** \"holle\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"leetcode\"\n**Output:** \"leotcede\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consist of **printable ASCII** characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"hello\"",
                "output": "\"holle\""
            },
            {
                "input": "\"leetcode\"",
                "output": "\"leotcede\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic String reverseVowels(String s) {\n    int i = 0, j = s.length() - 1;\n    char[] result = new char[s.length()];\n    Set<Character> vowels = new HashSet<>();\n    for (char c : \"aeiouAEIOU\".toCharArray()) {\n        vowels.add(c);\n    }\n    while (i <= j) {\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci)) {\n            result[i++] = ci;\n        } else if (!vowels.contains(cj)) {\n            result[j--] = cj;\n        } else {\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "python": "\n    ```python\ndef reverseVowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int i = 0, j = s.size() - 1;\n    while (i < j) {\n        if (!isVowel(s[i])) {\n            i++;\n        } else if (!isVowel(s[j])) {\n            j--;\n        } else {\n            std::swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n    return s;\n}\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "js": "\n    ```javascript\nfunction reverseVowels(s) {\n    const vowels = new Set('aeiouAEIOU');\n    let chars = Array.from(s);\n    let i = 0, j = s.length - 1;\n    while (i < j) {\n        if (!vowels.has(chars[i])) {\n            i++;\n        } else if (!vowels.has(chars[j])) {\n            j--;\n        } else {\n            [chars[i], chars[j]] = [chars[j], chars[i]];\n            i++;\n            j--;\n        }\n    }\n    return chars.join('');\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    "
    },
    {
        "id": 63,
        "title": "Intersection of Two Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must be **unique** and you may return the result in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[9,4\\]\n**Explanation:** \\[4,9\\] is also accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,2,1],[2,2]",
                "output": "[2]"
            },
            {
                "input": "[4,9,5],[9,4,9,8,4]",
                "output": "[9,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> set1 = new HashSet<>();\n    for (int num : nums1) {\n        set1.add(num);\n    }\n    \n    Set<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n        if (set1.contains(num)) {\n            resultSet.add(num);\n        }\n    }\n    \n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) {\n        result[i++] = num;\n    }\n    return result;\n}\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "python": "\n    ```python\ndef intersection(nums1, nums2):\n    set1 = set(nums1)\n    result = set1.intersection(nums2)\n    return list(result)\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::set<int> set1(nums1.begin(), nums1.end());\n    std::set<int> result;\n    for (int num : nums2) {\n        if (set1.count(num)) {\n            result.insert(num);\n        }\n    }\n    return std::vector<int>(result.begin(), result.end());\n}\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "js": "\n    ```javascript\nfunction intersection(nums1, nums2) {\n    const set1 = new Set(nums1);\n    const resultSet = new Set();\n\n    for (const num of nums2) {\n        if (set1.has(num)) {\n            resultSet.add(num);\n        }\n    }\n\n    return Array.from(resultSet);\n}\n```\n\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    "
    },
    {
        "id": 64,
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[4,9\\]\n**Explanation:** \\[9,4\\] is also accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`\n\n**",
            "follow_up": "Follow up:**\n\n*   What if the given array is already sorted? How would you optimize your algorithm?\n*   What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n*   What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,2,1],[2,2]",
                "output": "[2,2]"
            },
            {
                "input": "[4,9,5],[9,4,9,8,4]",
                "output": "[4,9]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> countMap = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n    \n    for (int num : nums1) {\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n    }\n    \n    for (int num : nums2) {\n        if (countMap.getOrDefault(num, 0) > 0) {\n            result.add(num);\n            countMap.put(num, countMap.get(num) - 1);\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "python": "\n    ```python\ndef intersect(nums1, nums2):\n    count_map = {}\n    result = []\n    \n    for num in nums1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    for num in nums2:\n        if count_map.get(num, 0) > 0:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> count_map;\n    std::vector<int> result;\n    \n    for (int num : nums1) {\n        count_map[num]++;\n    }\n    \n    for (int num : nums2) {\n        if (count_map[num] > 0) {\n            result.push_back(num);\n            count_map[num]--;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "js": "\n    ```javascript\nfunction intersect(nums1, nums2) {\n    const countMap = {};\n    const result = [];\n    \n    for (const num of nums1) {\n        countMap[num] = (countMap[num] || 0) + 1;\n    }\n    \n    for (const num of nums2) {\n        if (countMap[num] > 0) {\n            result.push(num);\n            countMap[num]--;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    "
    },
    {
        "id": 65,
        "title": "Valid Perfect Square",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer num, return `true` _if_ `num` _is a perfect square or_ `false` _otherwise_.\n\nA **perfect square** is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\nYou must not use any built-in library function, such as `sqrt`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 16\n**Output:** true\n**Explanation:** We return true because 4 \\* 4 = 16 and 4 is an integer.\n\n",
                "**Example 2:**\n\n**Input:** num = 14\n**Output:** false\n**Explanation:** We return false because 3.742 \\* 3.742 = 14 and 3.742 is not an integer."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "16",
                "output": "true"
            },
            {
                "input": "14",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "python": "\n    ```python\ndef is_perfect_square(num: int) -> bool:\n    if num < 2:\n        return True\n    left, right = 2, num // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n        if square == num:\n            return True\n        if square > num:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "c++": "\n    ```cpp\nbool isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "js": "\n    ```javascript\nfunction isPerfectSquare(num) {\n    if (num < 2) return true;\n    let left = 2, right = Math.floor(num / 2), mid, square;\n    while (left <= right) {\n        mid = left + Math.floor((right - left) / 2);\n        square = mid * mid;\n        if (square === num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    "
    },
    {
        "id": 66,
        "title": "Guess Number Higher or Lower",
        "difficulty": "Easy",
        "content": {
            "problem": "We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`",
            "follow_up": null
        },
        "tag": [
            "Binary Search",
            "Interactive"
        ],
        "example": [
            {
                "input": "10,6",
                "output": "6"
            },
            {
                "input": "1,1",
                "output": "1"
            },
            {
                "input": "2,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int guessNumber(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int result = guess(mid);\n        if (result == 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "python": "\n    ```python\ndef guessNumber(n):\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "c++": "\n    ```cpp\nint guessNumber(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int result = guess(mid);\n        if (result == 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "js": "\n    ```javascript\nfunction guessNumber(n) {\n    let low = 1, high = n;\n    while (low <= high) {\n        let mid = Math.floor(low + (high - low) / 2);\n        let result = guess(mid);\n        if (result === 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    "
    },
    {
        "id": 67,
        "title": "Ransom Note",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `ransomNote` and `magazine`, return `true` _if_ `ransomNote` _can be constructed by using the letters from_ `magazine` _and_ `false` _otherwise_.\n\nEach letter in `magazine` can only be used once in `ransomNote`.",
            "examples": [
                "**Example 1:**\n\n**Input:** ransomNote = \"a\", magazine = \"b\"\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** ransomNote = \"aa\", magazine = \"ab\"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** ransomNote = \"aa\", magazine = \"aab\"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= ransomNote.length, magazine.length <= 105`\n*   `ransomNote` and `magazine` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"a\",\"b\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"ab\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"aab\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean canConstruct(String ransomNote, String magazine) {\n    HashMap<Character, Integer> letterCount = new HashMap<>();\n    \n    for (char c : magazine.toCharArray()) {\n        letterCount.put(c, letterCount.getOrDefault(c, 0) + 1);\n    }\n    \n    for (char c : ransomNote.toCharArray()) {\n        if (!letterCount.containsKey(c) || letterCount.get(c) == 0) {\n            return false;\n        }\n        letterCount.put(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "python": "\n    ```python\ndef can_construct(ransom_note, magazine):\n    letter_count = {}\n    \n    for c in magazine:\n        letter_count[c] = letter_count.get(c, 0) + 1\n        \n    for c in ransom_note:\n        if c not in letter_count or letter_count[c] == 0:\n            return False\n        letter_count[c] -= 1\n        \n    return True\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n\nbool canConstruct(std::string ransomNote, std::string magazine) {\n    std::unordered_map<char, int> letterCount;\n    for (char c : magazine) {\n        letterCount[c]++;\n    }\n    \n    for (char c : ransomNote) {\n        if (letterCount[c] == 0) {\n            return false;\n        }\n        letterCount[c]--;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "js": "\n    ```javascript\nfunction canConstruct(ransomNote, magazine) {\n    let letterCount = new Map();\n    \n    for (const c of magazine) {\n        letterCount.set(c, (letterCount.get(c) || 0) + 1);\n    }\n    \n    for (const c of ransomNote) {\n        if (!letterCount.has(c) || letterCount.get(c) === 0) {\n            return false;\n        }\n        letterCount.set(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    "
    },
    {
        "id": 68,
        "title": "First Unique Character in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, _find the first non-repeating character in it and return its index_. If it does not exist, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"leetcode\"\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** s = \"loveleetcode\"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** s = \"aabb\"\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Queue",
            "Counting"
        ],
        "example": [
            {
                "input": "\"leetcode\"",
                "output": "0"
            },
            {
                "input": "\"loveleetcode\"",
                "output": "2"
            },
            {
                "input": "\"aabb\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int firstUniqChar(String s) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    for (char c : s.toCharArray())\n        charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    for (int i = 0; i < s.length(); i++)\n        if (charCount.get(s.charAt(i)) == 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "python": "\n    ```python\ndef firstUniqChar(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "c++": "\n    ```cpp\nint firstUniqChar(std::string s) {\n    std::unordered_map<char, int> charCount;\n    for (char c : s)\n        charCount[c]++;\n    for (int i = 0; i < s.length(); i++)\n        if (charCount[s[i]] == 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "js": "\n    ```javascript\nfunction firstUniqChar(s) {\n    let charCount = {};\n    for (let c of s)\n        charCount[c] = (charCount[c] || 0) + 1;\n    for (let i = 0; i < s.length; i++)\n        if (charCount[s[i]] === 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    "
    },
    {
        "id": 69,
        "title": "Find the Difference",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `s` and `t`.\n\nString `t` is generated by random shuffling string `s` and then add one more letter at a random position.\n\nReturn the letter that was added to `t`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcd \", t =  \"abcde \"\n**Output:**  \"e \"\n**Explanation:** 'e' is the letter that was added.\n\n",
                "**Example 2:**\n\n**Input:** s =  \" \", t =  \"y \"\n**Output:**  \"y \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 1000`\n*   `t.length == s.length + 1`\n*   `s` and `t` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"abcd\",\"abcde\"",
                "output": "\"e\""
            },
            {
                "input": "\"\",\"y\"",
                "output": "\"y\""
            }
        ],
        "java": "\n    ```java\npublic char findTheDifference(String s, String t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s.toCharArray()) sum_s += c;\n    for(char c : t.toCharArray()) sum_t += c;\n    return (char)(sum_t - sum_s);\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "python": "\n    ```python\ndef findTheDifference(s: str, t: str) -> str:\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "c++": "\n    ```cpp\nchar findTheDifference(std::string s, std::string t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s) sum_s += c;\n    for(char c : t) sum_t += c;\n    return sum_t - sum_s;\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "js": "\n    ```javascript\nfunction findTheDifference(s, t) {\n    let sum_s = 0, sum_t = 0;\n    for(let c of s) sum_s += c.charCodeAt(0);\n    for(let c of t) sum_t += c.charCodeAt(0);\n    return String.fromCharCode(sum_t - sum_s);\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    "
    },
    {
        "id": 70,
        "title": "Is Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abc\", t = \"ahbgdc\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"axc\", t = \"ahbgdc\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 100`\n*   `0 <= t.length <= 104`\n*   `s` and `t` consist only of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?"
        },
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"abc\",\"ahbgdc\"",
                "output": "true"
            },
            {
                "input": "\"axc\",\"ahbgdc\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isSubsequence(String s, String t) {\n    int si = 0, ti = 0;\n\n    while (si < s.length() && ti < t.length()) {\n        if (s.charAt(si) == t.charAt(ti))\n            si++;\n        ti++;\n    }\n\n    return si == s.length();\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "python": "\n    ```python\ndef is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "c++": "\n    ```cpp\nbool isSubsequence(std::string s, std::string t) {\n    int si = 0, ti = 0;\n\n    while (si < s.size() && ti < t.size()) {\n        if (s[si] == t[ti])\n            si++;\n        ti++;\n    }\n\n    return si == s.size();\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "js": "\n    ```javascript\nfunction isSubsequence(s, t) {\n    let si = 0, ti = 0;\n\n    while (si < s.length && ti < t.length) {\n        if (s[si] === t[ti])\n            si++;\n        ti++;\n    }\n\n    return si === s.length;\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    "
    },
    {
        "id": 71,
        "title": "Binary Watch",
        "difficulty": "Easy",
        "content": {
            "problem": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n*   For example, the below binary watch reads `\"4:51 \"`.\n\nGiven an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n*   For example, `\"01:00 \"` is not valid. It should be `\"1:00 \"`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n*   For example, `\"10:2 \"` is not valid. It should be `\"10:02 \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** turnedOn = 1\n**Output:** \\[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"\\]\n\n",
                "**Example 2:**\n\n**Input:** turnedOn = 9\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= turnedOn <= 10`",
            "follow_up": null
        },
        "tag": [
            "Backtracking",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "1",
                "output": "[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]"
            },
            {
                "input": "9",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> readBinaryWatch(int turnedOn) {\n    List<String> times = new ArrayList<>();\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                times.add(String.format(\"%d:%02d\", h, m));\n            }\n        }\n    }\n    return times;\n}\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "python": "\n    ```python\ndef readBinaryWatch(turnedOn: int):\n    def count_bits(n):\n        return bin(n).count('1')\n\n    times = []\n    for h in range(12):\n        for m in range(60):\n            if count_bits(h) + count_bits(m) == turnedOn:\n                times.append(f\"{h}:{m:02d}\")\n    return times\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> readBinaryWatch(int turnedOn) {\n    vector<string> times;\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {\n                times.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\n            }\n        }\n    }\n    return times;\n}\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "js": "\n    ```javascript\nfunction readBinaryWatch(turnedOn) {\n    function countBits(n) {\n        return n.toString(2).split('1').length - 1;\n    }\n\n    const times = [];\n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (countBits(h) + countBits(m) === turnedOn) {\n                times.push(`${h}:${m.toString().padStart(2, '0')}`);\n            }\n        }\n    }\n    return times;\n}\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    "
    },
    {
        "id": 72,
        "title": "Sum of Left Leaves",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the sum of all left leaves._\n\nA **leaf** is a node with no children. A **left leaf** is a leaf that is the left child of another node.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 24\n**Explanation:** There are two left leaves in the binary tree, with values 9 and 15 respectively.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "24"
            },
            {
                "input": "[1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int sumOfLeftLeaves(TreeNode root) {\n    if (root == null) return 0;\n    int sum = 0;\n    if (root.left != null && root.left.left == null && root.left.right == null) sum += root.left.val;\n    return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);\n}\n```\n    \n    The algorithm uses a recursive approach. For every node in the tree, the program checks if the left child is a leaf node by verifying if it exists and if it has no children. If the left child is a leaf, add its value to the sum, and then call the function for both left and right children of the current node. Since the tree can have varying depths, recursion is useful to explore each subtree and accumulate the sum of all left leaves.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sum_of_left_leaves(root):\n    if not root:\n        return 0\n    left_sum = 0\n    if root.left and not root.left.left and not root.left.right:\n        left_sum += root.left.val\n    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)\n```\n    \n    The algorithm uses a recursive approach. For every node in the tree, the program checks if the left child is a leaf node by verifying if it exists and if it has no children. If the left child is a leaf, add its value to the sum, and then call the function for both left and right children of the current node. Since the tree can have varying depths, recursion is useful to explore each subtree and accumulate the sum of all left leaves.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint sumOfLeftLeaves(TreeNode* root) {\n    if (!root) return 0;\n    int sum = 0;\n    if (root->left && !root->left->left && !root->left->right) sum += root->left->val;\n    return sum + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}\n```\n    \n    The algorithm uses a recursive approach. For every node in the tree, the program checks if the left child is a leaf node by verifying if it exists and if it has no children. If the left child is a leaf, add its value to the sum, and then call the function for both left and right children of the current node. Since the tree can have varying depths, recursion is useful to explore each subtree and accumulate the sum of all left leaves.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction sumOfLeftLeaves(root) {\n    if (!root) return 0;\n    let sum = 0;\n    if (root.left && !root.left.left && !root.left.right) sum += root.left.val;\n    return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);\n}\n```\n    \n    The algorithm uses a recursive approach. For every node in the tree, the program checks if the left child is a leaf node by verifying if it exists and if it has no children. If the left child is a leaf, add its value to the sum, and then call the function for both left and right children of the current node. Since the tree can have varying depths, recursion is useful to explore each subtree and accumulate the sum of all left leaves.\n    "
    },
    {
        "id": 73,
        "title": "Convert a Number to Hexadecimal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, return _a string representing its hexadecimal representation_. For negative integers, [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) method is used.\n\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\n\n**Note:** You are not allowed to use any built-in library method to directly solve this problem.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 26\n**Output:** \"1a\"\n\n",
                "**Example 2:**\n\n**Input:** num = -1\n**Output:** \"ffffffff\""
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= num <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "26",
                "output": "\"1a\""
            },
            {
                "input": "-1",
                "output": "\"ffffffff\""
            }
        ],
        "java": "\n    ```java\npublic String toHex(int num) {\n    if (num == 0) return \"0\";\n    String hex = \"\";\n    char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    for (int i = 0; num != 0 && i < 8; ++i) {\n        hex = hexDigits[num & 0xf] + hex;\n        num >>>= 4;\n    }\n    return hex;\n}\n```\n    \n    The algorithm for converting an integer to its hexadecimal representation follows these steps:\n\n1. Check if the input number is 0, if so, return the string \"0\".\n2. Initialize an empty string (hex) to store the hexadecimal representation of the integer.\n3. Initialize an array or string (hexDigits) containing the characters representing the hexadecimal digits from 0 to 15 (0-9 and a-f).\n4. If the input integer is negative, convert it to its unsigned 32-bit integer representation.\n5. While the integer is not 0, extract the last 4 bits using a bitwise AND operation with the value `0xf` (15 in decimal) and use the result as an index to get the corresponding hexadecimal character from hexDigits. Append this character to the left side of the hex string.\n6. Shift the integer right by 4 bits (n >>= 4) to move on to the next 4 bits.\n7. Repeat steps 5 and 6 until the integer is 0.\n8. Return the hex string as the final hexadecimal representation of the input integer.\n    ",
        "python": "\n    ```python\ndef to_hex(num: int) -> str:\n    if num == 0:\n        return '0'\n    hex_str = ''\n    hex_digits = '0123456789abcdef'\n    n = num & 0xffffffff\n    while n:\n        hex_str = hex_digits[n & 0xf] + hex_str\n        n >>= 4\n    return hex_str\n```\n    \n    The algorithm for converting an integer to its hexadecimal representation follows these steps:\n\n1. Check if the input number is 0, if so, return the string \"0\".\n2. Initialize an empty string (hex) to store the hexadecimal representation of the integer.\n3. Initialize an array or string (hexDigits) containing the characters representing the hexadecimal digits from 0 to 15 (0-9 and a-f).\n4. If the input integer is negative, convert it to its unsigned 32-bit integer representation.\n5. While the integer is not 0, extract the last 4 bits using a bitwise AND operation with the value `0xf` (15 in decimal) and use the result as an index to get the corresponding hexadecimal character from hexDigits. Append this character to the left side of the hex string.\n6. Shift the integer right by 4 bits (n >>= 4) to move on to the next 4 bits.\n7. Repeat steps 5 and 6 until the integer is 0.\n8. Return the hex string as the final hexadecimal representation of the input integer.\n    ",
        "c++": "\n    ```cpp\nstd::string toHex(int num) {\n    if (num == 0) return \"0\";\n    std::string hex = \"\";\n    unsigned int n = num;\n    char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    while (n) {\n        hex = hexDigits[n & 15] + hex;\n        n >>= 4;\n    }\n    return hex;\n}\n```\n    \n    The algorithm for converting an integer to its hexadecimal representation follows these steps:\n\n1. Check if the input number is 0, if so, return the string \"0\".\n2. Initialize an empty string (hex) to store the hexadecimal representation of the integer.\n3. Initialize an array or string (hexDigits) containing the characters representing the hexadecimal digits from 0 to 15 (0-9 and a-f).\n4. If the input integer is negative, convert it to its unsigned 32-bit integer representation.\n5. While the integer is not 0, extract the last 4 bits using a bitwise AND operation with the value `0xf` (15 in decimal) and use the result as an index to get the corresponding hexadecimal character from hexDigits. Append this character to the left side of the hex string.\n6. Shift the integer right by 4 bits (n >>= 4) to move on to the next 4 bits.\n7. Repeat steps 5 and 6 until the integer is 0.\n8. Return the hex string as the final hexadecimal representation of the input integer.\n    ",
        "js": "\n    ```javascript\nfunction toHex(num) {\n  if (num === 0) return '0';\n  const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n  let hex = '';\n  let n = num >>> 0;\n  while (n) {\n    hex = hexDigits[n & 0xf] + hex;\n    n >>>= 4;\n  }\n  return hex;\n}\n```\n    \n    The algorithm for converting an integer to its hexadecimal representation follows these steps:\n\n1. Check if the input number is 0, if so, return the string \"0\".\n2. Initialize an empty string (hex) to store the hexadecimal representation of the integer.\n3. Initialize an array or string (hexDigits) containing the characters representing the hexadecimal digits from 0 to 15 (0-9 and a-f).\n4. If the input integer is negative, convert it to its unsigned 32-bit integer representation.\n5. While the integer is not 0, extract the last 4 bits using a bitwise AND operation with the value `0xf` (15 in decimal) and use the result as an index to get the corresponding hexadecimal character from hexDigits. Append this character to the left side of the hex string.\n6. Shift the integer right by 4 bits (n >>= 4) to move on to the next 4 bits.\n7. Repeat steps 5 and 6 until the integer is 0.\n8. Return the hex string as the final hexadecimal representation of the input integer.\n    "
    },
    {
        "id": 74,
        "title": "Longest Palindrome",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` which consists of lowercase or uppercase letters, return _the length of the **longest palindrome**_ that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa \"` is not considered a palindrome here.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abccccdd \"\n**Output:** 7\n**Explanation:** One longest palindrome that can be built is  \"dccaccd \", whose length is 7.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** The longest palindrome that can be built is  \"a \", whose length is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase **and/or** uppercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abccccdd\"",
                "output": "7"
            },
            {
                "input": "\"a\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int longestPalindrome(String s) {\n    int[] charCount = new int[128];\n    int result = 0;\n    for (char c : s.toCharArray())\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "python": "\n    ```python\ndef longestPalindrome(s: str) -> int:\n    charCount = [0] * 128\n    result = 0\n    for c in s:\n        charCount[ord(c)] += 1\n    for count in charCount:\n        result += count // 2 * 2\n        if result % 2 == 0 and count % 2 == 1:\n            result += 1\n    return result\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "c++": "\n    ```cpp\nint longestPalindrome(string s) {\n    int charCount[128] = {0};\n    int result = 0;\n    for (char c : s)\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "js": "\n    ```javascript\nfunction longestPalindrome(s) {\n    let charCount = new Array(128).fill(0);\n    let result = 0;\n    for (let c of s)\n        charCount[c.charCodeAt(0)]++;\n    for (let count of charCount) {\n        result += Math.floor(count / 2) * 2;\n        if (result % 2 === 0 && count % 2 === 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    "
    },
    {
        "id": 75,
        "title": "Fizz Buzz",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _a string array_ `answer` _(**1-indexed**) where_:\n\n*   `answer[i] == \"FizzBuzz \"` if `i` is divisible by `3` and `5`.\n*   `answer[i] == \"Fizz \"` if `i` is divisible by `3`.\n*   `answer[i] == \"Buzz \"` if `i` is divisible by `5`.\n*   `answer[i] == i` (as a string) if none of the above conditions are true.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"1\",\"2\",\"Fizz\"\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 15\n**Output:** \\[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "3",
                "output": "[\"1\",\"2\",\"Fizz\"]"
            },
            {
                "input": "5",
                "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
            },
            {
                "input": "15",
                "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic ArrayList<String> fizzBuzz(int n) {\n    ArrayList<String> result = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 15 == 0) result.add(\"FizzBuzz\");\n        else if (i % 3 == 0) result.add(\"Fizz\");\n        else if (i % 5 == 0) result.add(\"Buzz\");\n        else result.add(Integer.toString(i));\n    }\n    return result;\n}\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "python": "\n    ```python\ndef fizzBuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> fizzBuzz(int n) {\n    std::vector<std::string> result(n);\n    for(int i = 1; i <= n; ++i) {\n        if (i % 15 == 0) result[i - 1] = \"FizzBuzz\";\n        else if (i % 3 == 0) result[i - 1] = \"Fizz\";\n        else if (i % 5 == 0) result[i - 1] = \"Buzz\";\n        else result[i - 1] = std::to_string(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "js": "\n    ```javascript\nfunction fizzBuzz(n) {\n    let result = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 15 === 0) result.push(\"FizzBuzz\");\n        else if (i % 3 === 0) result.push(\"Fizz\");\n        else if (i % 5 === 0) result.push(\"Buzz\");\n        else result.push(String(i));\n    }\n    return result;\n}\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    "
    },
    {
        "id": 76,
        "title": "Third Maximum Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the **third distinct maximum** number in this array. If the third maximum does not exist, return the **maximum** number_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 2\n**Explanation:**\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,2,3,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Can you find an `O(n)` solution?"
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,2,1]",
                "output": "1"
            },
            {
                "input": "[1,2]",
                "output": "2"
            },
            {
                "input": "[2,2,3,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic int thirdMax(int[] nums) {\n    TreeSet<Integer> top3 = new TreeSet<>();\n    for (int num : nums) {\n        top3.add(num);\n        if (top3.size() > 3) {\n            top3.remove(top3.first());\n        }\n    }\n    return top3.size() == 3 ? top3.first() : top3.last();\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "python": "\n    ```python\ndef third_max(nums):\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n    return min(top3) if len(top3) == 3 else max(top3)\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n\nint thirdMax(vector<int>& nums) {\n    set<int> top3;\n    for (int num : nums) {\n        top3.insert(num);\n        if (top3.size() > 3) {\n            top3.erase(top3.begin());\n        }\n    }\n    return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "js": "\n    ```javascript\nfunction thirdMax(nums) {\n    const top3 = new Set();\n    for (const num of nums) {\n        top3.add(num);\n        if (top3.size > 3) {\n            top3.delete(Math.min(...top3));\n        }\n    }\n    return top3.size === 3 ? Math.min(...top3) : Math.max(...top3);\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    "
    },
    {
        "id": 77,
        "title": "Add Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two non-negative integers, `num1` and `num2` represented as string, return _the sum of_ `num1` _and_ `num2` _as a string_.\n\nYou must solve the problem without using any built-in library for handling large integers (such as `BigInteger`). You must also not convert the inputs to integers directly.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 =  \"11 \", num2 =  \"123 \"\n**Output:**  \"134 \"\n\n",
                "**Example 2:**\n\n**Input:** num1 =  \"456 \", num2 =  \"77 \"\n**Output:**  \"533 \"\n\n",
                "**Example 3:**\n\n**Input:** num1 =  \"0 \", num2 =  \"0 \"\n**Output:**  \"0 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 104`\n*   `num1` and `num2` consist of only digits.\n*   `num1` and `num2` don't have any leading zeros except for the zero itself.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"11\",\"123\"",
                "output": "\"134\""
            },
            {
                "input": "\"456\",\"77\"",
                "output": "\"533\""
            },
            {
                "input": "\"0\",\"0\"",
                "output": "\"0\""
            }
        ],
        "java": "\n    ```java\npublic String addStrings(String num1, String num2) {\n    int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n    StringBuilder result = new StringBuilder();\n\n    while (i >= 0 || j >= 0 || carry != 0) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1.charAt(i) - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2.charAt(j) - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.append(sum % 10);\n    }\n\n    return result.reverse().toString();\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "python": "\n    ```python\ndef addStrings(num1: str, num2: str) -> str:\n    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []\n\n    while i >= 0 or j >= 0 or carry:\n        sum = carry\n\n        if i >= 0:\n            sum += int(num1[i])\n            i -= 1\n        if j >= 0:\n            sum += int(num2[j])\n            j -= 1\n\n        carry = sum // 10\n        result.append(str(sum % 10))\n\n    return ''.join(result[::-1])\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "c++": "\n    ```cpp\nstd::string addStrings(std::string num1, std::string num2) {\n    int i = num1.size() - 1, j = num2.size() - 1, carry = 0;\n    std::string result;\n\n    while (i >= 0 || j >= 0 || carry) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1[i] - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2[j] - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.push_back(sum % 10 + '0');\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "js": "\n    ```javascript\nfunction addStrings(num1, num2) {\n    let i = num1.length - 1, j = num2.length - 1, carry = 0;\n    let result = [];\n\n    while (i >= 0 || j >= 0 || carry) {\n        let sum = carry;\n\n        if (i >= 0) {\n            sum += parseInt(num1[i]);\n            --i;\n        }\n        if (j >= 0) {\n            sum += parseInt(num2[j]);\n            --j;\n        }\n\n        carry = Math.floor(sum / 10);\n        result.push(sum % 10);\n    }\n\n    return result.reverse().join('');\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    "
    },
    {
        "id": 78,
        "title": "Number of Segments in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the number of segments in the string_.\n\nA **segment** is defined to be a contiguous sequence of **non-space characters**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello, my name is John \"\n**Output:** 5\n**Explanation:** The five segments are \\[ \"Hello, \",  \"my \",  \"name \",  \"is \",  \"John \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"Hello \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 300`\n*   `s` consists of lowercase and uppercase English letters, digits, or one of the following characters `\"!@#$%^&*()_+-=',.: \"`.\n*   The only space character in `s` is `' '`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"Hello,",
                "output": "5"
            },
            {
                "input": "\"Hello\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int countSegments(String s) {\n    if (s == null || s.trim().length() == 0) {\n        return 0;\n    }\n    String[] segments = s.trim().split(\"\\\\s+\");\n    return segments.length;\n}\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "python": "\n    ```python\ndef count_segments(s: str) -> int:\n    return len(s.split())\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n\nint countSegments(const std::string& s) {\n    std::stringstream ss(s);\n    int count = 0;\n    std::string temp;\n\n    while (ss >> temp) {\n        ++count;\n    }\n\n    return count;\n}\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "js": "\n    ```javascript\nfunction countSegments(s) {\n    if (!s || s.trim().length === 0) {\n        return 0;\n    }\n    const segments = s.trim().split(/\\s+/);\n    return segments.length;\n}\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    "
    },
    {
        "id": 79,
        "title": "Arranging Coins",
        "difficulty": "Easy",
        "content": {
            "problem": "You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.\n\nGiven the integer `n`, return _the number of **complete rows** of the staircase you will build_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** Because the 3rd row is incomplete, we return 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** Because the 4th row is incomplete, we return 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "5",
                "output": "2"
            },
            {
                "input": "8",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "python": "\n    ```python\ndef arrange_coins(n: int) -> int:\n    k = 0\n    while n > k:\n        k += 1\n        n -= k\n    return k\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "c++": "\n    ```cpp\nint arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "js": "\n    ```javascript\nfunction arrangeCoins(n) {\n    let k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    "
    },
    {
        "id": 80,
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return _an array of all the integers in the range_ `[1, n]` _that do not appear in_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,7,8,2,3,1\\]\n**Output:** \\[5,6\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= n`\n\n**",
            "follow_up": "Follow up:** Could you do it without extra space and in `O(n)` runtime? You may assume the returned list does not count as extra space."
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[4,3,2,7,8,2,3,1]",
                "output": "[5,6]"
            },
            {
                "input": "[1,1]",
                "output": "[2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "python": "\n    ```python\ndef find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums) {\n    vector<int> result;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        int index = abs(nums[i]) - 1;\n        nums[index] = -abs(nums[index]);\n    }\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "js": "\n    ```javascript\nfunction findDisappearedNumbers(nums) {\n    const result = [];\n\n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    "
    },
    {
        "id": 81,
        "title": "Assign Cookies",
        "difficulty": "Easy",
        "content": {
            "problem": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.",
            "examples": [
                "**Example 1:**\n\n**Input:** g = \\[1,2,3\\], s = \\[1,1\\]\n**Output:** 1\n**Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n",
                "**Example 2:**\n\n**Input:** g = \\[1,2\\], s = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= g.length <= 3 * 104`\n*   `0 <= s.length <= 3 * 104`\n*   `1 <= g[i], s[j] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3],[1,1]",
                "output": "1"
            },
            {
                "input": "[1,2],[1,2,3]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "python": "\n    ```python\ndef find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s) {\n    std::sort(g.begin(), g.end());\n    std::sort(s.begin(), s.end());\n    int i = 0, j = 0;\n\n    while (i < g.size() && j < s.size()) {\n      if (s[j] >= g[i]) {\n        i++;\n      }\n\n      j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "js": "\n    ```javascript\nfunction findContentChildren(g, s) {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    "
    },
    {
        "id": 82,
        "title": "Repeated Substring Pattern",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abab \"\n**Output:** true\n**Explanation:** It is the substring  \"ab \" twice.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abcabcabcabc \"\n**Output:** true\n**Explanation:** It is the substring  \"abc \" four times or the substring  \"abcabc \" twice."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"abab\"",
                "output": "true"
            },
            {
                "input": "\"aba\"",
                "output": "false"
            },
            {
                "input": "\"abcabcabcabc\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean canConstruct(String s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            String substr = s.substring(0, i);\n            boolean flag = true;\n            for (int j = i; j < n; j += i) {\n                if (!s.substring(j, j + i).equals(substr)) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "python": "\n    ```python\ndef can_construct(s):\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            substr = s[:i]\n            flag = True\n            for j in range(i, n, i):\n                if s[j:j+i] != substr:\n                    flag = False\n                    break\n\n            if flag:\n                return True\n\n    return False\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool can_construct(string s) {\n    int n = s.size();\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            string substr = s.substr(0, i);\n            bool flag = true;\n            for (int j = i; j < n; j += i) {\n                if (s.substr(j, i) != substr) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "js": "\n    ```javascript\nfunction canConstruct(s) {\n    const n = s.length;\n    for (let i = Math.floor(n / 2); i > 0; --i) {\n        if (n % i === 0) {\n            const substr = s.substring(0, i);\n            let flag = true;\n            for (let j = i; j < n; j += i) {\n                if (s.substring(j, j + i) !== substr) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    "
    },
    {
        "id": 83,
        "title": "Hamming Distance",
        "difficulty": "Easy",
        "content": {
            "problem": "The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers `x` and `y`, return _the **Hamming distance** between them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 1, y = 4\n**Output:** 2\n**Explanation:**\n1   (0 0 0 1)\n4   (0 1 0 0)\n          \nThe above arrows point to positions where the corresponding bits are different.\n\n",
                "**Example 2:**\n\n**Input:** x = 3, y = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= x, y <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "1,4",
                "output": "2"
            },
            {
                "input": "3,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "python": "\n    ```python\ndef hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "c++": "\n    ```cpp\nint hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "js": "\n    ```javascript\nfunction hammingDistance(x, y) {\n    let dist = 0;\n    let xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    "
    },
    {
        "id": 84,
        "title": "Island Perimeter",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]",
                "output": "16"
            },
            {
                "input": "[[1]]",
                "output": "4"
            },
            {
                "input": "[[1,0]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "python": "\n    ```python\ndef islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "c++": "\n    ```cpp\nint islandPerimeter(vector<vector<int>>& grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.size(); row++) {\n        for (int col = 0; col < grid[row].size(); col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "js": "\n    ```javascript\nfunction islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    "
    },
    {
        "id": 85,
        "title": "Number Complement",
        "difficulty": "Easy",
        "content": {
            "problem": "The **complement** of an integer is the integer you get when you flip all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n*   For example, The integer `5` is `\"101 \"` in binary and its **complement** is `\"010 \"` which is the integer `2`.\n\nGiven an integer `num`, return _its complement_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 5\n**Output:** 2\n**Explanation:** The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\n",
                "**Example 2:**\n\n**Input:** num = 1\n**Output:** 0\n**Explanation:** The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num < 231`\n\n**Note:** This question is the same as 1009: [https://leetcode.com/problems/complement-of-base-10-integer/](https://leetcode.com/problems/complement-of-base-10-integer/)",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "5",
                "output": "2"
            },
            {
                "input": "1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "python": "\n    ```python\ndef find_complement(num: int) -> int:\n    bit_length = 0\n    mask = num\n    while mask > 0:\n        mask >>= 1\n        bit_length += 1\n    all_ones = (1 << bit_length) - 1\n\n    return num ^ all_ones\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "c++": "\n    ```cpp\nint findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "js": "\n    ```javascript\nfunction findComplement(num) {\n    let bitLength = 0;\n    let mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    const allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    "
    },
    {
        "id": 86,
        "title": "License Key Formatting",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a license key represented as a string `s` that consists of only alphanumeric characters and dashes. The string is separated into `n + 1` groups by `n` dashes. You are also given an integer `k`.\n\nWe want to reformat the string `s` such that each group contains exactly `k` characters, except for the first group, which could be shorter than `k` but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\nReturn _the reformatted license key_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"5F3Z-2e-9-w \", k = 4\n**Output:**  \"5F3Z-2E9W \"\n**Explanation:** The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"2-5g-3-J \", k = 2\n**Output:**  \"2-5G-3J \"\n**Explanation:** The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of English letters, digits, and dashes `'-'`.\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"5F3Z-2e-9-w\",4",
                "output": "\"5F3Z-2E9W\""
            },
            {
                "input": "\"2-5g-3-J\",2",
                "output": "\"2-5G-3J\""
            }
        ],
        "java": "\n    ```java\npublic String licenseKeyFormatting(String s, int k) {\n    StringBuilder result = new StringBuilder();\n    int count = 0;\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s.charAt(i) != '-') {\n            if (count == k) {\n                result.append('-');\n                count = 0;\n            }\n            result.append(Character.toUpperCase(s.charAt(i)));\n            count++;\n        }\n    }\n    return result.reverse().toString();\n}\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "python": "\n    ```python\ndef license_key_formatting(s: str, k: int) -> str:\n    result = []\n    count = 0\n    for c in reversed(s):\n        if c != '-':\n            if count == k:\n                result.append('-')\n                count = 0\n            result.append(c.upper())\n            count += 1\n    return ''.join(reversed(result))\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <string>\nusing namespace std;\n\nstring licenseKeyFormatting(string s, int k) {\n    string result = \"\";\n    int count = 0;\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] != '-') {\n            if (count == k) {\n                result.push_back('-');\n                count = 0;\n            }\n            result.push_back(toupper(s[i]));\n            count++;\n        }\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "js": "\n    ```javascript\nfunction licenseKeyFormatting(s, k) {\n    let result = '';\n    let count = 0;\n    for (let i = s.length - 1; i >= 0; i--) {\n        if (s[i] !== '-') {\n            if (count === k) {\n                result = '-' + result;\n                count = 0;\n            }\n            result = s[i].toUpperCase() + result;\n            count++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    "
    },
    {
        "id": 87,
        "title": "Max Consecutive Ones",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,0,1,1,1\\]\n**Output:** 3\n**Explanation:** The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1,0,1\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,1,0,1,1,1]",
                "output": "3"
            },
            {
                "input": "[1,0,1,1,0,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "python": "\n    ```python\ndef findMaxConsecutiveOnes(nums):\n    max_consecutive, current_consecutive = 0, 0\n    for num in nums:\n        current_consecutive = current_consecutive + 1 if num == 1 else 0\n        max_consecutive = max(max_consecutive, current_consecutive)\n    return max_consecutive\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "c++": "\n    ```cpp\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "js": "\n    ```javascript\nfunction findMaxConsecutiveOnes(nums) {\n    let maxConsecutive = 0, currentConsecutive = 0;\n    for (let num of nums) {\n        currentConsecutive = (num === 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    "
    },
    {
        "id": 88,
        "title": "Construct the Rectangle",
        "difficulty": "Easy",
        "content": {
            "problem": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web page's area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n1.  The area of the rectangular web page you designed must equal to the given target area.\n2.  The width `W` should not be larger than the length `L`, which means `L >= W`.\n3.  The difference between length `L` and width `W` should be as small as possible.\n\nReturn _an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence._",
            "examples": [
                "**Example 1:**\n\n**Input:** area = 4\n**Output:** \\[2,2\\]\n**Explanation:** The target area is 4, and all the possible ways to construct it are \\[1,4\\], \\[2,2\\], \\[4,1\\]. \nBut according to requirement 2, \\[1,4\\] is illegal; according to requirement 3,  \\[4,1\\] is not optimal compared to \\[2,2\\]. So the length L is 2, and the width W is 2.\n\n",
                "**Example 2:**\n\n**Input:** area = 37\n**Output:** \\[37,1\\]\n\n",
                "**Example 3:**\n\n**Input:** area = 122122\n**Output:** \\[427,286\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= area <= 107`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "4",
                "output": "[2,2]"
            },
            {
                "input": "37",
                "output": "[37,1]"
            },
            {
                "input": "122122",
                "output": "[427,286]"
            }
        ],
        "java": "\n    ```java\npublic int[] constructRectangle(int area) {\n    int width = (int)Math.sqrt(area);\n    while(area % width != 0) {\n        width--;\n    }\n    int length = area / width;\n    return new int[]{length, width};\n}\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "python": "\n    ```python\ndef constructRectangle(area: int) -> List[int]:\n    width = int(area**0.5)\n    while area % width != 0:\n        width -= 1\n    length = area // width\n    return [length, width]\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> constructRectangle(int area) {\n    int width = std::sqrt(area);\n    while(area % width != 0) {\n        width -= 1;\n    }\n    int length = area / width;\n    return {length, width};\n}\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "js": "\n    ```javascript\nfunction constructRectangle(area) {\n    let width = Math.floor(Math.sqrt(area));\n    while(area % width !== 0) {\n        width--;\n    }\n    let length = area / width;\n    return [length, width];\n}\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    "
    },
    {
        "id": 89,
        "title": "Teemo Attacking",
        "difficulty": "Easy",
        "content": {
            "problem": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.\n\nReturn _the **total** number of seconds that Ashe is poisoned_.",
            "examples": [
                "**Example 1:**\n\n**Input:** timeSeries = \\[1,4\\], duration = 2\n**Output:** 4\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n\n",
                "**Example 2:**\n\n**Input:** timeSeries = \\[1,2\\], duration = 2\n**Output:** 3\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= timeSeries.length <= 104`\n*   `0 <= timeSeries[i], duration <= 107`\n*   `timeSeries` is sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,4],2",
                "output": "4"
            },
            {
                "input": "[1,2],2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findPoisonedDuration(int[] timeSeries, int duration) {\n    if (timeSeries.length == 0) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "python": "\n    ```python\ndef find_poisoned_duration(time_series, duration):\n    if not time_series:\n        return 0\n    total = 0\n    for i in range(1, len(time_series)):\n        total += min(time_series[i] - time_series[i - 1], duration)\n    return total + duration\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "c++": "\n    ```cpp\nint findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (timeSeries.empty()) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.size(); ++i) {\n        total += min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "js": "\n    ```javascript\nfunction findPoisonedDuration(timeSeries, duration) {\n    if (timeSeries.length === 0) return 0;\n    let total = 0;\n    for (let i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    "
    },
    {
        "id": 90,
        "title": "Next Greater Element I",
        "difficulty": "Easy",
        "content": {
            "problem": "The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.\n\nYou are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.\n\nFor each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.\n\nReturn _an array_ `ans` _of length_ `nums1.length` _such that_ `ans[i]` _is the **next greater element** as described above._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[4,1,2\\], nums2 = \\[1,3,4,2\\]\n**Output:** \\[-1,3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = \\[1,3,4,2\\]. The next greater element is 3.\n- 2 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[2,4\\], nums2 = \\[1,2,3,4\\]\n**Output:** \\[3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = \\[1,2,3,4\\]. The next greater element is 3.\n- 4 is underlined in nums2 = \\[1,2,3,4\\]. There is no next greater element, so the answer is -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length <= nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 104`\n*   All integers in `nums1` and `nums2` are **unique**.\n*   All the integers of `nums1` also appear in `nums2`.\n\n**",
            "follow_up": "Follow up:** Could you find an `O(nums1.length + nums2.length)` solution?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[4,1,2],[1,3,4,2]",
                "output": "[-1,3,-1]"
            },
            {
                "input": "[2,4],[1,2,3,4]",
                "output": "[3,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "python": "\n    ```python\ndef next_greater_element(nums1, nums2):\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "js": "\n    ```javascript\nfunction nextGreaterElement(nums1, nums2) {\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    return nums1.map(n => nextGreater.get(n) || -1);\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    "
    },
    {
        "id": 91,
        "title": "Keyboard Row",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `words`, return _the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below_.\n\nIn the **American keyboard**:\n\n*   the first row consists of the characters `\"qwertyuiop \"`,\n*   the second row consists of the characters `\"asdfghjkl \"`, and\n*   the third row consists of the characters `\"zxcvbnm \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"Hello \", \"Alaska \", \"Dad \", \"Peace \"\\]\n**Output:** \\[ \"Alaska \", \"Dad \"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"omk \"\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"adsdf \", \"sfd \"\\]\n**Output:** \\[ \"adsdf \", \"sfd \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 20`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of English letters (both lowercase and uppercase).",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]",
                "output": "[\"Alaska\",\"Dad\"]"
            },
            {
                "input": "[\"omk\"]",
                "output": "[]"
            },
            {
                "input": "[\"adsdf\",\"sfd\"]",
                "output": "[\"adsdf\",\"sfd\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class Solution {\n    public String[] findWords(String[] words) {\n        HashSet<Character>[] rows = new HashSet[] {\n            new HashSet<Character>() {{\n                add('q'); add('w'); add('e'); add('r'); add('t');\n                add('y'); add('u'); add('i'); add('o'); add('p');\n            }},\n            new HashSet<Character>() {{\n                add('a'); add('s'); add('d'); add('f'); add('g');\n                add('h'); add('j'); add('k'); add('l');\n            }},\n            new HashSet<Character>() {{\n                add('z'); add('x'); add('c'); add('v'); add('b');\n                add('n'); add('m');\n            }}\n        };\n        List<String> res = new ArrayList<>();\n        \n        for (String word : words) {\n            int row = -1;\n            for (int i = 0; i < 3; i++) {\n                if (rows[i].contains(Character.toLowerCase(word.charAt(0)))) {\n                    row = i;\n                    break;\n                }\n            }\n            \n            boolean isOneRow = true;\n            for (char letter : word.toCharArray()) {\n                if (!rows[row].contains(Character.toLowerCase(letter))) {\n                    isOneRow = false;\n                    break;\n                }\n            }\n            \n            if (isOneRow)\n                res.add(word);\n        }\n        \n        return res.toArray(new String[0]);\n    }\n}\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "python": "\n    ```python\ndef find_words(words):\n    rows = [\n        set(\"qwertyuiopQWERTYUIOP\"),\n        set(\"asdfghjklASDFGHJKL\"),\n        set(\"zxcvbnmZXCVBNM\")\n    ]\n    res = []\n\n    for word in words:\n        row = -1\n        for i in range(3):\n            if word[0] in rows[i]:\n                row = i\n                break\n\n        if all(c in rows[row] for c in word):\n            res.append(word)\n\n    return res\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> findWords(vector<string>& words) {\n    vector<unordered_set<char>> rows = {\n        {'q','w','e','r','t','y','u','i','o','p'},\n        {'a','s','d','f','g','h','j','k','l'},\n        {'z','x','c','v','b','n','m'}\n    };\n    vector<string> result;\n    \n    for (const auto& word : words) {\n        int row = -1;\n        for (int i = 0; i < 3; ++i) {\n            if (rows[i].count(tolower(word[0])) > 0) {\n                row = i;\n                break;\n            }\n        }\n        \n        bool isOneRow = true;\n        for (const auto& letter : word) {\n            if (rows[row].count(tolower(letter)) == 0) {\n                isOneRow = false;\n                break;\n            }\n        }\n        \n        if (isOneRow) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "js": "\n    ```javascript\nfunction findWords(words) {\n    const rows = [\n        new Set(\"qwertyuiopQWERTYUIOP\".split('')),\n        new Set(\"asdfghjklASDFGHJKL\".split('')),\n        new Set(\"zxcvbnmZXCVBNM\".split(''))\n    ];\n    const res = [];\n\n    for (const word of words) {\n        let row = -1;\n        for (let i = 0; i < 3; i++) {\n            if (rows[i].has(word[0])) {\n                row = i;\n                break;\n            }\n        }\n\n        if (word.split('').every(c => rows[row].has(c))) {\n            res.push(word);\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    "
    },
    {
        "id": 92,
        "title": "Find Mode in Binary Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree (BST) with duplicates, return _all the [mode(s)](https://en.wikipedia.org/wiki/Mode_(statistics)) (i.e., the most frequently occurred element) in it_.\n\nIf the tree has more than one mode, return them in **any order**.\n\nAssume a BST is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n*   Both the left and right subtrees must also be binary search trees.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,2\\]\n**Output:** \\[2\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\n\n**",
            "follow_up": "Follow up:** Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count)."
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,2]",
                "output": "[2]"
            },
            {
                "input": "[0]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\npublic List<Integer> findMode(TreeNode root) {\n    List<Integer> modes = new ArrayList<>();\n    if (root == null) return modes;\n    \n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode currentNode = root;\n    int maxFrequency = 0;\n    \n    while (currentNode != null || !stack.isEmpty()) {\n        while (currentNode != null) {\n            stack.add(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencyMap.put(currentNode.val, frequencyMap.getOrDefault(currentNode.val, 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencyMap.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        if (entry.getValue() == maxFrequency) modes.add(entry.getKey());\n    }\n    \n    return modes;\n}\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "python": "\n    ```python\ndef findMode(root):\n    def InOrder(node):\n        if not node: return\n        yield from InOrder(node.left)\n        yield node.val\n        yield from InOrder(node.right)\n        \n    counts = collections.Counter(InOrder(root))\n    max_count = max(counts.values(), default=0)\n    return [k for k, v in counts.items() if v == max_count]\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "c++": "\n    ```cpp\nvoid InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) {\n    if (!root) return;\n    InOrder(root->left, frequencies, max_frequency);\n    frequencies[root->val]++;\n    max_frequency = max(max_frequency, frequencies[root->val]);\n    InOrder(root->right, frequencies, max_frequency);\n}\n\nvector<int> findMode(TreeNode* root) {\n    unordered_map<int, int> frequencies;\n    int max_frequency = 0;\n    InOrder(root, frequencies, max_frequency);\n    vector<int> modes;\n    \n    for (const auto& freq : frequencies) {\n        if (freq.second == max_frequency) modes.push_back(freq.first);\n    }\n    \n    return modes;\n}\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "js": "\n    ```javascript\nfunction findMode(root) {\n    if (!root) return [];\n    \n    const frequencies = new Map();\n    const stack = [];\n    let maxFrequency = 0;\n    let currentNode = root;\n    \n    while (currentNode || stack.length) {\n        while (currentNode) {\n            stack.push(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencies.set(currentNode.val, (frequencies.get(currentNode.val) || 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencies.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    const modes = [];\n    for (const [key, value] of frequencies) {\n        if (value === maxFrequency) modes.push(key);\n    }\n    \n    return modes;\n}\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    "
    },
    {
        "id": 93,
        "title": "Base 7",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, return _a string of its **base 7** representation_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 100\n**Output:** \"202\"\n\n",
                "**Example 2:**\n\n**Input:** num = -7\n**Output:** \"-10\""
            ],
            "constraints": "**Constraints:**\n\n*   `-107 <= num <= 107`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "100",
                "output": "\"202\""
            },
            {
                "input": "-7",
                "output": "\"-10\""
            }
        ],
        "java": "\n    ```java\npublic String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "python": "\n    ```python\ndef convert_to_base7(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    result = \"\"\n    negative = num < 0\n    if negative:\n        num *= -1\n    while num > 0:\n        result = str(num % 7) + result\n        num //= 7\n    return \"-\" + result if negative else result\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "c++": "\n    ```cpp\nstd::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "js": "\n    ```javascript\nfunction convertToBase7(num) {\n    if (num === 0) return \"0\";\n    let result = \"\";\n    let negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = (num % 7).toString() + result;\n        num = Math.floor(num / 7);\n    }\n    return negative ? \"-\" + result : result;\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    "
    },
    {
        "id": 94,
        "title": "Relative Ranks",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `score` of size `n`, where `score[i]` is the score of the `ith` athlete in a competition. All the scores are guaranteed to be **unique**.\n\nThe athletes are **placed** based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:\n\n*   The `1st` place athlete's rank is `\"Gold Medal \"`.\n*   The `2nd` place athlete's rank is `\"Silver Medal \"`.\n*   The `3rd` place athlete's rank is `\"Bronze Medal \"`.\n*   For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `\"x \"`).\n\nReturn an array `answer` of size `n` where `answer[i]` is the **rank** of the `ith` athlete.",
            "examples": [
                "**Example 1:**\n\n**Input:** score = \\[5,4,3,2,1\\]\n**Output:** \\[ \"Gold Medal \", \"Silver Medal \", \"Bronze Medal \", \"4 \", \"5 \"\\]\n**Explanation:** The placements are \\[1st, 2nd, 3rd, 4th, 5th\\].\n\n",
                "**Example 2:**\n\n**Input:** score = \\[10,3,8,9,4\\]\n**Output:** \\[ \"Gold Medal \", \"5 \", \"Bronze Medal \", \"Silver Medal \", \"4 \"\\]\n**Explanation:** The placements are \\[1st, 5th, 3rd, 2nd, 4th\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == score.length`\n*   `1 <= n <= 104`\n*   `0 <= score[i] <= 106`\n*   All the values in `score` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[5,4,3,2,1]",
                "output": "[\"GoldMedal\",\"SilverMedal\",\"BronzeMedal\",\"4\",\"5\"]"
            },
            {
                "input": "[10,3,8,9,4]",
                "output": "[\"GoldMedal\",\"5\",\"BronzeMedal\",\"SilverMedal\",\"4\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] findRelativeRanks(int[] score) {\n    Integer[] rank_sort = new Integer[score.length];\n    for(int i = 0; i < score.length; ++i) rank_sort[i] = i;\n    Arrays.sort(rank_sort, (i1, i2) -> Integer.compare(score[i2], score[i1]));\n    int[] result = new int[score.length];\n    for(int i = 0; i < rank_sort.length; ++i) result[rank_sort[i]] = i + 1;\n    return result;\n}\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "python": "\n    ```python\ndef find_relative_ranks(score):\n    rank_sort = sorted(range(len(score)), key=lambda i: score[i], reverse=True)\n    result = [0] * len(score)\n    for i, rank in enumerate(rank_sort):\n        result[rank] = i + 1\n    return result\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> findRelativeRanks(std::vector<int>& score) {\n    std::vector<int> rank_sort(score.size());\n    for(int i = 0; i < score.size(); ++i) rank_sort[i] = i;\n    std::sort(rank_sort.begin(), rank_sort.end(), [&](int i1, int i2) { return score[i1] > score[i2]; });\n    std::vector<int>  result(score.size());\n    for(int i = 0; i < rank_sort.size(); ++i) result[rank_sort[i]] = i + 1;\n    return result;\n}\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "js": "\n    ```javascript\nfunction findRelativeRanks(score) {\n    const rankSort = [...Array(score.length).keys()].sort((a, b) => score[b] - score[a]);\n    const result = new Array(score.length);\n    for (let i = 0; i < rankSort.length; ++i) {\n        result[rankSort[i]] = i + 1;\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    "
    },
    {
        "id": 95,
        "title": "Perfect Number",
        "difficulty": "Easy",
        "content": {
            "problem": "A [**perfect number**](https://en.wikipedia.org/wiki/Perfect_number) is a **positive integer** that is equal to the sum of its **positive divisors**, excluding the number itself. A **divisor** of an integer `x` is an integer that can divide `x` evenly.\n\nGiven an integer `n`, return `true` _if_ `n` _is a perfect number, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 28\n**Output:** true\n**Explanation:** 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\n",
                "**Example 2:**\n\n**Input:** num = 7\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 108`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "28",
                "output": "true"
            },
            {
                "input": "7",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "python": "\n    ```python\ndef checkPerfectNumber(num: int) -> bool:\n    if num <= 1:\n        return False\n    sum = 1\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            sum += i\n            if i * i != num:\n                sum += num // i\n        i += 1\n    return sum == num\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "c++": "\n    ```cpp\nbool checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "js": "\n    ```javascript\nfunction checkPerfectNumber(num) {\n    if (num <= 1) return false;\n    let sum = 1;\n    for (let i = 2; i * i <= num; i++) {\n        if (num % i === 0) {\n            sum += i;\n            if (i * i !== num) sum += num / i;\n        }\n    }\n    return sum === num;\n}\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    "
    },
    {
        "id": 96,
        "title": "Fibonacci Number",
        "difficulty": "Easy",
        "content": {
            "problem": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 30`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Recursion",
            "Memoization"
        ],
        "example": [
            {
                "input": "2",
                "output": "1"
            },
            {
                "input": "3",
                "output": "2"
            },
            {
                "input": "4",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "python": "\n    ```python\ndef fib(n: int) -> int:\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "c++": "\n    ```cpp\nint fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "js": "\n    ```javascript\nfunction fib(n) {\n    if(n < 2) {\n        return n;\n    }\n    let a = 0, b = 1, c;\n    for(let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    "
    },
    {
        "id": 97,
        "title": "Detect Capital",
        "difficulty": "Easy",
        "content": {
            "problem": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\n*   All letters in this word are capitals, like `\"USA \"`.\n*   All letters in this word are not capitals, like `\"leetcode \"`.\n*   Only the first letter in this word is capital, like `\"Google \"`.\n\nGiven a string `word`, return `true` if the usage of capitals in it is right.",
            "examples": [
                "**Example 1:**\n\n**Input:** word = \"USA\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** word = \"FlaG\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 100`\n*   `word` consists of lowercase and uppercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"USA\"",
                "output": "true"
            },
            {
                "input": "\"FlaG\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean detectCapitalUse(String word) {\n    int numCapital = 0;\n    for (char c : word.toCharArray()) {\n        if (Character.isUpperCase(c)) numCapital++;\n    }\n    return numCapital == 0 || numCapital == word.length() || (numCapital == 1 && Character.isUpperCase(word.charAt(0)));\n}\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "python": "\n    ```python\ndef detectCapitalUse(word: str) -> bool:\n    numCapital = sum(1 for c in word if c.isupper())\n    return numCapital == 0 or numCapital == len(word) or (numCapital == 1 and word[0].isupper())\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "c++": "\n    ```cpp\nbool detectCapitalUse(string word) {\n    int numCapital = 0;\n    for (char c : word) {\n        if (isupper(c)) numCapital++;\n    }\n    return numCapital == 0 || numCapital == word.size() || (numCapital == 1 && isupper(word[0]));\n}\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "js": "\n    ```javascript\nfunction detectCapitalUse(word) {\n    let numCapital = 0;\n    for (let c of word) {\n        if (c === c.toUpperCase()) numCapital++;\n    }\n    return numCapital === 0 || numCapital === word.length || (numCapital === 1 && word[0] === word[0].toUpperCase());\n}\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    "
    },
    {
        "id": 98,
        "title": "Longest Uncommon Subsequence I",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `a` and `b`, return _the length of the **longest uncommon subsequence** between_ `a` _and_ `b`. If the longest uncommon subsequence does not exist, return `-1`.\n\nAn **uncommon subsequence** between two strings is a string that is a **subsequence of one but not the other**.\n\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string).",
            "examples": [
                "**Example 1:**\n\n**Input:** a =  \"aba \", b =  \"cdc \"\n**Output:** 3\n**Explanation:** One longest uncommon subsequence is  \"aba \" because  \"aba \" is a subsequence of  \"aba \" but not  \"cdc \".\nNote that  \"cdc \" is also a longest uncommon subsequence.\n\n",
                "**Example 2:**\n\n**Input:** a =  \"aaa \", b =  \"bbb \"\n**Output:** 3\n**Explanation:** The longest uncommon subsequences are  \"aaa \" and  \"bbb \".\n\n",
                "**Example 3:**\n\n**Input:** a =  \"aaa \", b =  \"aaa \"\n**Output:** -1\n**Explanation:** Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a.length, b.length <= 100`\n*   `a` and `b` consist of lower-case English letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"aba\",\"cdc\"",
                "output": "3"
            },
            {
                "input": "\"aaa\",\"bbb\"",
                "output": "3"
            },
            {
                "input": "\"aaa\",\"aaa\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findLUSlength(String a, String b) {\n    if (a.equals(b)) {\n        return -1;\n    }\n    return Math.max(a.length(), b.length());\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "python": "\n    ```python\ndef findLUSlength(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "c++": "\n    ```cpp\nint findLUSlength(string a, string b) {\n    if (a == b) {\n        return -1;\n    }\n    return max(a.length(), b.length());\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "js": "\n    ```javascript\nfunction findLUSlength(a, b) {\n    if (a === b) {\n        return -1;\n    }\n    return Math.max(a.length, b.length);\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    "
    },
    {
        "id": 99,
        "title": "Minimum Absolute Difference in BST",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a Binary Search Tree (BST), return _the minimum absolute difference between the values of any two different nodes in the tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,6,1,3\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,0,48,null,null,12,49\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 104]`.\n*   `0 <= Node.val <= 105`\n\n**Note:** This question is the same as 783: [https://leetcode.com/problems/minimum-distance-between-bst-nodes/](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[4,2,6,1,3]",
                "output": "1"
            },
            {
                "input": "[1,0,48,null,null,12,49]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\npublic class Solution {\n    private int result = Integer.MAX_VALUE;\n    private TreeNode prev;\n\n    public int getMinimumDifference(TreeNode root) {\n        inorderTraversal(root);\n        return result;\n    }\n\n    private void inorderTraversal(TreeNode node) {\n        if (node == null) return;\n        inorderTraversal(node.left);\n        if (prev != null) {\n            result = Math.min(result, node.val - prev.val);\n        }\n        prev = node;\n        inorderTraversal(node.right);\n    }\n}\n```\n    \n    The algorithm uses an in-order traversal of the binary search tree to find the minimum absolute difference between the values of any two different nodes in the tree. Since it's an in-order traversal, we are going through the nodes in ascending order, which makes it easier to calculate and compare differences. During the traversal, we maintain a `prev` variable that stores the previously visited node to calculate the difference with the current node. If the difference between the current node and the previous node is smaller than the current result, we update the result accordingly. At the end of the traversal, the result will be the minimum absolute difference between any two different nodes in the tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def getMinimumDifference(self, root: TreeNode) -> int:\n        result = float('inf')\n        prev = None\n\n        def inorderTraversal(node):\n            nonlocal result, prev\n            if node is None:\n                return\n            inorderTraversal(node.left)\n            if prev is not None:\n                result = min(result, node.val - prev.val)\n            prev = node\n            inorderTraversal(node.right)\n\n        inorderTraversal(root)\n        return result\n```\n    \n    The algorithm uses an in-order traversal of the binary search tree to find the minimum absolute difference between the values of any two different nodes in the tree. Since it's an in-order traversal, we are going through the nodes in ascending order, which makes it easier to calculate and compare differences. During the traversal, we maintain a `prev` variable that stores the previously visited node to calculate the difference with the current node. If the difference between the current node and the previous node is smaller than the current result, we update the result accordingly. At the end of the traversal, the result will be the minimum absolute difference between any two different nodes in the tree.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <climits>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        int result = INT_MAX, prev = -1;\n        minimumDifference(root, result, prev);\n        return result;\n    }\n\n    void minimumDifference(TreeNode* node, int& result, int& prev) {\n        if (!node) return;\n        minimumDifference(node->left, result, prev);\n        if (prev != -1) {\n            result = std::min(result, node->val - prev);\n        }\n        prev = node->val;\n        minimumDifference(node->right, result, prev);\n    }\n};\n```\n    \n    The algorithm uses an in-order traversal of the binary search tree to find the minimum absolute difference between the values of any two different nodes in the tree. Since it's an in-order traversal, we are going through the nodes in ascending order, which makes it easier to calculate and compare differences. During the traversal, we maintain a `prev` variable that stores the previously visited node to calculate the difference with the current node. If the difference between the current node and the previous node is smaller than the current result, we update the result accordingly. At the end of the traversal, the result will be the minimum absolute difference between any two different nodes in the tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n}\n\nfunction getMinimumDifference(root) {\n    let result = Number.MAX_VALUE, prev = null;\n\n    function inorderTraversal(node) {\n        if (!node) return;\n        inorderTraversal(node.left);\n        if (prev) {\n            result = Math.min(result, node.val - prev.val);\n        }\n        prev = node;\n        inorderTraversal(node.right);\n    }\n\n    inorderTraversal(root);\n    return result;\n}\n```\n    \n    The algorithm uses an in-order traversal of the binary search tree to find the minimum absolute difference between the values of any two different nodes in the tree. Since it's an in-order traversal, we are going through the nodes in ascending order, which makes it easier to calculate and compare differences. During the traversal, we maintain a `prev` variable that stores the previously visited node to calculate the difference with the current node. If the difference between the current node and the previous node is smaller than the current result, we update the result accordingly. At the end of the traversal, the result will be the minimum absolute difference between any two different nodes in the tree.\n    "
    },
    {
        "id": 100,
        "title": "Reverse String II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.\n\nIf there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abcdefg\", k = 2\n**Output:** \"bacdfeg\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\", k = 2\n**Output:** \"bacd\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"abcdefg\",2",
                "output": "\"bacdfeg\""
            },
            {
                "input": "\"abcd\",2",
                "output": "\"bacd\""
            }
        ],
        "java": "\n    ```java\npublic String reverseStr(String s, int k) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i += 2 * k) {\n        int left = i;\n        int right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            char temp = chars[left];\n            chars[left++] = chars[right];\n            chars[right--] = temp;\n        }\n    }\n    return new String(chars);\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "python": "\n    ```python\ndef reverseStr(s, k):\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        chars[i:i + k] = reversed(chars[i:i + k])\n    return \"\".join(chars)\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring reverseStr(string s, int k) {\n    for (int i = 0; i < s.size(); i += 2*k) {\n        if (i + k <= s.size()) {\n            reverse(s.begin() + i, s.begin() + i + k);\n        } else {\n            reverse(s.begin() + i, s.end());\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "js": "\n    ```javascript\nfunction reverseStr(s, k) {\n    let chars = s.split(\"\");\n    for (let i = 0; i < chars.length; i += 2 * k) {\n        let left = i;\n        let right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            [chars[left++], chars[right--]] = [chars[right], chars[left]];\n        }\n    }\n    return chars.join(\"\");\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    "
    },
    {
        "id": 101,
        "title": "Diameter of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the length of the **diameter** of the tree_.\n\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.\n\nThe **length** of a path between two nodes is represented by the number of edges between them.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5\\]\n**Output:** 3\n**Explanation:** 3 is the length of the path \\[4,2,1,3\\] or \\[5,2,1,3\\].\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5]",
                "output": "3"
            },
            {
                "input": "[1,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic int[] diameterHelper(TreeNode root) {\n    if (root == null) return new int[]{0, 0};\n    int[] left = diameterHelper(root.left);\n    int[] right = diameterHelper(root.right);\n    int maxHeight = 1 + Math.max(left[0], right[0]);\n    int maxDiameter = Math.max(left[0] + right[0], Math.max(left[1], right[1]));\n    return new int[]{maxHeight, maxDiameter};\n}\n\npublic int diameterOfBinaryTree(TreeNode root) {\n    return diameterHelper(root)[1];\n}\n```\n    \n    1. Create a helper function to return a tuple/array with two values:\n   - The height of the subtree rooted at the given node\n   - The largest diameter among the subtree's nodes\n2. If the node is null/None, return (0, 0), as the height and diameter are both 0.\n3. Recurse on the left and right children, obtaining their heights and diameters.\n4. The height at the current node is 1 + the maximum of the left and right heights.\n5. The diameter at the current node is the maximum of the following three values:\n   - The sum of the left and right heights (the path goes through the root)\n   - The left child's diameter\n   - The right child's diameter\n6. Return the diameter of the tree as the second element in the output tuple/array of the helper function called with the root node.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root):\n    def _diameter_of_binary_tree(node):\n        if not node:\n            return 0, 0\n        left_height, left_diameter = _diameter_of_binary_tree(node.left)\n        right_height, right_diameter = _diameter_of_binary_tree(node.right)\n        height = 1 + max(left_height, right_height)\n        diameter = max(left_height + right_height, max(left_diameter, right_diameter))\n        return height, diameter\n\n    return _diameter_of_binary_tree(root)[1]\n```\n    \n    1. Create a helper function to return a tuple/array with two values:\n   - The height of the subtree rooted at the given node\n   - The largest diameter among the subtree's nodes\n2. If the node is null/None, return (0, 0), as the height and diameter are both 0.\n3. Recurse on the left and right children, obtaining their heights and diameters.\n4. The height at the current node is 1 + the maximum of the left and right heights.\n5. The diameter at the current node is the maximum of the following three values:\n   - The sum of the left and right heights (the path goes through the root)\n   - The left child's diameter\n   - The right child's diameter\n6. Return the diameter of the tree as the second element in the output tuple/array of the helper function called with the root node.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root, int* height) {\n    int leftHeight = 0, rightHeight = 0;\n    if (root == nullptr) {\n        *height = 0;\n        return 0;\n    }\n    int leftDiameter = diameterOfBinaryTree(root->left, &leftHeight);\n    int rightDiameter = diameterOfBinaryTree(root->right, &rightHeight);\n    *height = std::max(leftHeight, rightHeight) + 1;\n    return std::max(std::max(leftDiameter, rightDiameter), leftHeight + rightHeight);\n}\n```\n    \n    1. Create a helper function to return a tuple/array with two values:\n   - The height of the subtree rooted at the given node\n   - The largest diameter among the subtree's nodes\n2. If the node is null/None, return (0, 0), as the height and diameter are both 0.\n3. Recurse on the left and right children, obtaining their heights and diameters.\n4. The height at the current node is 1 + the maximum of the left and right heights.\n5. The diameter at the current node is the maximum of the following three values:\n   - The sum of the left and right heights (the path goes through the root)\n   - The left child's diameter\n   - The right child's diameter\n6. Return the diameter of the tree as the second element in the output tuple/array of the helper function called with the root node.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction diameterOfBinaryTree(root) {\n    function diameterHelper(node) {\n        if (!node) return [0, 0];\n        let [leftHeight, leftDiameter] = diameterHelper(node.left);\n        let [rightHeight, rightDiameter] = diameterHelper(node.right);\n        let maxHeight = 1 + Math.max(leftHeight, rightHeight);\n        let maxDiameter = Math.max(leftHeight + rightHeight, Math.max(leftDiameter, rightDiameter));\n        return [maxHeight, maxDiameter];\n    }\n\n    return diameterHelper(root)[1];\n}\n```\n\n    \n    1. Create a helper function to return a tuple/array with two values:\n   - The height of the subtree rooted at the given node\n   - The largest diameter among the subtree's nodes\n2. If the node is null/None, return (0, 0), as the height and diameter are both 0.\n3. Recurse on the left and right children, obtaining their heights and diameters.\n4. The height at the current node is 1 + the maximum of the left and right heights.\n5. The diameter at the current node is the maximum of the following three values:\n   - The sum of the left and right heights (the path goes through the root)\n   - The left child's diameter\n   - The right child's diameter\n6. Return the diameter of the tree as the second element in the output tuple/array of the helper function called with the root node.\n    "
    },
    {
        "id": 102,
        "title": "Student Attendance Record I",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nThe student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nReturn `true` _if the student is eligible for an attendance award, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"PPALLP \"\n**Output:** true\n**Explanation:** The student has fewer than 2 absences and was never late 3 or more consecutive days.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"PPALLL \"\n**Output:** false\n**Explanation:** The student was late 3 consecutive days in the last 3 days, so is not eligible for the award."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'A'`, `'L'`, or `'P'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"PPALLP\"",
                "output": "true"
            },
            {
                "input": "\"PPALLL\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean checkRecord(String s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == 'A') {\n            absent++;\n            late = 0;\n        } else if (s.charAt(i) == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "python": "\n    ```python\ndef checkRecord(s: str) -> bool:\n    late, absent = 0, 0\n    for c in s:\n        if c == 'A':\n            absent += 1\n            late = 0\n        elif c == 'L':\n            late += 1\n        else:\n            late = 0\n\n        if absent >= 2 or late >= 3:\n            return False\n    return True\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nbool checkRecord(std::string s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "js": "\n    ```javascript\nfunction checkRecord(s) {\n    let late = 0, absent = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] === 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    "
    },
    {
        "id": 103,
        "title": "Reverse Words in a String III",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"Let's take LeetCode contest\"\n**Output:** \"s'teL ekat edoCteeL tsetnoc\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"God Ding\"\n**Output:** \"doG gniD\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `s` contains printable **ASCII** characters.\n*   `s` does not contain any leading or trailing spaces.\n*   There is **at least one** word in `s`.\n*   All the words in `s` are separated by a single space.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"Let'stakeLeetCodecontest\"",
                "output": "\"s'teLekatedoCteeLtsetnoc\""
            },
            {
                "input": "\"GodDing\"",
                "output": "\"doGgniD\""
            }
        ],
        "java": "\n    ```java\nimport java.util.StringJoiner;\n\npublic String reverseWordsInString(String s) {\n    String[] words = s.split(\" \");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = new StringBuilder(words[i]).reverse().toString();\n    }\n    return String.join(\" \", words);\n}\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "python": "\n    ```python\ndef reverse_words_in_string(s: str) -> str:\n    return \" \".join(word[::-1] for word in s.split(\" \"))\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nstd::string reverseWordsInString(const std::string& s) {\n    std::istringstream iss(s);\n    std::ostringstream oss;\n    std::string word;\n    while (iss >> word) {\n        std::reverse(word.begin(), word.end());\n        oss << word << ' ';\n    }\n    std::string result = oss.str();\n    if (!result.empty()) result.pop_back();\n    return result;\n}\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "js": "\n    ```javascript\nfunction reverseWordsInString(s) {\n    return s.split(' ').map(word => word.split('').reverse().join('')).join(' ');\n}\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    "
    },
    {
        "id": 104,
        "title": "Maximum Depth of N-ary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a n-ary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n_Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples)._",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   The total number of nodes is in the range `[0, 104]`.\n*   The depth of the n-ary tree is less than or equal to `1000`.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "3"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic class Node {\n    public int val;\n    public List<Node> children;\n    \n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n\npublic int maxDepth(Node root) {\n    if (root == null) return 0;\n    int maxDepth = 0;\n    for (Node child : root.children) {\n        maxDepth = Math.max(maxDepth, maxDepth(child));\n    }\n    return maxDepth + 1;\n}\n```\n    \n    The algorithm used for all the language implementations is Depth First Traversal. The base case checks if the current root is `null` or not. If it is `null`, the function returns 0. Then, we iterate through each child node in the `children` list and calculate the maximum depth from each child node by making a recursive call. The maximum depth from a child node is added to the current depth which is initialized to 0. Finally, we return the maximum depth + 1 to account for the current node.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    max_depth = 0\n    for child in root.children:\n        max_depth = max(max_depth, max_depth(child))\n    return max_depth + 1\n```\n    \n    The algorithm used for all the language implementations is Depth First Traversal. The base case checks if the current root is `null` or not. If it is `null`, the function returns 0. Then, we iterate through each child node in the `children` list and calculate the maximum depth from each child node by making a recursive call. The maximum depth from a child node is added to the current depth which is initialized to 0. Finally, we return the maximum depth + 1 to account for the current node.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nint maxDepth(Node* root) {\n    if (!root) return 0;\n    int max_depth = 0;\n    for (Node* child : root->children) {\n        max_depth = max(max_depth, maxDepth(child));\n    }\n    return max_depth + 1;\n}\n```\n    \n    The algorithm used for all the language implementations is Depth First Traversal. The base case checks if the current root is `null` or not. If it is `null`, the function returns 0. Then, we iterate through each child node in the `children` list and calculate the maximum depth from each child node by making a recursive call. The maximum depth from a child node is added to the current depth which is initialized to 0. Finally, we return the maximum depth + 1 to account for the current node.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, children) {\n        this.val = val;\n        this.children = children ? children : [];\n    }\n}\n\nfunction maxDepth(root) {\n    if (!root) return 0;\n    let maxDepth = 0;\n    for (const child of root.children) {\n        maxDepth = Math.max(maxDepth, maxDepth(child));\n    }\n    return maxDepth + 1;\n}\n```\n    \n    The algorithm used for all the language implementations is Depth First Traversal. The base case checks if the current root is `null` or not. If it is `null`, the function returns 0. Then, we iterate through each child node in the `children` list and calculate the maximum depth from each child node by making a recursive call. The maximum depth from a child node is added to the current depth which is initialized to 0. Finally, we return the maximum depth + 1 to account for the current node.\n    "
    },
    {
        "id": 105,
        "title": "Array Partition",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,4,3,2\\]\n**Output:** 4\n**Explanation:** All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,2,6,5,1,2\\]\n**Output:** 9\n**Explanation:** The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`\n*   `nums.length == 2 * n`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Counting Sort"
        ],
        "example": [
            {
                "input": "[1,4,3,2]",
                "output": "4"
            },
            {
                "input": "[6,2,6,5,1,2]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int arrayPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int sum = 0;\n    for (int i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "python": "\n    ```python\ndef array_pair_sum(nums):\n    nums.sort()\n    return sum(nums[::2])\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint arrayPairSum(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "js": "\n    ```javascript\nfunction arrayPairSum(nums) {\n    nums.sort((a, b) => a - b);\n    let sum = 0;\n    for (let i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    "
    },
    {
        "id": 106,
        "title": "Binary Tree Tilt",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the sum of every tree node's **tilt**._\n\nThe **tilt** of a tree node is the **absolute difference** between the sum of all left subtree node **values** and all right subtree node **values**. If a node does not have a left child, then the sum of the left subtree node **values** is treated as `0`. The rule is similar if the node does not have a right child.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\n",
                "**Example 2:**\n\n**Input:** root = \\[4,2,9,3,5,null,7\\]\n**Output:** 15\n**Explanation:** \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\n",
                "**Example 3:**\n\n**Input:** root = \\[21,7,14,1,1,2,2,3,3\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "1"
            },
            {
                "input": "[4,2,9,3,5,null,7]",
                "output": "15"
            },
            {
                "input": "[21,7,14,1,1,2,2,3,3]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int findTilt(TreeNode root) {\n    int[] tiltSum = new int[] {0};\n    findTiltUtil(root, tiltSum);\n    return tiltSum[0];\n}\n\nprivate int findTiltUtil(TreeNode root, int[] tiltSum) {\n    if (root == null) {\n        return 0;\n    }\n\n    int leftSum = findTiltUtil(root.left, tiltSum);\n    int rightSum = findTiltUtil(root.right, tiltSum);\n\n    tiltSum[0] += Math.abs(leftSum - rightSum);\n    return root.val + leftSum + rightSum;\n}\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "python": "\n    ```python\ndef findTilt(self, root):\n    def findTiltUtil(node):\n        if not node: return 0, 0\n        \n        leftSum, leftTilt = findTiltUtil(node.left)\n        rightSum, rightTilt = findTiltUtil(node.right)\n    \n        return (node.val + leftSum + rightSum, abs(leftSum - rightSum) + leftTilt + rightTilt)\n\n    return findTiltUtil(root)[1]\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "c++": "\n    ```cpp\nint findTiltUtil(TreeNode* root, int& tiltSum) {\n    if (!root) return 0;\n\n    int leftSum = findTiltUtil(root->left, tiltSum);\n    int rightSum = findTiltUtil(root->right, tiltSum);\n\n    tiltSum += abs(leftSum - rightSum);\n    return root->val + leftSum + rightSum;\n}\n\nint findTilt(TreeNode* root) {\n    int tiltSum = 0;\n    findTiltUtil(root, tiltSum);\n    return tiltSum;\n}\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "js": "\n    ```javascript\nfunction findTilt(root) {\n    function findTiltUtil(node) {\n        if (!node) return [0, 0];\n        \n        let [leftSum, leftTilt] = findTiltUtil(node.left);\n        let [rightSum, rightTilt] = findTiltUtil(node.right);\n    \n        return [node.val + leftSum + rightSum, Math.abs(leftSum - rightSum) + leftTilt + rightTilt];\n    }\n\n    return findTiltUtil(root)[1];\n};\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    "
    },
    {
        "id": 107,
        "title": "Reshape the Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "In MATLAB, there is a handy function called `reshape` which can reshape an `m x n` matrix into a new one with a different size `r x c` keeping its original data.\n\nYou are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix.\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\nIf the `reshape` operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,2\\],\\[3,4\\]\\], r = 1, c = 4\n**Output:** \\[\\[1,2,3,4\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,2\\],\\[3,4\\]\\], r = 2, c = 4\n**Output:** \\[\\[1,2\\],\\[3,4\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 100`\n*   `-1000 <= mat[i][j] <= 1000`\n*   `1 <= r, c <= 300`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,2],[3,4]],1,4",
                "output": "[[1,2,3,4]]"
            },
            {
                "input": "[[1,2],[3,4]],2,4",
                "output": "[[1,2],[3,4]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\n    int m = mat.length;\n    int n = mat[0].length;\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    int[][] reshaped = new int[r][c];\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n\n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "python": "\n    ```python\ndef matrixReshape(mat, r, c):\n    m, n = len(mat), len(mat[0])\n    if m * n != r * c:\n        return mat\n\n    reshaped = [[0] * c for _ in range(r)]\n    for i in range(m * n):\n        reshaped[i // c][i % c] = mat[i // n][i % n]\n\n    return reshaped\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\n    int m = mat.size();\n    int n = mat[0].size();\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    vector<vector<int>> reshaped(r, vector<int>(c));\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n    \n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "js": "\n    ```javascript\nfunction matrixReshape(mat, r, c) {\n    const m = mat.length;\n    const n = mat[0].length;\n    if (m * n !== r * c) {\n        return mat;\n    }\n\n    const reshaped = new Array(r).fill(null).map(() => new Array(c));\n    for (let i = 0; i < m * n; ++i) {\n        reshaped[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n];\n    }\n\n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    "
    },
    {
        "id": 108,
        "title": "Subtree of Another Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,4,5,1,2\\], subRoot = \\[4,1,2\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,4,5,1,2,null,null,null,null,0\\], subRoot = \\[4,1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the `root` tree is in the range `[1, 2000]`.\n*   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.\n*   `-104 <= root.val <= 104`\n*   `-104 <= subRoot.val <= 104`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "String Matching",
            "Binary Tree",
            "Hash Function"
        ],
        "example": [
            {
                "input": "[3,4,5,1,2],[4,1,2]",
                "output": "true"
            },
            {
                "input": "[3,4,5,1,2,null,null,null,null,0],[4,1,2]",
                "output": "false"
            }
        ],
        "java": "\n    \n```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if (root == null) return false;\n    if (isIdentical(root, subRoot)) return true;\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n\npublic boolean isIdentical(TreeNode n1, TreeNode n2) {\n    if (n1 == null || n2 == null) return n1 == n2;\n    if (n1.val != n2.val) return false;\n    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);\n}\n```\n\n    \n    \nThe algorithm checks if `subRoot` is a subtree of `root` by first looking whether the two trees have the same root node. If they do, it checks whether the substructures are also identical. If they are not, then `subRoot` is not a subtree at this level, and the algorithm looks further down the left and right branches of `root`. This is done by returning the logical `OR` between the result of checking left and right branches.\n\nThe helper function `isIdentical` checks whether the two given trees have the same structure and node values, by comparing the current nodes and then recursively traversing the left and right substructures. If a `None` value for a node is found, the two nodes are identical if they are both `None`. Otherwise, if the node values differ, the trees are not identical.\n    ",
        "js": "\n    \n```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isSubtree(root, subRoot) {\n    if (root === null) return false;\n    if (isIdentical(root, subRoot)) return true;\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n\nfunction isIdentical(n1, n2) {\n    if (n1 === null || n2 === null) return n1 === n2;\n    if (n1.val !== n2.val) return false;\n    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);\n}\n```\n\n    \n    \nThe algorithm checks if `subRoot` is a subtree of `root` by first looking whether the two trees have the same root node. If they do, it checks whether the substructures are also identical. If they are not, then `subRoot` is not a subtree at this level, and the algorithm looks further down the left and right branches of `root`. This is done by returning the logical `OR` between the result of checking left and right branches.\n\nThe helper function `isIdentical` checks whether the two given trees have the same structure and node values, by comparing the current nodes and then recursively traversing the left and right substructures. If a `None` value for a node is found, the two nodes are identical if they are both `None`. Otherwise, if the node values differ, the trees are not identical.\n    ",
        "c++": "\n    \n```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nbool isSubtree(TreeNode* root, TreeNode* subRoot) {\n    if (root == nullptr) return false;\n    if (isIdentical(root, subRoot)) return true;\n    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\n}\n\nbool isIdentical(TreeNode* n1, TreeNode* n2) {\n    if (n1 == nullptr || n2 == nullptr) return n1 == n2;\n    if (n1->val != n2->val) return false;\n    return isIdentical(n1->left, n2->left) && isIdentical(n1->right, n2->right);\n}\n```\n\n    \n    \nThe algorithm checks if `subRoot` is a subtree of `root` by first looking whether the two trees have the same root node. If they do, it checks whether the substructures are also identical. If they are not, then `subRoot` is not a subtree at this level, and the algorithm looks further down the left and right branches of `root`. This is done by returning the logical `OR` between the result of checking left and right branches.\n\nThe helper function `isIdentical` checks whether the two given trees have the same structure and node values, by comparing the current nodes and then recursively traversing the left and right substructures. If a `None` value for a node is found, the two nodes are identical if they are both `None`. Otherwise, if the node values differ, the trees are not identical.\n    ",
        "python": "\n    \n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \ndef isSubtree(root, subRoot):\n    if root is None:\n        return False\n    if is_identical(root, subRoot):\n        return True\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef is_identical(n1, n2):\n    if n1 is None or n2 is None:\n        return n1 == n2\n    if n1.val != n2.val:\n        return False\n    return is_identical(n1.left, n2.left) and is_identical(n1.right, n2.right)\n```\n\n    \n    \nThe algorithm checks if `subRoot` is a subtree of `root` by first looking whether the two trees have the same root node. If they do, it checks whether the substructures are also identical. If they are not, then `subRoot` is not a subtree at this level, and the algorithm looks further down the left and right branches of `root`. This is done by returning the logical `OR` between the result of checking left and right branches.\n\nThe helper function `isIdentical` checks whether the two given trees have the same structure and node values, by comparing the current nodes and then recursively traversing the left and right substructures. If a `None` value for a node is found, the two nodes are identical if they are both `None`. Otherwise, if the node values differ, the trees are not identical.\n    "
    },
    {
        "id": 109,
        "title": "Distribute Candies",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array `candyType` of length `n`, return _the **maximum** number of different types of candies she can eat if she only eats_ `n / 2` _of them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** candyType = \\[1,1,2,2,3,3\\]\n**Output:** 3\n**Explanation:** Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n\n",
                "**Example 2:**\n\n**Input:** candyType = \\[1,1,2,3\\]\n**Output:** 2\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Whether she eats types \\[1,2\\], \\[1,3\\], or \\[2,3\\], she still can only eat 2 different types.\n\n",
                "**Example 3:**\n\n**Input:** candyType = \\[6,6,6,6\\]\n**Output:** 1\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
            ],
            "constraints": "**Constraints:**\n\n*   `n == candyType.length`\n*   `2 <= n <= 104`\n*   `n` is even.\n*   `-105 <= candyType[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,1,2,2,3,3]",
                "output": "3"
            },
            {
                "input": "[1,1,2,3]",
                "output": "2"
            },
            {
                "input": "[6,6,6,6]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int maxNumberOfCandies(int[] candyType) {\n    Set<Integer> uniqueCandies = new HashSet<>();\n    for (int type : candyType) {\n        uniqueCandies.add(type);\n    }\n    return Math.min(uniqueCandies.size(), candyType.length / 2);\n}\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "python": "\n    ```python\ndef maxNumberOfCandies(candyType):\n    uniqueCandies = set(candyType)\n    return min(len(uniqueCandies), len(candyType) // 2)\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint maxNumberOfCandies(vector<int>& candyType) {\n    unordered_set<int> uniqueCandies(candyType.begin(), candyType.end());\n    return min(uniqueCandies.size(), candyType.size() / 2);\n}\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberOfCandies(candyType) {\n    const uniqueCandies = new Set(candyType);\n    return Math.min(uniqueCandies.size, candyType.length / 2);\n}\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    "
    },
    {
        "id": 110,
        "title": "N-ary Tree Preorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of an n-ary tree, return _the preorder traversal of its nodes' values_.\n\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** \\[1,3,5,6,2,4\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** \\[1,2,3,6,7,11,14,4,8,12,5,9,13,10\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `0 <= Node.val <= 104`\n*   The height of the n-ary tree is less than or equal to `1000`.\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search"
        ],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "[1,3,5,6,2,4]"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "[1,2,3,6,7,11,14,4,8,12,5,9,13,10]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n\npublic List<Integer> preorder(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    Stack<Node> nodes = new Stack<>();\n    nodes.push(root);\n    \n    while (!nodes.isEmpty()) {\n        Node current = nodes.pop();\n        result.add(current.val);\n        for (int i = current.children.size() - 1; i >= 0; i--) {\n            nodes.push(current.children.get(i));\n        }\n    }\n    return result;\n}\n```\n    \n    The problem asks for an iterative solution, although a recursive solution would be trivial. Therefore, this solution uses a stack data structure to perform the preorder traversal of the n-ary tree.\n\n1. Initialize an empty list called `result` to store the traversed node values.\n2. If `root` is null, return the empty `result`.\n3. Initialize a stack called `nodes` and push `root` onto the stack.\n4. While the stack is not empty, perform the following steps:\n   a. Pop the top node from the stack and store it in a variable called `current`.\n   b. Add `current`'s value to the `result`.\n   c. Reverse iterate through `current`'s children, pushing them onto the stack.\n5. Once the stack is empty, return the `result`.\n\nThe algorithm's time complexity is O(n), where n is the number of nodes in the tree. This is because each node gets pushed onto and popped from the stack exactly once. The space complexity is also O(n), as at worst, the stack will store all the nodes in the tree.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\ndef preorder(root):\n    result = []\n    if not root:\n        return result\n    nodes = [root]\n\n    while nodes:\n        current = nodes.pop()\n        result.append(current.val)\n        nodes.extend(reversed(current.children))\n    return result\n```\n    \n    The problem asks for an iterative solution, although a recursive solution would be trivial. Therefore, this solution uses a stack data structure to perform the preorder traversal of the n-ary tree.\n\n1. Initialize an empty list called `result` to store the traversed node values.\n2. If `root` is null, return the empty `result`.\n3. Initialize a stack called `nodes` and push `root` onto the stack.\n4. While the stack is not empty, perform the following steps:\n   a. Pop the top node from the stack and store it in a variable called `current`.\n   b. Add `current`'s value to the `result`.\n   c. Reverse iterate through `current`'s children, pushing them onto the stack.\n5. Once the stack is empty, return the `result`.\n\nThe algorithm's time complexity is O(n), where n is the number of nodes in the tree. This is because each node gets pushed onto and popped from the stack exactly once. The space complexity is also O(n), as at worst, the stack will store all the nodes in the tree.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nclass Node {\npublic:\n    int val;\n    std::vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, std::vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nvector<int> preorder(Node* root) {\n    vector<int> result;\n    if (root == nullptr) return result;\n    stack<Node*> nodes;\n    nodes.push(root);\n    \n    while (!nodes.empty()) {\n        Node* current = nodes.top();\n        nodes.pop();\n        result.push_back(current->val);\n        for (int i = current->children.size() - 1; i >= 0; i--) {\n            nodes.push(current->children[i]);\n        }\n    }\n    return result;\n}\n```\n    \n    The problem asks for an iterative solution, although a recursive solution would be trivial. Therefore, this solution uses a stack data structure to perform the preorder traversal of the n-ary tree.\n\n1. Initialize an empty list called `result` to store the traversed node values.\n2. If `root` is null, return the empty `result`.\n3. Initialize a stack called `nodes` and push `root` onto the stack.\n4. While the stack is not empty, perform the following steps:\n   a. Pop the top node from the stack and store it in a variable called `current`.\n   b. Add `current`'s value to the `result`.\n   c. Reverse iterate through `current`'s children, pushing them onto the stack.\n5. Once the stack is empty, return the `result`.\n\nThe algorithm's time complexity is O(n), where n is the number of nodes in the tree. This is because each node gets pushed onto and popped from the stack exactly once. The space complexity is also O(n), as at worst, the stack will store all the nodes in the tree.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, children) {\n        this.val = val === undefined ? 0 : val;\n        this.children = children === undefined ? [] : children;\n    }\n}\n\nvar preorder = function(root) {\n    const result = [];\n    if (!root) return result;\n    const nodes = [root];\n\n    while (nodes.length > 0) {\n        const current = nodes.pop();\n        result.push(current.val);\n        for (let i = current.children.length - 1; i >= 0; i--) {\n            nodes.push(current.children[i]);\n        }\n    }\n    return result;\n};\n```\n\n    \n    The problem asks for an iterative solution, although a recursive solution would be trivial. Therefore, this solution uses a stack data structure to perform the preorder traversal of the n-ary tree.\n\n1. Initialize an empty list called `result` to store the traversed node values.\n2. If `root` is null, return the empty `result`.\n3. Initialize a stack called `nodes` and push `root` onto the stack.\n4. While the stack is not empty, perform the following steps:\n   a. Pop the top node from the stack and store it in a variable called `current`.\n   b. Add `current`'s value to the `result`.\n   c. Reverse iterate through `current`'s children, pushing them onto the stack.\n5. Once the stack is empty, return the `result`.\n\nThe algorithm's time complexity is O(n), where n is the number of nodes in the tree. This is because each node gets pushed onto and popped from the stack exactly once. The space complexity is also O(n), as at worst, the stack will store all the nodes in the tree.\n    "
    },
    {
        "id": 111,
        "title": "N-ary Tree Postorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of an n-ary tree, return _the postorder traversal of its nodes' values_.\n\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** \\[5,6,3,2,4,1\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** \\[2,6,14,11,7,3,12,8,4,13,9,10,5,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `0 <= Node.val <= 104`\n*   The height of the n-ary tree is less than or equal to `1000`.\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search"
        ],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "[5,6,3,2,4,1]"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "[2,6,14,11,7,3,12,8,4,13,9,10,5,1]"
            }
        ],
        "java": "\n    ```java\nclass Node {\n    public int val;\n    public List<Node> children;\n}\n\npublic List<Integer> postorder(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    \n    Stack<Node> stk = new Stack<>();\n    stk.push(root);\n    \n    while (!stk.isEmpty()) {\n        Node current = stk.pop();\n        result.add(current.val);\n        \n        for (Node child : current.children)\n            stk.push(child);\n    }\n    \n    Collections.reverse(result);\n    return result;\n}\n```\n    \n    The algorithm for iterative postorder traversal of an n-ary tree is as follows:\n\n1. Create an empty stack and push the root node onto it.\n2. While the stack is not empty:\n    a. Pop the top node from the stack and add its value to the result list.\n    b. Iterate through the node's children, pushing them onto the stack.\n3. Reverse the result list and return it.\n\nThis algorithm ensures a depth-first traversal of the tree, visiting each node's children before the node itself (postorder traversal). By reversing the result list at the end, the desired postorder list is obtained.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children or []\n\ndef postorder(root):\n    result = []\n    if not root:\n        return result\n    \n    stk = [root]\n    \n    while stk:\n        current = stk.pop()\n        result.append(current.val)\n        \n        for child in current.children:\n            stk.append(child)\n    \n    return result[::-1]\n```\n    \n    The algorithm for iterative postorder traversal of an n-ary tree is as follows:\n\n1. Create an empty stack and push the root node onto it.\n2. While the stack is not empty:\n    a. Pop the top node from the stack and add its value to the result list.\n    b. Iterate through the node's children, pushing them onto the stack.\n3. Reverse the result list and return it.\n\nThis algorithm ensures a depth-first traversal of the tree, visiting each node's children before the node itself (postorder traversal). By reversing the result list at the end, the desired postorder list is obtained.\n    ",
        "c++": "\n    ```cpp\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nvector<int> postorder(Node* root) {\n    vector<int> result;\n    if (!root) return result;\n    \n    stack<Node*> stk;\n    stk.push(root);\n    \n    while (!stk.empty()) {\n        Node* current = stk.top();\n        stk.pop();\n        result.push_back(current->val);\n        \n        for (auto child : current->children)\n            stk.push(child);\n    }\n    \n    reverse(result.begin(), result.end());\n    return result;\n}\n```\n    \n    The algorithm for iterative postorder traversal of an n-ary tree is as follows:\n\n1. Create an empty stack and push the root node onto it.\n2. While the stack is not empty:\n    a. Pop the top node from the stack and add its value to the result list.\n    b. Iterate through the node's children, pushing them onto the stack.\n3. Reverse the result list and return it.\n\nThis algorithm ensures a depth-first traversal of the tree, visiting each node's children before the node itself (postorder traversal). By reversing the result list at the end, the desired postorder list is obtained.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, children) {\n        this.val = val;\n        this.children = children || [];\n    }\n}\n\nfunction postorder(root) {\n    let result = [];\n    if (!root) return result;\n    \n    let stk = [root];\n    \n    while (stk.length > 0) {\n        let current = stk.pop();\n        result.push(current.val);\n        \n        for (let child of current.children)\n            stk.push(child);\n    }\n    \n    return result.reverse();\n}\n```\n    \n    The algorithm for iterative postorder traversal of an n-ary tree is as follows:\n\n1. Create an empty stack and push the root node onto it.\n2. While the stack is not empty:\n    a. Pop the top node from the stack and add its value to the result list.\n    b. Iterate through the node's children, pushing them onto the stack.\n3. Reverse the result list and return it.\n\nThis algorithm ensures a depth-first traversal of the tree, visiting each node's children before the node itself (postorder traversal). By reversing the result list at the end, the desired postorder list is obtained.\n    "
    },
    {
        "id": 112,
        "title": "Longest Harmonious Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is **exactly** `1`.\n\nGiven an integer array `nums`, return _the length of its longest harmonious subsequence among all its possible subsequences_.\n\nA **subsequence** of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,2,5,2,3,7\\]\n**Output:** 5\n**Explanation:** The longest harmonious subsequence is \\[3,2,2,2,3\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,3,2,2,5,2,3,7]",
                "output": "5"
            },
            {
                "input": "[1,2,3,4]",
                "output": "2"
            },
            {
                "input": "[1,1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int findLHS(int[] nums) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    for (int num : nums)\n        count.put(num, count.getOrDefault(num, 0) + 1);\n\n    int longest_sequence = 0;\n    for (int key : count.keySet()) {\n        if (count.containsKey(key + 1))\n            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n    }\n    \n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "python": "\n    ```python\ndef findLHS(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    longest_sequence = 0\n    for key in count:\n        if key + 1 in count:\n            longest_sequence = max(longest_sequence, count[key] + count[key + 1])\n\n    return longest_sequence\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint findLHS(vector<int>& nums) {\n    unordered_map<int, int> count;\n    for (int num : nums)\n        count[num]++;\n    \n    int longest_sequence = 0;\n    for (auto &elem : count) {\n        if (count.find(elem.first + 1) != count.end())\n            longest_sequence = max(longest_sequence, elem.second + count[elem.first + 1]);\n    }\n    \n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "js": "\n    ```javascript\nfunction findLHS(nums) {\n    const count = new Map();\n    for (const num of nums) {\n        count.set(num, (count.get(num) || 0) + 1);\n    }\n\n    let longest_sequence = 0;\n    for (const key of count.keys()) {\n        if (count.has(key + 1)) {\n            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n        }\n    }\n\n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    "
    },
    {
        "id": 113,
        "title": "Range Addition II",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.\n\nCount and return _the number of maximum integers in the matrix after performing all the operations_.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 4\n**Explanation:** The maximum integer in M is 2, and there are four of it in M. So return 4.\n\n",
                "**Example 2:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\]\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** m = 3, n = 3, ops = \\[\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 4 * 104`\n*   `0 <= ops.length <= 104`\n*   `ops[i].length == 2`\n*   `1 <= ai <= m`\n*   `1 <= bi <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "3,3,[[2,2],[3,3]]",
                "output": "4"
            },
            {
                "input": "3,3,[[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]",
                "output": "4"
            },
            {
                "input": "3,3,[]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int maxCount(int m, int n, int[][] ops) {\n    for (int[] op : ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "python": "\n    ```python\ndef maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint maxCount(int m, int n, vector<vector<int>>& ops) {\n    for (vector<int>& op : ops) {\n        m = min(m, op[0]);\n        n = min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "js": "\n    ```javascript\nfunction maxCount(m, n, ops) {\n    for (let op of ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    "
    },
    {
        "id": 114,
        "title": "Minimum Index Sum of Two Lists",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two arrays of strings `list1` and `list2`, find the **common strings with the least index sum**.\n\nA **common string** is a string that appeared in both `list1` and `list2`.\n\nA **common string with the least index sum** is a common string such that if it appeared at `list1[i]` and `list2[j]` then `i + j` should be the minimum value among all the other **common strings**.\n\nReturn _all the **common strings with the least index sum**_. Return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** list1 = \\[ \"Shogun \", \"Tapioca Express \", \"Burger King \", \"KFC \"\\], list2 = \\[ \"Piatti \", \"The Grill at Torrey Pines \", \"Hungry Hunter Steakhouse \", \"Shogun \"\\]\n**Output:** \\[ \"Shogun \"\\]\n**Explanation:** The only common string is  \"Shogun \".\n\n",
                "**Example 2:**\n\n**Input:** list1 = \\[ \"Shogun \", \"Tapioca Express \", \"Burger King \", \"KFC \"\\], list2 = \\[ \"KFC \", \"Shogun \", \"Burger King \"\\]\n**Output:** \\[ \"Shogun \"\\]\n**Explanation:** The common string with the least index sum is  \"Shogun \" with index sum = (0 + 1) = 1.\n\n",
                "**Example 3:**\n\n**Input:** list1 = \\[ \"happy \", \"sad \", \"good \"\\], list2 = \\[ \"sad \", \"happy \", \"good \"\\]\n**Output:** \\[ \"sad \", \"happy \"\\]\n**Explanation:** There are three common strings:\n \"happy \" with index sum = (0 + 1) = 1.\n \"sad \" with index sum = (1 + 0) = 1.\n \"good \" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are  \"sad \" and  \"happy \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= list1.length, list2.length <= 1000`\n*   `1 <= list1[i].length, list2[i].length <= 30`\n*   `list1[i]` and `list2[i]` consist of spaces `' '` and English letters.\n*   All the strings of `list1` are **unique**.\n*   All the strings of `list2` are **unique**.\n*   There is at least a common string between `list1` and `list2`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"Shogun\",\"TapiocaExpress\",\"BurgerKing\",\"KFC\"],[\"Piatti\",\"TheGrillatTorreyPines\",\"HungryHunterSteakhouse\",\"Shogun\"]",
                "output": "[\"Shogun\"]"
            },
            {
                "input": "[\"Shogun\",\"TapiocaExpress\",\"BurgerKing\",\"KFC\"],[\"KFC\",\"Shogun\",\"BurgerKing\"]",
                "output": "[\"Shogun\"]"
            },
            {
                "input": "[\"happy\",\"sad\",\"good\"],[\"sad\",\"happy\",\"good\"]",
                "output": "[\"sad\",\"happy\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<String> findRestaurant(String[] list1, String[] list2) {\n    HashMap<String, Integer> restaurantMap = new HashMap<>();\n    for (int i = 0; i < list1.length; i++) {\n        restaurantMap.put(list1[i], i);\n    }\n\n    int minSum = Integer.MAX_VALUE;\n    List<String> result = new ArrayList<>();\n    for (int j = 0; j < list2.length; j++) {\n        Integer index = restaurantMap.get(list2[j]);\n        if (index != null) {\n            int sum = j + index;\n            if (sum < minSum) {\n                result.clear();\n                result.add(list2[j]);\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.add(list2[j]);\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hashmap to store the restaurants and their indices (or just index for Python and JavaScript) in list1.\n2. Initialize a variable, minSum, to store the minimum sum of indices, and a result list to store the common restaurants with the least index sum.\n3. Iterate through list2; for each restaurant, check if it is in the hashmap.\n   a. If it is, calculate the sum of its index in list1 and list2.\n   b. If the sum is less than the current minSum, clear the result list, add the current restaurant to the result list, and update minSum.\n   c. If the sum is equal to minSum, add the restaurant to the result list.\n5. Return the result list.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef findRestaurant(list1: List[str], list2: List[str]) -> List[str]:\n    restaurantMap = {restaurant: i for i, restaurant in enumerate(list1)}\n\n    minSum = float(\"inf\")\n    result = []\n    for j, restaurant in enumerate(list2):\n        if restaurant in restaurantMap:\n            totalSum = j + restaurantMap[restaurant]\n            if totalSum < minSum:\n                result = [restaurant]\n                minSum = totalSum\n            elif totalSum == minSum:\n                result.append(restaurant)\n\n    return result\n```\n\n    \n    1. Create a hashmap to store the restaurants and their indices (or just index for Python and JavaScript) in list1.\n2. Initialize a variable, minSum, to store the minimum sum of indices, and a result list to store the common restaurants with the least index sum.\n3. Iterate through list2; for each restaurant, check if it is in the hashmap.\n   a. If it is, calculate the sum of its index in list1 and list2.\n   b. If the sum is less than the current minSum, clear the result list, add the current restaurant to the result list, and update minSum.\n   c. If the sum is equal to minSum, add the restaurant to the result list.\n5. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <string>\n\nstd::vector<std::string> findRestaurant(std::vector<std::string>& list1, std::vector<std::string>& list2) {\n    std::unordered_map<std::string, int> restaurantMap;\n    for (int i = 0; i < list1.size(); i++) {\n        restaurantMap[list1[i]] = i;\n    }\n\n    int minSum = INT_MAX;\n    std::vector<std::string> result;\n    for (int j = 0; j < list2.size(); j++) {\n        if (restaurantMap.count(list2[j])) {\n            int sum = j + restaurantMap[list2[j]];\n            if (sum < minSum) {\n                result.clear();\n                result.push_back(list2[j]);\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.push_back(list2[j]);\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hashmap to store the restaurants and their indices (or just index for Python and JavaScript) in list1.\n2. Initialize a variable, minSum, to store the minimum sum of indices, and a result list to store the common restaurants with the least index sum.\n3. Iterate through list2; for each restaurant, check if it is in the hashmap.\n   a. If it is, calculate the sum of its index in list1 and list2.\n   b. If the sum is less than the current minSum, clear the result list, add the current restaurant to the result list, and update minSum.\n   c. If the sum is equal to minSum, add the restaurant to the result list.\n5. Return the result list.\n    ",
        "js": "\n    ```javascript\nfunction findRestaurant(list1, list2) {\n    let restaurantMap = new Map();\n    for (let i = 0; i < list1.length; i++) {\n        restaurantMap.set(list1[i], i);\n    }\n\n    let minSum = Infinity;\n    let result = [];\n    for (let j = 0; j < list2.length; j++) {\n        if (restaurantMap.has(list2[j])) {\n            let sum = j + restaurantMap.get(list2[j]);\n            if (sum < minSum) {\n                result = [list2[j]];\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.push(list2[j]);\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hashmap to store the restaurants and their indices (or just index for Python and JavaScript) in list1.\n2. Initialize a variable, minSum, to store the minimum sum of indices, and a result list to store the common restaurants with the least index sum.\n3. Iterate through list2; for each restaurant, check if it is in the hashmap.\n   a. If it is, calculate the sum of its index in list1 and list2.\n   b. If the sum is less than the current minSum, clear the result list, add the current restaurant to the result list, and update minSum.\n   c. If the sum is equal to minSum, add the restaurant to the result list.\n5. Return the result list.\n    "
    },
    {
        "id": 115,
        "title": "Can Place Flowers",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.\n\nGiven an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` _if_ `n` _new flowers can be planted in the_ `flowerbed` _without violating the no-adjacent-flowers rule and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 1\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= flowerbed.length <= 2 * 104`\n*   `flowerbed[i]` is `0` or `1`.\n*   There are no two adjacent flowers in `flowerbed`.\n*   `0 <= n <= flowerbed.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,0,0,0,1],1",
                "output": "true"
            },
            {
                "input": "[1,0,0,0,1],2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean canPlaceFlowers(int[] flowerbed, int n) {\n    int count = 0;\n    for(int i = 0; i < flowerbed.length; i++) {\n        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "python": "\n    ```python\ndef canPlaceFlowers(flowerbed, n):\n    count = 0\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n            flowerbed[i] = 1\n            count += 1\n        if count >= n:\n            return True\n    return count >= n\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool canPlaceFlowers(vector<int>& flowerbed, int n) {\n    int count = 0;\n    for(int i = 0; i < flowerbed.size(); i++) {\n        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "js": "\n    ```javascript\nfunction canPlaceFlowers(flowerbed, n) {\n    let count = 0;\n    for(let i = 0; i < flowerbed.length; i++) {\n        if(flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    "
    },
    {
        "id": 116,
        "title": "Construct String from Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.\n\nOmit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4\\]\n**Output:**  \"1(2(4))(3) \"\n**Explanation:** Originally, it needs to be  \"1(2(4)())(3()()) \", but you need to omit all the unnecessary empty parenthesis pairs. And it will be  \"1(2(4))(3) \"\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3,null,4\\]\n**Output:**  \"1(2()(4))(3) \"\n**Explanation:** Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "\"1(2(4))(3)\""
            },
            {
                "input": "[1,2,3,null,4]",
                "output": "\"1(2()(4))(3)\""
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public String tree2str(TreeNode t) {\n        if (t == null) {\n            return \"\";\n        }\n        if (t.left == null && t.right == null) {\n            return t.val + \"\";\n        }\n        if (t.right == null) {\n            return t.val + \"(\" + tree2str(t.left) + \")\";\n        }\n        return t.val + \"(\" + tree2str(t.left) + \")(\" + tree2str(t.right) + \")\";\n    }\n}\n```\n    \n    The algorithm performs a modified preorder traversal of the binary tree. During the traversal, when we encounter a non-null node, we add the value of the node followed by left and right sub-trees enclosed in parentheses if they are not null. If the right subtree is null but the left subtree is not, then only the left subtree is added in parentheses. This way, we get a unique string representing the binary tree without any redundant empty parentheses. The algorithm works for each of the languages mentioned in the same way. The traversal is performed using recursion which saves nodes' values in the string representation.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef tree2str(t):\n    if not t:\n        return \"\"\n    if not t.left and not t.right:\n        return str(t.val)\n    if not t.right:\n        return \"{}({})\".format(t.val, tree2str(t.left))\n    return \"{}({})({})\".format(t.val, tree2str(t.left), tree2str(t.right))\n```\n    \n    The algorithm performs a modified preorder traversal of the binary tree. During the traversal, when we encounter a non-null node, we add the value of the node followed by left and right sub-trees enclosed in parentheses if they are not null. If the right subtree is null but the left subtree is not, then only the left subtree is added in parentheses. This way, we get a unique string representing the binary tree without any redundant empty parentheses. The algorithm works for each of the languages mentioned in the same way. The traversal is performed using recursion which saves nodes' values in the string representation.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstring tree2str(TreeNode* t) {\n    if (t == nullptr) {\n        return \"\";\n    }\n    if (t->left == nullptr && t->right == nullptr) {\n        return to_string(t->val);\n    }\n    if (t->right == nullptr) {\n        return to_string(t->val) + \"(\" + tree2str(t->left) + \")\";\n    }\n    return to_string(t->val) + \"(\" + tree2str(t->left) + \")(\" + tree2str(t->right) + \")\";\n}\n```\n    \n    The algorithm performs a modified preorder traversal of the binary tree. During the traversal, when we encounter a non-null node, we add the value of the node followed by left and right sub-trees enclosed in parentheses if they are not null. If the right subtree is null but the left subtree is not, then only the left subtree is added in parentheses. This way, we get a unique string representing the binary tree without any redundant empty parentheses. The algorithm works for each of the languages mentioned in the same way. The traversal is performed using recursion which saves nodes' values in the string representation.\n    ",
        "js": "\n    ```javascript\nfunction TreeNode(val, left, right) {\n    this.val = val;\n    this.left = left || null;\n    this.right = right || null;\n}\n\nvar tree2str = function(t) {\n    if (!t) {\n        return \"\";\n    }\n    if (!t.left && !t.right) {\n        return t.val + \"\";\n    }\n    if (!t.right) {\n        return t.val + \"(\" + tree2str(t.left) + \")\";\n    }\n    return t.val + \"(\" + tree2str(t.left) + \")(\" + tree2str(t.right) + \")\";\n};\n```\n    \n    The algorithm performs a modified preorder traversal of the binary tree. During the traversal, when we encounter a non-null node, we add the value of the node followed by left and right sub-trees enclosed in parentheses if they are not null. If the right subtree is null but the left subtree is not, then only the left subtree is added in parentheses. This way, we get a unique string representing the binary tree without any redundant empty parentheses. The algorithm works for each of the languages mentioned in the same way. The traversal is performed using recursion which saves nodes' values in the string representation.\n    "
    },
    {
        "id": 117,
        "title": "Merge Two Binary Trees",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two binary trees `root1` and `root2`.\n\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n\nReturn _the merged tree_.\n\n**Note:** The merging process must start from the root nodes of both trees.",
            "examples": [
                "**Example 1:**\n\n**Input:** root1 = \\[1,3,2,5\\], root2 = \\[2,1,3,null,4,null,7\\]\n**Output:** \\[3,4,5,5,4,null,7\\]\n\n",
                "**Example 2:**\n\n**Input:** root1 = \\[1\\], root2 = \\[1,2\\]\n**Output:** \\[2,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 2000]`.\n*   `-104 <= Node.val <= 104`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,3,2,5],[2,1,3,null,4,null,7]",
                "output": "[3,4,5,5,4,null,7]"
            },
            {
                "input": "[1],[1,2]",
                "output": "[2,2]"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n    if (root1 == null) return root2;\n    if (root2 == null) return root1;\n\n    root1.val += root2.val;\n    root1.left = mergeTrees(root1.left, root2.left);\n    root1.right = mergeTrees(root1.right, root2.right);\n    return root1;\n}\n```\n    \n    The algorithm uses a recursive approach to merge the two given binary trees. We define a base case: If one of the tree nodes is null, we return the other tree node. For the overlapping nodes, we add the values of the two nodes and update the value of the first node. Then, we call the function recursively for the left and right child nodes of both trees. Finally, we return the first tree as a merged tree.\n\nHere is a step-by-step explanation of the algorithm:\n\n1. If `root1` is null, return `root2`, and vice versa.\n2. Add the value of `root2` to the value of `root1`.\n3. Call the function recursively for the left child nodes of both trees and store the result in `root1`'s left node.\n4. Call the function recursively for the right child nodes of both trees and store the result in `root1`'st right node.\n5. Return `root1` as the merged tree.\n\nThe algorithm ensures that the trees are merged according to the given conditions in the question.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef merge_trees(root1: TreeNode, root2: TreeNode) -> TreeNode:\n    if root1 is None: return root2\n    if root2 is None: return root1\n\n    root1.val += root2.val\n    root1.left = merge_trees(root1.left, root2.left)\n    root1.right = merge_trees(root1.right, root2.right)\n    return root1\n```\n    \n    The algorithm uses a recursive approach to merge the two given binary trees. We define a base case: If one of the tree nodes is null, we return the other tree node. For the overlapping nodes, we add the values of the two nodes and update the value of the first node. Then, we call the function recursively for the left and right child nodes of both trees. Finally, we return the first tree as a merged tree.\n\nHere is a step-by-step explanation of the algorithm:\n\n1. If `root1` is null, return `root2`, and vice versa.\n2. Add the value of `root2` to the value of `root1`.\n3. Call the function recursively for the left child nodes of both trees and store the result in `root1`'s left node.\n4. Call the function recursively for the right child nodes of both trees and store the result in `root1`'st right node.\n5. Return `root1` as the merged tree.\n\nThe algorithm ensures that the trees are merged according to the given conditions in the question.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n    if (root1 == nullptr) return root2;\n    if (root2 == nullptr) return root1;\n\n    root1->val += root2->val;\n    root1->left = mergeTrees(root1->left, root2->left);\n    root1->right = mergeTrees(root1->right, root2->right);\n    return root1;\n}\n```\n    \n    The algorithm uses a recursive approach to merge the two given binary trees. We define a base case: If one of the tree nodes is null, we return the other tree node. For the overlapping nodes, we add the values of the two nodes and update the value of the first node. Then, we call the function recursively for the left and right child nodes of both trees. Finally, we return the first tree as a merged tree.\n\nHere is a step-by-step explanation of the algorithm:\n\n1. If `root1` is null, return `root2`, and vice versa.\n2. Add the value of `root2` to the value of `root1`.\n3. Call the function recursively for the left child nodes of both trees and store the result in `root1`'s left node.\n4. Call the function recursively for the right child nodes of both trees and store the result in `root1`'st right node.\n5. Return `root1` as the merged tree.\n\nThe algorithm ensures that the trees are merged according to the given conditions in the question.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction mergeTrees(root1, root2) {\n    if (root1 === null) return root2;\n    if (root2 === null) return root1;\n\n    root1.val += root2.val;\n    root1.left = mergeTrees(root1.left, root2.left);\n    root1.right = mergeTrees(root1.right, root2.right);\n    return root1;\n}\n```\n    \n    The algorithm uses a recursive approach to merge the two given binary trees. We define a base case: If one of the tree nodes is null, we return the other tree node. For the overlapping nodes, we add the values of the two nodes and update the value of the first node. Then, we call the function recursively for the left and right child nodes of both trees. Finally, we return the first tree as a merged tree.\n\nHere is a step-by-step explanation of the algorithm:\n\n1. If `root1` is null, return `root2`, and vice versa.\n2. Add the value of `root2` to the value of `root1`.\n3. Call the function recursively for the left child nodes of both trees and store the result in `root1`'s left node.\n4. Call the function recursively for the right child nodes of both trees and store the result in `root1`'st right node.\n5. Return `root1` as the merged tree.\n\nThe algorithm ensures that the trees are merged according to the given conditions in the question.\n    "
    },
    {
        "id": 118,
        "title": "Maximum Product of Three Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, _find three numbers whose product is maximum and return the maximum product_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 24\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,-2,-3\\]\n**Output:** -6"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "6"
            },
            {
                "input": "[1,2,3,4]",
                "output": "24"
            },
            {
                "input": "[-1,-2,-3]",
                "output": "-6"
            }
        ],
        "java": "\n    ```java\npublic int maximumProduct(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "python": "\n    ```python\ndef maximumProduct(nums):\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "c++": "\n    ```cpp\nint maximumProduct(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "js": "\n    ```javascript\nfunction maximumProduct(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    "
    },
    {
        "id": 119,
        "title": "Average of Levels in Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "[3.00000,14.50000,11.00000]\nExplanation:Theaveragevalueofnodesonlevel0is3,onlevel1is14.5,andonlevel2is11.\nHencereturn[3,14.5,11]."
            },
            {
                "input": "[3,9,20,15,7]",
                "output": "[3.00000,14.50000,11.00000]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<Double> averageOfLevels(TreeNode root) {\n    List<Double> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        long sum = 0;\n        int count = 0;\n        Queue<TreeNode> temp = new LinkedList<>();\n        while (!queue.isEmpty()) {\n            TreeNode currentNode = queue.poll();\n            sum += currentNode.val;\n            count++;\n            if (currentNode.left != null) temp.add(currentNode.left);\n            if (currentNode.right != null) temp.add(currentNode.right);\n        }\n        queue = temp;\n        result.add((1.0 * sum) / count);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a Breadth First Search (BFS) approach to solve this problem. A queue data structure is used to keep track of the tree nodes at each level. The algorithm iterates through each level of the binary tree, summing the values of all the nodes at the current level, and dividing by the number of nodes in that level to get the average. The result is added to a vector (C++), list (Java, Python), or array (JavaScript) and returned once the queue is empty, meaning all levels have been traversed.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef averageOfLevels(root: TreeNode):\n    result = []\n    queue = [root]\n\n    while queue:\n        sum_ = 0\n        count = 0\n        temp = []\n        while queue:\n            node = queue.pop(0)\n            sum_ += node.val\n            count += 1\n            if node.left: temp.append(node.left)\n            if node.right: temp.append(node.right)\n        queue = temp\n        result.append(sum_ / count)\n\n    return result\n```\n    \n    The algorithm uses a Breadth First Search (BFS) approach to solve this problem. A queue data structure is used to keep track of the tree nodes at each level. The algorithm iterates through each level of the binary tree, summing the values of all the nodes at the current level, and dividing by the number of nodes in that level to get the average. The result is added to a vector (C++), list (Java, Python), or array (JavaScript) and returned once the queue is empty, meaning all levels have been traversed.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<double> averageOfLevels(TreeNode* root) {\n    vector<double> result;\n    queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        long long sum = 0;\n        int count = 0;\n        queue<TreeNode*> temp;\n        while (!q.empty()) {\n            TreeNode* n = q.front();\n            q.pop();\n            sum += n->val;\n            count++;\n            if (n->left) temp.push(n->left);\n            if (n->right) temp.push(n->right);\n        }\n        q = temp;\n        result.push_back(static_cast<double>(sum) / count);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a Breadth First Search (BFS) approach to solve this problem. A queue data structure is used to keep track of the tree nodes at each level. The algorithm iterates through each level of the binary tree, summing the values of all the nodes at the current level, and dividing by the number of nodes in that level to get the average. The result is added to a vector (C++), list (Java, Python), or array (JavaScript) and returned once the queue is empty, meaning all levels have been traversed.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction averageOfLevels(root) {\n    let result = [];\n    let queue = [root];\n\n    while (queue.length > 0) {\n        let sum = 0;\n        let count = 0;\n        let temp = [];\n        while (queue.length > 0) {\n            let currentNode = queue.shift();\n            sum += currentNode.val;\n            count++;\n            if (currentNode.left !== null) temp.push(currentNode.left);\n            if (currentNode.right !== null) temp.push(currentNode.right);\n        }\n        queue = temp;\n        result.push(sum / count);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a Breadth First Search (BFS) approach to solve this problem. A queue data structure is used to keep track of the tree nodes at each level. The algorithm iterates through each level of the binary tree, summing the values of all the nodes at the current level, and dividing by the number of nodes in that level to get the average. The result is added to a vector (C++), list (Java, Python), or array (JavaScript) and returned once the queue is empty, meaning all levels have been traversed.\n    "
    },
    {
        "id": 120,
        "title": "Maximum Average Subarray I",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,12,-5,-6,50,3\\], k = 4\n**Output:** 12.75000\n**Explanation:** Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5\\], k = 1\n**Output:** 5.00000"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= k <= n <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[1,12,-5,-6,50,3],4",
                "output": "12.75000"
            },
            {
                "input": "[5],1",
                "output": "5.00000"
            }
        ],
        "java": "\n    ```java\npublic double findMaxAverage(int[] nums, int k) {\n    int n = nums.length;\n    double sum = 0;\n    for (int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n    double max_avg = sum / k;\n    for (int i = k; i < n; i++) {\n        sum = sum - nums[i - k] + nums[i];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    return max_avg;\n}\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "python": "\n    ```python\ndef findMaxAverage(nums, k):\n    n = len(nums)\n    sum_ = sum(nums[:k])\n    max_avg = sum_ / k\n    for i in range(k, n):\n        sum_ = sum_ - nums[i - k] + nums[i]\n        max_avg = max(max_avg, sum_ / k)\n    return max_avg\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "c++": "\n    ```cpp\ndouble findMaxAverage(vector<int>& nums, int k) {\n    int n = nums.size();\n    double sum = 0;\n    for (int i = 0; i < k; ++i) {\n        sum += nums[i];\n    }\n    double max_avg = sum / k;\n    for (int i = k; i < n; ++i) {\n        sum = sum - nums[i - k] + nums[i];\n        max_avg = max(max_avg, sum / k);\n    }\n    return max_avg;\n}\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "js": "\n    ```javascript\nfunction findMaxAverage(nums, k) {\n    let n = nums.length;\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n    let max_avg = sum / k;\n    for (let i = k; i < n; i++) {\n        sum = sum - nums[i - k] + nums[i];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    return max_avg;\n}\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    "
    },
    {
        "id": 121,
        "title": "Set Mismatch",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.\n\nYou are given an integer array `nums` representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return _them in the form of an array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,4\\]\n**Output:** \\[2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `1 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,2,4]",
                "output": "[2,3]"
            },
            {
                "input": "[1,1]",
                "output": "[1,2]"
            }
        ],
        "java": "\n    ```java\npublic int[] findErrorNums(int[] nums) {\n    int[] result = new int[2];\n    for (int num : nums) {\n        int index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result[0] = index + 1;\n        }\n    }\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result[1] = i + 1;\n            break;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "python": "\n    ```python\ndef findErrorNums(nums):\n    result = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n        else:\n            result.append(index + 1)\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n            break\n    return result\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findErrorNums(vector<int>& nums) {\n    vector<int> result;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push_back(index + 1);\n        }\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "js": "\n    ```javascript\nfunction findErrorNums(nums) {\n    let result = [];\n    for (let num of nums) {\n        let index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push(index + 1);\n        }\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    "
    },
    {
        "id": 122,
        "title": "Robot Return to Origin",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\n\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\n\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.",
            "examples": [
                "**Example 1:**\n\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n",
                "**Example 2:**\n\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"UD\"",
                "output": "true"
            },
            {
                "input": "\"LL\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean judgeCircle(String moves) {\n    int x = 0, y = 0;\n    for(char move : moves.toCharArray()) {\n        if(move == 'U') y++;\n        else if(move == 'D') y--;\n        else if(move == 'R') x++;\n        else if(move == 'L') x--;\n    }\n    return x == 0 && y == 0;\n}\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef judgeCircle(moves: str) -> bool:\n    x, y = 0, 0\n    for move in moves:\n        if move == 'U': y += 1\n        elif move == 'D': y -= 1\n        elif move == 'R': x += 1\n        elif move == 'L': x -= 1\n    return x == 0 and y == 0\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool judgeCircle(string moves) {\n    int x = 0, y = 0;\n    for(char move : moves) {\n        if(move == 'U') y++;\n        else if(move == 'D') y--;\n        else if(move == 'R') x++;\n        else if(move == 'L') x--;\n    }\n    return x == 0 && y == 0;\n}\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction judgeCircle(moves) {\n    let x = 0, y = 0;\n    for(let move of moves) {\n        if(move === 'U') y++;\n        else if(move === 'D') y--;\n        else if(move === 'R') x++;\n        else if(move === 'L') x--;\n    }\n    return x === 0 && y === 0;\n}\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    "
    },
    {
        "id": 123,
        "title": "Image Smoother",
        "difficulty": "Easy",
        "content": {
            "problem": "An **image smoother** is a filter of the size `3 x 3` that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\nGiven an `m x n` integer matrix `img` representing the grayscale of an image, return _the image after applying the smoother on each cell of it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** img = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:**\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n",
                "**Example 2:**\n\n**Input:** img = \\[\\[100,200,100\\],\\[200,50,200\\],\\[100,200,100\\]\\]\n**Output:** \\[\\[137,141,137\\],\\[141,138,141\\],\\[137,141,137\\]\\]\n**Explanation:**\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138"
            ],
            "constraints": "**Constraints:**\n\n*   `m == img.length`\n*   `n == img[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= img[i][j] <= 255`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                "output": "[[0,0,0],[0,0,0],[0,0,0]]"
            },
            {
                "input": "[[100,200,100],[200,50,200],[100,200,100]]",
                "output": "[[137,141,137],[141,138,141],[137,141,137]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] imageSmoother(int[][] img) {\n    int m = img.length, n = img[0].length;\n    int[][] result = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "python": "\n    ```python\ndef imageSmoother(img):\n    m, n = len(img), len(img[0])\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            count, total = 0, 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n:\n                        total += img[x][y]\n                        count += 1\n            result[i][j] = total // count\n\n    return result\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n    int m = img.size(), n = img[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "js": "\n    ```javascript\nfunction imageSmoother(img) {\n    const m = img.length, n = img[0].length;\n    const result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let count = 0, sum = 0;\n\n            for (let x = i - 1; x <= i + 1; x++) {\n                for (let y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = Math.floor(sum / count);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    "
    },
    {
        "id": 124,
        "title": "Second Minimum Node In a Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly `two` or `zero` sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property `root.val = min(root.left.val, root.right.val)` always holds.\n\nGiven such a binary tree, you need to output the **second minimum** value in the set made of all the nodes' value in the whole tree.\n\nIf no such second minimum value exists, output -1 instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[2,2,5,null,null,5,7\\]\n**Output:** 5\n**Explanation:** The smallest value is 2, the second smallest value is 5.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,2,2\\]\n**Output:** -1\n**Explanation:** The smallest value is 2, but there isn't any second smallest value."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 25]`.\n*   `1 <= Node.val <= 231 - 1`\n*   `root.val == min(root.left.val, root.right.val)` for each internal node of the tree.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[2,2,5,null,null,5,7]",
                "output": "5"
            },
            {
                "input": "[2,2,2]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int findSecondMinimumValue(TreeNode root) {\n    return findSecondMinimumValue(root, -1);\n}\n\nprivate int findSecondMinimumValue(TreeNode root, int current) {\n    if (root == null) return current;\n    if (current == -1 || root.val < current) current = root.val;\n    if (root.left != null && root.right != null) {\n        if (root.val == root.left.val) {\n            current = findSecondMinimumValue(root.left, current);\n            if (root.val != root.right.val)\n                current = (current == -1) ? root.right.val : Math.min(current, root.right.val);\n        } else {\n            current = findSecondMinimumValue(root.right, current);\n            if (root.val != root.left.val)\n                current = (current == -1) ? root.left.val : Math.min(current, root.left.val);\n        }\n    }\n    return current;\n}\n```\n    \n    The algorithm starts at the root of the tree and recursively searches for the second smallest value in the tree. It maintains a variable `current` that stores the current smallest or second smallest value found so far, initialized to -1.\n\nThe base case is when the tree is empty, in which case the algorithm returns the value of `current`. When the value of the root is smaller than `current`, the value of the root is assigned to `current`. \n\nIf the root has left and right child, the algorithm checks if the root's value is equal to its left child or its right child, and then compares the current value, if any, with the root's children value. Then, the function is called recursively to explore their sub-trees to find the second minimum value. Eventually, it will return -1 if there is no such second minimum value, or it will return the second minimum value found in the tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_second_minimum_value(root, current=-1):\n    if root is None:\n        return current\n    if current == -1 or root.val < current:\n        current = root.val\n    if root.left is not None and root.right is not None:\n        if root.val == root.left.val:\n            current = find_second_minimum_value(root.left, current)\n            if root.val != root.right.val:\n                current = root.right.val if current == -1 else min(current, root.right.val)\n        else:\n            current = find_second_minimum_value(root.right, current)\n            if root.val != root.left.val:\n                current = root.left.val if current == -1 else min(current, root.left.val)\n    return current\n```\n    \n    The algorithm starts at the root of the tree and recursively searches for the second smallest value in the tree. It maintains a variable `current` that stores the current smallest or second smallest value found so far, initialized to -1.\n\nThe base case is when the tree is empty, in which case the algorithm returns the value of `current`. When the value of the root is smaller than `current`, the value of the root is assigned to `current`. \n\nIf the root has left and right child, the algorithm checks if the root's value is equal to its left child or its right child, and then compares the current value, if any, with the root's children value. Then, the function is called recursively to explore their sub-trees to find the second minimum value. Eventually, it will return -1 if there is no such second minimum value, or it will return the second minimum value found in the tree.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nint findSecondMinimumValue(TreeNode* root, int current = -1) {\n    if (!root) return current;\n    if (current == -1 || root->val < current) current = root->val;\n    if (root->left && root->right) {\n        if (root->val == root->left->val) {\n            current = findSecondMinimumValue(root->left, current);\n            if (root->val != root->right->val)\n                current = (current == -1) ? root->right->val : std::min(current, root->right->val);\n        } else {\n            current = findSecondMinimumValue(root->right, current);\n            if (root->val != root->left->val)\n                current = (current == -1) ? root->left->val : std::min(current, root->left->val);\n        }\n    }\n    return current;\n}\n```\n    \n    The algorithm starts at the root of the tree and recursively searches for the second smallest value in the tree. It maintains a variable `current` that stores the current smallest or second smallest value found so far, initialized to -1.\n\nThe base case is when the tree is empty, in which case the algorithm returns the value of `current`. When the value of the root is smaller than `current`, the value of the root is assigned to `current`. \n\nIf the root has left and right child, the algorithm checks if the root's value is equal to its left child or its right child, and then compares the current value, if any, with the root's children value. Then, the function is called recursively to explore their sub-trees to find the second minimum value. Eventually, it will return -1 if there is no such second minimum value, or it will return the second minimum value found in the tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction findSecondMinimumValue(root, current = -1) {\n    if (root === null) return current;\n    if (current === -1 || root.val < current) current = root.val;\n    if (root.left !== null && root.right !== null) {\n        if (root.val === root.left.val) {\n            current = findSecondMinimumValue(root.left, current);\n            if (root.val !== root.right.val)\n                current = (current === -1) ? root.right.val : Math.min(current, root.right.val);\n        } else {\n            current = findSecondMinimumValue(root.right, current);\n            if (root.val !== root.left.val)\n                current = (current === -1) ? root.left.val : Math.min(current, root.left.val);\n        }\n    }\n    return current;\n}\n```\n    \n    The algorithm starts at the root of the tree and recursively searches for the second smallest value in the tree. It maintains a variable `current` that stores the current smallest or second smallest value found so far, initialized to -1.\n\nThe base case is when the tree is empty, in which case the algorithm returns the value of `current`. When the value of the root is smaller than `current`, the value of the root is assigned to `current`. \n\nIf the root has left and right child, the algorithm checks if the root's value is equal to its left child or its right child, and then compares the current value, if any, with the root's children value. Then, the function is called recursively to explore their sub-trees to find the second minimum value. Eventually, it will return -1 if there is no such second minimum value, or it will return the second minimum value found in the tree.\n    "
    },
    {
        "id": 125,
        "title": "Longest Continuous Increasing Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an unsorted array of integers `nums`, return _the length of the longest **continuous increasing subsequence** (i.e. subarray)_. The subsequence must be **strictly** increasing.\n\nA **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 3\n**Explanation:** The longest continuous increasing subsequence is \\[1,3,5\\] with length 3.\nEven though \\[1,3,5,7\\] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 1\n**Explanation:** The longest continuous increasing subsequence is \\[2\\] with length 1. Note that it must be strictly\nincreasing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,3,5,4,7]",
                "output": "3"
            },
            {
                "input": "[2,2,2,2,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findLengthOfLCIS(int[] nums) {\n    if (nums.length == 0) return 0;\n    int result = 1, current = 1;\n    for (int i = 1; i < nums.length; ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = Math.max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef findLengthOfLCIS(nums):\n    if not nums:\n        return 0\n    result, current = 1, 1\n    for i in range(1, len(nums)):\n        current = current + 1 if nums[i] > nums[i - 1] else 1\n        result = max(result, current)\n    return result\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint findLengthOfLCIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int result = 1, current = 1;\n    for (int i = 1; i < nums.size(); ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction findLengthOfLCIS(nums) {\n    if (nums.length === 0) return 0;\n    let result = 1, current = 1;\n    for (let i = 1; i < nums.length; ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = Math.max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    "
    },
    {
        "id": 126,
        "title": "Valid Palindrome II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return `true` _if the_ `s` _can be palindrome after deleting **at most one** character from it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aba \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abca \"\n**Output:** true\n**Explanation:** You could delete the character 'c'.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abc \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"aba\"",
                "output": "true"
            },
            {
                "input": "\"abca\"",
                "output": "true"
            },
            {
                "input": "\"abc\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean validPalindrome(String s) {\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\n        if (s.charAt(i) != s.charAt(j)) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "python": "\n    ```python\ndef validPalindrome(s: str) -> bool:\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            temp1, temp2 = i + 1, j\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            temp1, temp2 = i, j - 1\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            return False\n        i += 1\n        j -= 1\n    return True\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "c++": "\n    ```cpp\nbool validPalindrome(string s) {\n    for (int i = 0, j = s.size() - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "js": "\n    ```javascript\nfunction validPalindrome(s) {\n    for (let i = 0, j = s.length - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            let temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    "
    },
    {
        "id": 127,
        "title": "Baseball Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:\n\n*   An integer `x`.\n    *   Record a new score of `x`.\n*   `'+'`.\n    *   Record a new score that is the sum of the previous two scores.\n*   `'D'`.\n    *   Record a new score that is the double of the previous score.\n*   `'C'`.\n    *   Invalidate the previous score, removing it from the record.\n\nReturn _the sum of all the scores on the record after applying all the operations_.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer and that all operations are valid.",
            "examples": [
                "**Example 1:**\n\n**Input:** ops = \\[ \"5 \", \"2 \", \"C \", \"D \", \"+ \"\\]\n**Output:** 30\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"2 \" - Add 2 to the record, record is now \\[5, 2\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5\\].\n \"D \" - Add 2 \\* 5 = 10 to the record, record is now \\[5, 10\\].\n \"+ \" - Add 5 + 10 = 15 to the record, record is now \\[5, 10, 15\\].\nThe total sum is 5 + 10 + 15 = 30.\n\n",
                "**Example 2:**\n\n**Input:** ops = \\[ \"5 \", \"-2 \", \"4 \", \"C \", \"D \", \"9 \", \"+ \", \"+ \"\\]\n**Output:** 27\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"-2 \" - Add -2 to the record, record is now \\[5, -2\\].\n \"4 \" - Add 4 to the record, record is now \\[5, -2, 4\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5, -2\\].\n \"D \" - Add 2 \\* -2 = -4 to the record, record is now \\[5, -2, -4\\].\n \"9 \" - Add 9 to the record, record is now \\[5, -2, -4, 9\\].\n \"+ \" - Add -4 + 9 = 5 to the record, record is now \\[5, -2, -4, 9, 5\\].\n \"+ \" - Add 9 + 5 = 14 to the record, record is now \\[5, -2, -4, 9, 5, 14\\].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n",
                "**Example 3:**\n\n**Input:** ops = \\[ \"1 \", \"C \"\\]\n**Output:** 0\n**Explanation:**\n \"1 \" - Add 1 to the record, record is now \\[1\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[\\].\nSince the record is empty, the total sum is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= operations.length <= 1000`\n*   `operations[i]` is `\"C \"`, `\"D \"`, `\"+ \"`, or a string representing an integer in the range `[-3 * 104, 3 * 104]`.\n*   For operation `\"+ \"`, there will always be at least two previous scores on the record.\n*   For operations `\"C \"` and `\"D \"`, there will always be at least one previous score on the record.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Simulation"
        ],
        "example": [
            {
                "input": "[\"5\",\"2\",\"C\",\"D\",\"+\"]",
                "output": "30"
            },
            {
                "input": "[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
                "output": "27"
            },
            {
                "input": "[\"1\",\"C\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int calPoints(String[] ops) {\n        LinkedList<Integer> record = new LinkedList<>();\n        for (String op : ops) {\n            if (op.equals(\"+\")) {\n                record.add(record.getLast() + record.get(record.size() - 2));\n            } else if (op.equals(\"D\")) {\n                record.add(record.getLast() * 2);\n            } else if (op.equals(\"C\")) {\n                record.removeLast();\n            } else {\n                record.add(Integer.parseInt(op));\n            }\n        }\n        return record.stream().mapToInt(Integer::intValue).sum();\n    }\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "python": "\n    ```python\ndef calPoints(ops):\n    record = []\n    for op in ops:\n        if op == '+':\n            record.append(record[-1] + record[-2])\n        elif op == 'D':\n            record.append(record[-1] * 2)\n        elif op == 'C':\n            record.pop()\n        else:\n            record.append(int(op))\n    return sum(record)\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint calPoints(std::vector<std::string>& ops) {\n    std::vector<int> record;\n    for (const std::string& op : ops) {\n        if (op == \"+\") {\n            record.push_back(record[record.size() - 1] + record[record.size() - 2]);\n        } else if (op == \"D\") {\n            record.push_back(2 * record.back());\n        } else if (op == \"C\") {\n            record.pop_back();\n        } else {\n            record.push_back(stoi(op));\n        }\n    }\n    return std::accumulate(record.begin(), record.end(), 0);\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "js": "\n    ```javascript\nfunction calPoints(ops) {\n    let record = [];\n    for (let op of ops) {\n        if (op === '+') {\n            record.push(record[record.length - 1] + record[record.length - 2]);\n        } else if (op === 'D') {\n            record.push(record[record.length - 1] * 2);\n        } else if (op === 'C') {\n            record.pop();\n        } else {\n            record.push(parseInt(op));\n        }\n    }\n    return record.reduce((a, b) => a + b, 0);\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    "
    },
    {
        "id": 128,
        "title": "Binary Number with Alternating Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** true\n**Explanation:** The binary representation of 5 is: 101\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** false\n**Explanation:** The binary representation of 7 is: 111.\n\n",
                "**Example 3:**\n\n**Input:** n = 11\n**Output:** false\n**Explanation:** The binary representation of 11 is: 1011."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "5",
                "output": "true"
            },
            {
                "input": "7",
                "output": "false"
            },
            {
                "input": "11",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "python": "\n    ```python\ndef has_alternating_bits(n):\n    prev_bit = n % 2\n    n //= 2\n    while n > 0:\n        curr_bit = n % 2\n        if curr_bit == prev_bit:\n            return False\n        prev_bit = curr_bit\n        n //= 2\n    return True\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "js": "\n    ```javascript\nfunction hasAlternatingBits(n) {\n    let prevBit = n % 2;\n    n = Math.floor(n / 2);\n    while (n > 0) {\n        let currBit = n % 2;\n        if (currBit === prevBit) return false;\n        prevBit = currBit;\n        n = Math.floor(n / 2);\n    }\n    return true;\n}\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    "
    },
    {
        "id": 129,
        "title": "Count Binary Substrings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"00110011 \"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's:  \"0011 \",  \"01 \",  \"1100 \",  \"10 \",  \"0011 \", and  \"01 \".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso,  \"00110011 \" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10101 \"\n**Output:** 4\n**Explanation:** There are 4 substrings:  \"10 \",  \"01 \",  \"10 \",  \"01 \" that have equal number of consecutive 1's and 0's."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"00110011\"",
                "output": "6"
            },
            {
                "input": "\"10101\"",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int countBinarySubstrings(String s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "python": "\n    ```python\ndef count_binary_substrings(s: str) -> int:\n    prev, curr, result = 0, 1, 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            curr += 1\n        else:\n            result += min(prev, curr)\n            prev, curr = curr, 1\n    return result + min(prev, curr)\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "c++": "\n    ```cpp\nint countBinarySubstrings(string s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            curr++;\n        } else {\n            result += min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "js": "\n    ```javascript\nfunction countBinarySubstrings(s) {\n    let prev = 0, curr = 1, result = 0;\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    "
    },
    {
        "id": 130,
        "title": "Degree of an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a non-empty array of non-negative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements.\n\nYour task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,3,1\\]\n**Output:** 2\n**Explanation:** \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n\\[1, 2, 2, 3, 1\\], \\[1, 2, 2, 3\\], \\[2, 2, 3, 1\\], \\[1, 2, 2\\], \\[2, 2, 3\\], \\[2, 2\\]\nThe shortest length is 2. So return 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,2,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \nThe degree is 3 because the element 2 is repeated 3 times.\nSo \\[2,2,3,1,4,2\\] is the shortest subarray, therefore returning 6."
            ],
            "constraints": "**Constraints:**\n\n*   `nums.length` will be between 1 and 50,000.\n*   `nums[i]` will be an integer between 0 and 49,999.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2,2,3,1]",
                "output": "2"
            },
            {
                "input": "[1,2,2,3,1,4,2]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass Solution {\n    public int findShortestSubArray(int[] nums) {\n        HashMap<Integer, Integer> freq_map = new HashMap<>(), start_map = new HashMap<>();\n        int max_freq = 0, min_length = nums.length;\n        \n        for (int i = 0; i < nums.length; ++i) {\n            if (!start_map.containsKey(nums[i])) {\n                start_map.put(nums[i], i);\n            }\n            freq_map.put(nums[i], freq_map.getOrDefault(nums[i], 0) + 1);\n            \n            int freq = freq_map.get(nums[i]);\n            if (freq > max_freq) {\n                max_freq = freq;\n                min_length = i - start_map.get(nums[i]) + 1;\n            } else if (freq == max_freq) {\n                min_length = Math.min(min_length, i - start_map.get(nums[i]) + 1);\n            }\n        }\n        \n        return min_length;\n    }\n}\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef findShortestSubArray(nums):\n    freq_map, start_map = {}, {}\n    max_freq, min_length = 0, len(nums)\n\n    for i, num in enumerate(nums):\n        if num not in start_map:\n            start_map[num] = i\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n        freq = freq_map[num]\n        if freq > max_freq:\n            max_freq = freq\n            min_length = i - start_map[num] + 1\n        elif freq == max_freq:\n            min_length = min(min_length, i - start_map[num] + 1)\n\n    return min_length\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint findShortestSubArray(std::vector<int>& nums) {\n    std::unordered_map<int, int> freq_map, start_map;\n    int max_freq = 0, min_length = nums.size();\n\n    for (int i = 0; i < nums.size(); ++i) {\n        if (start_map.count(nums[i]) == 0) {\n            start_map[nums[i]] = i;\n        }\n        freq_map[nums[i]]++;\n\n        int freq = freq_map[nums[i]];\n        if (freq > max_freq) {\n            max_freq = freq;\n            min_length = i - start_map[nums[i]] + 1;\n        } else if (freq == max_freq) {\n            min_length = std::min(min_length, i - start_map[nums[i]] + 1);\n        }\n    }\n\n    return min_length;\n}\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction findShortestSubArray(nums) {\n    const freq_map = {}, start_map = {};\n    let max_freq = 0, min_length = nums.length;\n\n    for (let i = 0; i < nums.length; ++i) {\n        if (!start_map.hasOwnProperty(nums[i])) {\n            start_map[nums[i]] = i;\n        }\n        if (!freq_map.hasOwnProperty(nums[i])) {\n            freq_map[nums[i]] = 0;\n        }\n        freq_map[nums[i]]++;\n\n        const freq = freq_map[nums[i]];\n        if (freq > max_freq) {\n            max_freq = freq;\n            min_length = i - start_map[nums[i]] + 1;\n        } else if (freq === max_freq) {\n            min_length = Math.min(min_length, i - start_map[nums[i]] + 1);\n        }\n    }\n\n    return min_length;\n}\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    "
    },
    {
        "id": 131,
        "title": "Search in a Binary Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the `root` of a binary search tree (BST) and an integer `val`.\n\nFind the node in the BST that the node's value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3\\], val = 2\n**Output:** \\[2,1,3\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[4,2,7,1,3\\], val = 5\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 5000]`.\n*   `1 <= Node.val <= 107`\n*   `root` is a binary search tree.\n*   `1 <= val <= 107`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[4,2,7,1,3],2",
                "output": "[2,1,3]"
            },
            {
                "input": "[4,2,7,1,3],5",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || root.val == val)\n        return root;\n    return (root.val < val) ? searchBST(root.right, val) : searchBST(root.left, val);\n}\n```\n\n    \n    We use a recursive search function for searching the BST. The basic logic is as follows:\n1. Check if the current node is `null` or its value equals the target value. If so, return the node itself.\n2. If the target value is greater than the current node's value, search the right child.\n3. If the target value is less than the current node's value, search the left child.\n\nIn all four programming languages, the implementation is pretty much the same:\n\n1. Define a TreeNode structure/class with value, left child, and right child properties.\n2. Apply the algorithm logic in the `searchBST` function.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef searchBST(root: TreeNode, val: int) -> TreeNode:\n    if not root or root.val == val:\n        return root\n    return searchBST(root.right, val) if root.val < val else searchBST(root.left, val)\n```\n\n    \n    We use a recursive search function for searching the BST. The basic logic is as follows:\n1. Check if the current node is `null` or its value equals the target value. If so, return the node itself.\n2. If the target value is greater than the current node's value, search the right child.\n3. If the target value is less than the current node's value, search the left child.\n\nIn all four programming languages, the implementation is pretty much the same:\n\n1. Define a TreeNode structure/class with value, left child, and right child properties.\n2. Apply the algorithm logic in the `searchBST` function.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nTreeNode* searchBST(TreeNode* root, int val) {\n    if (!root || root->val == val)\n        return root;\n    return (root->val < val) ? searchBST(root->right, val) : searchBST(root->left, val);\n}\n```\n    \n    We use a recursive search function for searching the BST. The basic logic is as follows:\n1. Check if the current node is `null` or its value equals the target value. If so, return the node itself.\n2. If the target value is greater than the current node's value, search the right child.\n3. If the target value is less than the current node's value, search the left child.\n\nIn all four programming languages, the implementation is pretty much the same:\n\n1. Define a TreeNode structure/class with value, left child, and right child properties.\n2. Apply the algorithm logic in the `searchBST` function.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction searchBST(root, val) {\n    if (!root || root.val === val) {\n        return root;\n    }\n    return (root.val < val) ? searchBST(root.right, val) : searchBST(root.left, val);\n}\n```\n\n    \n    We use a recursive search function for searching the BST. The basic logic is as follows:\n1. Check if the current node is `null` or its value equals the target value. If so, return the node itself.\n2. If the target value is greater than the current node's value, search the right child.\n3. If the target value is less than the current node's value, search the left child.\n\nIn all four programming languages, the implementation is pretty much the same:\n\n1. Define a TreeNode structure/class with value, left child, and right child properties.\n2. Apply the algorithm logic in the `searchBST` function.\n    "
    },
    {
        "id": 132,
        "title": "Kth Largest Element in a Stream",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a class to find the `kth` largest element in a stream. Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nImplement `KthLargest` class:\n\n*   `KthLargest(int k, int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`.\n*   `int add(int val)` Appends the integer `val` to the stream and returns the element representing the `kth` largest element in the stream.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"KthLargest \",  \"add \",  \"add \",  \"add \",  \"add \",  \"add \"\\]\n\\[\\[3, \\[4, 5, 8, 2\\]\\], \\[3\\], \\[5\\], \\[10\\], \\[9\\], \\[4\\]\\]\n**Output**\n\\[null, 4, 5, 5, 8, 8\\]\n\n**Explanation**\nKthLargest kthLargest = new KthLargest(3, \\[4, 5, 8, 2\\]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 104`\n*   `0 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `-104 <= val <= 104`\n*   At most `104` calls will be made to `add`.\n*   It is guaranteed that there will be at least `k` elements in the array when you search for the `kth` element.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Design",
            "Binary Search Tree",
            "Heap (Priority Queue)",
            "Binary Tree",
            "Data Stream"
        ],
        "example": [
            {
                "input": "]\n]],[3],[5],[10],[9],[4]]",
                "output": "**Output**\n[null,4,5,5,8,8]"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\nclass KthLargest {\n    int k;\n    PriorityQueue<Integer> minHeap;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        minHeap = new PriorityQueue<>(k);\n        for (int num : nums) {\n            add(num);\n        }\n    }\n\n    public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n        return minHeap.peek();\n    }\n}\n```\n    \n    We will use a min-heap to solve this problem. We initialize the KthLargest class with an integer `k` and an array `nums`. In the constructor, we loop through the `nums` array and call the `add` function for every element.\n\nThe `add` function does the following:\n1. Pushes the new value into the min-heap.\n2. If the size of the min-heap is greater than `k`, we pop an element from the min-heap (i.e., remove the smallest element).\n3. We return the top element of the min-heap which represents the k-th largest element in the stream.\n\nFor the JavaScript implementation, we also need to create a separate MinHeap class covering the basic functions (offer, poll, peek, size) to maintain minimum priority queue.\n\nAll implementations follow the same algorithm, with small syntax differences between programming languages.\n    ",
        "python": "\n    ```python\nimport heapq\n\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.min_heap = nums\n        heapq.heapify(self.min_heap)\n        \n        while len(self.min_heap) > k:\n            heapq.heappop(self.min_heap)\n\n    def add(self, val: int) -> int:\n        if len(self.min_heap) < self.k:\n            heapq.heappush(self.min_heap, val)\n        elif val > self.min_heap[0]:\n            heapq.heappushpop(self.min_heap, val)\n        return self.min_heap[0]\n```\n    \n    We will use a min-heap to solve this problem. We initialize the KthLargest class with an integer `k` and an array `nums`. In the constructor, we loop through the `nums` array and call the `add` function for every element.\n\nThe `add` function does the following:\n1. Pushes the new value into the min-heap.\n2. If the size of the min-heap is greater than `k`, we pop an element from the min-heap (i.e., remove the smallest element).\n3. We return the top element of the min-heap which represents the k-th largest element in the stream.\n\nFor the JavaScript implementation, we also need to create a separate MinHeap class covering the basic functions (offer, poll, peek, size) to maintain minimum priority queue.\n\nAll implementations follow the same algorithm, with small syntax differences between programming languages.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nclass KthLargest {\npublic:\n    int k;\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    KthLargest(int k, std::vector<int>& nums) {\n        this->k = k;\n        for (int num : nums) {\n            add(num);\n        }\n    }\n    \n    int add(int val) {\n        minHeap.push(val);\n        if (minHeap.size() > k) {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};\n```\n    \n    We will use a min-heap to solve this problem. We initialize the KthLargest class with an integer `k` and an array `nums`. In the constructor, we loop through the `nums` array and call the `add` function for every element.\n\nThe `add` function does the following:\n1. Pushes the new value into the min-heap.\n2. If the size of the min-heap is greater than `k`, we pop an element from the min-heap (i.e., remove the smallest element).\n3. We return the top element of the min-heap which represents the k-th largest element in the stream.\n\nFor the JavaScript implementation, we also need to create a separate MinHeap class covering the basic functions (offer, poll, peek, size) to maintain minimum priority queue.\n\nAll implementations follow the same algorithm, with small syntax differences between programming languages.\n    ",
        "js": "\n    ```javascript\nclass KthLargest {\n    constructor(k, nums) {\n        this.k = k;\n        this.minHeap = new MinHeap();\n        for (let num of nums) {\n            this.add(num);\n        }\n    }\n    \n    add(val) {\n        this.minHeap.offer(val);\n        if (this.minHeap.size() > this.k) {\n            this.minHeap.poll();\n        }\n        return this.minHeap.peek();\n    }\n}\n\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    offer(val) {\n        this.heap.push(val);\n        this.heap.sort((a, b) => a - b);\n    }\n\n    poll() {\n        return this.heap.shift();\n    }\n\n    peek() {\n        return this.heap[0];\n    }\n\n    size() {\n        return this.heap.length;\n    }\n}\n```\n    \n    We will use a min-heap to solve this problem. We initialize the KthLargest class with an integer `k` and an array `nums`. In the constructor, we loop through the `nums` array and call the `add` function for every element.\n\nThe `add` function does the following:\n1. Pushes the new value into the min-heap.\n2. If the size of the min-heap is greater than `k`, we pop an element from the min-heap (i.e., remove the smallest element).\n3. We return the top element of the min-heap which represents the k-th largest element in the stream.\n\nFor the JavaScript implementation, we also need to create a separate MinHeap class covering the basic functions (offer, poll, peek, size) to maintain minimum priority queue.\n\nAll implementations follow the same algorithm, with small syntax differences between programming languages.\n    "
    },
    {
        "id": 133,
        "title": "Binary Search",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 9\n**Output:** 4\n**Explanation:** 9 exists in nums and its index is 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in nums so return -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 < nums[i], target < 104`\n*   All the integers in `nums` are **unique**.\n*   `nums` is sorted in ascending order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[-1,0,3,5,9,12],9",
                "output": "4"
            },
            {
                "input": "[-1,0,3,5,9,12],2",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "python": "\n    ```python\ndef search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "c++": "\n    ```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "js": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    "
    },
    {
        "id": 134,
        "title": "Design HashSet",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a HashSet without using any built-in hash table libraries.\n\nImplement `MyHashSet` class:\n\n*   `void add(key)` Inserts the value `key` into the HashSet.\n*   `bool contains(key)` Returns whether the value `key` exists in the HashSet or not.\n*   `void remove(key)` Removes the value `key` in the HashSet. If `key` does not exist in the HashSet, do nothing.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyHashSet \",  \"add \",  \"add \",  \"contains \",  \"contains \",  \"add \",  \"contains \",  \"remove \",  \"contains \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[1\\], \\[3\\], \\[2\\], \\[2\\], \\[2\\], \\[2\\]\\]\n**Output**\n\\[null, null, null, true, false, null, true, null, false\\]\n\n**Explanation**\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = \\[1\\]\nmyHashSet.add(2);      // set = \\[1, 2\\]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = \\[1, 2\\]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = \\[1\\]\nmyHashSet.contains(2); // return False, (already removed)"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= key <= 106`\n*   At most `104` calls will be made to `add`, `remove`, and `contains`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Linked List",
            "Design",
            "Hash Function"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,true,false,null,true,null,false]"
            }
        ],
        "java": "\n    ```java\nclass MyHashSet {\n    boolean[] storage;\n\n    public MyHashSet() {\n        storage = new boolean[1000001];\n    }\n\n    public void add(int key) {\n        storage[key] = true;\n    }\n\n    public void remove(int key) {\n        storage[key] = false;\n    }\n\n    public boolean contains(int key) {\n        return storage[key];\n    }\n}\n```\n\n    \n    The simplest way to implement a HashSet without using any built-in hash table libraries is to use an array of boolean values. The index of the array represents the key and the value at that index represents whether the key is present in the HashSet or not. In this case, we know the key range is `0 <= key <= 10^6`, so we can create an array with a length of `1000001`.\n\nFor the `add(key)` method, we set the value at the index of the key to be `true`.\nFor the `remove(key)` method, we set the value at the index of the key to be `false`.\nFor the `contains(key)` method, we check the value at the index of the key and return it.\n\nThe implementations of these methods are straightforward, and they are similar in each language. We create a storage array (vector in C++, boolean array in Java, list in Python, and array in JavaScript), and then we use simple array operations to manipulate the data.\n    ",
        "python": "\n    ```python\nclass MyHashSet:\n\n    def __init__(self):\n        self.storage = [False] * 1000001\n\n    def add(self, key: int):\n        self.storage[key] = True\n\n    def remove(self, key: int):\n        self.storage[key] = False\n\n    def contains(self, key: int) -> bool:\n        return self.storage[key]\n```\n\n    \n    The simplest way to implement a HashSet without using any built-in hash table libraries is to use an array of boolean values. The index of the array represents the key and the value at that index represents whether the key is present in the HashSet or not. In this case, we know the key range is `0 <= key <= 10^6`, so we can create an array with a length of `1000001`.\n\nFor the `add(key)` method, we set the value at the index of the key to be `true`.\nFor the `remove(key)` method, we set the value at the index of the key to be `false`.\nFor the `contains(key)` method, we check the value at the index of the key and return it.\n\nThe implementations of these methods are straightforward, and they are similar in each language. We create a storage array (vector in C++, boolean array in Java, list in Python, and array in JavaScript), and then we use simple array operations to manipulate the data.\n    ",
        "c++": "\n    ```cpp\nclass MyHashSet {\npublic:\n    vector<bool> storage;\n\n    MyHashSet() : storage(1000001, false) { }\n\n    void add(int key) {\n        storage[key] = true;\n    }\n\n    void remove(int key) {\n        storage[key] = false;\n    }\n\n    bool contains(int key) {\n        return storage[key];\n    }\n};\n```\n\n    \n    The simplest way to implement a HashSet without using any built-in hash table libraries is to use an array of boolean values. The index of the array represents the key and the value at that index represents whether the key is present in the HashSet or not. In this case, we know the key range is `0 <= key <= 10^6`, so we can create an array with a length of `1000001`.\n\nFor the `add(key)` method, we set the value at the index of the key to be `true`.\nFor the `remove(key)` method, we set the value at the index of the key to be `false`.\nFor the `contains(key)` method, we check the value at the index of the key and return it.\n\nThe implementations of these methods are straightforward, and they are similar in each language. We create a storage array (vector in C++, boolean array in Java, list in Python, and array in JavaScript), and then we use simple array operations to manipulate the data.\n    ",
        "js": "\n    ```javascript\nclass MyHashSet {\n    constructor() {\n        this.storage = new Array(1000001).fill(false);\n    }\n\n    add(key) {\n        this.storage[key] = true;\n    }\n\n    remove(key) {\n        this.storage[key] = false;\n    }\n\n    contains(key) {\n        return this.storage[key];\n    }\n}\n```\n\n    \n    The simplest way to implement a HashSet without using any built-in hash table libraries is to use an array of boolean values. The index of the array represents the key and the value at that index represents whether the key is present in the HashSet or not. In this case, we know the key range is `0 <= key <= 10^6`, so we can create an array with a length of `1000001`.\n\nFor the `add(key)` method, we set the value at the index of the key to be `true`.\nFor the `remove(key)` method, we set the value at the index of the key to be `false`.\nFor the `contains(key)` method, we check the value at the index of the key and return it.\n\nThe implementations of these methods are straightforward, and they are similar in each language. We create a storage array (vector in C++, boolean array in Java, list in Python, and array in JavaScript), and then we use simple array operations to manipulate the data.\n    "
    },
    {
        "id": 135,
        "title": "Design HashMap",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the `MyHashMap` class:\n\n*   `MyHashMap()` initializes the object with an empty map.\n*   `void put(int key, int value)` inserts a `(key, value)` pair into the HashMap. If the `key` already exists in the map, update the corresponding `value`.\n*   `int get(int key)` returns the `value` to which the specified `key` is mapped, or `-1` if this map contains no mapping for the `key`.\n*   `void remove(key)` removes the `key` and its corresponding `value` if the map contains the mapping for the `key`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyHashMap \",  \"put \",  \"put \",  \"get \",  \"get \",  \"put \",  \"get \",  \"remove \",  \"get \"\\]\n\\[\\[\\], \\[1, 1\\], \\[2, 2\\], \\[1\\], \\[3\\], \\[2, 1\\], \\[2\\], \\[2\\], \\[2\\]\\]\n**Output**\n\\[null, null, null, 1, -1, null, 1, null, -1\\]\n\n**Explanation**\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now \\[\\[1,1\\]\\]\nmyHashMap.put(2, 2); // The map is now \\[\\[1,1\\], \\[2,2\\]\\]\nmyHashMap.get(1);    // return 1, The map is now \\[\\[1,1\\], \\[2,2\\]\\]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now \\[\\[1,1\\], \\[2,2\\]\\]\nmyHashMap.put(2, 1); // The map is now \\[\\[1,1\\], \\[2,1\\]\\] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now \\[\\[1,1\\], \\[2,1\\]\\]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now \\[\\[1,1\\]\\]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now \\[\\[1,1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= key, value <= 106`\n*   At most `104` calls will be made to `put`, `get`, and `remove`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Linked List",
            "Design",
            "Hash Function"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,1,-1,null,1,null,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\n\nclass MyHashMap {\n    private LinkedList<Pair>[] data;\n    private static final int size = 10007;\n\n    public MyHashMap() {\n        data = new LinkedList[size];\n        for (int i = 0; i < size; ++i) {\n            data[i] = new LinkedList<>();\n        }\n    }\n\n    public void put(int key, int value) {\n        LinkedList<Pair> bucket = data[key % size];\n        for (Pair pair : bucket) {\n            if (pair.getKey() == key) {\n                pair.setValue(value);\n                return;\n            }\n        }\n        bucket.add(new Pair(key, value));\n    }\n\n    public int get(int key) {\n        LinkedList<Pair> bucket = data[key % size];\n        for (Pair pair : bucket) {\n            if (pair.getKey() == key) {\n                return pair.getValue();\n            }\n        }\n        return -1;\n    }\n\n    public void remove(int key) {\n        LinkedList<Pair> bucket = data[key % size];\n        bucket.removeIf(pair -> pair.getKey() == key);\n    }\n\n    private static class Pair {\n        int key;\n        int value;\n\n        Pair(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        int getKey() {\n            return key;\n        }\n\n        int getValue() {\n            return value;\n        }\n\n        void setValue(int value) {\n            this.value = value;\n        }\n    }\n}\n```\n    \n    The basic strategy for a simple hash map, given that the number of keys will be at most 10^4, is to use a hashing function to map an integer key to an index in an array or list of \"buckets\". We will use the modulo operation to do this, with a prime number for the size (e.g., 10007) to minimize the likelihood of collisions.\n\nEach \"bucket\" is a list that can store the (key, value) pairs with the same hash. When a collision happens (i.e., two keys share the same hash), we simply append the new value to the list of that same \"bucket\". We use separate chaining in the linked list, which means that if two values collide, they will coexist in the same bucket.\n\nTo perform the `put` operation, we first hash the key modulo the size to find the corresponding bucket. We iterate through this bucket to check if the key already exists; if so, we update its value, and otherwise, we insert a new (key, value) pair at the end of the list.\n\nThe `get` operation works similarly to `put`: we find the corresponding bucket by hashing the key modulo the size, then iterate through the list to find the requested key. If we find the key, we return the associated value; otherwise, we return -1 to indicate that the key is not in the hash map.\n\nFor the `remove` operation, we again find the corresponding bucket, then iterate through the list to find the pair with the matching key, and remove it from the list if found.\n\nThe complexity of this solution is O(N/K) for each operation (where N is the number of all possible keys and K is the size of the array), but if the number of keys is much smaller than the size of the array, the operations are sufficiently quick.\n    ",
        "python": "\n    ```python\nclass MyHashMap:\n    def __init__(self):\n        self.size = 10007\n        self.data = [[] for _ in range(self.size)]\n\n    def put(self, key: int, value: int) -> None:\n        bucket = self.data[key % self.size]\n        for pair in bucket:\n            if pair[0] == key:\n                pair[1] = value\n                return\n        bucket.append([key, value])\n\n    def get(self, key: int) -> int:\n        bucket = self.data[key % self.size]\n        for pair in bucket:\n            if pair[0] == key:\n                return pair[1]\n        return -1\n\n    def remove(self, key: int) -> None:\n        bucket = self.data[key % self.size]\n        for i, pair in enumerate(bucket):\n            if pair[0] == key:\n                bucket.pop(i)\n                return\n```\n    \n    The basic strategy for a simple hash map, given that the number of keys will be at most 10^4, is to use a hashing function to map an integer key to an index in an array or list of \"buckets\". We will use the modulo operation to do this, with a prime number for the size (e.g., 10007) to minimize the likelihood of collisions.\n\nEach \"bucket\" is a list that can store the (key, value) pairs with the same hash. When a collision happens (i.e., two keys share the same hash), we simply append the new value to the list of that same \"bucket\". We use separate chaining in the linked list, which means that if two values collide, they will coexist in the same bucket.\n\nTo perform the `put` operation, we first hash the key modulo the size to find the corresponding bucket. We iterate through this bucket to check if the key already exists; if so, we update its value, and otherwise, we insert a new (key, value) pair at the end of the list.\n\nThe `get` operation works similarly to `put`: we find the corresponding bucket by hashing the key modulo the size, then iterate through the list to find the requested key. If we find the key, we return the associated value; otherwise, we return -1 to indicate that the key is not in the hash map.\n\nFor the `remove` operation, we again find the corresponding bucket, then iterate through the list to find the pair with the matching key, and remove it from the list if found.\n\nThe complexity of this solution is O(N/K) for each operation (where N is the number of all possible keys and K is the size of the array), but if the number of keys is much smaller than the size of the array, the operations are sufficiently quick.\n    ",
        "c++": "\n    ```cpp\nclass MyHashMap {\npublic:\n    vector<list<pair<int, int>>> data;\n    static const int size = 10007;\n\n    MyHashMap() {\n        data = vector<list<pair<int, int>>>(size);\n    }\n\n    void put(int key, int value) {\n        auto& bucket = data[key % size];\n        for (auto& pair : bucket) {\n            if (pair.first == key) {\n                pair.second = value;\n                return;\n            }\n        }\n        bucket.emplace_back(key, value);\n    }\n\n    int get(int key) {\n        const auto& bucket = data[key % size];\n        for (const auto& pair : bucket) {\n            if (pair.first == key) {\n                return pair.second;\n            }\n        }\n        return -1;\n    }\n\n    void remove(int key) {\n        auto& bucket = data[key % size];\n        bucket.remove_if([key](const auto& pair) { return pair.first == key; });\n    }\n};\n```\n    \n    The basic strategy for a simple hash map, given that the number of keys will be at most 10^4, is to use a hashing function to map an integer key to an index in an array or list of \"buckets\". We will use the modulo operation to do this, with a prime number for the size (e.g., 10007) to minimize the likelihood of collisions.\n\nEach \"bucket\" is a list that can store the (key, value) pairs with the same hash. When a collision happens (i.e., two keys share the same hash), we simply append the new value to the list of that same \"bucket\". We use separate chaining in the linked list, which means that if two values collide, they will coexist in the same bucket.\n\nTo perform the `put` operation, we first hash the key modulo the size to find the corresponding bucket. We iterate through this bucket to check if the key already exists; if so, we update its value, and otherwise, we insert a new (key, value) pair at the end of the list.\n\nThe `get` operation works similarly to `put`: we find the corresponding bucket by hashing the key modulo the size, then iterate through the list to find the requested key. If we find the key, we return the associated value; otherwise, we return -1 to indicate that the key is not in the hash map.\n\nFor the `remove` operation, we again find the corresponding bucket, then iterate through the list to find the pair with the matching key, and remove it from the list if found.\n\nThe complexity of this solution is O(N/K) for each operation (where N is the number of all possible keys and K is the size of the array), but if the number of keys is much smaller than the size of the array, the operations are sufficiently quick.\n    ",
        "js": "\n    ```javascript\nclass MyHashMap {\n    constructor() {\n        this.size = 10007;\n        this.data = new Array(this.size).fill(null).map(() => []);\n    }\n\n    put(key, value) {\n        const bucket = this.data[key % this.size];\n        for (const pair of bucket) {\n            if (pair[0] === key) {\n                pair[1] = value;\n                return;\n            }\n        }\n        bucket.push([key, value]);\n    }\n\n    get(key) {\n        const bucket = this.data[key % this.size];\n        for (const pair of bucket) {\n            if (pair[0] === key) {\n                return pair[1];\n            }\n        }\n        return -1;\n    }\n\n    remove(key) {\n        const bucket = this.data[key % this.size];\n        const index = bucket.findIndex(pair => pair[0] === key);\n        if (index !== -1) {\n            bucket.splice(index, 1);\n        }\n    }\n}\n```\n    \n    The basic strategy for a simple hash map, given that the number of keys will be at most 10^4, is to use a hashing function to map an integer key to an index in an array or list of \"buckets\". We will use the modulo operation to do this, with a prime number for the size (e.g., 10007) to minimize the likelihood of collisions.\n\nEach \"bucket\" is a list that can store the (key, value) pairs with the same hash. When a collision happens (i.e., two keys share the same hash), we simply append the new value to the list of that same \"bucket\". We use separate chaining in the linked list, which means that if two values collide, they will coexist in the same bucket.\n\nTo perform the `put` operation, we first hash the key modulo the size to find the corresponding bucket. We iterate through this bucket to check if the key already exists; if so, we update its value, and otherwise, we insert a new (key, value) pair at the end of the list.\n\nThe `get` operation works similarly to `put`: we find the corresponding bucket by hashing the key modulo the size, then iterate through the list to find the requested key. If we find the key, we return the associated value; otherwise, we return -1 to indicate that the key is not in the hash map.\n\nFor the `remove` operation, we again find the corresponding bucket, then iterate through the list to find the pair with the matching key, and remove it from the list if found.\n\nThe complexity of this solution is O(N/K) for each operation (where N is the number of all possible keys and K is the size of the array), but if the number of keys is much smaller than the size of the array, the operations are sufficiently quick.\n    "
    },
    {
        "id": 136,
        "title": "To Lower Case",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the string after replacing every uppercase letter with the same lowercase letter_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello \"\n**Output:**  \"hello \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"here \"\n**Output:**  \"here \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LOVELY \"\n**Output:**  \"lovely \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of printable ASCII characters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"Hello\"",
                "output": "\"hello\""
            },
            {
                "input": "\"here\"",
                "output": "\"here\""
            },
            {
                "input": "\"LOVELY\"",
                "output": "\"lovely\""
            }
        ],
        "java": "\n    ```java\npublic String toLowerCase(String s) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        if (chars[i] >= 'A' && chars[i] <= 'Z') {\n            chars[i] = (char)(chars[i] - 'A' + 'a');\n        }\n    }\n    return new String(chars);\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "python": "\n    ```python\ndef toLowerCase(s: str) -> str:\n    return s.lower()\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string toLowerCase(std::string s) {\n    for (char& c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "js": "\n    ```javascript\nfunction toLowerCase(s) {\n    let result = '';\n    for (let i = 0; i < s.length; i++) {\n        let charCode = s.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 90) {\n            charCode += 32;\n        }\n        result += String.fromCharCode(charCode);\n    }\n    return result;\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    "
    },
    {
        "id": 137,
        "title": "1-bit and 2-bit Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "We have two special characters:\n\n*   The first character can be represented by one bit `0`.\n*   The second character can be represented by two bits (`10` or `11`).\n\nGiven a binary array `bits` that ends with `0`, return `true` if the last character must be a one-bit character.",
            "examples": [
                "**Example 1:**\n\n**Input:** bits = \\[1,0,0\\]\n**Output:** true\n**Explanation:** The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character.\n\n",
                "**Example 2:**\n\n**Input:** bits = \\[1,1,1,0\\]\n**Output:** false\n**Explanation:** The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= bits.length <= 1000`\n*   `bits[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,0,0]",
                "output": "true"
            },
            {
                "input": "[1,1,1,0]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isOneBitCharacter(int[] bits) {\n    int i;\n    for (i = 0; i < bits.length - 1; i++) {\n        i += bits[i];\n    }\n    return i == bits.length - 1;\n}\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "python": "\n    ```python\ndef is_one_bit_character(bits):\n    i = 0\n    while i < len(bits) - 1:\n        i += bits[i] + 1\n    return i == len(bits) - 1\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool isOneBitCharacter(std::vector<int>& bits) {\n    int i;\n    for (i = 0; i < bits.size() - 1; i++) {\n        i += bits[i];\n    }\n    return i == bits.size() - 1;\n}\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "js": "\n    ```javascript\nfunction isOneBitCharacter(bits) {\n    let i;\n    for (i = 0; i < bits.length - 1; i++) {\n        i += bits[i];\n    }\n    return i === bits.length - 1;\n}\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    "
    },
    {
        "id": 138,
        "title": "Find Pivot Index",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, calculate the **pivot index** of this array.\n\nThe **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn _the **leftmost pivot index**_. If no such index exists, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,7,3,6,5,6\\]\n**Output:** 3\n**Explanation:**\nThe pivot index is 3.\nLeft sum = nums\\[0\\] + nums\\[1\\] + nums\\[2\\] = 1 + 7 + 3 = 11\nRight sum = nums\\[4\\] + nums\\[5\\] = 5 + 6 = 11\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** -1\n**Explanation:**\nThere is no index that satisfies the conditions in the problem statement.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,1,-1\\]\n**Output:** 0\n**Explanation:**\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums\\[1\\] + nums\\[2\\] = 1 + -1 = 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`\n\n**Note:** This question is the same as 1991: [https://leetcode.com/problems/find-the-middle-index-in-array/](https://leetcode.com/problems/find-the-middle-index-in-array/)",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,7,3,6,5,6]",
                "output": "3"
            },
            {
                "input": "[1,2,3]",
                "output": "-1"
            },
            {
                "input": "[2,1,-1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int pivotIndex(int[] nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.length; ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "python": "\n    ```python\ndef pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "c++": "\n    ```cpp\nint pivotIndex(vector<int>& nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "js": "\n    ```javascript\nfunction pivotIndex(nums) {\n    const total_sum = nums.reduce((a, b) => a + b, 0);\n    let left_sum = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (left_sum === total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    "
    },
    {
        "id": 139,
        "title": "Self Dividing Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "A **self-dividing number** is a number that is divisible by every digit it contains.\n\n*   For example, `128` is **a self-dividing number** because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`.\n\nA **self-dividing number** is not allowed to contain the digit zero.\n\nGiven two integers `left` and `right`, return _a list of all the **self-dividing numbers** in the range_ `[left, right]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 1, right = 22\n**Output:** \\[1,2,3,4,5,6,7,8,9,11,12,15,22\\]\n\n",
                "**Example 2:**\n\n**Input:** left = 47, right = 85\n**Output:** \\[48,55,66,77\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left <= right <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "1,22",
                "output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]"
            },
            {
                "input": "47,85",
                "output": "[48,55,66,77]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static boolean isSelfDividing(int num) {\n        int n = num;\n        while (n != 0) {\n            int digit = n % 10;\n            if (digit == 0 || num % digit != 0)\n                return false;\n            n /= 10;\n        }\n        return true;\n    }\n\n    public static List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = left; i <= right; ++i) {\n            if (isSelfDividing(i))\n                result.add(i);\n        }\n        return result;\n    }\n}\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "python": "\n    ```python\ndef is_self_dividing(num):\n    n = num\n    while n:\n        digit = n % 10\n        if digit == 0 or num % digit != 0:\n            return False\n        n //= 10\n    return True\n\ndef self_dividing_numbers(left, right):\n    return [i for i in range(left, right+1) if is_self_dividing(i)]\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool isSelfDividing(int num) {\n    int n = num;\n    while (n) {\n        int digit = n % 10;\n        if (digit == 0 || num % digit != 0)\n            return false;\n        n /= 10;\n    }\n    return true;\n}\n\nstd::vector<int> selfDividingNumbers(int left, int right) {\n    std::vector<int> result;\n    for (int i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push_back(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "js": "\n    ```javascript\nfunction isSelfDividing(num) {\n    let n = num;\n    while (n) {\n        const digit = n % 10;\n        if (digit === 0 || num % digit !== 0)\n            return false;\n        n = Math.floor(n / 10);\n    }\n    return true;\n}\n\nfunction selfDividingNumbers(left, right) {\n    const result = [];\n    for (let i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    "
    },
    {
        "id": 140,
        "title": "Flood Fill",
        "difficulty": "Easy",
        "content": {
            "problem": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image."
            ],
            "constraints": "**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1,1],[1,1,0],[1,0,1]],1,1,2",
                "output": "[[2,2,2],[2,2,0],[2,0,1]]"
            },
            {
                "input": "[[0,0,0],[0,0,0]],0,0,0",
                "output": "[[0,0,0],[0,0,0]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    int startColor = image[sr][sc];\n    fill(image, sr, sc, newColor, startColor);\n    return image;\n}\n\nprivate void fill(int[][] image, int sr, int sc, int newColor, int startColor) {\n    if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\n    image[sr][sc] = newColor;\n    fill(image, sr - 1, sc, newColor, startColor);\n    fill(image, sr + 1, sc, newColor, startColor);\n    fill(image, sr, sc - 1, newColor, startColor);\n    fill(image, sr, sc + 1, newColor, startColor);\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "python": "\n    ```python\ndef floodFill(image, sr, sc, newColor):\n    startColor = image[sr][sc]\n    def fill(sr, sc):\n        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: \n            return\n        image[sr][sc] = newColor\n        fill(sr - 1, sc)\n        fill(sr + 1, sc)\n        fill(sr, sc - 1)\n        fill(sr, sc + 1)\n    \n    fill(sr, sc)\n    return image\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {\n    if (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\n    image[sr][sc] = newColor;\n    fill(image, sr - 1, sc, newColor, startColor);\n    fill(image, sr + 1, sc, newColor, startColor);\n    fill(image, sr, sc - 1, newColor, startColor);\n    fill(image, sr, sc + 1, newColor, startColor);\n}\n\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n    int startColor = image[sr][sc];\n    fill(image, sr, sc, newColor, startColor);\n    return image;\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "js": "\n    ```javascript\nfunction floodFill(image, sr, sc, newColor) {\n    let startColor = image[sr][sc];\n    function fill(sr, sc) {\n        if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] !== startColor || image[sr][sc] === newColor) return;\n        image[sr][sc] = newColor;\n        fill(sr - 1, sc);\n        fill(sr + 1, sc);\n        fill(sr, sc - 1);\n        fill(sr, sc + 1);\n    }\n    fill(sr, sc);\n    return image;\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    "
    },
    {
        "id": 141,
        "title": "Find Smallest Letter Greater Than Target",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of characters `letters` that is sorted in **non-decreasing order**, and a character `target`. There are **at least two different** characters in `letters`.\n\nReturn _the smallest character in_ `letters` _that is lexicographically greater than_ `target`. If such a character does not exist, return the first character in `letters`.",
            "examples": [
                "**Example 1:**\n\n**Input:** letters = \\[ \"c \", \"f \", \"j \"\\], target =  \"a \"\n**Output:**  \"c \"\n**Explanation:** The smallest character that is lexicographically greater than 'a' in letters is 'c'.\n\n",
                "**Example 2:**\n\n**Input:** letters = \\[ \"c \", \"f \", \"j \"\\], target =  \"c \"\n**Output:**  \"f \"\n**Explanation:** The smallest character that is lexicographically greater than 'c' in letters is 'f'.\n\n",
                "**Example 3:**\n\n**Input:** letters = \\[ \"x \", \"x \", \"y \", \"y \"\\], target =  \"z \"\n**Output:**  \"x \"\n**Explanation:** There are no characters in letters that is lexicographically greater than 'z' so we return letters\\[0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= letters.length <= 104`\n*   `letters[i]` is a lowercase English letter.\n*   `letters` is sorted in **non-decreasing** order.\n*   `letters` contains at least two different characters.\n*   `target` is a lowercase English letter.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[\"c\",\"f\",\"j\"],\"a\"",
                "output": "\"c\""
            },
            {
                "input": "[\"c\",\"f\",\"j\"],\"c\"",
                "output": "\"f\""
            },
            {
                "input": "[\"x\",\"x\",\"y\",\"y\"],\"z\"",
                "output": "\"x\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++)\n            graph.add(new ArrayList<>());\n        for (int[] edge : times)\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        \n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[k] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        pq.add(new int[]{0, k});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int time = curr[0], node = curr[1];\n            \n            if (time > dist[node]) continue;\n            for (int[] neighbour : graph.get(node)) {\n                int neighbourNode = neighbour[0], neighbourTime = neighbour[1];\n                if (time + neighbourTime < dist[neighbourNode]) {\n                    dist[neighbourNode] = time + neighbourTime;\n                    pq.add(new int[]{dist[neighbourNode], neighbourNode});\n                }\n            }\n        }\n        \n        int maxTime = Arrays.stream(dist).skip(1).max().getAsInt();\n        return maxTime == Integer.MAX_VALUE ? -1 : maxTime;\n    }\n}\n```\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the shortest time it takes for the signal to reach every node.\n\n1. Create an adjacency list (graph) to represent the times between nodes.\n   (note: we use different data structures depending on the language, but the idea is the same)\n2. Initialize a distance array (dist) to store the shortest time it takes for the signal to arrive at each node. Set the initial values to infinity (maximum possible time) except for node k, which is set to 0 as it's the source.\n3. Create a priority queue (pq) to store the time it takes to visit a node. Initialize it with node k and time 0.\n4. Iterate through the priority queue while it's not empty:\n   a. Pop the node with the smallest time from the priority queue.\n   b. Check if the current time is greater than the distance for the current node; if true, continue to the next iteration.\n   c. For each neighbor's node in the graph, compare the sum of the current time and travel time to reach the neighbor with the minimum distance for the neighbor in the dist array. If the new calculated time is less, update the dist array and push the neighbor with the new calculated time into the priority queue.\n5. After the loop is finished, find the maximum value in the dist array (ignoring the first value, which is a placeholder). If the maximum value is infinity, return -1, as not all nodes could receive the signal. Otherwise, return the maximum time.\n    ",
        "python": "\n    ```python\nimport heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times, n, k):\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {i: float('inf') for i in range(1, n + 1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        time, node = heapq.heappop(pq)\n\n        if time > dist[node]:\n            continue\n\n        for neighbour, neighbourTime in graph[node]:\n            candidate_dist = time + neighbourTime\n            if candidate_dist < dist[neighbour]:\n                dist[neighbour] = candidate_dist\n                heapq.heappush(pq, (candidate_dist, neighbour))\n\n    maxTime = max(dist.values())\n    return maxTime if maxTime < float('inf') else -1\n```\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the shortest time it takes for the signal to reach every node.\n\n1. Create an adjacency list (graph) to represent the times between nodes.\n   (note: we use different data structures depending on the language, but the idea is the same)\n2. Initialize a distance array (dist) to store the shortest time it takes for the signal to arrive at each node. Set the initial values to infinity (maximum possible time) except for node k, which is set to 0 as it's the source.\n3. Create a priority queue (pq) to store the time it takes to visit a node. Initialize it with node k and time 0.\n4. Iterate through the priority queue while it's not empty:\n   a. Pop the node with the smallest time from the priority queue.\n   b. Check if the current time is greater than the distance for the current node; if true, continue to the next iteration.\n   c. For each neighbor's node in the graph, compare the sum of the current time and travel time to reach the neighbor with the minimum distance for the neighbor in the dist array. If the new calculated time is less, update the dist array and push the neighbor with the new calculated time into the priority queue.\n5. After the loop is finished, find the maximum value in the dist array (ignoring the first value, which is a placeholder). If the maximum value is infinity, return -1, as not all nodes could receive the signal. Otherwise, return the maximum time.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nint networkDelayTime(std::vector<std::vector<int>>& times, int n, int k) {\n    std::vector<std::vector<std::pair<int, int>>> graph(n + 1);\n    for (const auto &edge : times)\n        graph[edge[0]].emplace_back(edge[1], edge[2]);\n\n    std::vector<int> dist(n + 1, std::numeric_limits<int>::max());\n    dist[k] = 0;\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n    pq.emplace(0, k);\n\n    while (!pq.empty()) {\n        int time = pq.top().first, node = pq.top().second;\n        pq.pop();\n\n        if (time > dist[node]) continue;\n        for (const auto &neighbour : graph[node]) {\n            int nextNode = neighbour.first, nextTime = neighbour.second;\n            if (time + nextTime < dist[nextNode]) {\n                dist[nextNode] = time + nextTime;\n                pq.push({dist[nextNode], nextNode});\n            }\n        }\n    }\n\n    int maxTime = *std::max_element(dist.begin() + 1, dist.end());\n    return maxTime == std::numeric_limits<int>::max() ? -1 : maxTime;\n}\n```\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the shortest time it takes for the signal to reach every node.\n\n1. Create an adjacency list (graph) to represent the times between nodes.\n   (note: we use different data structures depending on the language, but the idea is the same)\n2. Initialize a distance array (dist) to store the shortest time it takes for the signal to arrive at each node. Set the initial values to infinity (maximum possible time) except for node k, which is set to 0 as it's the source.\n3. Create a priority queue (pq) to store the time it takes to visit a node. Initialize it with node k and time 0.\n4. Iterate through the priority queue while it's not empty:\n   a. Pop the node with the smallest time from the priority queue.\n   b. Check if the current time is greater than the distance for the current node; if true, continue to the next iteration.\n   c. For each neighbor's node in the graph, compare the sum of the current time and travel time to reach the neighbor with the minimum distance for the neighbor in the dist array. If the new calculated time is less, update the dist array and push the neighbor with the new calculated time into the priority queue.\n5. After the loop is finished, find the maximum value in the dist array (ignoring the first value, which is a placeholder). If the maximum value is infinity, return -1, as not all nodes could receive the signal. Otherwise, return the maximum time.\n    ",
        "js": "\n    ```javascript\nfunction networkDelayTime(times, n, k) {\n    const graph = new Map();\n    for (const [u, v, w] of times) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push([v, w]);\n    }\n\n    const dist = new Array(n + 1).fill(Infinity);\n    dist[k] = 0;\n\n    const pq = [[0, k]];\n    while (pq.length) {\n        pq.sort((a, b) => b[0] - a[0]);\n        const [time, node] = pq.pop();\n\n        if (time > dist[node]) continue;\n\n        if (graph.has(node)) {\n            for (const [neighbour, neighbourTime] of graph.get(node)) {\n                const candidate_dist = time + neighbourTime;\n                if (candidate_dist < dist[neighbour]) {\n                    dist[neighbour] = candidate_dist;\n                    pq.push([candidate_dist, neighbour]);\n                }\n            }\n        }\n    }\n\n    const maxTime = Math.max(...dist.slice(1));\n    return maxTime === Infinity ? -1 : maxTime;\n}\n```\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the shortest time it takes for the signal to reach every node.\n\n1. Create an adjacency list (graph) to represent the times between nodes.\n   (note: we use different data structures depending on the language, but the idea is the same)\n2. Initialize a distance array (dist) to store the shortest time it takes for the signal to arrive at each node. Set the initial values to infinity (maximum possible time) except for node k, which is set to 0 as it's the source.\n3. Create a priority queue (pq) to store the time it takes to visit a node. Initialize it with node k and time 0.\n4. Iterate through the priority queue while it's not empty:\n   a. Pop the node with the smallest time from the priority queue.\n   b. Check if the current time is greater than the distance for the current node; if true, continue to the next iteration.\n   c. For each neighbor's node in the graph, compare the sum of the current time and travel time to reach the neighbor with the minimum distance for the neighbor in the dist array. If the new calculated time is less, update the dist array and push the neighbor with the new calculated time into the priority queue.\n5. After the loop is finished, find the maximum value in the dist array (ignoring the first value, which is a placeholder). If the maximum value is infinity, return -1, as not all nodes could receive the signal. Otherwise, return the maximum time.\n    "
    },
    {
        "id": 142,
        "title": "Min Cost Climbing Stairs",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn _the minimum cost to reach the top of the floor_.",
            "examples": [
                "**Example 1:**\n\n**Input:** cost = \\[10,15,20\\]\n**Output:** 15\n**Explanation:** You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n",
                "**Example 2:**\n\n**Input:** cost = \\[1,100,1,1,1,100,1,1,100,1\\]\n**Output:** 6\n**Explanation:** You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= cost.length <= 1000`\n*   `0 <= cost[i] <= 999`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[10,15,20]",
                "output": "15"
            },
            {
                "input": "[1,100,1,1,1,100,1,1,100,1]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass WordFilter {\n    private HashMap<String, Integer> dict;\n    \n    public WordFilter(String[] words) {\n        dict = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            for (int j = 0; j <= words[i].length(); j++) {\n                dict.put(words[i].substring(0, j) + \"#\" + words[i].substring(j), i);\n            }\n        }\n    }\n    \n    public int f(String prefix, String suffix) {\n        Integer result = dict.get(prefix + \"#\" + suffix);\n        return result == null ? -1 : result;\n    }\n}\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    ",
        "python": "\n    ```python\nclass WordFilter:\n\n    def __init__(self, words):\n        self.dict = {}\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                self.dict[word[:j] + \"#\" + word[j:]] = i\n\n    def f(self, prefix, suffix):\n        return self.dict.get(prefix + \"#\" + suffix, -1)\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass WordFilter {\n    unordered_map<string, int> dict;\npublic:\n    WordFilter(vector<string>& words) {\n        for (int i = 0; i < words.size(); ++i) {\n            for (int j = 0; j <= words[i].size(); ++j) {\n                dict[words[i].substr(0, j) + \"#\" + words[i].substr(j)] = i;\n            }\n        }\n    }\n\n    int f(string prefix, string suffix) {\n        auto it = dict.find(prefix + \"#\" + suffix);\n        if (it == dict.end()) {\n            return -1;\n        }\n        return it->second;\n    }\n};\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    ",
        "js": "\n    ```javascript\nclass WordFilter {\n    constructor(words) {\n        this.dict = {};\n        for (let i = 0; i < words.length; i++) {\n            for (let j = 0; j <= words[i].length; j++) {\n                this.dict[words[i].slice(0, j) + \"#\" + words[i].slice(j)] = i;\n            }\n        }\n    }\n\n    f(prefix, suffix) {\n        if (this.dict.hasOwnProperty(prefix + \"#\" + suffix)) {\n            return this.dict[prefix + \"#\" + suffix];\n        }\n        return -1;\n    }\n}\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    "
    },
    {
        "id": 143,
        "title": "Largest Number At Least Twice of Others",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` where the largest integer is **unique**.\n\nDetermine whether the largest element in the array is **at least twice** as much as every other number in the array. If it is, return _the **index** of the largest element, or return_ `-1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,6,1,0\\]\n**Output:** 1\n**Explanation:** 6 is the largest integer.\nFor every other number in the array x, 6 is at least twice as big as x.\nThe index of value 6 is 1, so we return 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** -1\n**Explanation:** 4 is less than twice the value of 3, so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 50`\n*   `0 <= nums[i] <= 100`\n*   The largest element in `nums` is unique.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,6,1,0]",
                "output": "1"
            },
            {
                "input": "[1,2,3,4]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minCostClimbingStairs(int[] cost) {\n    for(int i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "python": "\n    ```python\ndef minCostClimbingStairs(cost):\n    for i in range(2, len(cost)):\n        cost[i] += min(cost[i-1], cost[i-2])\n    return min(cost[-1], cost[-2])\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "c++": "\n    ```cpp\nint minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    for(int i=2; i<n; i++)\n        cost[i] += min(cost[i-1], cost[i-2]);\n    return min(cost[n-1], cost[n-2]);\n}\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "js": "\n    ```javascript\nfunction minCostClimbingStairs(cost) {\n    for(let i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    "
    },
    {
        "id": 144,
        "title": "Shortest Completing Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `licensePlate` and an array of strings `words`, find the **shortest completing** word in `words`.\n\nA **completing** word is a word that **contains all the letters** in `licensePlate`. **Ignore numbers and spaces** in `licensePlate`, and treat letters as **case insensitive**. If a letter appears more than once in `licensePlate`, then it must appear in the word the same number of times or more.\n\nFor example, if `licensePlate` `= \"aBc 12c \"`, then it contains letters `'a'`, `'b'` (ignoring case), and `'c'` twice. Possible **completing** words are `\"abccdef \"`, `\"caaacab \"`, and `\"cbca \"`.\n\nReturn _the shortest **completing** word in_ `words`_._ It is guaranteed an answer exists. If there are multiple shortest **completing** words, return the **first** one that occurs in `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** licensePlate =  \"1s3 PSt \", words = \\[ \"step \", \"steps \", \"stripe \", \"stepple \"\\]\n**Output:**  \"steps \"\n**Explanation:** licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n \"step \" contains 't' and 'p', but only contains 1 's'.\n \"steps \" contains 't', 'p', and both 's' characters.\n \"stripe \" is missing an 's'.\n \"stepple \" is missing an 's'.\nSince  \"steps \" is the only word containing all the letters, that is the answer.\n\n",
                "**Example 2:**\n\n**Input:** licensePlate =  \"1s3 456 \", words = \\[ \"looks \", \"pest \", \"stew \", \"show \"\\]\n**Output:**  \"pest \"\n**Explanation:** licensePlate only contains the letter 's'. All the words contain 's', but among these  \"pest \",  \"stew \", and  \"show \" are shortest. The answer is  \"pest \" because it is the word that appears earliest of the 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= licensePlate.length <= 7`\n*   `licensePlate` contains digits, letters (uppercase or lowercase), or space `' '`.\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 15`\n*   `words[i]` consists of lower case English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"1s3PSt\",[\"step\",\"steps\",\"stripe\",\"stepple\"]",
                "output": "\"steps\""
            },
            {
                "input": "\"1s3456\",[\"looks\",\"pest\",\"stew\",\"show\"]",
                "output": "\"pest\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String shortestCompletingWord(String licensePlate, String[] words) {\n    HashMap<Character, Integer> lpCount = new HashMap<>();\n    for (char c : licensePlate.toCharArray()) {\n        if (Character.isLetter(c)) {\n            char lower = Character.toLowerCase(c);\n            lpCount.put(lower, lpCount.getOrDefault(lower, 0) + 1);\n        }\n    }\n\n    String result = \"\";\n    for (String word : words) {\n        HashMap<Character, Integer> wordCount = new HashMap<>();\n        for (char c : word.toCharArray()) {\n            wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);\n        }\n\n        boolean valid = true;\n        for (char ch : lpCount.keySet()) {\n            if (wordCount.getOrDefault(ch, 0) < lpCount.get(ch)) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid && (result.isEmpty() || word.length() < result.length())) {\n            result = word;\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "python": "\n    ```python\ndef shortestCompletingWord(licensePlate: str, words: list[str]) -> str:\n    from collections import Counter\n\n    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n    result = \"\"\n    for word in words:\n        word_count = Counter(word)\n\n        valid = all(word_count[ch] >= count for ch, count in lp_count.items())\n\n        if valid and (not result or len(word) < len(result)):\n            result = word\n\n    return result\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nstd::string shortestCompletingWord(std::string licensePlate, std::vector<std::string>& words) {\n    std::unordered_map<char, int> lp_count;\n    for (char c : licensePlate)\n        if (isalpha(c))\n            lp_count[tolower(c)]++;\n\n    std::string result = \"\";\n    for (const std::string& word : words) {\n        std::unordered_map<char, int> word_count;\n        for (char c : word)\n            word_count[c]++;\n\n        bool valid = true;\n        for (const auto& [ch, count] : lp_count)\n            if (word_count[ch] < count) {\n                valid = false;\n                break;\n            }\n\n        if (valid && (result.empty() || word.length() < result.length()))\n            result = word;\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "js": "\n    ```javascript\nfunction shortestCompletingWord(licensePlate, words) {\n  const lpCount = new Map();\n  for (const c of licensePlate)\n    if (c.match(/[a-zA-Z]/))\n      lpCount.set(c.toLowerCase(), (lpCount.get(c.toLowerCase()) || 0) + 1);\n\n  let result = \"\";\n  for (const word of words) {\n    const wordCount = new Map();\n    for (const c of word)\n      wordCount.set(c, (wordCount.get(c) || 0) + 1);\n\n    let valid = true;\n    for (const [ch, count] of lpCount)\n      if ((wordCount.get(ch) || 0) < count) {\n        valid = false;\n        break;\n      }\n\n    if (valid && (!result || word.length < result.length))\n      result = word;\n  }\n  return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    "
    },
    {
        "id": 145,
        "title": "Prime Number of Set Bits in Binary Representation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integers `left` and `right`, return _the **count** of numbers in the **inclusive** range_ `[left, right]` _having a **prime number of set bits** in their binary representation_.\n\nRecall that the **number of set bits** an integer has is the number of `1`'s present when written in binary.\n\n*   For example, `21` written in binary is `10101`, which has `3` set bits.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 6, right = 10\n**Output:** 4\n**Explanation:**\n6  -> 110 (2 set bits, 2 is prime)\n7  -> 111 (3 set bits, 3 is prime)\n8  -> 1000 (1 set bit, 1 is not prime)\n9  -> 1001 (2 set bits, 2 is prime)\n10 -> 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits.\n\n",
                "**Example 2:**\n\n**Input:** left = 10, right = 15\n**Output:** 5\n**Explanation:**\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left <= right <= 106`\n*   `0 <= right - left <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "6,10",
                "output": "4"
            },
            {
                "input": "10,15",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i += 6)\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        return true;\n    }\n    \n    public int countPrimeSetBits(int left, int right) {\n        int count = 0;\n        for (int i = left; i <= right; ++i)\n            count += isPrime(Integer.bitCount(i)) ? 1 : 0;\n        return count;\n    }\n}\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "python": "\n    ```python\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "c++": "\n    ```cpp\n#include <bitset>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    return true;\n}\n\nint countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; ++i)\n        count += isPrime(std::bitset<32>(i).count());\n    return count;\n}\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "js": "\n    ```javascript\nfunction isPrime(n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6)\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    return true;\n}\n\nfunction countPrimeSetBits(left, right) {\n    let count = 0;\n    for (let i = left; i <= right; ++i)\n        count += isPrime(i.toString(2).split('1').length - 1) ? 1 : 0;\n    return count;\n}\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    "
    },
    {
        "id": 146,
        "title": "Toeplitz Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an `m x n` `matrix`, return _`true` if the matrix is Toeplitz. Otherwise, return `false`._\n\nA matrix is **Toeplitz** if every diagonal from top-left to bottom-right has the same elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3,4\\],\\[5,1,2,3\\],\\[9,5,1,2\\]\\]\n**Output:** true\n**Explanation:**\nIn the above grid, the diagonals are:\n \"\\[9\\] \",  \"\\[5, 5\\] \",  \"\\[1, 1, 1\\] \",  \"\\[2, 2, 2\\] \",  \"\\[3, 3\\] \",  \"\\[4\\] \".\nIn each diagonal all elements are the same, so the answer is True.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,2\\],\\[2,2\\]\\]\n**Output:** false\n**Explanation:**\nThe diagonal  \"\\[1, 2\\] \" has different elements."
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 20`\n*   `0 <= matrix[i][j] <= 99`\n\n**",
            "follow_up": "Follow up:**\n\n*   What if the `matrix` is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\n*   What if the `matrix` is so large that you can only load up a partial row into the memory at once?"
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3,4],[5,1,2,3],[9,5,1,2]]",
                "output": "true"
            },
            {
                "input": "[[1,2],[2,2]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class Node {\n    public int val;\n    public Node prev;\n    public Node next;\n    public Node child;\n}\n\npublic Node flatten(Node head) {\n    if(head == null) return null;\n    \n    Node curr = head;\n    while(curr != null) {\n        if(curr.child != null) {\n            Node insert = curr.child;\n            Node next = curr.next;\n            \n            insert.prev = curr;\n            curr.next = insert;\n            curr.child = null;\n            \n            while(insert.next != null) insert = insert.next;\n            \n            if(next != null) {\n                next.prev = insert;\n                insert.next = next;\n            }\n        }\n        curr = curr.next;\n    }\n    \n    return head;\n}\n```\n\n    \n    The basic idea of the algorithm is to traverse the doubly linked list and if a node has a child, we insert the child list between the current node and its next node. We do this by adjusting the previous and next pointers accordingly. After inserting the child list, we set the child pointer of the current node to null. We keep doing this for each node in the list.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=0, prev=None, next=None, child=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\ndef flatten(head: Node) -> Node:\n    if not head:\n        return None\n    \n    curr = head\n    while curr:\n        if curr.child:\n            insert = curr.child\n            next_node = curr.next\n            \n            insert.prev = curr\n            curr.next = insert\n            curr.child = None\n            \n            while insert.next:\n                insert = insert.next\n                \n            if next_node:\n                next_node.prev = insert\n                insert.next = next_node\n                \n        curr = curr.next\n        \n    return head\n```\n\n    \n    The basic idea of the algorithm is to traverse the doubly linked list and if a node has a child, we insert the child list between the current node and its next node. We do this by adjusting the previous and next pointers accordingly. After inserting the child list, we set the child pointer of the current node to null. We keep doing this for each node in the list.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    Node* prev;\n    Node* next;\n    Node* child;\n};\n\nNode* flatten(Node* head) {\n    if(!head) return nullptr;\n    \n    Node* curr = head;\n    while(curr) {\n        if(curr->child) {\n            Node* insert = curr->child;\n            Node* next = curr->next;\n            \n            insert->prev = curr;\n            curr->next = insert;\n            curr->child = nullptr;\n            \n            while(insert->next) insert = insert->next;\n            \n            if(next) {\n                next->prev = insert;\n                insert->next = next;\n            }\n        }\n        curr = curr->next;\n    }\n    \n    return head;\n}\n```\n\n    \n    The basic idea of the algorithm is to traverse the doubly linked list and if a node has a child, we insert the child list between the current node and its next node. We do this by adjusting the previous and next pointers accordingly. After inserting the child list, we set the child pointer of the current node to null. We keep doing this for each node in the list.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, prev, next, child) {\n        this.val = val;\n        this.prev = prev || null;\n        this.next = next || null;\n        this.child = child || null;\n    }\n}\n\nfunction flatten(head) {\n    if (!head) return null;\n\n    let curr = head;\n    while (curr) {\n        if (curr.child) {\n            let insert = curr.child;\n            let next = curr.next;\n            \n            insert.prev = curr;\n            curr.next = insert;\n            curr.child = null;\n            \n            while (insert.next) insert = insert.next;\n\n            if (next) {\n                next.prev = insert;\n                insert.next = next;\n            }\n        }\n        curr = curr.next;\n    }\n\n    return head;\n}\n```\n\n    \n    The basic idea of the algorithm is to traverse the doubly linked list and if a node has a child, we insert the child list between the current node and its next node. We do this by adjusting the previous and next pointers accordingly. After inserting the child list, we set the child pointer of the current node to null. We keep doing this for each node in the list.\n    "
    },
    {
        "id": 147,
        "title": "Jewels and Stones",
        "difficulty": "Easy",
        "content": {
            "problem": "You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\nLetters are case sensitive, so `\"a \"` is considered a different type of stone from `\"A \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** jewels = \"aA\", stones = \"aAAbbbb\"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** jewels = \"z\", stones = \"ZZ\"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= jewels.length, stones.length <= 50`\n*   `jewels` and `stones` consist of only English letters.\n*   All the characters of `jewels` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"aA\",\"aAAbbbb\"",
                "output": "3"
            },
            {
                "input": "\"z\",\"ZZ\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char stone : stones.toCharArray()) {\n        if (jewels.indexOf(stone) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "python": "\n    ```python\ndef num_jewels_in_stones(jewels: str, stones: str) -> int:\n    count = 0\n    for stone in stones:\n        if stone in jewels:\n            count += 1\n    return count\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "c++": "\n    ```cpp\nint numJewelsInStones(string jewels, string stones) {\n    int count = 0;\n    for (char stone : stones) {\n        if (jewels.find(stone) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "js": "\n    ```javascript\nfunction numJewelsInStones(jewels, stones) {\n    let count = 0;\n    for (let stone of stones) {\n        if (jewels.indexOf(stone) !== -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    "
    },
    {
        "id": 148,
        "title": "Minimum Distance Between BST Nodes",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a Binary Search Tree (BST), return _the minimum difference between the values of any two different nodes in the tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,6,1,3\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,0,48,null,null,12,49\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 100]`.\n*   `0 <= Node.val <= 105`\n\n**Note:** This question is the same as 530: [https://leetcode.com/problems/minimum-absolute-difference-in-bst/](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[4,2,6,1,3]",
                "output": "1"
            },
            {
                "input": "[1,0,48,null,null,12,49]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || root.val == val) {\n        return root;\n    }\n    return (root.val > val) ? searchBST(root.left, val) : searchBST(root.right, val);\n}\n```\n    \n    We are given a binary search tree (BST) and an integer value `val`. Our task is to find the node in the tree with the same value as `val` and return the subtree rooted at that node. If there is no such node, we should return null.\n\nTo solve this problem, we use a recursive function `searchBST`. We first check whether the current `root` is null or has the value we are searching for. If either condition is true, we return the root.\n\nOtherwise, we compare the given `val` with the current node's value. If `val` is less than the current node's value, we proceed to search the left subtree. Otherwise, we search the right subtree, and we return the result of either search.\n\nThis algorithm leverages the properties of a binary search tree, which ensures that for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node, enabling efficient search.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef searchBST(root: TreeNode, val: int) -> TreeNode:\n    if not root or root.val == val:\n        return root\n    return searchBST(root.left, val) if root.val > val else searchBST(root.right, val)\n```\n    \n    We are given a binary search tree (BST) and an integer value `val`. Our task is to find the node in the tree with the same value as `val` and return the subtree rooted at that node. If there is no such node, we should return null.\n\nTo solve this problem, we use a recursive function `searchBST`. We first check whether the current `root` is null or has the value we are searching for. If either condition is true, we return the root.\n\nOtherwise, we compare the given `val` with the current node's value. If `val` is less than the current node's value, we proceed to search the left subtree. Otherwise, we search the right subtree, and we return the result of either search.\n\nThis algorithm leverages the properties of a binary search tree, which ensures that for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node, enabling efficient search.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* searchBST(TreeNode* root, int val) {\n    if (!root || root->val == val) {\n        return root;\n    }\n    return (root->val > val) ? searchBST(root->left, val) : searchBST(root->right, val);\n}\n```\n    \n    We are given a binary search tree (BST) and an integer value `val`. Our task is to find the node in the tree with the same value as `val` and return the subtree rooted at that node. If there is no such node, we should return null.\n\nTo solve this problem, we use a recursive function `searchBST`. We first check whether the current `root` is null or has the value we are searching for. If either condition is true, we return the root.\n\nOtherwise, we compare the given `val` with the current node's value. If `val` is less than the current node's value, we proceed to search the left subtree. Otherwise, we search the right subtree, and we return the result of either search.\n\nThis algorithm leverages the properties of a binary search tree, which ensures that for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node, enabling efficient search.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction searchBST(root, val) {\n    if (!root || root.val === val) {\n        return root;\n    }\n    return (root.val > val) ? searchBST(root.left, val) : searchBST(root.right, val);\n}\n```\n    \n    We are given a binary search tree (BST) and an integer value `val`. Our task is to find the node in the tree with the same value as `val` and return the subtree rooted at that node. If there is no such node, we should return null.\n\nTo solve this problem, we use a recursive function `searchBST`. We first check whether the current `root` is null or has the value we are searching for. If either condition is true, we return the root.\n\nOtherwise, we compare the given `val` with the current node's value. If `val` is less than the current node's value, we proceed to search the left subtree. Otherwise, we search the right subtree, and we return the result of either search.\n\nThis algorithm leverages the properties of a binary search tree, which ensures that for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node, enabling efficient search.\n    "
    },
    {
        "id": 149,
        "title": "Rotate String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `goal`, return `true` _if and only if_ `s` _can become_ `goal` _after some number of **shifts** on_ `s`.\n\nA **shift** on `s` consists of moving the leftmost character of `s` to the rightmost position.\n\n*   For example, if `s = \"abcde \"`, then it will be `\"bcdea \"` after one shift.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abcde\", goal = \"cdeab\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcde\", goal = \"abced\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, goal.length <= 100`\n*   `s` and `goal` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"abcde\",\"cdeab\"",
                "output": "true"
            },
            {
                "input": "\"abcde\",\"abced\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean canTransform(int sx, int sy, int tx, int ty) {\n    while (sx != tx || sy != ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx < tx) {\n            tx -= ty;\n        } else {\n            ty -= sx;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "python": "\n    ```python\ndef can_transform(sx, sy, tx, ty):\n    while sx != tx or sy != ty:\n        if sx > tx or sy > ty:\n            return False\n        if sx < tx:\n            tx -= ty\n        else:\n            ty -= sx\n    return True\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool canTransform(int sx, int sy, int tx, int ty) {\n    while (sx != tx || sy != ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx < tx) {\n            tx -= ty;\n        } else {\n            ty -= sx;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "js": "\n    ```javascript\nfunction canTransform(sx, sy, tx, ty) {\n    while (sx !== tx || sy !== ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx < tx) {\n            tx -= ty;\n        } else {\n            ty -= sx;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    "
    },
    {
        "id": 150,
        "title": "Unique Morse Code Words",
        "difficulty": "Easy",
        "content": {
            "problem": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n*   `'a'` maps to `\".- \"`,\n*   `'b'` maps to `\"-... \"`,\n*   `'c'` maps to `\"-.-. \"`, and so on.\n\nFor convenience, the full table for the `26` letters of the English alphabet is given below:\n\n\\[ \".- \", \"-... \", \"-.-. \", \"-.. \", \". \", \"..-. \", \"--. \", \".... \", \".. \", \".--- \", \"-.- \", \".-.. \", \"-- \", \"-. \", \"--- \", \".--. \", \"--.- \", \".-. \", \"... \", \"- \", \"..- \", \"...- \", \".-- \", \"-..- \", \"-.-- \", \"--.. \"\\]\n\nGiven an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter.\n\n*   For example, `\"cab \"` can be written as `\"-.-..--... \"`, which is the concatenation of `\"-.-. \"`, `\".- \"`, and `\"-... \"`. We will call such a concatenation the **transformation** of a word.\n\nReturn _the number of different **transformations** among all words we have_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"gin \", \"zen \", \"gig \", \"msg \"\\]\n**Output:** 2\n**Explanation:** The transformation of each word is:\n \"gin \" ->  \"--...-. \"\n \"zen \" ->  \"--...-. \"\n \"gig \" ->  \"--...--. \"\n \"msg \" ->  \"--...--. \"\nThere are 2 different transformations:  \"--...-. \" and  \"--...--. \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \"\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 12`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"gin\",\"zen\",\"gig\",\"msg\"]",
                "output": "2"
            },
            {
                "input": "[\"a\"]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nint rotatedDigits(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        boolean isValidAfterRotation = true;\n        boolean isDifferentAfterRotation = false;\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digit == 3 || digit == 4 || digit == 7) {\n                isValidAfterRotation = false;\n                break;\n            }\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\n                isDifferentAfterRotation = true;\n            }\n            num /= 10;\n        }\n        if (isValidAfterRotation && isDifferentAfterRotation) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "python": "\n    ```python\ndef rotated_digits(n):\n    count = 0\n    for i in range(1, n + 1):\n        is_valid_after_rotation = True\n        is_different_after_rotation = False\n        num = i\n        while num:\n            digit = num % 10\n            if digit in {3, 4, 7}:\n                is_valid_after_rotation = False\n                break\n            if digit in {2, 5, 6, 9}:\n                is_different_after_rotation = True\n            num //= 10\n        if is_valid_after_rotation and is_different_after_rotation:\n            count += 1\n    return count\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "c++": "\n    ```cpp\nint rotatedDigits(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        bool is_valid_after_rotation = true;\n        bool is_different_after_rotation = false;\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digit == 3 || digit == 4 || digit == 7) {\n                is_valid_after_rotation = false;\n                break;\n            }\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\n                is_different_after_rotation = true;\n            }\n            num /= 10;\n        }\n        if (is_valid_after_rotation && is_different_after_rotation) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "js": "\n    ```javascript\nfunction rotatedDigits(n) {\n    let count = 0;\n    for (let i = 1; i <= n; ++i) {\n        let isValidAfterRotation = true;\n        let isDifferentAfterRotation = false;\n        let num = i;\n        while (num !== 0) {\n            let digit = num % 10;\n            if (digit === 3 || digit === 4 || digit === 7) {\n                isValidAfterRotation = false;\n                break;\n            }\n            if (digit === 2 || digit === 5 || digit === 6 || digit === 9) {\n                isDifferentAfterRotation = true;\n            }\n            num = Math.floor(num / 10);\n        }\n        if (isValidAfterRotation && isDifferentAfterRotation) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    "
    },
    {
        "id": 151,
        "title": "Number of Lines To Write String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` of lowercase English letters and an array `widths` denoting **how many pixels wide** each lowercase English letter is. Specifically, `widths[0]` is the width of `'a'`, `widths[1]` is the width of `'b'`, and so on.\n\nYou are trying to write `s` across several lines, where **each line is no longer than** `100` **pixels**. Starting at the beginning of `s`, write as many letters on the first line such that the total width does not exceed `100` pixels. Then, from where you stopped in `s`, continue writing as many letters as you can on the second line. Continue this process until you have written all of `s`.\n\nReturn _an array_ `result` _of length 2 where:_\n\n*   `result[0]` _is the total number of lines._\n*   `result[1]` _is the width of the last line in pixels._",
            "examples": [
                "**Example 1:**\n\n**Input:** widths = \\[10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10\\], s =  \"abcdefghijklmnopqrstuvwxyz \"\n**Output:** \\[3,60\\]\n**Explanation:** You can write s as follows:\nabcdefghij  // 100 pixels wide\nklmnopqrst  // 100 pixels wide\nuvwxyz      // 60 pixels wide\nThere are a total of 3 lines, and the last line is 60 pixels wide.\n\n",
                "**Example 2:**\n\n**Input:** widths = \\[4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10\\], s =  \"bbbcccdddaaa \"\n**Output:** \\[2,4\\]\n**Explanation:** You can write s as follows:\nbbbcccdddaa  // 98 pixels wide\na            // 4 pixels wide\nThere are a total of 2 lines, and the last line is 4 pixels wide."
            ],
            "constraints": "**Constraints:**\n\n*   `widths.length == 26`\n*   `2 <= widths[i] <= 10`\n*   `1 <= s.length <= 1000`\n*   `s` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],\"abcdefghijklmnopqrstuvwxyz\"",
                "output": "[3,60]"
            },
            {
                "input": "[4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],\"bbbcccdddaaa\"",
                "output": "[2,4]"
            }
        ],
        "java": "\n    ```java\npublic int numberOfWays(int n) {\n    int MOD = 1000000007;\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++)\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\n    return dp[n];\n}\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "python": "\n    ```python\ndef numberOfWays(n):\n    MOD = 1000000007\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n    return dp[n]\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "c++": "\n    ```c++\nint numberOfWays(int n) {\n    int MOD = 1000000007;\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\n    return dp[n];\n}\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "js": "\n    ```javascript\nfunction numberOfWays(n) {\n    const MOD = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++)\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\n    return dp[n];\n}\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    "
    },
    {
        "id": 152,
        "title": "Largest Triangle Area",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,1\\],\\[1,0\\],\\[0,2\\],\\[2,0\\]\\]\n**Output:** 2.00000\n**Explanation:** The five points are shown in the above figure. The red triangle is the largest.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,0\\],\\[0,0\\],\\[0,1\\]\\]\n**Output:** 0.50000"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= points.length <= 50`\n*   `-50 <= xi, yi <= 50`\n*   All the given points are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[0,0],[0,1],[1,0],[0,2],[2,0]]",
                "output": "2.00000"
            },
            {
                "input": "[[1,0],[0,0],[0,1]]",
                "output": "0.50000"
            }
        ],
        "java": "\n    ```java\npublic boolean isShifted(String s, String goal) {\n    if(s.length() != goal.length()) return false;\n    \n    s = s + s;\n    return s.contains(goal);\n}\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "python": "\n    ```python\ndef is_shifted(s, goal):\n    if len(s) != len(goal): return False\n\n    s = s + s\n    return goal in s\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "c++": "\n    ```cpp\nbool isShifted(string s, string goal) {\n    if(s.length() != goal.length()) return false;\n\n    s = s + s;\n    return s.find(goal) != string::npos;\n}\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "js": "\n    ```javascript\nfunction isShifted(s, goal) {\n    if (s.length !== goal.length) return false;\n    \n    s = s + s;\n    return s.includes(goal);\n}\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    "
    },
    {
        "id": 153,
        "title": "Most Common Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `paragraph` and a string array of the banned words `banned`, return _the most frequent word that is not banned_. It is **guaranteed** there is **at least one word** that is not banned, and that the answer is **unique**.\n\nThe words in `paragraph` are **case-insensitive** and the answer should be returned in **lowercase**.",
            "examples": [
                "**Example 1:**\n\n**Input:** paragraph =  \"Bob hit a ball, the hit BALL flew far after it was hit. \", banned = \\[ \"hit \"\\]\n**Output:**  \"ball \"\n**Explanation:** \n \"hit \" occurs 3 times, but it is a banned word.\n \"ball \" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as  \"ball, \"), \nand that  \"hit \" isn't the answer even though it occurs more because it is banned.\n\n",
                "**Example 2:**\n\n**Input:** paragraph =  \"a. \", banned = \\[\\]\n**Output:**  \"a \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= paragraph.length <= 1000`\n*   paragraph consists of English letters, space `' '`, or one of the symbols: `\"!?',;. \"`.\n*   `0 <= banned.length <= 100`\n*   `1 <= banned[i].length <= 10`\n*   `banned[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"Bobhitaball,[\"hit\"]",
                "output": "\"ball\""
            },
            {
                "input": "\"a.\",[]",
                "output": "\"a\""
            }
        ],
        "java": "\n    ```java\npublic int minSwaps(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    int[] noSwap = new int[n];\n    int[] doSwap = new int[n];\n    Arrays.fill(noSwap, Integer.MAX_VALUE);\n    Arrays.fill(doSwap, Integer.MAX_VALUE);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            noSwap[i] = noSwap[i - 1];\n            doSwap[i] = doSwap[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            noSwap[i] = Math.min(noSwap[i], doSwap[i - 1]);\n            doSwap[i] = Math.min(doSwap[i], noSwap[i - 1] + 1);\n        }\n    }\n\n    return Math.min(noSwap[n - 1], doSwap[n - 1]);\n}\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "python": "\n    ```python\ndef minSwaps(nums1, nums2):\n    n = len(nums1)\n    noSwap = [float('inf')] * n\n    doSwap = [float('inf')] * n\n    noSwap[0] = 0\n    doSwap[0] = 1\n\n    for i in range(1, n):\n        if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n            noSwap[i] = noSwap[i - 1]\n            doSwap[i] = doSwap[i - 1] + 1\n        if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n            noSwap[i] = min(noSwap[i], doSwap[i - 1])\n            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1)\n\n    return min(noSwap[n - 1], doSwap[n - 1])\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "c++": "\n    ```cpp\nint minSwaps(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size();\n    vector<int> noSwap(n, INT_MAX);\n    vector<int> doSwap(n, INT_MAX);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            noSwap[i] = noSwap[i - 1];\n            doSwap[i] = doSwap[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            noSwap[i] = min(noSwap[i], doSwap[i - 1]);\n            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1);\n        }\n    }\n\n    return min(noSwap[n - 1], doSwap[n - 1]);\n}\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "js": "\n    ```javascript\nfunction minSwaps(nums1, nums2) {\n    const n = nums1.length;\n    const noSwap = new Array(n).fill(Infinity);\n    const doSwap = new Array(n).fill(Infinity);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            noSwap[i] = noSwap[i - 1];\n            doSwap[i] = doSwap[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            noSwap[i] = Math.min(noSwap[i], doSwap[i - 1]);\n            doSwap[i] = Math.min(doSwap[i], noSwap[i - 1] + 1);\n        }\n    }\n\n    return Math.min(noSwap[n - 1], doSwap[n - 1]);\n}\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    "
    },
    {
        "id": 154,
        "title": "Shortest Distance to a Character",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` and a character `c` that occurs in `s`, return _an array of integers_ `answer` _where_ `answer.length == s.length` _and_ `answer[i]` _is the **distance** from index_ `i` _to the **closest** occurrence of character_ `c` _in_ `s`.\n\nThe **distance** between two indices `i` and `j` is `abs(i - j)`, where `abs` is the absolute value function.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"loveleetcode \", c =  \"e \"\n**Output:** \\[3,2,1,0,1,0,0,1,2,2,1,0\\]\n**Explanation:** The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaab \", c =  \"b \"\n**Output:** \\[3,2,1,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s[i]` and `c` are lowercase English letters.\n*   It is guaranteed that `c` occurs at least once in `s`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"loveleetcode\",\"e\"",
                "output": "[3,2,1,0,1,0,0,1,2,2,1,0]"
            },
            {
                "input": "\"aaab\",\"b\"",
                "output": "[3,2,1,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int[] hitBricks(int[][] grid, int[][] hits) {\n    for (int[] hit : hits) {\n        grid[hit[0]][hit[1]]--;\n    }\n\n    int m = grid.length, n = grid[0].length;\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    int dfs(int x, int y) {\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) {\n            return 0;\n        }\n        grid[x][y] = -1;\n        int sum = 1;\n        for (int[] d : directions) {\n            sum += dfs(x + d[0], y + d[1]);\n        }\n        return sum;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (grid[0][i] == 1) {\n            dfs(0, i);\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int[] hit : hits) {\n        grid[hit[0]][hit[1]]++;\n        if (grid[hit[0]][hit[1]] != 1) {\n            result.add(0);\n            continue;\n        }\n        for (int[] d : directions) {\n            if (dfs(hit[0] + d[0], hit[1] + d[1]) != 0) {\n                result.add(dfs(hit[0], hit[1]) - 1);\n                break;\n            }\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n```\n    \n    First, we subtract the presence of bricks in the grid according to the `hits`. Then, we use Depth-First Search (DFS) to determine if a brick can be reached from the top row of the grid. \n\nFor every hit position, if there is a brick there, we check if any adjacent bricks are also stable. If any adjacent bricks are stable, we count the total number of bricks that become unstable starting from the hit position by calling the DFS function on its current cell. Finally, we restore the brick in the current hit position and add the number of fallen bricks to the result array.\n\nNote that we subtract and add the presence of bricks in the grid differently in each language. In C++ and Java, we use `grid[hit[0]][hit[1]]--` and `grid[hit[0]][hit[1]]++`. In Python, we use `grid[x][y] -= 1` and `grid[x][y] += 1`. In JavaScript, we use `grid[x][y]--` and `grid[x][y]++`. The rest of the implementation remains the same across all languages.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n    def dfs(x, y):\n        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] <= 0:\n            return 0\n        grid[x][y] = -1\n        return 1 + sum(dfs(x + dx, y + dy) for dx, dy in directions)\n\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for x, y in hits:\n        grid[x][y] -= 1\n\n    for j in range(n):\n        if grid[0][j] == 1:\n            dfs(0, j)\n\n    result = []\n    for x, y in hits:\n        grid[x][y] += 1\n        if grid[x][y] != 1:\n            result.append(0)\n            continue\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy) != 0:\n                result.append(dfs(x, y) - 1)\n                break\n        else:\n            result.append(0)\n\n    return result\n```\n    \n    First, we subtract the presence of bricks in the grid according to the `hits`. Then, we use Depth-First Search (DFS) to determine if a brick can be reached from the top row of the grid. \n\nFor every hit position, if there is a brick there, we check if any adjacent bricks are also stable. If any adjacent bricks are stable, we count the total number of bricks that become unstable starting from the hit position by calling the DFS function on its current cell. Finally, we restore the brick in the current hit position and add the number of fallen bricks to the result array.\n\nNote that we subtract and add the presence of bricks in the grid differently in each language. In C++ and Java, we use `grid[hit[0]][hit[1]]--` and `grid[hit[0]][hit[1]]++`. In Python, we use `grid[x][y] -= 1` and `grid[x][y] += 1`. In JavaScript, we use `grid[x][y]--` and `grid[x][y]++`. The rest of the implementation remains the same across all languages.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> hitBricks(std::vector<std::vector<int>>& grid, std::vector<std::vector<int>>& hits) {\n    const int m = grid.size(), n = grid[0].size();\n    std::vector<int> result;\n    std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (const auto& hit : hits) {\n        grid[hit[0]][hit[1]]--;\n    }\n\n    function<int(int, int)> dfs = [&](int x, int y) {\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) {\n            return 0;\n        }\n        grid[x][y] = -1;\n        int sum = 1;\n        for (const auto& d : directions) {\n            sum += dfs(x + d[0], y + d[1]);\n        }\n        return sum;\n    };\n\n    for (int i = 0; i < n; ++i) {\n        if (grid[0][i] == 1) {\n            dfs(0, i);\n        }\n    }\n\n    for (const auto& hit : hits) {\n        grid[hit[0]][hit[1]]++;\n        if (grid[hit[0]][hit[1]] != 1) {\n            result.push_back(0);\n            continue;\n        }\n        for (const auto& d : directions) {\n            if (dfs(hit[0] + d[0], hit[1] + d[1])) {\n                result.push_back(dfs(hit[0], hit[1]) - 1);\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    First, we subtract the presence of bricks in the grid according to the `hits`. Then, we use Depth-First Search (DFS) to determine if a brick can be reached from the top row of the grid. \n\nFor every hit position, if there is a brick there, we check if any adjacent bricks are also stable. If any adjacent bricks are stable, we count the total number of bricks that become unstable starting from the hit position by calling the DFS function on its current cell. Finally, we restore the brick in the current hit position and add the number of fallen bricks to the result array.\n\nNote that we subtract and add the presence of bricks in the grid differently in each language. In C++ and Java, we use `grid[hit[0]][hit[1]]--` and `grid[hit[0]][hit[1]]++`. In Python, we use `grid[x][y] -= 1` and `grid[x][y] += 1`. In JavaScript, we use `grid[x][y]--` and `grid[x][y]++`. The rest of the implementation remains the same across all languages.\n    ",
        "js": "\n    ```javascript\nfunction hitBricks(grid, hits) {\n    function dfs(x, y) {\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) {\n            return 0;\n        }\n        grid[x][y] = -1;\n        let sum = 1;\n        for (const [dx, dy] of directions) {\n            sum += dfs(x + dx, y + dy);\n        }\n        return sum;\n    }\n\n    const m = grid.length, n = grid[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    hits.forEach(([x, y]) => grid[x][y]--);\n\n    for (let i = 0; i < n; ++i) {\n        if (grid[0][i] === 1) {\n            dfs(0, i);\n        }\n    }\n\n    const result = [];\n    for (const [x, y] of hits) {\n        grid[x][y]++;\n        if (grid[x][y] !== 1) {\n            result.push(0);\n            continue;\n        }\n        for (const [dx, dy] of directions) {\n            if (dfs(x + dx, y + dy) !== 0) {\n                result.push(dfs(x, y) - 1);\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    First, we subtract the presence of bricks in the grid according to the `hits`. Then, we use Depth-First Search (DFS) to determine if a brick can be reached from the top row of the grid. \n\nFor every hit position, if there is a brick there, we check if any adjacent bricks are also stable. If any adjacent bricks are stable, we count the total number of bricks that become unstable starting from the hit position by calling the DFS function on its current cell. Finally, we restore the brick in the current hit position and add the number of fallen bricks to the result array.\n\nNote that we subtract and add the presence of bricks in the grid differently in each language. In C++ and Java, we use `grid[hit[0]][hit[1]]--` and `grid[hit[0]][hit[1]]++`. In Python, we use `grid[x][y] -= 1` and `grid[x][y] += 1`. In JavaScript, we use `grid[x][y]--` and `grid[x][y]++`. The rest of the implementation remains the same across all languages.\n    "
    },
    {
        "id": 155,
        "title": "Goat Latin",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `sentence` that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\nWe would like to convert the sentence to \"Goat Latin \" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\n*   If a word begins with a vowel (`'a'`, `'e'`, `'i'`, `'o'`, or `'u'`), append `\"ma \"` to the end of the word.\n    *   For example, the word `\"apple \"` becomes `\"applema \"`.\n*   If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add `\"ma \"`.\n    *   For example, the word `\"goat \"` becomes `\"oatgma \"`.\n*   Add one letter `'a'` to the end of each word per its word index in the sentence, starting with `1`.\n    *   For example, the first word gets `\"a \"` added to the end, the second word gets `\"aa \"` added to the end, and so on.\n\nReturn _the final sentence representing the conversion from sentence to Goat Latin_.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence = \"I speak Goat Latin\"\n**Output:** \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n\n",
                "**Example 2:**\n\n**Input:** sentence = \"The quick brown fox jumped over the lazy dog\"\n**Output:** \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 150`\n*   `sentence` consists of English letters and spaces.\n*   `sentence` has no leading or trailing spaces.\n*   All the words in `sentence` are separated by a single space.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"IspeakGoatLatin\"",
                "output": "\"ImaapeaksmaaaoatGmaaaaatinLmaaaaa\""
            },
            {
                "input": "\"Thequickbrownfoxjumpedoverthelazydog\"",
                "output": "\"heTmaauickqmaaarownbmaaaaoxfmaaaaaumpedjmaaaaaaovermaaaaaaahetmaaaaaaaaazylmaaaaaaaaaogdmaaaaaaaaaa\""
            }
        ],
        "java": "\n    ```java\npublic int[] numberOfLines(int[] widths, String s) {\n    int lines = 1;\n    int currentPixel = 0;\n    for (char c : s.toCharArray()) {\n        int letterPixels = widths[c - 'a'];\n        if (currentPixel + letterPixels > 100) {\n            lines++;\n            currentPixel = 0;\n        }\n        currentPixel += letterPixels;\n    }\n    return new int[]{lines, currentPixel};\n}\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "python": "\n    ```python\ndef number_of_lines(widths, s):\n    lines = 1\n    current_pixel = 0\n    for c in s:\n        letter_pixels = widths[ord(c) - ord('a')]\n        if current_pixel + letter_pixels > 100:\n            lines += 1\n            current_pixel = 0\n        current_pixel += letter_pixels\n    return [lines, current_pixel]\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nstd::vector<int> numberOfLines(std::vector<int>& widths, std::string s) {\n    int lines = 1;\n    int currentPixel = 0;\n    for (char c : s) {\n        int letterPixels = widths[c - 'a'];\n        if (currentPixel + letterPixels > 100) {\n            lines++;\n            currentPixel = 0;\n        }\n        currentPixel += letterPixels;\n    }\n    return {lines, currentPixel};\n}\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "js": "\n    ```javascript\nfunction numberOfLines(widths, s) {\n    let lines = 1;\n    let currentPixel = 0;\n    for (let c of s) {\n        let letterPixels = widths[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n        if (currentPixel + letterPixels > 100) {\n            lines++;\n            currentPixel = 0;\n        }\n        currentPixel += letterPixels;\n    }\n    return [lines, currentPixel];\n}\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    "
    },
    {
        "id": 156,
        "title": "Positions of Large Groups",
        "difficulty": "Easy",
        "content": {
            "problem": "In a string `s` of lowercase letters, these letters form consecutive groups of the same character.\n\nFor example, a string like `s = \"abbxxxxzyy \"` has the groups `\"a \"`, `\"bb \"`, `\"xxxx \"`, `\"z \"`, and `\"yy \"`.\n\nA group is identified by an interval `[start, end]`, where `start` and `end` denote the start and end indices (inclusive) of the group. In the above example, `\"xxxx \"` has the interval `[3,6]`.\n\nA group is considered **large** if it has 3 or more characters.\n\nReturn _the intervals of every **large** group sorted in **increasing order by start index**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abbxxxxzzy \"\n**Output:** \\[\\[3,6\\]\\]\n**Explanation:** `\"xxxx \" is the only` large group with start index 3 and end index 6.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abc \"\n**Output:** \\[\\]\n**Explanation:** We have groups  \"a \",  \"b \", and  \"c \", none of which are large groups.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abcdddeeeeaabbbcd \"\n**Output:** \\[\\[3,5\\],\\[6,9\\],\\[12,14\\]\\]\n**Explanation:** The large groups are  \"ddd \",  \"eeee \", and  \"bbb \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` contains lowercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"abbxxxxzzy\"",
                "output": "[[3,6]]"
            },
            {
                "input": "\"abc\"",
                "output": "[]"
            },
            {
                "input": "\"abcdddeeeeaabbbcd\"",
                "output": "[[3,5],[6,9],[12,14]]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public double largestTriangleArea(int[][] points) {\n        double max_area = 0.0;\n        for (int i = 0; i < points.length; ++i) {\n            for (int j = i + 1; j < points.length; ++j) {\n                for (int k = j + 1; k < points.length; ++k) {\n                    max_area = Math.max(max_area, 0.5 * Math.abs(points[i][0] * (points[j][1] - points[k][1])\n                                                              + points[j][0] * (points[k][1] - points[i][1])\n                                                              + points[k][0] * (points[i][1] - points[j][1])));\n                }\n            }\n        }\n        return max_area;\n    }\n}\n```\n    \n    The algorithm computes the area of the triangle formed by any three different points in the input array. To do this, the algorithm performs the following steps:\n\n1. Iterate through all possible unique combinations of three points (i, j, k) in the input array, with i < j < k.\n2. Compute and store the area of the triangle formed by the three points using the shoelace formula: area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|. The formula is derived from the determinant of a matrix.\n3. Keep track of the maximum area found so far and return it after iterating through all combinations of points.\n\nThe algorithm has a time complexity of O(n^3), where n is the number of points in the input array.\n    ",
        "python": "\n    ```python\nfrom itertools import combinations\n\ndef largestTriangleArea(points):\n    return max(0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3))\n```\n    \n    The algorithm computes the area of the triangle formed by any three different points in the input array. To do this, the algorithm performs the following steps:\n\n1. Iterate through all possible unique combinations of three points (i, j, k) in the input array, with i < j < k.\n2. Compute and store the area of the triangle formed by the three points using the shoelace formula: area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|. The formula is derived from the determinant of a matrix.\n3. Keep track of the maximum area found so far and return it after iterating through all combinations of points.\n\nThe algorithm has a time complexity of O(n^3), where n is the number of points in the input array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ndouble largestTriangleArea(vector<vector<int>>& points) {\n    double max_area = 0.0;\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            for (int k = j + 1; k < points.size(); ++k) {\n                max_area = max(max_area, 0.5 * abs(points[i][0] * (points[j][1] - points[k][1])\n                                                  + points[j][0] * (points[k][1] - points[i][1])\n                                                  + points[k][0] * (points[i][1] - points[j][1])));\n            }\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm computes the area of the triangle formed by any three different points in the input array. To do this, the algorithm performs the following steps:\n\n1. Iterate through all possible unique combinations of three points (i, j, k) in the input array, with i < j < k.\n2. Compute and store the area of the triangle formed by the three points using the shoelace formula: area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|. The formula is derived from the determinant of a matrix.\n3. Keep track of the maximum area found so far and return it after iterating through all combinations of points.\n\nThe algorithm has a time complexity of O(n^3), where n is the number of points in the input array.\n    ",
        "js": "\n    ```javascript\nfunction largestTriangleArea(points) {\n    let max_area = 0.0;\n    for (let i = 0; i < points.length; ++i) {\n        for (let j = i + 1; j < points.length; ++j) {\n            for (let k = j + 1; k < points.length; ++k) {\n                max_area = Math.max(max_area, 0.5 * Math.abs(points[i][0] * (points[j][1] - points[k][1])\n                                                      + points[j][0] * (points[k][1] - points[i][1])\n                                                      + points[k][0] * (points[i][1] - points[j][1])));\n            }\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm computes the area of the triangle formed by any three different points in the input array. To do this, the algorithm performs the following steps:\n\n1. Iterate through all possible unique combinations of three points (i, j, k) in the input array, with i < j < k.\n2. Compute and store the area of the triangle formed by the three points using the shoelace formula: area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|. The formula is derived from the determinant of a matrix.\n3. Keep track of the maximum area found so far and return it after iterating through all combinations of points.\n\nThe algorithm has a time complexity of O(n^3), where n is the number of points in the input array.\n    "
    },
    {
        "id": 157,
        "title": "Flipping an Image",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an `n x n` binary matrix `image`, flip the image **horizontally**, then invert it, and return _the resulting image_.\n\nTo flip an image horizontally means that each row of the image is reversed.\n\n*   For example, flipping `[1,1,0]` horizontally results in `[0,1,1]`.\n\nTo invert an image means that each `0` is replaced by `1`, and each `1` is replaced by `0`.\n\n*   For example, inverting `[0,1,1]` results in `[1,0,0]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[1,1,0\\],\\[1,0,1\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[1,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Explanation:** First reverse each row: \\[\\[0,1,1\\],\\[1,0,1\\],\\[0,0,0\\]\\].\nThen, invert the image: \\[\\[1,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[1,1,0,0\\],\\[1,0,0,1\\],\\[0,1,1,1\\],\\[1,0,1,0\\]\\]\n**Output:** \\[\\[1,1,0,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\],\\[1,0,1,0\\]\\]\n**Explanation:** First reverse each row: \\[\\[0,0,1,1\\],\\[1,0,0,1\\],\\[1,1,1,0\\],\\[0,1,0,1\\]\\].\nThen invert the image: \\[\\[1,1,0,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\],\\[1,0,1,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == image.length`\n*   `n == image[i].length`\n*   `1 <= n <= 20`\n*   `images[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Bit Manipulation",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,1,0],[1,0,1],[0,0,0]]",
                "output": "[[1,0,0],[0,1,0],[1,1,1]]"
            },
            {
                "input": "[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]",
                "output": "[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]"
            }
        ],
        "java": "\n    ```java\npublic TreeNode pruneTree(TreeNode root) {\n    if (root == null) return null;\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if (root.val == 0 && root.left == null && root.right == null) return null;\n    return root;\n}\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "python": "\n    ```python\ndef pruneTree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    root.left = pruneTree(root.left)\n    root.right = pruneTree(root.right)\n    if root.val == 0 and not root.left and not root.right:\n        return None\n    return root\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "c++": "\n    ```cpp\nTreeNode* pruneTree(TreeNode* root) {\n    if (!root) return nullptr;\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if (root->val == 0 && !root->left && !root->right) return nullptr;\n    return root;\n}\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "js": "\n    ```javascript\nfunction pruneTree(root) {\n    if (!root) return null;\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if (root.val === 0 && !root.left && !root.right) return null;\n    return root;\n}\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    "
    },
    {
        "id": 158,
        "title": "Rectangle Overlap",
        "difficulty": "Easy",
        "content": {
            "problem": "An axis-aligned rectangle is represented as a list `[x1, y1, x2, y2]`, where `(x1, y1)` is the coordinate of its bottom-left corner, and `(x2, y2)` is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\nTwo rectangles overlap if the area of their intersection is **positive**. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\nGiven two axis-aligned rectangles `rec1` and `rec2`, return `true` _if they overlap, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rec1 = \\[0,0,2,2\\], rec2 = \\[1,1,3,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** rec1 = \\[0,0,1,1\\], rec2 = \\[1,0,2,1\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** rec1 = \\[0,0,1,1\\], rec2 = \\[2,2,3,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `rec1.length == 4`\n*   `rec2.length == 4`\n*   `-109 <= rec1[i], rec2[i] <= 109`\n*   `rec1` and `rec2` represent a valid rectangle with a non-zero area.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[0,0,2,2],[1,1,3,3]",
                "output": "true"
            },
            {
                "input": "[0,0,1,1],[1,0,2,1]",
                "output": "false"
            },
            {
                "input": "[0,0,1,1],[2,2,3,3]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int racecar(int target) {\n    return racecar(target, new HashMap<>());\n}\n\npublic int racecar(int target, Map<String, Integer> memo) {\n    return dp(0, 1, target, memo);\n}\n\npublic int dp(int pos, int speed, int target, Map<String, Integer> memo) {\n    if (Math.abs(pos) > 2 * target)\n        return Integer.MAX_VALUE - 1;\n\n    if (pos == target)\n        return 0;\n\n    String key = pos + \",\" + speed;\n    if (memo.containsKey(key))\n        return memo.get(key);\n\n    int op1 = dp(pos + speed, speed * 2, target, memo) + 1;\n    int op2 = dp(pos, -speed, target, memo) + 2;\n\n    int ans = Math.min(op1, op2);\n    memo.put(key, ans);\n    return ans;\n}\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "python": "\n    ```python\ndef racecar(target: int) -> int:\n    memo = {}\n\n    def dp(pos: int, speed: int) -> int:\n        if pos == target:\n            return 0\n        if abs(pos) > 2 * target:\n            return float('inf')\n\n        key = (pos, speed)\n        if key in memo:\n            return memo[key]\n\n        op1 = dp(pos + speed, speed * 2) + 1\n        op2 = dp(pos, -speed) + 2\n\n        ans = min(op1, op2)\n        memo[key] = ans\n        return ans\n\n    return dp(0, 1)\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "c++": "\n    ```cpp\nint racecar(int target) {\n    unordered_map<int, unordered_map<int, int>> memo;\n    function<int(int, int)> dp = [&](int pos, int speed) {\n        if (pos == target) return 0;\n        if (abs(pos) > 2 * target) return INT_MAX;\n\n        int &ans = memo[pos][speed];\n        if (ans) return ans;\n\n        if (speed == -1) {\n            int op1 = dp(pos + speed, 2 * speed) + 1;\n            int op2 = dp(pos, -speed) + 2;\n\n            ans = min(op1, op2);\n        } else {\n            int op1 = dp(pos - speed, -2 * speed) + 1;\n            int op2 = dp(pos, -speed) + 2;\n\n            ans = min(op1, op2);\n        }\n\n        return ans;\n    };\n\n    return dp(0, target) + 1;\n}\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "js": "\n    ```javascript\nfunction racecar(target) {\n    return dp(0, 1, target, new Map());\n}\n\nfunction dp(position, speed, target, memo) {\n    if (Math.abs(position) > 2 * target)\n        return Infinity - 1;\n\n    if (position === target)\n        return 0;\n\n    let key = position + \",\" + speed;\n    if (memo.has(key))\n        return memo.get(key);\n\n    let op1 = dp(position + speed, speed * 2, target, memo) + 1;\n    let op2 = dp(position, -speed, target, memo) + 2;\n\n    let ans = Math.min(op1, op2);\n    memo.set(key, ans);\n    return ans;\n}\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    "
    },
    {
        "id": 159,
        "title": "Backspace String Compare",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if they are equal when both are typed into empty text editors_. `'#'` means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ab#c \", t =  \"ad#c \"\n**Output:** true\n**Explanation:** Both s and t become  \"ac \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ab## \", t =  \"c#d# \"\n**Output:** true\n**Explanation:** Both s and t become  \" \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a#c \", t =  \"b \"\n**Output:** false\n**Explanation:** s becomes  \"c \" while t becomes  \"b \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 200`\n*   `s` and `t` only contain lowercase letters and `'#'` characters.\n\n**",
            "follow_up": "Follow up:** Can you solve it in `O(n)` time and `O(1)` space?"
        },
        "tag": [
            "Two Pointers",
            "String",
            "Stack",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"ab#c\",\"ad#c\"",
                "output": "true"
            },
            {
                "input": "\"ab##\",\"c#d#\"",
                "output": "true"
            },
            {
                "input": "\"a#c\",\"b\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean backspaceCompare(String s, String t) {\n    int i = s.length() - 1, j = t.length() - 1;\n    while (true) {\n        int back;\n        for (back = 0; i >= 0 && (back > 0 || s.charAt(i) == '#'); --i)\n            back += s.charAt(i) == '#' ? 1 : -1;\n        for (back = 0; j >= 0 && (back > 0 || t.charAt(j) == '#'); --j)\n            back += t.charAt(j) == '#' ? 1 : -1;\n        if (i >= 0 && j >= 0 && s.charAt(i) == t.charAt(j))\n            i--, j--;\n        else\n            return i == -1 && j == -1;\n    }\n}\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "python": "\n    ```python\ndef backspaceCompare(s: str, t: str) -> bool:\n    i, j = len(s) - 1, len(t) - 1\n    while True:\n        back = 0\n        while i >= 0 and (back > 0 or s[i] == '#'):\n            back = back + 1 if s[i] == '#' else back - 1\n            i -= 1\n        back = 0\n        while j >= 0 and (back > 0 or t[j] == '#'):\n            back = back + 1 if t[j] == '#' else back - 1\n            j -= 1\n        if i >= 0 and j >= 0 and s[i] == t[j]:\n            i, j = i -1, j - 1\n        else:\n            return i == -1 and j == -1\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "c++": "\n    ```cpp\nbool backspaceCompare(string s, string t) {\n    int i = s.length() - 1, j = t.length() - 1;\n    while (true) {\n        int back;\n        for (back = 0; i >= 0 && (back > 0 || s[i] == '#'); --i)\n            back += s[i] == '#' ? 1 : -1;\n        for (back = 0; j >= 0 && (back > 0 || t[j] == '#'); --j)\n            back += t[j] == '#' ? 1 : -1;\n        if (i >= 0 && j >= 0 && s[i] == t[j])\n            i--, j--;\n        else\n            return i == -1 && j == -1;\n    }\n}\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "js": "\n    ```javascript\nvar backspaceCompare = function(s, t) {\n    let i = s.length - 1, j = t.length - 1;\n    while (true) {\n        let back;\n        for (back = 0; i >= 0 && (back > 0 || s[i] === '#'); --i)\n            back += s[i] === '#' ? 1 : -1;\n        for (back = 0; j >= 0 && (back > 0 || t[j] === '#'); --j)\n            back += t[j] === '#' ? 1 : -1;\n        if (i >= 0 && j >= 0 && s[i] === t[j])\n            i--, j--;\n        else\n            return i === -1 && j === -1;\n    }\n};\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    "
    },
    {
        "id": 160,
        "title": "Buddy Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `goal`, return `true` _if you can swap two letters in_ `s` _so the result is equal to_ `goal`_, otherwise, return_ `false`_._\n\nSwapping letters is defined as taking two indices `i` and `j` (0-indexed) such that `i != j` and swapping the characters at `s[i]` and `s[j]`.\n\n*   For example, swapping at indices `0` and `2` in `\"abcd \"` results in `\"cbad \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ab \", goal =  \"ba \"\n**Output:** true\n**Explanation:** You can swap s\\[0\\] = 'a' and s\\[1\\] = 'b' to get  \"ba \", which is equal to goal.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ab \", goal =  \"ab \"\n**Output:** false\n**Explanation:** The only letters you can swap are s\\[0\\] = 'a' and s\\[1\\] = 'b', which results in  \"ba \" != goal.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aa \", goal =  \"aa \"\n**Output:** true\n**Explanation:** You can swap s\\[0\\] = 'a' and s\\[1\\] = 'a' to get  \"aa \", which is equal to goal."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, goal.length <= 2 * 104`\n*   `s` and `goal` consist of lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"ab\",\"ba\"",
                "output": "true"
            },
            {
                "input": "\"ab\",\"ab\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"aa\"",
                "output": "true"
            }
        ],
        "java": "\n    \n```java\npublic class MyCircularDeque {\n    private int[] buffer;\n    private int front, rear, size;\n\n    public MyCircularDeque(int k) {\n        buffer = new int[k];\n        front = 0;\n        rear = 0;\n        size = 0;\n    }\n\n    public boolean insertFront(int value) {\n        if (size == buffer.length) return false;\n        front = (front - 1 + buffer.length) % buffer.length;\n        buffer[front] = value;\n        size++;\n        return true;\n    }\n\n    public boolean insertLast(int value) {\n        if (size == buffer.length) return false;\n        buffer[rear] = value;\n        rear = (rear + 1) % buffer.length;\n        size++;\n        return true;\n    }\n\n    public boolean deleteFront() {\n        if (size == 0) return false;\n        front = (front + 1) % buffer.length;\n        size--;\n        return true;\n    }\n\n    public boolean deleteLast() {\n        if (size == 0) return false;\n        rear = (rear - 1 + buffer.length) % buffer.length;\n        size--;\n        return true;\n    }\n\n    public int getFront() {\n        if (size == 0) return -1;\n        return buffer[front];\n    }\n\n    public int getRear() {\n        if (size == 0) return -1;\n        return buffer[(rear - 1 + buffer.length) % buffer.length];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == buffer.length;\n    }\n}\n```\n\n#    \n    #\nThe circular double-ended queue (deque) is implemented with an array (or vector in C++), two pointers, 'front' and 'rear', and an integer 'size', which represents the current number of elements in the deque. The array has a fixed capacity, 'k'. Front represents the index of the first element in the deque, and rear points to the index after the last element in the deque.\n\nInsertion or deletion is done by manipulating these pointers, front and rear accordingly. When the deque is full, the front and rear pointers wrap around, creating a circular structure.\n\nThe main operations are:\n\n1. insertFront(): inserts an element at the front of the deque. To do this, the front pointer is first decremented and then the value is inserted.\n2. insertLast(): inserts an element at the rear of the deque. The value is directly inserted at the rear and the rear pointer is incremented.\n3. deleteFront(): deletes an element from the front of the deque by incrementing the front pointer.\n4. deleteLast(): deletes an element from the rear of the deque by decrementing the rear pointer.\n5. getFront(): returns the front element of the deque.\n6. getRear(): returns the rear element of the deque.\n7. isEmpty(): returns true if the deque is empty.\n8. isFull(): returns true if the deque is full.\n\n##\n    ",
        "js": "\n    \n```javascript\nclass MyCircularDeque {\n    constructor(k) {\n        this.buffer = new Array(k);\n        this.front = 0;\n        this.rear = 0;\n        this.size = 0;\n    }\n\n    insertFront(value) {\n        if (this.size == this.buffer.length) return false;\n        this.front = (this.front - 1 + this.buffer.length) % this.buffer.length;\n        this.buffer[this.front] = value;\n        this.size++;\n        return true;\n    }\n\n    insertLast(value) {\n        if (this.size == this.buffer.length) return false;\n        this.buffer[this.rear] = value;\n        this.rear = (this.rear + 1) % this.buffer.length;\n        this.size++;\n        return true;\n    }\n\n    deleteFront() {\n        if (this.size == 0) return false;\n        this.front = (this.front + 1) % this.buffer.length;\n        this.size--;\n        return true;\n    }\n\n    deleteLast() {\n        if (this.size == 0) return false;\n        this.rear = (this.rear - 1 + this.buffer.length) % this.buffer.length;\n        this.size--;\n        return true;\n    }\n\n    getFront() {\n        if (this.size == 0) return -1;\n        return this.buffer[this.front];\n    }\n\n    getRear() {\n        if (this.size == 0) return -1;\n        return this.buffer[(this.rear - 1 + this.buffer.length) % this.buffer.length];\n    }\n\n    isEmpty() {\n        return this.size == 0;\n    }\n\n    isFull() {\n        return this.size == this.buffer.length;\n    }\n}\n```\n\n#    \n    #\nThe circular double-ended queue (deque) is implemented with an array (or vector in C++), two pointers, 'front' and 'rear', and an integer 'size', which represents the current number of elements in the deque. The array has a fixed capacity, 'k'. Front represents the index of the first element in the deque, and rear points to the index after the last element in the deque.\n\nInsertion or deletion is done by manipulating these pointers, front and rear accordingly. When the deque is full, the front and rear pointers wrap around, creating a circular structure.\n\nThe main operations are:\n\n1. insertFront(): inserts an element at the front of the deque. To do this, the front pointer is first decremented and then the value is inserted.\n2. insertLast(): inserts an element at the rear of the deque. The value is directly inserted at the rear and the rear pointer is incremented.\n3. deleteFront(): deletes an element from the front of the deque by incrementing the front pointer.\n4. deleteLast(): deletes an element from the rear of the deque by decrementing the rear pointer.\n5. getFront(): returns the front element of the deque.\n6. getRear(): returns the rear element of the deque.\n7. isEmpty(): returns true if the deque is empty.\n8. isFull(): returns true if the deque is full.\n\n##\n    ",
        "c++": "\n    ```cpp\nclass MyCircularDeque {\npublic:\n    vector<int> buffer;\n    int front, rear, size;\n\n    MyCircularDeque(int k) {\n        buffer.resize(k);\n        front = 0;\n        rear = 0;\n        size = 0;\n    }\n\n    bool insertFront(int value) {\n        if (size == buffer.size()) return false;\n        front = (front - 1 + buffer.size()) % buffer.size();\n        buffer[front] = value;\n        size++;\n        return true;\n    }\n\n    bool insertLast(int value) {\n        if (size == buffer.size()) return false;\n        buffer[rear] = value;\n        rear = (rear + 1) % buffer.size();\n        size++;\n        return true;\n    }\n\n    bool deleteFront() {\n        if (size == 0) return false;\n        front = (front + 1) % buffer.size();\n        size--;\n        return true;\n    }\n\n    bool deleteLast() {\n        if (size == 0) return false;\n        rear = (rear - 1 + buffer.size()) % buffer.size();\n        size--;\n        return true;\n    }\n\n    int getFront() {\n        if (size == 0) return -1;\n        return buffer[front];\n    }\n\n    int getRear() {\n        if (size == 0) return -1;\n        return buffer[(rear - 1 + buffer.size()) % buffer.size()];\n    }\n\n    bool isEmpty() {\n        return size == 0;\n    }\n\n    bool isFull() {\n        return size == buffer.size();\n    }\n};\n```\n\n#    \n    #\nThe circular double-ended queue (deque) is implemented with an array (or vector in C++), two pointers, 'front' and 'rear', and an integer 'size', which represents the current number of elements in the deque. The array has a fixed capacity, 'k'. Front represents the index of the first element in the deque, and rear points to the index after the last element in the deque.\n\nInsertion or deletion is done by manipulating these pointers, front and rear accordingly. When the deque is full, the front and rear pointers wrap around, creating a circular structure.\n\nThe main operations are:\n\n1. insertFront(): inserts an element at the front of the deque. To do this, the front pointer is first decremented and then the value is inserted.\n2. insertLast(): inserts an element at the rear of the deque. The value is directly inserted at the rear and the rear pointer is incremented.\n3. deleteFront(): deletes an element from the front of the deque by incrementing the front pointer.\n4. deleteLast(): deletes an element from the rear of the deque by decrementing the rear pointer.\n5. getFront(): returns the front element of the deque.\n6. getRear(): returns the rear element of the deque.\n7. isEmpty(): returns true if the deque is empty.\n8. isFull(): returns true if the deque is full.\n\n##\n    ",
        "python": "\n    \n```python\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.buffer = [0] * k\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\n    def insertFront(self, value):\n        if self.size == len(self.buffer): return False\n        self.front = (self.front - 1 + len(self.buffer)) % len(self.buffer)\n        self.buffer[self.front] = value\n        self.size += 1\n        return True\n\n    def insertLast(self, value):\n        if self.size == len(self.buffer): return False\n        self.buffer[self.rear] = value\n        self.rear = (self.rear + 1) % len(self.buffer)\n        self.size += 1\n        return True\n\n    def deleteFront(self):\n        if self.size == 0: return False\n        self.front = (self.front + 1) % len(self.buffer)\n        self.size -= 1\n        return True\n\n    def deleteLast(self):\n        if self.size == 0: return False\n        self.rear = (self.rear - 1 + len(self.buffer)) % len(self.buffer)\n        self.size -= 1\n        return True\n\n    def getFront(self):\n        if self.size == 0: return -1\n        return self.buffer[self.front]\n\n    def getRear(self):\n        if self.size == 0: return -1\n        return self.buffer[(self.rear - 1 + len(self.buffer)) % len(self.buffer)]\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def isFull(self):\n        return self.size == len(self.buffer)\n```\n\n#    \n    #\nThe circular double-ended queue (deque) is implemented with an array (or vector in C++), two pointers, 'front' and 'rear', and an integer 'size', which represents the current number of elements in the deque. The array has a fixed capacity, 'k'. Front represents the index of the first element in the deque, and rear points to the index after the last element in the deque.\n\nInsertion or deletion is done by manipulating these pointers, front and rear accordingly. When the deque is full, the front and rear pointers wrap around, creating a circular structure.\n\nThe main operations are:\n\n1. insertFront(): inserts an element at the front of the deque. To do this, the front pointer is first decremented and then the value is inserted.\n2. insertLast(): inserts an element at the rear of the deque. The value is directly inserted at the rear and the rear pointer is incremented.\n3. deleteFront(): deletes an element from the front of the deque by incrementing the front pointer.\n4. deleteLast(): deletes an element from the rear of the deque by decrementing the rear pointer.\n5. getFront(): returns the front element of the deque.\n6. getRear(): returns the rear element of the deque.\n7. isEmpty(): returns true if the deque is empty.\n8. isFull(): returns true if the deque is full.\n\n##\n    "
    },
    {
        "id": 161,
        "title": "Lemonade Change",
        "difficulty": "Easy",
        "content": {
            "problem": "At a lemonade stand, each lemonade costs `$5`. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a `$5`, `$10`, or `$20` bill. You must provide the correct change to each customer so that the net transaction is that the customer pays `$5`.\n\nNote that you do not have any change in hand at first.\n\nGiven an integer array `bills` where `bills[i]` is the bill the `ith` customer pays, return `true` _if you can provide every customer with the correct change, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** bills = \\[5,5,5,10,20\\]\n**Output:** true\n**Explanation:** \nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.\n\n",
                "**Example 2:**\n\n**Input:** bills = \\[5,5,10,10,20\\]\n**Output:** false\n**Explanation:** \nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can not give the change of $15 back because we only have two $10 bills.\nSince not every customer received the correct change, the answer is false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= bills.length <= 105`\n*   `bills[i]` is either `5`, `10`, or `20`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[5,5,5,10,20]",
                "output": "true"
            },
            {
                "input": "[5,5,10,10,20]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass MyCircularQueue {\n    private int[] data;\n    private int head, tail, size, capacity;\n\n    public MyCircularQueue(int k) {\n        data = new int[k];\n        head = 0;\n        tail = -1;\n        size = 0;\n        capacity = k;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        tail = (tail + 1) % capacity;\n        data[tail] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        head = (head + 1) % capacity;\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[head];\n    }\n\n    public int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[tail];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    ",
        "python": "\n    ```python\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.data = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.data[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.head]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.tail]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    ",
        "c++": "\n    ```c++\nclass MyCircularQueue {\npublic:\n    MyCircularQueue(int k) {\n        data.resize(k);\n        head = 0;\n        tail = -1;\n        size = 0;\n        capacity = k;\n    }\n    \n    bool enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        tail = (tail + 1) % capacity;\n        data[tail] = value;\n        size++;\n        return true;\n    }\n    \n    bool deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        head = (head + 1) % capacity;\n        size--;\n        return true;\n    }\n    \n    int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[head];\n    }\n    \n    int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[tail];\n    }\n    \n    bool isEmpty() {\n        return size == 0;\n    }\n    \n    bool isFull() {\n        return size == capacity;\n    }\n\nprivate:\n    vector<int> data;\n    int head, tail, size, capacity;\n};\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    ",
        "js": "\n    ```javascript\nclass MyCircularQueue {\n    constructor(k) {\n        this.data = new Array(k);\n        this.head = 0;\n        this.tail = -1;\n        this.size = 0;\n        this.capacity = k;\n    }\n\n    enQueue(value) {\n        if (this.isFull()) {\n            return false;\n        }\n        this.tail = (this.tail + 1) % this.capacity;\n        this.data[this.tail] = value;\n        this.size++;\n        return true;\n    }\n\n    deQueue() {\n        if (this.isEmpty()) {\n            return false;\n        }\n        this.head = (this.head + 1) % this.capacity;\n        this.size--;\n        return true;\n    }\n\n    Front() {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        return this.data[this.head];\n    }\n\n    Rear() {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        return this.data[this.tail];\n    }\n\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    isFull() {\n        return this.size === this.capacity;\n    }\n}\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    "
    },
    {
        "id": 162,
        "title": "Transpose Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a 2D integer array `matrix`, return _the **transpose** of_ `matrix`.\n\nThe **transpose** of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[\\[1,4,7\\],\\[2,5,8\\],\\[3,6,9\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** \\[\\[1,4\\],\\[2,5\\],\\[3,6\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `-109 <= matrix[i][j] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[[1,4,7],[2,5,8],[3,6,9]]"
            },
            {
                "input": "[[1,2,3],[4,5,6]]",
                "output": "[[1,4],[2,5],[3,6]]"
            }
        ],
        "java": "\n    ```java\npublic double new21Game(int n, int k, int maxPts) {\n    if (k == 0 || n >= k + maxPts) {\n        return 1;\n    }\n    \n    double[] dp = new double[n + 1];\n    dp[0] = 1;\n    double sum = 1, ans = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        dp[i] = sum / maxPts;\n        if (i < k) {\n            sum += dp[i];\n        } else {\n            ans += dp[i];\n        }\n        if (i >= maxPts) {\n            sum -= dp[i - maxPts];\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "python": "\n    ```python\ndef new21Game(n: int, k: int, maxPts: int) -> float:\n    if k == 0 or n >= k + maxPts:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    s, ans = 1, 0\n\n    for i in range(1, n + 1):\n        dp[i] = s / maxPts\n        if i < k:\n            s += dp[i]\n        else:\n            ans += dp[i]\n        if i >= maxPts:\n            s -= dp[i - maxPts]\n\n    return ans\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\ndouble new21Game(int n, int k, int maxPts) {\n    if (k == 0 || n >= k + maxPts) {\n        return 1;\n    }\n    \n    vector<double> dp(n + 1, 0);\n    dp[0] = 1;\n    double sum = 1, ans = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        dp[i] = sum / maxPts;\n        if (i < k) {\n            sum += dp[i];\n        } else {\n            ans += dp[i];\n        }\n        if (i >= maxPts) {\n            sum -= dp[i - maxPts];\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "js": "\n    ```javascript\nfunction new21Game(n, k, maxPts) {\n    if (k === 0 || n >= k + maxPts) {\n        return 1;\n    }\n\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    let sum = 1, ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        dp[i] = sum / maxPts;\n        if (i < k) {\n            sum += dp[i];\n        } else {\n            ans += dp[i];\n        }\n        if (i >= maxPts) {\n            sum -= dp[i - maxPts];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    "
    },
    {
        "id": 163,
        "title": "Binary Gap",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer `n`, find and return _the **longest distance** between any two **adjacent**_ `1`_'s in the binary representation of_ `n`_. If there are no two adjacent_ `1`_'s, return_ `0`_._\n\nTwo `1`'s are **adjacent** if there are only `0`'s separating them (possibly no `0`'s). The **distance** between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `\"1001 \"` have a distance of 3.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 22\n**Output:** 2\n**Explanation:** 22 in binary is  \"10110 \".\nThe first adjacent pair of 1's is  \"10110 \" with a distance of 2.\nThe second adjacent pair of 1's is  \"10110 \" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that  \"10110 \" is not a valid pair since there is a 1 separating the two 1's underlined.\n\n",
                "**Example 2:**\n\n**Input:** n = 8\n**Output:** 0\n**Explanation:** 8 in binary is  \"1000 \".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\n",
                "**Example 3:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 in binary is  \"101 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "22",
                "output": "2"
            },
            {
                "input": "8",
                "output": "0"
            },
            {
                "input": "5",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic String pushDominoes(String dominoes) {\n    int n = dominoes.length();\n    String prev;\n    String cur = dominoes;\n    do {\n        prev = cur;\n        StringBuilder sb = new StringBuilder(prev);\n        for (int i = 0; i < n; ++i) {\n            if (prev.charAt(i) == 'L' && i > 0 && prev.charAt(i - 1) == '.')\n                sb.setCharAt(i - 1, 'L');\n            else if (prev.charAt(i) == 'R' && i < n - 1 && prev.charAt(i + 1) == '.')\n                sb.setCharAt(i + 1, 'R');\n        }\n        cur = sb.toString();\n    } while (!prev.equals(cur));\n    return cur;\n}\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "python": "\n    ```python\ndef push_dominoes(dominoes: str) -> str:\n    prev, cur = None, dominoes\n    while prev != cur:\n        prev = cur\n        cur_lst = list(prev)\n        for i in range(len(cur)):\n            if prev[i] == 'L' and i > 0 and prev[i - 1] == '.':\n                cur_lst[i - 1] = 'L'\n            elif prev[i] == 'R' and i < len(cur) - 1 and prev[i + 1] == '.':\n                cur_lst[i + 1] = 'R'\n        cur = ''.join(cur_lst)\n    return cur\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring pushDominoes(string dominoes) {\n    int n = dominoes.size();\n    string prev, cur = dominoes;\n    do {\n        prev = cur;\n        for (int i = 0; i < n; ++i) {\n            if (prev[i] == 'L' && i > 0 && prev[i - 1] == '.')\n                cur[i - 1] = 'L';\n            else if (prev[i] == 'R' && i < n - 1 && prev[i + 1] == '.')\n                cur[i + 1] = 'R';\n        }\n    } while (prev != cur);\n    return cur;\n}\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "js": "\n    ```javascript\nfunction pushDominoes(dominoes) {\n    let prev, cur = dominoes;\n    do {\n        prev = cur;\n        let curList = prev.split('');\n        for (let i = 0; i < prev.length; ++i) {\n            if (prev[i] === 'L' && i > 0 && prev[i - 1] === '.')\n                curList[i - 1] = 'L';\n            else if (prev[i] === 'R' && i < prev.length - 1 && prev[i + 1] === '.')\n                curList[i + 1] = 'R';\n        }\n        cur = curList.join('');\n    } while (prev !== cur);\n    return cur;\n}\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    "
    },
    {
        "id": 164,
        "title": "Leaf-Similar Trees",
        "difficulty": "Easy",
        "content": {
            "problem": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a **leaf value sequence**_._\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\nTwo binary trees are considered _leaf-similar_ if their leaf value sequence is the same.\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.",
            "examples": [
                "**Example 1:**\n\n**Input:** root1 = \\[3,5,1,6,2,9,8,null,null,7,4\\], root2 = \\[3,5,1,6,7,4,2,null,null,null,null,null,null,9,8\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root1 = \\[1,2,3\\], root2 = \\[1,3,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in each tree will be in the range `[1, 200]`.\n*   Both of the given trees will have values in the range `[0, 200]`.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,5,1,6,2,9,8,null,null,7,4],[3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]",
                "output": "true"
            },
            {
                "input": "[1,2,3],[1,3,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> splitIntoFibonacci(String num) {\n    List<Integer> ans = new ArrayList<>();\n    backtrack(num, ans, 0, 0, 0);\n    return ans;\n}\n\nprivate boolean backtrack(String num, List<Integer> ans, int index, int prev1, int prev2) {\n    if (index == num.length()) {\n        return ans.size() >= 3;\n    }\n    long curr = 0;\n    for (int i = index; i < num.length(); ++i) {\n        if (i > index && num.charAt(index) == '0') {\n            break;\n        }\n        curr = curr * 10 + num.charAt(i) - '0';\n        if (curr > Integer.MAX_VALUE) {\n            break;\n        }\n\n        if (ans.size() >= 2) {\n            long sum = (long) prev1 + prev2;\n            if (curr < sum) {\n                continue;\n            } else if (curr > sum) {\n                break;\n            }\n        }\n\n        ans.add((int) curr);\n        if (backtrack(num, ans, i + 1, prev2, (int) curr)) {\n            return true;\n        }\n        ans.remove(ans.size() - 1);\n    }\n    return false;\n}\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "python": "\n    ```python\ndef splitIntoFibonacci(num):\n    ans = []\n    def backtrack(index, prev1, prev2):\n        if index == len(num):\n            return len(ans) >= 3\n        curr = 0\n        for i in range(index, len(num)):\n            if i > index and num[index] == '0':\n                break\n            curr = curr * 10 + ord(num[i]) - ord('0')\n            if curr > 2**31 - 1:\n                break\n            if len(ans) >= 2:\n                if curr < prev1 + prev2:\n                    continue\n                elif curr > prev1 + prev2:\n                    break\n            ans.append(curr)\n            if backtrack(i + 1, prev2, curr):\n                return True\n            ans.pop()\n        return False\n            \n    backtrack(0, 0, 0)\n    return ans\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "c++": "\n    ```c++\n#include <vector>\n#include <string>\n\nstd::vector<int> splitIntoFibonacci(std::string num) {\n    std::vector<int> ans;\n    backtrack(num, ans, 0, 0, 0);\n    return ans;\n}\n\nbool backtrack(std::string& num, std::vector<int>& ans, int index, int prev1, int prev2) {\n    if (index == num.size()) {\n        return ans.size() >= 3;\n    }\n    long curr = 0;\n    for (int i = index; i < num.size(); ++i) {\n        if (i > index && num[index] == '0') {\n            break;\n        }\n        curr = curr * 10 + num[i] - '0';\n        if (curr > INT32_MAX) {\n            break;\n        }\n        \n        if (ans.size() >= 2) {\n            long sum = (long)prev1 + prev2;\n            if (curr < sum) {\n                continue;\n            } else if (curr > sum) {\n                break;\n            }\n        }\n        \n        ans.push_back(curr);\n        if (backtrack(num, ans, i + 1, prev2, curr)) {\n            return true;\n        }\n        ans.pop_back();\n    }\n    return false;\n}\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "js": "\n    ```javascript\nfunction splitIntoFibonacci(num) {\n    const ans = [];\n    const backtrack = (index, prev1, prev2) => {\n        if (index === num.length) {\n            return ans.length >= 3;\n        }\n        let curr = 0;\n        for (let i = index; i < num.length; ++i) {\n            if (i > index && num[index] === '0') {\n                break;\n            }\n            curr = curr * 10 + num.charCodeAt(i) - 48;\n            if (curr > 2**31 - 1) {\n                break;\n            }\n            \n            if (ans.length >= 2) {\n                const sum = prev1 + prev2;\n                if (curr < sum) {\n                    continue;\n                } else if (curr > sum) {\n                    break;\n                }\n            }\n            \n            ans.push(curr);\n            if (backtrack(i + 1, prev2, curr)) {\n                return true;\n            }\n            ans.pop();\n        }\n        return false;\n    }\n    \n    backtrack(0, 0, 0);\n    return ans;\n}\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    "
    },
    {
        "id": 165,
        "title": "Middle of the Linked List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a singly linked list, return _the middle node of the linked list_.\n\nIf there are two middle nodes, return **the second middle** node.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[3,4,5\\]\n**Explanation:** The middle node of the list is node 3.\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2,3,4,5,6\\]\n**Output:** \\[4,5,6\\]\n**Explanation:** Since the list has two middle nodes with values 3 and 4, we return the second one."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 100]`.\n*   `1 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5]",
                "output": "[3,4,5]"
            },
            {
                "input": "[1,2,3,4,5,6]",
                "output": "[4,5,6]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean isNStraightHand(int[] hand, int groupSize) {\n    TreeMap<Integer, Integer> counts = new TreeMap<>();\n\n    for (int card : hand) {\n        counts.put(card, counts.getOrDefault(card, 0) + 1);\n    }\n\n    for (Integer key : counts.keySet()) {\n        if (counts.get(key) > 0) {\n            for (int i = groupSize - 1; i >= 0; --i) {\n                if (counts.getOrDefault(key + i, 0) < counts.get(key)) {\n                    return false;\n                }\n                counts.put(key + i, counts.get(key + i) - counts.get(key));\n            }\n        }\n    }\n    \n    return true;\n}\n```\n\n    \n    The algorithm uses a hashmap (Python's `Counter` class, or `Map` class in JavaScript) to count the occurrences of each card value in the hand. Then, it iterates through the card values in sorted order (using `sorted()` for Python and `sort()` for JavaScript). For each card value with positive count, it checks that it can form a group of consecutive cards of size `groupSize`. If any of these groups cannot be formed, it returns False, otherwise returns True. This approach takes advantage of the sorted order to ensure that the consecutive groups are formed in a optimal way.  \n\\\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef is_n_straight_hand(hand, group_size):\n    counts = Counter(hand)\n\n    for card in sorted(counts):\n        if counts[card] > 0:\n            for i in range(group_size - 1, -1, -1):\n                if counts[card + i] < counts[card]:\n                    return False\n                counts[card + i] -= counts[card]\n\n    return True\n```\n\n    \n    The algorithm uses a hashmap (Python's `Counter` class, or `Map` class in JavaScript) to count the occurrences of each card value in the hand. Then, it iterates through the card values in sorted order (using `sorted()` for Python and `sort()` for JavaScript). For each card value with positive count, it checks that it can form a group of consecutive cards of size `groupSize`. If any of these groups cannot be formed, it returns False, otherwise returns True. This approach takes advantage of the sorted order to ensure that the consecutive groups are formed in a optimal way.  \n\\\n    ",
        "c++": "\n    ```cpp\n#include <map>\n#include <vector>\nusing namespace std;\n\nbool isNStraightHand(vector<int>& hand, int groupSize) {\n    map<int, int> counts;\n\n    for (int card : hand) {\n        counts[card]++;\n    }\n\n    for (auto it = counts.begin(); it != counts.end(); ++it) {\n        if (it->second > 0) {\n            for (int i = groupSize - 1; i >= 0; --i) {\n                if (counts[it->first + i] < it->second) {\n                    return false;\n                }\n                counts[it->first + i] -= it->second;\n            }\n        }\n    }\n    \n    return true;\n}\n```\n\n    \n    The algorithm uses a hashmap (Python's `Counter` class, or `Map` class in JavaScript) to count the occurrences of each card value in the hand. Then, it iterates through the card values in sorted order (using `sorted()` for Python and `sort()` for JavaScript). For each card value with positive count, it checks that it can form a group of consecutive cards of size `groupSize`. If any of these groups cannot be formed, it returns False, otherwise returns True. This approach takes advantage of the sorted order to ensure that the consecutive groups are formed in a optimal way.  \n\\\n    ",
        "js": "\n    ```javascript\nfunction isNStraightHand(hand, groupSize) {\n    const counts = new Map();\n\n    for (let card of hand) {\n        counts.set(card, (counts.get(card) || 0) + 1);\n    }\n\n    for (let key of [...counts.keys()].sort((a, b) => a - b)) {\n        if (counts.get(key) > 0) {\n            for (let i = groupSize - 1; i >= 0; --i) {\n                if ((counts.get(key + i) || 0) < counts.get(key)) {\n                    return false;\n                }\n                counts.set(key + i, counts.get(key + i) - counts.get(key));\n            }\n        }\n    }\n    \n    return true;\n}\n```\n\n    \n    The algorithm uses a hashmap (Python's `Counter` class, or `Map` class in JavaScript) to count the occurrences of each card value in the hand. Then, it iterates through the card values in sorted order (using `sorted()` for Python and `sort()` for JavaScript). For each card value with positive count, it checks that it can form a group of consecutive cards of size `groupSize`. If any of these groups cannot be formed, it returns False, otherwise returns True. This approach takes advantage of the sorted order to ensure that the consecutive groups are formed in a optimal way.  \n\\\n    "
    },
    {
        "id": 166,
        "title": "Projection Area of 3D Shapes",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `n x n` `grid` where we place some `1 x 1 x 1` cubes that are axis-aligned with the `x`, `y`, and `z` axes.\n\nEach value `v = grid[i][j]` represents a tower of `v` cubes placed on top of the cell `(i, j)`.\n\nWe view the projection of these cubes onto the `xy`, `yz`, and `zx` planes.\n\nA **projection** is like a shadow, that maps our **3-dimensional** figure to a **2-dimensional** plane. We are viewing the \"shadow \" when looking at the cubes from the top, the front, and the side.\n\nReturn _the total area of all three projections_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** 17\n**Explanation:** Here are the three projections ( \"shadows \") of the shape made with each axis-aligned plane.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[2\\]\\]\n**Output:** 5\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,2\\]\\]\n**Output:** 8"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] <= 50`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2],[3,4]]",
                "output": "17"
            },
            {
                "input": "[[2]]",
                "output": "5"
            },
            {
                "input": "[[1,0],[0,2]]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int carFleet(int target, int[] position, int[] speed) {\n    int n = position.length;\n    Integer[] indices = new Integer[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n\n    Arrays.sort(indices, (a, b) -> position[b] - position[a]);\n\n    int fleets = 0;\n    double lastArrival = -1;\n    for (int i : indices) {\n        double arrival = (double) (target - position[i]) / speed[i];\n        if (arrival > lastArrival) {\n            fleets++;\n            lastArrival = arrival;\n        }\n    }\n\n    return fleets;\n}\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "python": "\n    ```python\ndef carFleet(target: int, position: List[int], speed: List[int]) -> int:\n    cars = sorted(zip(position, speed), reverse=True)\n    fleets = 0\n    last_arrival = -1\n\n    for pos, sp in cars:\n        arrival = (target - pos) / sp\n        if arrival > last_arrival:\n            fleets += 1\n            last_arrival = arrival\n\n    return fleets\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "c++": "\n    ```cpp\nint carFleet(int target, vector<int>& position, vector<int>& speed) {\n    int n = position.size();\n    vector<pair<int, int>> cars;\n    for (int i = 0; i < n; ++i) {\n        cars.emplace_back(position[i], speed[i]);\n    }\n    sort(cars.begin(), cars.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.first > b.first;\n    });\n\n    int fleets = 0;\n    double last_arrival = -1;\n    for (int i = 0; i < n; ++i) {\n        double arrival = (double)(target - cars[i].first) / cars[i].second;\n        if (arrival > last_arrival) {\n            ++fleets;\n            last_arrival = arrival;\n        }\n    }\n\n    return fleets;\n}\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "js": "\n    ```javascript\nfunction carFleet(target, position, speed) {\n  const n = position.length;\n  const cars = position.map((pos, i) => [pos, speed[i]]).sort((a, b) => b[0] - a[0]);\n\n  let fleets = 0;\n  let lastArrival = -1;\n\n  for (let i = 0; i < n; i++) {\n    const arrival = (target - cars[i][0]) / cars[i][1];\n    if (arrival > lastArrival) {\n      fleets++;\n      lastArrival = arrival;\n    }\n  }\n\n  return fleets;\n}\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    "
    },
    {
        "id": 167,
        "title": "Uncommon Words from Two Sentences",
        "difficulty": "Easy",
        "content": {
            "problem": "A **sentence** is a string of single-space separated words where each word consists only of lowercase letters.\n\nA word is **uncommon** if it appears exactly once in one of the sentences, and **does not appear** in the other sentence.\n\nGiven two **sentences** `s1` and `s2`, return _a list of all the **uncommon words**_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n**Output:** \\[\"sweet\",\"sour\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s1 = \"apple apple\", s2 = \"banana\"\n**Output:** \\[\"banana\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 200`\n*   `s1` and `s2` consist of lowercase English letters and spaces.\n*   `s1` and `s2` do not have leading or trailing spaces.\n*   All the words in `s1` and `s2` are separated by a single space.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"thisappleissweet\",\"thisappleissour\"",
                "output": "[\"sweet\",\"sour\"]"
            },
            {
                "input": "\"appleapple\",\"banana\"",
                "output": "[\"banana\"]"
            }
        ],
        "java": "\n    ```java\npublic int kSimilarity(String s1, String s2) {\n    int k = 0;\n    StringBuilder a = new StringBuilder(s1);\n    StringBuilder b = new StringBuilder(s2);\n    for (int i = 0; i < a.length(); ++i) {\n        if (a.charAt(i) != b.charAt(i)) {\n            for (int j = i + 1; j < b.length(); ++j) {\n                if (a.charAt(i) == b.charAt(j) && a.charAt(j) != b.charAt(j)) {\n                    a.setCharAt(i, a.charAt(j));\n                    a.setCharAt(j, b.charAt(j));\n                    k++;\n                    break;\n                }\n            }\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "python": "\n    ```python\ndef k_similarity(s1, s2):\n    k = 0\n    a, b = list(s1), list(s2)\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            for j in range(i + 1, len(b)):\n                if a[i] == b[j] and a[j] != b[j]:\n                    a[i], a[j] = a[j], a[i]\n                    k += 1\n                    break\n    return k\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "c++": "\n    ```cpp\nint kSimilarity(const std::string& s1, const std::string& s2) {\n    int k = 0;\n    std::string a = s1, b = s2;\n    for (int i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            for (int j = i + 1; j < b.size(); ++j) {\n                if (a[i] == b[j] && a[j] != b[j]) {\n                    std::swap(a[i], a[j]);\n                    k++;\n                    break;\n                }\n            }\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "js": "\n    ```javascript\nfunction kSimilarity(s1, s2) {\n    let k = 0;\n    let a = Array.from(s1);\n    let b = Array.from(s2);\n    for (let i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) {\n            for (let j = i + 1; j < b.length; ++j) {\n                if (a[i] === b[j] && a[j] !== b[j]) {\n                    [a[i], a[j]] = [a[j], a[i]];\n                    k++;\n                    break;\n                }\n            }\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    "
    },
    {
        "id": 168,
        "title": "Fair Candy Swap",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice and Bob have a different total number of candies. You are given two integer arrays `aliceSizes` and `bobSizes` where `aliceSizes[i]` is the number of candies of the `ith` box of candy that Alice has and `bobSizes[j]` is the number of candies of the `jth` box of candy that Bob has.\n\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\n\nReturn a_n integer array_ `answer` _where_ `answer[0]` _is the number of candies in the box that Alice must exchange, and_ `answer[1]` _is the number of candies in the box that Bob must exchange_. If there are multiple answers, you may **return any** one of them. It is guaranteed that at least one answer exists.",
            "examples": [
                "**Example 1:**\n\n**Input:** aliceSizes = \\[1,1\\], bobSizes = \\[2,2\\]\n**Output:** \\[1,2\\]\n\n",
                "**Example 2:**\n\n**Input:** aliceSizes = \\[1,2\\], bobSizes = \\[2,3\\]\n**Output:** \\[1,2\\]\n\n",
                "**Example 3:**\n\n**Input:** aliceSizes = \\[2\\], bobSizes = \\[1,3\\]\n**Output:** \\[2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= aliceSizes.length, bobSizes.length <= 104`\n*   `1 <= aliceSizes[i], bobSizes[j] <= 105`\n*   Alice and Bob have a different total number of candies.\n*   There will be at least one valid answer for the given input.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,1],[2,2]",
                "output": "[1,2]"
            },
            {
                "input": "[1,2],[2,3]",
                "output": "[1,2]"
            },
            {
                "input": "[2],[1,3]",
                "output": "[2,3]"
            }
        ],
        "java": "\n    ```java\npublic int mirrorReflection(int p, int q) {\n    int m = p, n = q;\n    int gcd;\n    while (n != 0) {\n        gcd = m % n;\n        m = n;\n        n = gcd;\n    }\n\n    if ((p / m) % 2 == 0) return 2;\n    if ((q / m) % 2 == 0) return 0;\n    return 1;\n}\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "python": "\n    ```python\ndef mirrorReflection(p, q):\n    from math import gcd\n    m = p // gcd(p, q)\n\n    if m % 2 == 0:\n        return 2\n    if (q // gcd(p, q)) % 2 == 0:\n        return 0\n    return 1\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "c++": "\n    ```cpp\nint mirrorReflection(int p, int q) {\n    int m = p, n = q;\n    int gcd;\n    while (n) {\n        gcd = m % n;\n        m = n;\n        n = gcd;\n    }\n\n    if ((p / m) % 2 == 0) return 2;\n    if ((q / m) % 2 == 0) return 0;\n    return 1;\n}\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "js": "\n    ```javascript\nfunction mirrorReflection(p, q) {\n    function gcd(a, b) {\n        return b === 0 ? a : gcd(b, a % b);\n    }\n    let m = p / gcd(p, q);\n\n    if (m % 2 === 0) return 2;\n    if ((q / gcd(p, q)) % 2 === 0) return 0;\n    return 1;\n}\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    "
    },
    {
        "id": 169,
        "title": "Surface Area of 3D Shapes",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `n x n` `grid` where you have placed some `1 x 1 x 1` cubes. Each value `v = grid[i][j]` represents a tower of `v` cubes placed on top of cell `(i, j)`.\n\nAfter placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.\n\nReturn _the total surface area of the resulting shapes_.\n\n**Note:** The bottom face of each shape counts toward its surface area.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** 34\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 32\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n**Output:** 46"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] <= 50`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2],[3,4]]",
                "output": "34"
            },
            {
                "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                "output": "32"
            },
            {
                "input": "[[2,2,2],[2,1,2],[2,2,2]]",
                "output": "46"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic int shortestSubarray(int[] nums, int k) {\n    int n = nums.length;\n    int[] prefixSum = new int[n + 1];\n    for (int i = 0; i < n; i++) prefixSum[i + 1] = prefixSum[i] + nums[i];\n\n    int res = n + 1;\n    Deque<Integer> dq = new ArrayDeque<>();\n    for (int i = 0; i < n + 1; i++) {\n        while (!dq.isEmpty() && prefixSum[i] - prefixSum[dq.peek()] >= k) {\n            res = Math.min(res, i - dq.poll());\n        }\n        while (!dq.isEmpty() && prefixSum[i] <= prefixSum[dq.peekLast()]) {\n            dq.pollLast();\n        }\n        dq.offer(i);\n    }\n    return res <= n ? res : -1;\n}\n```\n    \n    The algorithm first calculates the prefix sum of the array. Then, it initializes a double-ended queue (deque) to store indices of the prefix sum. For each index of the calculated prefix sum, perform these steps:\n\n1. Check if the current prefix sum minus the prefix sum at the front of the deque is greater than or equal to `k`. If true, update the result with the minimum value. This means we found a subarray that meets the requirement of sum >= k, so we remove the deque's front element to see if there's a shorter subarray.\n2. In an increasing order within the deque, check if the current prefix sum is less than or equal to the prefix sum at the back of deque. If true, remove the last element. The goal here is to maintain each element of the deque in increasing order.\n3. Add the index to the deque.\n\nFinally, after iterating through all elements, check if the stored result is valid. If valid, return the result; otherwise, return -1. This logic is implemented in all 4 language solutions.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef shortest_subarray(nums, k):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    res = n + 1\n    dq = deque()\n    for i in range(n + 1):\n        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:\n            res = min(res, i - dq.popleft())\n        while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:\n            dq.pop()\n        dq.append(i)\n\n    return res if res <= n else -1\n```\n    \n    The algorithm first calculates the prefix sum of the array. Then, it initializes a double-ended queue (deque) to store indices of the prefix sum. For each index of the calculated prefix sum, perform these steps:\n\n1. Check if the current prefix sum minus the prefix sum at the front of the deque is greater than or equal to `k`. If true, update the result with the minimum value. This means we found a subarray that meets the requirement of sum >= k, so we remove the deque's front element to see if there's a shorter subarray.\n2. In an increasing order within the deque, check if the current prefix sum is less than or equal to the prefix sum at the back of deque. If true, remove the last element. The goal here is to maintain each element of the deque in increasing order.\n3. Add the index to the deque.\n\nFinally, after iterating through all elements, check if the stored result is valid. If valid, return the result; otherwise, return -1. This logic is implemented in all 4 language solutions.\n    ",
        "c++": "\n    ```cpp\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint shortestSubarray(vector<int>& nums, int k) {\n    int n = nums.size();\n    vector<int> prefix_sum(n + 1, 0);\n    for (int i = 0; i < n; i++) prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n\n    int res = n + 1;\n    deque<int> dq;\n    for (int i = 0; i < n + 1; i++) {\n        while (!dq.empty() && prefix_sum[i] - prefix_sum[dq.front()] >= k) {\n            res = min(res, i - dq.front());\n            dq.pop_front();\n        }\n        while (!dq.empty() && prefix_sum[i] <= prefix_sum[dq.back()]) {\n            dq.pop_back();\n        }\n        dq.push_back(i);\n    }\n    return res <= n ? res : -1;\n}\n```\n    \n    The algorithm first calculates the prefix sum of the array. Then, it initializes a double-ended queue (deque) to store indices of the prefix sum. For each index of the calculated prefix sum, perform these steps:\n\n1. Check if the current prefix sum minus the prefix sum at the front of the deque is greater than or equal to `k`. If true, update the result with the minimum value. This means we found a subarray that meets the requirement of sum >= k, so we remove the deque's front element to see if there's a shorter subarray.\n2. In an increasing order within the deque, check if the current prefix sum is less than or equal to the prefix sum at the back of deque. If true, remove the last element. The goal here is to maintain each element of the deque in increasing order.\n3. Add the index to the deque.\n\nFinally, after iterating through all elements, check if the stored result is valid. If valid, return the result; otherwise, return -1. This logic is implemented in all 4 language solutions.\n    ",
        "js": "\n    ```javascript\nfunction shortestSubarray(nums, k) {\n    const n = nums.length;\n    const prefixSum = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) prefixSum[i + 1] = prefixSum[i] + nums[i];\n\n    let res = n + 1;\n    const dq = [];\n    for (let i = 0; i < n + 1; i++) {\n        while (dq.length > 0 && prefixSum[i] - prefixSum[dq[0]] >= k) {\n            res = Math.min(res, i - dq.shift());\n        }\n        while (dq.length > 0 && prefixSum[i] <= prefixSum[dq[dq.length - 1]]) {\n            dq.pop();\n        }\n        dq.push(i);\n    }\n    return res <= n ? res : -1;\n}\n```\n\n    \n    The algorithm first calculates the prefix sum of the array. Then, it initializes a double-ended queue (deque) to store indices of the prefix sum. For each index of the calculated prefix sum, perform these steps:\n\n1. Check if the current prefix sum minus the prefix sum at the front of the deque is greater than or equal to `k`. If true, update the result with the minimum value. This means we found a subarray that meets the requirement of sum >= k, so we remove the deque's front element to see if there's a shorter subarray.\n2. In an increasing order within the deque, check if the current prefix sum is less than or equal to the prefix sum at the back of deque. If true, remove the last element. The goal here is to maintain each element of the deque in increasing order.\n3. Add the index to the deque.\n\nFinally, after iterating through all elements, check if the stored result is valid. If valid, return the result; otherwise, return -1. This logic is implemented in all 4 language solutions.\n    "
    },
    {
        "id": 170,
        "title": "Monotonic Array",
        "difficulty": "Easy",
        "content": {
            "problem": "An array is **monotonic** if it is either monotone increasing or monotone decreasing.\n\nAn array `nums` is monotone increasing if for all `i <= j`, `nums[i] <= nums[j]`. An array `nums` is monotone decreasing if for all `i <= j`, `nums[i] >= nums[j]`.\n\nGiven an integer array `nums`, return `true` _if the given array is monotonic, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,5,4,4\\]\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,3,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,2,2,3]",
                "output": "true"
            },
            {
                "input": "[6,5,4,4]",
                "output": "true"
            },
            {
                "input": "[1,3,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int maxDepth(TreeNode node) {\n    if (node == null)\n        return 0;\n    else\n        return Math.max(maxDepth(node.left), maxDepth(node.right)) + 1;\n}\n\npublic TreeNode subtreeWithAllDeepest(TreeNode root) {\n    if (root == null)\n        return null;\n\n    int leftDepth = maxDepth(root.left);\n    int rightDepth = maxDepth(root.right);\n\n    if (leftDepth == rightDepth)\n        return root;\n\n    if (leftDepth > rightDepth)\n        return subtreeWithAllDeepest(root.left);\n    else\n        return subtreeWithAllDeepest(root.right);\n}\n```\n    \n    The algorithm works as follows:\n1. Create a helper function `maxDepth` to find the maximum depth of a given node in the tree.\n2. Create the main function `subtreeWithAllDeepest` that takes the root of the tree as input.\n3. If the root is `null`, return `null`.\n4. Calculate the maximum depth of the left and right children of the root.\n5. If the maximum depths of both children are equal, return the root since the subtree with all deepest nodes is rooted at the current root.\n6. If the maximum depth of the left child is greater than that of the right child, the subtree with all deepest nodes must be in the left subtree. So, call the function `subtreeWithAllDeepest` recursively on the left child.\n7. If the maximum depth of the right child is greater than that of the left child, the subtree with all deepest nodes must be in the right subtree. So, call the function `subtreeWithAllDeepest` recursively on the right child. \n\nThis algorithm has a time complexity of O(n) where n is the number of nodes in the tree since it recursively traverses the entire tree in the worst case.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(node):\n    if node is None:\n        return 0\n    else:\n        return max(maxDepth(node.left), maxDepth(node.right)) + 1\n\ndef subtreeWithAllDeepest(root):\n    if root is None:\n        return None\n\n    leftDepth = maxDepth(root.left)\n    rightDepth = maxDepth(root.right)\n\n    if leftDepth == rightDepth:\n        return root\n\n    if leftDepth > rightDepth:\n        return subtreeWithAllDeepest(root.left)\n    else:\n        return subtreeWithAllDeepest(root.right)\n```\n    \n    The algorithm works as follows:\n1. Create a helper function `maxDepth` to find the maximum depth of a given node in the tree.\n2. Create the main function `subtreeWithAllDeepest` that takes the root of the tree as input.\n3. If the root is `null`, return `null`.\n4. Calculate the maximum depth of the left and right children of the root.\n5. If the maximum depths of both children are equal, return the root since the subtree with all deepest nodes is rooted at the current root.\n6. If the maximum depth of the left child is greater than that of the right child, the subtree with all deepest nodes must be in the left subtree. So, call the function `subtreeWithAllDeepest` recursively on the left child.\n7. If the maximum depth of the right child is greater than that of the left child, the subtree with all deepest nodes must be in the right subtree. So, call the function `subtreeWithAllDeepest` recursively on the right child. \n\nThis algorithm has a time complexity of O(n) where n is the number of nodes in the tree since it recursively traverses the entire tree in the worst case.\n    ",
        "c++": "\n    ```cpp\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int v): val(v), left(NULL), right(NULL) {}\n};\n\nint maxDepth(TreeNode* node)\n{\n    if (node == NULL)\n        return 0;\n    else\n        return max(maxDepth(node->left), maxDepth(node->right)) + 1;\n}\n\nTreeNode* subtreeWithAllDeepest(TreeNode* root)\n{\n    if (root == NULL)\n        return NULL;\n\n    int leftDepth = maxDepth(root->left);\n    int rightDepth = maxDepth(root->right);\n\n    if (leftDepth == rightDepth)\n        return root;\n\n    if (leftDepth > rightDepth)\n        return subtreeWithAllDeepest(root->left);\n    else\n        return subtreeWithAllDeepest(root->right);\n}\n```\n    \n    The algorithm works as follows:\n1. Create a helper function `maxDepth` to find the maximum depth of a given node in the tree.\n2. Create the main function `subtreeWithAllDeepest` that takes the root of the tree as input.\n3. If the root is `null`, return `null`.\n4. Calculate the maximum depth of the left and right children of the root.\n5. If the maximum depths of both children are equal, return the root since the subtree with all deepest nodes is rooted at the current root.\n6. If the maximum depth of the left child is greater than that of the right child, the subtree with all deepest nodes must be in the left subtree. So, call the function `subtreeWithAllDeepest` recursively on the left child.\n7. If the maximum depth of the right child is greater than that of the left child, the subtree with all deepest nodes must be in the right subtree. So, call the function `subtreeWithAllDeepest` recursively on the right child. \n\nThis algorithm has a time complexity of O(n) where n is the number of nodes in the tree since it recursively traverses the entire tree in the worst case.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction maxDepth(node) {\n    if (node === null)\n        return 0;\n    else\n        return Math.max(maxDepth(node.left), maxDepth(node.right)) + 1;\n}\n\nfunction subtreeWithAllDeepest(root) {\n    if (root === null)\n        return null;\n\n    let leftDepth = maxDepth(root.left);\n    let rightDepth = maxDepth(root.right);\n\n    if (leftDepth === rightDepth)\n        return root;\n\n    if (leftDepth > rightDepth)\n        return subtreeWithAllDeepest(root.left);\n    else\n        return subtreeWithAllDeepest(root.right);\n}\n```\n\n    \n    The algorithm works as follows:\n1. Create a helper function `maxDepth` to find the maximum depth of a given node in the tree.\n2. Create the main function `subtreeWithAllDeepest` that takes the root of the tree as input.\n3. If the root is `null`, return `null`.\n4. Calculate the maximum depth of the left and right children of the root.\n5. If the maximum depths of both children are equal, return the root since the subtree with all deepest nodes is rooted at the current root.\n6. If the maximum depth of the left child is greater than that of the right child, the subtree with all deepest nodes must be in the left subtree. So, call the function `subtreeWithAllDeepest` recursively on the left child.\n7. If the maximum depth of the right child is greater than that of the left child, the subtree with all deepest nodes must be in the right subtree. So, call the function `subtreeWithAllDeepest` recursively on the right child. \n\nThis algorithm has a time complexity of O(n) where n is the number of nodes in the tree since it recursively traverses the entire tree in the worst case.\n    "
    },
    {
        "id": 171,
        "title": "Increasing Order Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree, rearrange the tree in **in-order** so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,3,6,2,4,null,8,1,null,null,null,7,9\\]\n**Output:** \\[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,1,7\\]\n**Output:** \\[1,null,5,null,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the given tree will be in the range `[1, 100]`.\n*   `0 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[5,3,6,2,4,null,8,1,null,null,null,7,9]",
                "output": "[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]"
            },
            {
                "input": "[5,1,7]",
                "output": "[1,null,5,null,7]"
            }
        ],
        "java": "\n    ```java\nboolean isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nboolean isPalindrome(int n) {\n    int rev = 0, orig = n;\n    while (n > 0) {\n        rev = rev * 10 + n % 10;\n        n /= 10;\n    }\n    return orig == rev;\n}\n\nint primePalindrome(int n) {\n    while (true) {\n        if (isPrime(n) && isPalindrome(n)) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "python": "\n    ```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef prime_palindrome(n):\n    while True:\n        if is_prime(n) and is_palindrome(n):\n            return n\n        n += 1\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "c++": "\n    ```cpp\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool isPalindrome(int n) {\n    int rev = 0, orig = n;\n    while (n > 0) {\n        rev = rev * 10 + n % 10;\n        n /= 10;\n    }\n    return orig == rev;\n}\n\nint primePalindrome(int n) {\n    while (true) {\n        if (isPrime(n) && isPalindrome(n)) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "js": "\n    ```javascript\nfunction isPrime(n) {\n    if (n <= 1) return false;\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}\n\nfunction isPalindrome(n) {\n    const str = n.toString();\n    return str === str.split('').reverse().join('');\n}\n\nfunction primePalindrome(n) {\n    while (true) {\n        if (isPrime(n) && isPalindrome(n)) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    "
    },
    {
        "id": 172,
        "title": "Sort Array By Parity",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, move all the even integers at the beginning of the array followed by all the odd integers.\n\nReturn _**any array** that satisfies this condition_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,2,4\\]\n**Output:** \\[2,4,3,1\\]\n**Explanation:** The outputs \\[4,2,3,1\\], \\[2,4,1,3\\], and \\[4,2,1,3\\] would also be accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `0 <= nums[i] <= 5000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,1,2,4]",
                "output": "[2,4,3,1]"
            },
            {
                "input": "[0]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int lenLongestFibSubseq(int[] arr) {\n    int n = arr.length;\n    Map<Integer, Integer> index = new HashMap<>();\n    for (int i = 0; i < n; ++i)\n        index.put(arr[i], i);\n\n    Map<Integer, Integer> longest = new HashMap<>();\n    int ans = 0;\n\n    for (int k = 0; k < n; ++k)\n        for (int j = 0; j < k; ++j) {\n            int i = index.getOrDefault(arr[k] - arr[j], -1);\n            if (i >= 0 && i < j) {\n                longest.put(j * n + k, longest.getOrDefault(i * n + j, 1) + 1);\n                ans = Math.max(ans, longest.get(j * n + k) + 1);\n            }\n        }\n\n    return ans >= 3 ? ans : 0;\n}\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "python": "\n    ```python\ndef lenLongestFibSubseq(arr):\n    index = {x: i for i, x in enumerate(arr)}\n\n    longest = dict()\n    ans = 0\n\n    for k, z in enumerate(arr):\n        for j, y in enumerate(arr[:k]):\n            i = index.get(z - y, None)\n            if i is not None and i < j:\n                longest[j, k] = longest.get((i, j), 1) + 1\n                ans = max(ans, longest[j, k] + 1)\n\n    return ans if ans >= 3 else 0\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint lenLongestFibSubseq(std::vector<int>& arr) {\n    int n = arr.size();\n    std::unordered_map<int, int> index;\n    for (int i = 0; i < n; ++i)\n        index[arr[i]] = i;\n\n    std::unordered_map<int, int> longest;\n    int ans = 0;\n\n    for (int k = 0; k < n; ++k)\n        for (int j = 0; j < k; ++j) {\n            int i = index.find(arr[k] - arr[j]) == index.end() ? -1 : index[arr[k] - arr[j]];\n            if (i >= 0 && i < j) {\n                longest[j * n + k] = longest.find(i * n + j) == longest.end() ? 2 : longest[i * n + j] + 1;\n                ans = std::max(ans, longest[j * n + k] + 1);\n            }\n        }\n\n    return ans >= 3 ? ans : 0;\n}\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "js": "\n    ```javascript\nfunction lenLongestFibSubseq(arr) {\n    const index = new Map(arr.map((x, i) => [x, i]));\n\n    const longest = new Map();\n    let ans = 0;\n\n    for (let k = 0; k < arr.length; ++k) {\n        for (let j = 0; j < k; ++j) {\n            const i = index.get(arr[k] - arr[j]) || -1;\n            if (i >= 0 && i < j) {\n                longest.set(j * arr.length + k, (longest.get(i * arr.length + j) || 1) + 1);\n                ans = Math.max(ans, longest.get(j * arr.length + k) + 1);\n            }\n        }\n    }\n\n    return ans >= 3 ? ans : 0;\n}\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    "
    },
    {
        "id": 173,
        "title": "Smallest Range I",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `k`.\n\nIn one operation, you can choose any index `i` where `0 <= i < nums.length` and change `nums[i]` to `nums[i] + x` where `x` is an integer from the range `[-k, k]`. You can apply this operation **at most once** for each index `i`.\n\nThe **score** of `nums` is the difference between the maximum and minimum elements in `nums`.\n\nReturn _the minimum **score** of_ `nums` _after applying the mentioned operation at most once for each index in it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1\\], k = 0\n**Output:** 0\n**Explanation:** The score is max(nums) - min(nums) = 1 - 1 = 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,10\\], k = 2\n**Output:** 6\n**Explanation:** Change nums to be \\[2, 8\\]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,3,6\\], k = 3\n**Output:** 0\n**Explanation:** Change nums to be \\[4, 4, 4\\]. The score is max(nums) - min(nums) = 4 - 4 = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 104`\n*   `0 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1],0",
                "output": "0"
            },
            {
                "input": "[0,10],2",
                "output": "6"
            },
            {
                "input": "[1,3,6],3",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode middleNode(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    \n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    return slow;\n}\n```\n    \n    The algorithm uses the tortoise and hare algorithm (slow and fast pointers). The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. Since the fast pointer is moving twice as fast as the slow pointer, when the fast pointer reaches the end of the list, the slow pointer will be in the middle. Thus, we can just return the slow pointer as the middle node. If there are two middle nodes, the slow pointer will be on the second middle node, as specified in the problem statement.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef middleNode(head):\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow\n```\n    \n    The algorithm uses the tortoise and hare algorithm (slow and fast pointers). The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. Since the fast pointer is moving twice as fast as the slow pointer, when the fast pointer reaches the end of the list, the slow pointer will be in the middle. Thus, we can just return the slow pointer as the middle node. If there are two middle nodes, the slow pointer will be on the second middle node, as specified in the problem statement.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* middleNode(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n    \n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return slow;\n}\n```\n    \n    The algorithm uses the tortoise and hare algorithm (slow and fast pointers). The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. Since the fast pointer is moving twice as fast as the slow pointer, when the fast pointer reaches the end of the list, the slow pointer will be in the middle. Thus, we can just return the slow pointer as the middle node. If there are two middle nodes, the slow pointer will be on the second middle node, as specified in the problem statement.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction middleNode(head) {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    return slow;\n}\n```\n    \n    The algorithm uses the tortoise and hare algorithm (slow and fast pointers). The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. Since the fast pointer is moving twice as fast as the slow pointer, when the fast pointer reaches the end of the list, the slow pointer will be in the middle. Thus, we can just return the slow pointer as the middle node. If there are two middle nodes, the slow pointer will be on the second middle node, as specified in the problem statement.\n    "
    },
    {
        "id": 174,
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `deck` where `deck[i]` represents the number written on the `ith` card.\n\nPartition the cards into **one or more groups** such that:\n\n*   Each group has **exactly** `x` cards where `x > 1`, and\n*   All the cards in one group have the same integer written on them.\n\nReturn `true` _if such partition is possible, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** deck = \\[1,2,3,4,4,3,2,1\\]\n**Output:** true\n**Explanation**: Possible partition \\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\].\n\n",
                "**Example 2:**\n\n**Input:** deck = \\[1,1,1,2,2,2,3,3\\]\n**Output:** false\n**Explanation**: No possible partition."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= deck.length <= 104`\n*   `0 <= deck[i] < 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Counting",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[1,2,3,4,4,3,2,1]",
                "output": "true"
            },
            {
                "input": "[1,1,1,2,2,2,3,3]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.Random;\nimport java.util.ArrayList;\n\nclass Solution {\n    private int[][] rects;\n    private ArrayList<Integer> areas;\n    private int totalArea;\n    private Random random;\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        areas = new ArrayList<Integer>();\n        totalArea = 0;\n        for (int[] rect : rects) {\n            int area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);\n            totalArea += area;\n            areas.add(totalArea);\n        }\n        random = new Random();\n    }\n\n    public int[] pick() {\n        int randomArea = random.nextInt(totalArea);\n        int rectIndex = 0;\n        while (areas.get(rectIndex) <= randomArea) {\n            rectIndex++;\n        }\n\n        int x = rects[rectIndex][0] + random.nextInt(rects[rectIndex][2] - rects[rectIndex][0] + 1);\n        int y = rects[rectIndex][1] + random.nextInt(rects[rectIndex][3] - rects[rectIndex][1] + 1);\n\n        return new int[] {x, y};\n    }\n}\n```\n\n    \n    The algorithm starts by initializing the data structures: input rectangles (rects), individual areas (areas), total area (total_area), and random number generator (Random for Python and JavaScript, Random for Java, default_random_engine for C++). For every input rectangle, it calculates its area and updates the areas and total_area.\n\nTo pick a random point inside a rectangle, the algorithm performs the following steps:\n\n1. Generate a random integer (random_area) between 0 and total_area - 1.\n2. Find the index (rect_index) of the first rectangle whose area is greater than the generated random number (this is the selected rectangle).\n3. Generate a random integer (x) between the minimum and maximum x-values of the selected rectangle.\n4. Generate a random integer (y) between the minimum and maximum y-values of the selected rectangle.\n5. Return the generated point [x, y].\n\nThis algorithm ensures that any integer point inside the space covered by one of the given rectangles is equally likely to be returned.\n    ",
        "python": "\n    ```python\nimport random\nfrom bisect import bisect_left\n\nclass Solution:\n    def __init__(self, rects):\n        self.rects = rects\n        self.areas = []\n        self.total_area = 0\n        for rect in rects:\n            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n            self.total_area += area\n            self.areas.append(self.total_area)\n\n    def pick(self):\n        random_area = random.randint(0, self.total_area - 1)\n        rect_index = bisect_left(self.areas, random_area + 1)\n\n        x = random.randint(self.rects[rect_index][0], self.rects[rect_index][2])\n        y = random.randint(self.rects[rect_index][1], self.rects[rect_index][3])\n\n        return [x, y]\n```\n\n    \n    The algorithm starts by initializing the data structures: input rectangles (rects), individual areas (areas), total area (total_area), and random number generator (Random for Python and JavaScript, Random for Java, default_random_engine for C++). For every input rectangle, it calculates its area and updates the areas and total_area.\n\nTo pick a random point inside a rectangle, the algorithm performs the following steps:\n\n1. Generate a random integer (random_area) between 0 and total_area - 1.\n2. Find the index (rect_index) of the first rectangle whose area is greater than the generated random number (this is the selected rectangle).\n3. Generate a random integer (x) between the minimum and maximum x-values of the selected rectangle.\n4. Generate a random integer (y) between the minimum and maximum y-values of the selected rectangle.\n5. Return the generated point [x, y].\n\nThis algorithm ensures that any integer point inside the space covered by one of the given rectangles is equally likely to be returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> rects;\n    std::vector<int> areas;\n    int total_area;\n    std::default_random_engine generator;\n\n    Solution(std::vector<std::vector<int>>& rectangles) {\n        rects = rectangles;\n        total_area = 0;\n        for (const auto& rect : rects) {\n            int area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);\n            total_area += area;\n            areas.push_back(total_area);\n        }\n    }\n\n    std::vector<int> pick() {\n        std::uniform_int_distribution<int> area_distribution(0, total_area - 1);\n        int random_area = area_distribution(generator);\n        int rect_index = std::lower_bound(areas.begin(), areas.end(), random_area + 1) - areas.begin();\n\n        std::uniform_int_distribution<int> x_distribution(rects[rect_index][0], rects[rect_index][2]);\n        std::uniform_int_distribution<int> y_distribution(rects[rect_index][1], rects[rect_index][3]);\n\n        int x = x_distribution(generator);\n        int y = y_distribution(generator);\n\n        return {x, y};\n    }\n};\n```\n\n    \n    The algorithm starts by initializing the data structures: input rectangles (rects), individual areas (areas), total area (total_area), and random number generator (Random for Python and JavaScript, Random for Java, default_random_engine for C++). For every input rectangle, it calculates its area and updates the areas and total_area.\n\nTo pick a random point inside a rectangle, the algorithm performs the following steps:\n\n1. Generate a random integer (random_area) between 0 and total_area - 1.\n2. Find the index (rect_index) of the first rectangle whose area is greater than the generated random number (this is the selected rectangle).\n3. Generate a random integer (x) between the minimum and maximum x-values of the selected rectangle.\n4. Generate a random integer (y) between the minimum and maximum y-values of the selected rectangle.\n5. Return the generated point [x, y].\n\nThis algorithm ensures that any integer point inside the space covered by one of the given rectangles is equally likely to be returned.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    constructor(rects) {\n        this.rects = rects;\n        this.totalArea = 0;\n        this.areas = new Array(rects.length);\n\n        for (let i = 0; i < rects.length; i++) {\n            let area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);\n            this.totalArea += area;\n            this.areas[i] = this.totalArea;\n        }\n    }\n\n    pick() {\n        let randomArea = Math.floor(Math.random() * this.totalArea);\n        let rectIndex = 0;\n        while (this.areas[rectIndex] <= randomArea) {\n            rectIndex++;\n        }\n\n        let x = this.rects[rectIndex][0] + Math.floor(Math.random() * (this.rects[rectIndex][2] - this.rects[rectIndex][0] + 1));\n        let y = this.rects[rectIndex][1] + Math.floor(Math.random() * (this.rects[rectIndex][3] - this.rects[rectIndex][1] + 1));\n\n        return [x, y];\n    }\n}\n```\n\n    \n    The algorithm starts by initializing the data structures: input rectangles (rects), individual areas (areas), total area (total_area), and random number generator (Random for Python and JavaScript, Random for Java, default_random_engine for C++). For every input rectangle, it calculates its area and updates the areas and total_area.\n\nTo pick a random point inside a rectangle, the algorithm performs the following steps:\n\n1. Generate a random integer (random_area) between 0 and total_area - 1.\n2. Find the index (rect_index) of the first rectangle whose area is greater than the generated random number (this is the selected rectangle).\n3. Generate a random integer (x) between the minimum and maximum x-values of the selected rectangle.\n4. Generate a random integer (y) between the minimum and maximum y-values of the selected rectangle.\n5. Return the generated point [x, y].\n\nThis algorithm ensures that any integer point inside the space covered by one of the given rectangles is equally likely to be returned.\n    "
    },
    {
        "id": 175,
        "title": "Reverse Only Letters",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse the string according to the following rules:\n\n*   All the characters that are not English letters remain in the same position.\n*   All the English letters (lowercase or uppercase) should be reversed.\n\nReturn `s` _after reversing it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"ab-cd\"\n**Output:** \"dc-ba\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"a-bC-dEf-ghIj\"\n**Output:** \"j-Ih-gfE-dCba\"\n\n",
                "**Example 3:**\n\n**Input:** s = \"Test1ng-Leet=code-Q!\"\n**Output:** \"Qedo1ct-eeLg=ntse-T!\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of characters with ASCII values in the range `[33, 122]`.\n*   `s` does not contain `'\\ \"'` or `'\\\\'`.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"ab-cd\"",
                "output": "\"dc-ba\""
            },
            {
                "input": "\"a-bC-dEf-ghIj\"",
                "output": "\"j-Ih-gfE-dCba\""
            },
            {
                "input": "\"Test1ng-Leet=code-Q!\"",
                "output": "\"Qedo1ct-eeLg=ntse-T!\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int numRescueBoats(int[] people, int limit) {\n    Arrays.sort(people);\n    int left = 0, right = people.length - 1;\n    int boats = 0;\n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    return boats;\n}\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "python": "\n    ```python\ndef num_rescue_boats(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint numRescueBoats(std::vector<int>& people, int limit) {\n    std::sort(people.begin(), people.end());\n    int left = 0, right = people.size() - 1;\n    int boats = 0;\n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    return boats;\n}\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "js": "\n    ```javascript\nfunction numRescueBoats(people, limit) {\n    people.sort((a, b) => a - b);\n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    return boats;\n}\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    "
    },
    {
        "id": 176,
        "title": "Sort Array By Parity II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, half of the integers in `nums` are **odd**, and the other half are **even**.\n\nSort the array so that whenever `nums[i]` is odd, `i` is **odd**, and whenever `nums[i]` is even, `i` is **even**.\n\nReturn _any answer array that satisfies this condition_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,5,7\\]\n**Output:** \\[4,5,2,7\\]\n**Explanation:** \\[4,7,2,5\\], \\[2,5,4,7\\], \\[2,7,4,5\\] would also have been accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3\\]\n**Output:** \\[2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 2 * 104`\n*   `nums.length` is even.\n*   Half of the integers in `nums` are even.\n*   `0 <= nums[i] <= 1000`\n\n**",
            "follow_up": "Follow Up:** Could you solve it in-place?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,2,5,7]",
                "output": "[4,5,2,7]"
            },
            {
                "input": "[2,3]",
                "output": "[2,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] groups = new int[n + 1];\n        List<List<Integer>> dislikeList = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            dislikeList.add(new ArrayList<>());\n        }\n        for (int[] dislikePair : dislikes) {\n            dislikeList.get(dislikePair[0]).add(dislikePair[1]);\n            dislikeList.get(dislikePair[1]).add(dislikePair[0]);\n        }\n        for (int person = 1; person <= n; person++) {\n            if (groups[person] == 0 && !dfs(person, 1, groups, dislikeList)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private boolean dfs(int person, int group, int[] groups, List<List<Integer>> dislikeList) {\n        if (groups[person] != 0) {\n            return groups[person] == group;\n        }\n        groups[person] = group;\n        for (int other : dislikeList.get(person)) {\n            if (!dfs(other, -group, groups, dislikeList)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n    \n    The problem can be modeled as a graph where each person is a node and dislikes are edges between nodes. We need to color the graph using two colors (or groups) such that if there is an edge between the nodes, they must have different colors. This is possible if and only if the graph is bipartite. \n\nWe can use Depth First Search (DFS) to check if the graph is bipartite. Start with an uncolored node, color it with group 1, and move to its neighbors. Each neighbor gets the opposite color (group) of the current node. If we find a node that has already been colored and it has the same color as the current node, then the graph is not bipartite, and we return false. If all nodes are successfully colored, the graph is bipartite, and we return true. The time complexity is O(n + e), where n is the number of nodes (people) and e is the number of edges (dislikes).\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\n\ndef possible_bipartition(n, dislikes):\n    def dfs(person, group):\n        if person in groups:\n            return groups[person] == group\n        groups[person] = group\n        for other in dislike_list[person]:\n            if not dfs(other, -group):\n                return False\n        return True\n\n    groups = {}\n    dislike_list = defaultdict(list)\n    for p1, p2 in dislikes:\n        dislike_list[p1].append(p2)\n        dislike_list[p2].append(p1)\n\n    for person in range(1, n + 1):\n        if person not in groups and not dfs(person, 1):\n            return False\n\n    return True\n```\n\n    \n    The problem can be modeled as a graph where each person is a node and dislikes are edges between nodes. We need to color the graph using two colors (or groups) such that if there is an edge between the nodes, they must have different colors. This is possible if and only if the graph is bipartite. \n\nWe can use Depth First Search (DFS) to check if the graph is bipartite. Start with an uncolored node, color it with group 1, and move to its neighbors. Each neighbor gets the opposite color (group) of the current node. If we find a node that has already been colored and it has the same color as the current node, then the graph is not bipartite, and we return false. If all nodes are successfully colored, the graph is bipartite, and we return true. The time complexity is O(n + e), where n is the number of nodes (people) and e is the number of edges (dislikes).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool dfs(int person, int group, vector<int> &groups, vector<vector<int>> &dislikeList) {\n    if (groups[person] != 0) {\n        return groups[person] == group;\n    }\n    groups[person] = group;\n    for (int other : dislikeList[person]) {\n        if (!dfs(other, -group, groups, dislikeList)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool possible_bipartition(int n, vector<vector<int>> &dislikes) {\n    vector<int> groups(n + 1, 0);\n    vector<vector<int>> dislikeList(n + 1);\n\n    for (auto &dislikePair : dislikes) {\n        dislikeList[dislikePair[0]].push_back(dislikePair[1]);\n        dislikeList[dislikePair[1]].push_back(dislikePair[0]);\n    }\n\n    for (int person = 1; person <= n; person++) {\n        if (groups[person] == 0 && !dfs(person, 1, groups, dislikeList)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    The problem can be modeled as a graph where each person is a node and dislikes are edges between nodes. We need to color the graph using two colors (or groups) such that if there is an edge between the nodes, they must have different colors. This is possible if and only if the graph is bipartite. \n\nWe can use Depth First Search (DFS) to check if the graph is bipartite. Start with an uncolored node, color it with group 1, and move to its neighbors. Each neighbor gets the opposite color (group) of the current node. If we find a node that has already been colored and it has the same color as the current node, then the graph is not bipartite, and we return false. If all nodes are successfully colored, the graph is bipartite, and we return true. The time complexity is O(n + e), where n is the number of nodes (people) and e is the number of edges (dislikes).\n    ",
        "js": "\n    ```javascript\nfunction possibleBipartition(n, dislikes) {\n    function dfs(person, group) {\n        if (groups[person] !== undefined) {\n            return groups[person] === group;\n        }\n        groups[person] = group;\n        for (let other of dislikeList[person]) {\n            if (!dfs(other, -group)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    const groups = {};\n    const dislikeList = Array.from({ length: n + 1 }, () => []);\n    for (let [p1, p2] of dislikes) {\n        dislikeList[p1].push(p2);\n        dislikeList[p2].push(p1);\n    }\n\n    for (let person = 1; person <= n; person++) {\n        if (groups[person] === undefined && !dfs(person, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    The problem can be modeled as a graph where each person is a node and dislikes are edges between nodes. We need to color the graph using two colors (or groups) such that if there is an edge between the nodes, they must have different colors. This is possible if and only if the graph is bipartite. \n\nWe can use Depth First Search (DFS) to check if the graph is bipartite. Start with an uncolored node, color it with group 1, and move to its neighbors. Each neighbor gets the opposite color (group) of the current node. If we find a node that has already been colored and it has the same color as the current node, then the graph is not bipartite, and we return false. If all nodes are successfully colored, the graph is bipartite, and we return true. The time complexity is O(n + e), where n is the number of nodes (people) and e is the number of edges (dislikes).\n    "
    },
    {
        "id": 177,
        "title": "Long Pressed Name",
        "difficulty": "Easy",
        "content": {
            "problem": "Your friend is typing his `name` into a keyboard. Sometimes, when typing a character `c`, the key might get _long pressed_, and the character will be typed 1 or more times.\n\nYou examine the `typed` characters of the keyboard. Return `True` if it is possible that it was your friends name, with some characters (possibly none) being long pressed.",
            "examples": [
                "**Example 1:**\n\n**Input:** name =  \"alex \", typed =  \"aaleex \"\n**Output:** true\n**Explanation:** 'a' and 'e' in 'alex' were long pressed.\n\n",
                "**Example 2:**\n\n**Input:** name =  \"saeed \", typed =  \"ssaaedd \"\n**Output:** false\n**Explanation:** 'e' must have been pressed twice, but it was not in the typed output."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= name.length, typed.length <= 1000`\n*   `name` and `typed` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"alex\",\"aaleex\"",
                "output": "true"
            },
            {
                "input": "\"saeed\",\"ssaaedd\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\n        return buildTree(pre, 0, pre.length, post, 0, post.length);\n    }\n\n    private TreeNode buildTree(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {\n        if (preStart == preEnd) return null;\n\n        TreeNode root = new TreeNode(pre[preStart]);\n\n        if (preStart + 1 == preEnd) return root;\n\n        int leftRoot = pre[preStart + 1];\n\n        int leftSize = 0;\n        for (int i = postStart; i < postEnd; ++i) {\n            if (post[i] == leftRoot) {\n                leftSize = i - postStart + 1;\n                break;\n            }\n        }\n\n        root.left = buildTree(pre, preStart + 1, preStart + 1 + leftSize, post, postStart, postStart + leftSize);\n        root.right = buildTree(pre, preStart + 1 + leftSize, preEnd, post, postStart + leftSize, postEnd - 1);\n\n        return root;\n    }\n}\n```\n    \n    The reconstruction of binary tree can be done using a divide-and-conquer strategy.\n\n1. The first element of the preorder array is the root node.\n2. The second element of the preorder array is the root of the left subtree.\n3. Find the index of the left subtree root in the postorder array. The left subtree size can be calculated as `index - postStart + 1`.\n4. The left subtree ranges can be found using `preStart + 1` and `preStart + 1 + leftSize` in the preorder array, `postStart` and `postStart + leftSize` in the postorder array.\n5. The right subtree ranges can be found with `preStart + 1 + leftSize` and `preEnd` in the preorder array, `postStart + leftSize` and `postEnd - 1` in the postorder array.\n6. Recursively build the left subtree and right subtree with the calculated ranges.\n7. Connect the left subtree and right subtree to the current root node.\n\nThe overall time complexity is O(N^2) due to finding the index of the left subtree root. The space complexity is O(N) because of the recursion stack.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def constructFromPrePost(self, pre, post):\n        def buildTree(preStart, preEnd, postStart, postEnd):\n            if preStart == preEnd:\n                return None\n\n            root = TreeNode(pre[preStart])\n\n            if preStart + 1 == preEnd:\n                return root\n\n            leftRoot = pre[preStart + 1]\n\n            leftSize = 0\n            for i in range(postStart, postEnd):\n                if post[i] == leftRoot:\n                    leftSize = i - postStart + 1\n                    break\n\n            root.left = buildTree(preStart + 1, preStart + 1 + leftSize, postStart, postStart + leftSize)\n            root.right = buildTree(preStart + 1 + leftSize, preEnd, postStart + leftSize, postEnd - 1)\n\n            return root\n\n        return buildTree(0, len(pre), 0, len(post))\n```\n    \n    The reconstruction of binary tree can be done using a divide-and-conquer strategy.\n\n1. The first element of the preorder array is the root node.\n2. The second element of the preorder array is the root of the left subtree.\n3. Find the index of the left subtree root in the postorder array. The left subtree size can be calculated as `index - postStart + 1`.\n4. The left subtree ranges can be found using `preStart + 1` and `preStart + 1 + leftSize` in the preorder array, `postStart` and `postStart + leftSize` in the postorder array.\n5. The right subtree ranges can be found with `preStart + 1 + leftSize` and `preEnd` in the preorder array, `postStart + leftSize` and `postEnd - 1` in the postorder array.\n6. Recursively build the left subtree and right subtree with the calculated ranges.\n7. Connect the left subtree and right subtree to the current root node.\n\nThe overall time complexity is O(N^2) due to finding the index of the left subtree root. The space complexity is O(N) because of the recursion stack.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\n        return buildTree(preorder, 0, preorder.size(), postorder, 0, postorder.size());\n    }\n\n    TreeNode* buildTree(vector<int>& pre, int preStart, int preEnd, vector<int>& post, int postStart, int postEnd) {\n        if (preStart == preEnd) return nullptr;\n\n        TreeNode* root = new TreeNode(pre[preStart]);\n\n        if (preStart + 1 == preEnd) return root;\n\n        int leftRoot = pre[preStart + 1];\n\n        int leftSize = 0;\n        for (int i = postStart; i < postEnd; ++i) {\n            if (post[i] == leftRoot) {\n                leftSize = i - postStart + 1;\n                break;\n            }\n        }\n\n        root->left = buildTree(pre, preStart + 1, preStart + 1 + leftSize, post, postStart, postStart + leftSize);\n        root->right = buildTree(pre, preStart + 1 + leftSize, preEnd, post, postStart + leftSize, postEnd - 1);\n\n        return root;\n    }\n};\n```\n    \n    The reconstruction of binary tree can be done using a divide-and-conquer strategy.\n\n1. The first element of the preorder array is the root node.\n2. The second element of the preorder array is the root of the left subtree.\n3. Find the index of the left subtree root in the postorder array. The left subtree size can be calculated as `index - postStart + 1`.\n4. The left subtree ranges can be found using `preStart + 1` and `preStart + 1 + leftSize` in the preorder array, `postStart` and `postStart + leftSize` in the postorder array.\n5. The right subtree ranges can be found with `preStart + 1 + leftSize` and `preEnd` in the preorder array, `postStart + leftSize` and `postEnd - 1` in the postorder array.\n6. Recursively build the left subtree and right subtree with the calculated ranges.\n7. Connect the left subtree and right subtree to the current root node.\n\nThe overall time complexity is O(N^2) due to finding the index of the left subtree root. The space complexity is O(N) because of the recursion stack.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction constructFromPrePost(pre, post) {\n    function buildTree(preStart, preEnd, postStart, postEnd) {\n        if (preStart === preEnd) return null;\n\n        let root = new TreeNode(pre[preStart]);\n\n        if (preStart + 1 === preEnd) return root;\n\n        let leftRoot = pre[preStart + 1];\n\n        let leftSize = 0;\n        for (let i = postStart; i < postEnd; ++i) {\n            if (post[i] === leftRoot) {\n                leftSize = i - postStart + 1;\n                break;\n            }\n        }\n\n        root.left = buildTree(preStart + 1, preStart + 1 + leftSize, postStart, postStart + leftSize);\n        root.right = buildTree(preStart + 1 + leftSize, preEnd, postStart + leftSize, postEnd - 1);\n\n        return root;\n    }\n\n    return buildTree(0, pre.length, 0, post.length);\n}\n```\n    \n    The reconstruction of binary tree can be done using a divide-and-conquer strategy.\n\n1. The first element of the preorder array is the root node.\n2. The second element of the preorder array is the root of the left subtree.\n3. Find the index of the left subtree root in the postorder array. The left subtree size can be calculated as `index - postStart + 1`.\n4. The left subtree ranges can be found using `preStart + 1` and `preStart + 1 + leftSize` in the preorder array, `postStart` and `postStart + leftSize` in the postorder array.\n5. The right subtree ranges can be found with `preStart + 1 + leftSize` and `preEnd` in the preorder array, `postStart + leftSize` and `postEnd - 1` in the postorder array.\n6. Recursively build the left subtree and right subtree with the calculated ranges.\n7. Connect the left subtree and right subtree to the current root node.\n\nThe overall time complexity is O(N^2) due to finding the index of the left subtree root. The space complexity is O(N) because of the recursion stack.\n    "
    },
    {
        "id": 178,
        "title": "Unique Email Addresses",
        "difficulty": "Easy",
        "content": {
            "problem": "Every **valid email** consists of a **local name** and a **domain name**, separated by the `'@'` sign. Besides lowercase letters, the email may contain one or more `'.'` or `'+'`.\n\n*   For example, in `\"alice@leetcode.com \"`, `\"alice \"` is the **local name**, and `\"leetcode.com \"` is the **domain name**.\n\nIf you add periods `'.'` between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule **does not apply** to **domain names**.\n\n*   For example, `\"alice.z@leetcode.com \"` and `\"alicez@leetcode.com \"` forward to the same email address.\n\nIf you add a plus `'+'` in the **local name**, everything after the first plus sign **will be ignored**. This allows certain emails to be filtered. Note that this rule **does not apply** to **domain names**.\n\n*   For example, `\"m.y+name@email.com \"` will be forwarded to `\"my@email.com \"`.\n\nIt is possible to use both of these rules at the same time.\n\nGiven an array of strings `emails` where we send one email to each `emails[i]`, return _the number of different addresses that actually receive mails_.",
            "examples": [
                "**Example 1:**\n\n**Input:** emails = \\[ \"test.email+alex@leetcode.com \", \"test.e.mail+bob.cathy@leetcode.com \", \"testemail+david@lee.tcode.com \"\\]\n**Output:** 2\n**Explanation:**  \"testemail@leetcode.com \" and  \"testemail@lee.tcode.com \" actually receive mails.\n\n",
                "**Example 2:**\n\n**Input:** emails = \\[ \"a@leetcode.com \", \"b@leetcode.com \", \"c@leetcode.com \"\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= emails.length <= 100`\n*   `1 <= emails[i].length <= 100`\n*   `emails[i]` consist of lowercase English letters, `'+'`, `'.'` and `'@'`.\n*   Each `emails[i]` contains exactly one `'@'` character.\n*   All local and domain names are non-empty.\n*   Local names do not start with a `'+'` character.\n*   Domain names end with the `\".com \"` suffix.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]",
                "output": "2"
            },
            {
                "input": "[\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Arrays;\n\npublic int numSpecialEquivalentGroups(String[] words) {\n    Set<String> groups = new HashSet<>();\n\n    for (String word : words) {\n        StringBuilder evens = new StringBuilder();\n        StringBuilder odds = new StringBuilder();\n\n        for (int i = 0; i < word.length(); ++i) {\n            if (i % 2 == 0) evens.append(word.charAt(i));\n            else odds.append(word.charAt(i));\n        }\n\n        char[] evenArr = evens.toString().toCharArray();\n        Arrays.sort(evenArr);\n        char[] oddArr = odds.toString().toCharArray();\n        Arrays.sort(oddArr);\n\n        groups.add(new String(evenArr) + new String(oddArr));\n    }\n\n    return groups.size();\n}\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "python": "\n    ```python\ndef num_special_equivalent_groups(words):\n    groups = set()\n\n    for word in words:\n        evens = \"\".join(sorted(word[0::2]))\n        odds = \"\".join(sorted(word[1::2]))\n\n        groups.add(evens + odds)\n\n    return len(groups)\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nint numSpecialEquivalentGroups(std::vector<std::string>& words) {\n    std::unordered_set<std::string> groups;\n\n    for (std::string word : words) {\n        std::string evens, odds;\n\n        for (size_t i = 0; i < word.size(); ++i) {\n            if (i % 2 == 0) evens += word[i];\n            else odds += word[i];\n        }\n\n        std::sort(evens.begin(), evens.end());\n        std::sort(odds.begin(), odds.end());\n\n        groups.insert(evens + odds);\n    }\n\n    return groups.size();\n}\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "js": "\n    ```javascript\nfunction numSpecialEquivalentGroups(words) {\n    const groups = new Set();\n\n    for (const word of words) {\n        let evens = \"\";\n        let odds = \"\";\n\n        for (let i = 0; i < word.length; ++i) {\n            if (i % 2 === 0) evens += word[i];\n            else odds += word[i];\n        }\n\n        evens = evens.split(\"\").sort().join(\"\");\n        odds = odds.split(\"\").sort().join(\"\");\n\n        groups.add(evens + odds);\n    }\n\n    return groups.size;\n}\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    "
    },
    {
        "id": 179,
        "title": "Number of Recent Calls",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a `RecentCounter` class which counts the number of recent requests within a certain time frame.\n\nImplement the `RecentCounter` class:\n\n*   `RecentCounter()` Initializes the counter with zero recent requests.\n*   `int ping(int t)` Adds a new request at time `t`, where `t` represents some time in milliseconds, and returns the number of requests that has happened in the past `3000` milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range `[t - 3000, t]`.\n\nIt is **guaranteed** that every call to `ping` uses a strictly larger value of `t` than the previous call.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"RecentCounter \",  \"ping \",  \"ping \",  \"ping \",  \"ping \"\\]\n\\[\\[\\], \\[1\\], \\[100\\], \\[3001\\], \\[3002\\]\\]\n**Output**\n\\[null, 1, 2, 3, 3\\]\n\n**Explanation**\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = \\[1\\], range is \\[-2999,1\\], return 1\nrecentCounter.ping(100);   // requests = \\[1, 100\\], range is \\[-2900,100\\], return 2\nrecentCounter.ping(3001);  // requests = \\[1, 100, 3001\\], range is \\[1,3001\\], return 3\nrecentCounter.ping(3002);  // requests = \\[1, 100, 3001, 3002\\], range is \\[2,3002\\], return 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= t <= 109`\n*   Each test case will call `ping` with **strictly increasing** values of `t`.\n*   At most `104` calls will be made to `ping`.",
            "follow_up": null
        },
        "tag": [
            "Design",
            "Queue",
            "Data Stream"
        ],
        "example": [
            {
                "input": "]\n],],],],]]",
                "output": "**Output**\n[null,1,2,3,3]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic TreeNode increasingBST(TreeNode root) {\n    TreeNode dummy = new TreeNode(0);\n    TreeNode prev = dummy;\n    inorder(root, prev);\n    return dummy.right;\n}\n\npublic void inorder(TreeNode node, TreeNode prev) {\n    if (node == null) return;\n\n    inorder(node.left, prev);\n    prev.right = node;\n    prev = node;\n    node.left = null;\n    inorder(node.right, prev);\n}\n```\n\n    \n    The algorithm uses a recursive inorder traversal of the given binary search tree. It starts by visiting the left child, if any, and then processes the root node, and finally the right child. The important part of this traversal is the processing of each node. When a node is encountered, its left pointer is set to null and its right pointer is set to the current node being processed.\n\nThe algorithm maintains a `prev` variable to keep the previous node encountered during the inorder traversal. Initially, we have a dummy node, and during the traversal, we set the right pointer of the `prev` node to the current node and update the `prev` node to the current node.\n\nFinally, after the traversal, the right child of the dummy node points to the root of the modified tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef increasingBST(root):\n    def inorder(node):\n        nonlocal prev\n        if not node: return\n\n        inorder(node.left)\n        prev.right = node\n        prev = node\n        node.left = None\n        inorder(node.right)\n\n    dummy = TreeNode(0)\n    prev = dummy\n    inorder(root)\n    return dummy.right\n```\n\n    \n    The algorithm uses a recursive inorder traversal of the given binary search tree. It starts by visiting the left child, if any, and then processes the root node, and finally the right child. The important part of this traversal is the processing of each node. When a node is encountered, its left pointer is set to null and its right pointer is set to the current node being processed.\n\nThe algorithm maintains a `prev` variable to keep the previous node encountered during the inorder traversal. Initially, we have a dummy node, and during the traversal, we set the right pointer of the `prev` node to the current node and update the `prev` node to the current node.\n\nFinally, after the traversal, the right child of the dummy node points to the root of the modified tree.\n    ",
        "c++": "\n    ```cpp\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nvoid inorder(TreeNode* node, TreeNode*& prev) {\n    if (node == nullptr) return;\n\n    inorder(node->left, prev);\n    prev->right = node;\n    prev = node;\n    node->left = nullptr;\n    inorder(node->right, prev);\n}\n\nTreeNode* increasingBST(TreeNode* root) {\n    TreeNode dummy(0);\n    TreeNode* prev = &dummy;\n    inorder(root, prev);\n    return dummy.right;\n}\n```\n\n    \n    The algorithm uses a recursive inorder traversal of the given binary search tree. It starts by visiting the left child, if any, and then processes the root node, and finally the right child. The important part of this traversal is the processing of each node. When a node is encountered, its left pointer is set to null and its right pointer is set to the current node being processed.\n\nThe algorithm maintains a `prev` variable to keep the previous node encountered during the inorder traversal. Initially, we have a dummy node, and during the traversal, we set the right pointer of the `prev` node to the current node and update the `prev` node to the current node.\n\nFinally, after the traversal, the right child of the dummy node points to the root of the modified tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction increasingBST(root) {\n    function inorder(node) {\n        if (!node) return;\n\n        inorder(node.left);\n        prev.right = node;\n        prev = node;\n        node.left = null;\n        inorder(node.right);\n    }\n\n    const dummy = new TreeNode(0);\n    let prev = dummy;\n    inorder(root);\n    return dummy.right;\n}\n```\n\n    \n    The algorithm uses a recursive inorder traversal of the given binary search tree. It starts by visiting the left child, if any, and then processes the root node, and finally the right child. The important part of this traversal is the processing of each node. When a node is encountered, its left pointer is set to null and its right pointer is set to the current node being processed.\n\nThe algorithm maintains a `prev` variable to keep the previous node encountered during the inorder traversal. Initially, we have a dummy node, and during the traversal, we set the right pointer of the `prev` node to the current node and update the `prev` node to the current node.\n\nFinally, after the traversal, the right child of the dummy node points to the root of the modified tree.\n    "
    },
    {
        "id": 180,
        "title": "Range Sum of BST",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` node of a binary search tree and two integers `low` and `high`, return _the sum of values of all nodes with a value in the **inclusive** range_ `[low, high]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[10,5,15,3,7,null,18\\], low = 7, high = 15\n**Output:** 32\n**Explanation:** Nodes 7, 10, and 15 are in the range \\[7, 15\\]. 7 + 10 + 15 = 32.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[10,5,15,3,7,13,18,1,null,6\\], low = 6, high = 10\n**Output:** 23\n**Explanation:** Nodes 6, 7, and 10 are in the range \\[6, 10\\]. 6 + 7 + 10 = 23."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 2 * 104]`.\n*   `1 <= Node.val <= 105`\n*   `1 <= low <= high <= 105`\n*   All `Node.val` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[10,5,15,3,7,null,18],7,15",
                "output": "32"
            },
            {
                "input": "[10,5,15,3,7,13,18,1,null,6],6,10",
                "output": "23"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int numDigitsLessThanN(int[] digits, int n) {\n    int ans = 0, factor = 1;\n    String nStr = Integer.toString(n);\n    for (int i = nStr.length() - 1; i >= 0; --i) {\n        ans += (Arrays.binarySearch(digits, nStr.charAt(i) - '0') + 1) * factor;\n        factor *= digits.length;\n    }\n    return ans;\n}\n```\n    \n    1. Initialize the answer as 0 and a factor as 1.\n2. Convert n into a string so that we can traverse each digit easily.\n3. Iterate over the digits of n from right to left.\n4. For each digit, find the number of digits less than or equal to the current digit of n using binary search, and add this number multiplied by the current factor to the answer.\n5. Multiply the factor by the number of given digits for every iteration to account for the combinations of smaller digits.\n6. Return the answer after all iterations.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_right\n\ndef num_digits_less_than_n(digits: List[int], n: int) -> int:\n    ans = 0\n    factor = 1\n    n_str = str(n)\n    for i in range(len(n_str) - 1, -1, -1):\n        ans += bisect_right(digits, int(n_str[i])) * factor\n        factor *= len(digits)\n    return ans\n```\n    \n    1. Initialize the answer as 0 and a factor as 1.\n2. Convert n into a string so that we can traverse each digit easily.\n3. Iterate over the digits of n from right to left.\n4. For each digit, find the number of digits less than or equal to the current digit of n using binary search, and add this number multiplied by the current factor to the answer.\n5. Multiply the factor by the number of given digits for every iteration to account for the combinations of smaller digits.\n6. Return the answer after all iterations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint num_digits_less_than_n(vector<int>& digits, int n) {\n    int ans = 0, factor = 1;\n    string n_str = to_string(n);\n    for (int i = n_str.size() - 1; i >= 0; --i) {\n        ans += (upper_bound(digits.begin(), digits.end(), n_str[i] - '0') - digits.begin()) * factor;\n        factor *= digits.size();\n    }\n    return ans;\n}\n```\n    \n    1. Initialize the answer as 0 and a factor as 1.\n2. Convert n into a string so that we can traverse each digit easily.\n3. Iterate over the digits of n from right to left.\n4. For each digit, find the number of digits less than or equal to the current digit of n using binary search, and add this number multiplied by the current factor to the answer.\n5. Multiply the factor by the number of given digits for every iteration to account for the combinations of smaller digits.\n6. Return the answer after all iterations.\n    ",
        "js": "\n    ```javascript\nfunction numDigitsLessThanN(digits, n) {\n    let ans = 0, factor = 1;\n    let nStr = String(n);\n    for (let i = nStr.length - 1; i >= 0; --i) {\n        ans += (upperBound(digits, nStr.charCodeAt(i) - 48)) * factor;\n        factor *= digits.length;\n    }\n    return ans;\n}\n\nfunction upperBound(arr, target) {\n    let low = 0, high = arr.length;\n    while (low < high) {\n        let mid = Math.floor((low + high) / 2);\n        if (arr[mid] > target) high = mid;\n        else low = mid + 1;\n    }\n    return low;\n}\n```\n    \n    1. Initialize the answer as 0 and a factor as 1.\n2. Convert n into a string so that we can traverse each digit easily.\n3. Iterate over the digits of n from right to left.\n4. For each digit, find the number of digits less than or equal to the current digit of n using binary search, and add this number multiplied by the current factor to the answer.\n5. Multiply the factor by the number of given digits for every iteration to account for the combinations of smaller digits.\n6. Return the answer after all iterations.\n    "
    },
    {
        "id": 181,
        "title": "Valid Mountain Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, return _`true` if and only if it is a valid mountain array_.\n\nRecall that arr is a mountain array if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,1\\]\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[3,5,5\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[0,3,2,1\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[2,1]",
                "output": "false"
            },
            {
                "input": "[3,5,5]",
                "output": "false"
            },
            {
                "input": "[0,3,2,1]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic void moveEvenOdd(int[] nums) {\n    int evenIndex = 0;\n    int oddIndex = nums.length - 1;\n\n    while (evenIndex < oddIndex) {\n        if (nums[evenIndex] % 2 == 0) {\n            evenIndex++;\n        } else {\n            int temp = nums[evenIndex];\n            nums[evenIndex] = nums[oddIndex];\n            nums[oddIndex] = temp;\n            oddIndex--;\n        }\n    }\n}\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "python": "\n    ```python\ndef move_even_odd(nums):\n    even_index = 0\n    odd_index = len(nums) - 1\n\n    while even_index < odd_index:\n        if nums[even_index] % 2 == 0:\n            even_index += 1\n        else:\n            nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]\n            odd_index -= 1\n\n    return nums\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid moveEvenOdd(vector<int>& nums) {\n    int evenIndex = 0;\n    int oddIndex = nums.size() - 1;\n\n    while (evenIndex < oddIndex) {\n        if (nums[evenIndex] % 2 == 0) {\n            evenIndex++;\n        } else {\n            swap(nums[evenIndex], nums[oddIndex]);\n            oddIndex--;\n        }\n    }\n}\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "js": "\n    ```javascript\nfunction moveEvenOdd(nums) {\n    let evenIndex = 0;\n    let oddIndex = nums.length - 1;\n\n    while (evenIndex < oddIndex) {\n        if (nums[evenIndex] % 2 === 0) {\n            evenIndex++;\n        } else {\n            [nums[evenIndex], nums[oddIndex]] = [nums[oddIndex], nums[evenIndex]];\n            oddIndex--;\n        }\n    }\n}\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    "
    },
    {
        "id": 182,
        "title": "DI String Match",
        "difficulty": "Easy",
        "content": {
            "problem": "A permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` can be represented as a string `s` of length `n` where:\n\n*   `s[i] == 'I'` if `perm[i] < perm[i + 1]`, and\n*   `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s`, reconstruct the permutation `perm` and return it. If there are multiple valid permutations perm, return **any of them**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"IDID\"\n**Output:** \\[0,4,1,3,2\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \"III\"\n**Output:** \\[0,1,2,3\\]\n\n",
                "**Example 3:**\n\n**Input:** s = \"DDI\"\n**Output:** \\[3,2,0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'I'` or `'D'`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"IDID\"",
                "output": "[0,4,1,3,2]"
            },
            {
                "input": "\"III\"",
                "output": "[0,1,2,3]"
            },
            {
                "input": "\"DDI\"",
                "output": "[3,2,0,1]"
            }
        ],
        "java": "\n    ```java\nboolean isPalindrome(long num) {\n    String str = Long.toString(num);\n    String revStr = new StringBuilder(str).reverse().toString();\n    return str.equals(revStr);\n}\n\nint superpalindromesInRange(String left, String right) {\n    long l = Long.parseLong(left);\n    long r = Long.parseLong(right);\n    int cnt = 0;\n    for (long base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "python": "\n    ```python\ndef isPalindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef superpalindromesInRange(left: str, right: str) -> int:\n    l = int(left)\n    r = int(right)\n    cnt = 0\n    base = 1\n    while base * base <= r:\n        if isPalindrome(base) and isPalindrome(base * base):\n            if base * base >= l:\n                cnt += 1\n        base += 1\n    return cnt\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "c++": "\n    ```cpp\nbool isPalindrome(long num) {\n    string str = to_string(num);\n    string revStr = str;\n    reverse(revStr.begin(), revStr.end());\n    return str == revStr;\n}\n\nint superpalindromesInRange(string left, string right) {\n    long l = stol(left);\n    long r = stol(right);\n    int cnt = 0;\n    for (long base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(num) {\n    const str = num.toString();\n    const revStr = str.split('').reverse().join('');\n    return str === revStr;\n}\n\nfunction superpalindromesInRange(left, right) {\n    const l = parseInt(left);\n    const r = parseInt(right);\n    let cnt = 0;\n    for (let base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    "
    },
    {
        "id": 183,
        "title": "Delete Columns to Make Sorted",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of `n` strings `strs`, all of the same length.\n\nThe strings can be arranged such that there is one on each line, making a grid.\n\n*   For example, `strs = [ \"abc \", \"bce \", \"cae \"]` can be arranged as follows:\n\nabc\nbce\ncae\n\nYou want to **delete** the columns that are **not sorted lexicographically**. In the above example (**0-indexed**), columns 0 (`'a'`, `'b'`, `'c'`) and 2 (`'c'`, `'e'`, `'e'`) are sorted, while column 1 (`'b'`, `'c'`, `'a'`) is not, so you would delete column 1.\n\nReturn _the number of columns that you will delete_.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"cba \", \"daf \", \"ghi \"\\]\n**Output:** 1\n**Explanation:** The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"a \", \"b \"\\]\n**Output:** 0\n**Explanation:** The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns.\n\n",
                "**Example 3:**\n\n**Input:** strs = \\[ \"zyx \", \"wvu \", \"tsr \"\\]\n**Output:** 3\n**Explanation:** The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3."
            ],
            "constraints": "**Constraints:**\n\n*   `n == strs.length`\n*   `1 <= n <= 100`\n*   `1 <= strs[i].length <= 1000`\n*   `strs[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"cba\",\"daf\",\"ghi\"]",
                "output": "1"
            },
            {
                "input": "[\"a\",\"b\"]",
                "output": "0"
            },
            {
                "input": "[\"zyx\",\"wvu\",\"tsr\"]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minDifference(int[] nums, int k) {\n    if(nums.length <= 1) return 0;\n    Arrays.sort(nums);\n    int min_diff = nums[nums.length - 1] - nums[0];\n    for(int i = 1; i < nums.length; i++) {\n        int high = Math.max(nums[i - 1] + k, nums[nums.length - 1] - k);\n        int low = Math.min(nums[i] - k, nums[0] + k);\n        min_diff = Math.min(min_diff, high - low);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "python": "\n    ```python\ndef minDifference(nums, k):\n    if len(nums) <= 1: return 0\n    nums.sort()\n    min_diff = nums[-1] - nums[0]\n    for i in range(1, len(nums)):\n        high = max(nums[i-1] + k, nums[-1] - k)\n        low = min(nums[i] - k, nums[0] + k)\n        min_diff = min(min_diff, high - low)\n    return min_diff\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "c++": "\n    ```cpp\nint minDifference(vector<int>& nums, int k) {\n    if(nums.size() <= 1) return 0;\n    sort(nums.begin(), nums.end());\n    int min_diff = nums.back() - nums.front();\n    for(int i=1; i<nums.size(); i++) {\n        int high = max(nums[i-1] + k, nums.back() - k);\n        int low = min(nums[i] - k, nums.front() + k);\n        min_diff = min(min_diff, high - low);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "js": "\n    ```javascript\nfunction minDifference(nums, k) {\n    if(nums.length <= 1) return 0;\n    nums.sort((a, b) => a - b);\n    let min_diff = nums[nums.length - 1] - nums[0];\n    for(let i = 1; i < nums.length; i++) {\n        let high = Math.max(nums[i - 1] + k, nums[nums.length - 1] - k);\n        let low = Math.min(nums[i] - k, nums[0] + k);\n        min_diff = Math.min(min_diff, high - low);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    "
    },
    {
        "id": 184,
        "title": "Verifying an Alien Dictionary",
        "difficulty": "Easy",
        "content": {
            "problem": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters.\n\nGiven a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographically in this alien language.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"hello \", \"leetcode \"\\], order =  \"hlabcdefgijkmnopqrstuvwxyz \"\n**Output:** true\n**Explanation:** As 'h' comes before 'l' in this language, then the sequence is sorted.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"word \", \"world \", \"row \"\\], order =  \"worldabcefghijkmnpqstuvxyz \"\n**Output:** false\n**Explanation:** As 'd' comes after 'l' in this language, then words\\[0\\] > words\\[1\\], hence the sequence is unsorted.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"apple \", \"app \"\\], order =  \"abcdefghijklmnopqrstuvwxyz \"\n**Output:** false\n**Explanation:** The first three characters  \"app \" match, and the second string is shorter (in size.) According to lexicographical rules  \"apple \" >  \"app \", because 'l' > '', where '' is defined as the blank character which is less than any other character ([More info](https://en.wikipedia.org/wiki/Lexicographical_order))."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 20`\n*   `order.length == 26`\n*   All characters in `words[i]` and `order` are English lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"hello\",\"leetcode\"],\"hlabcdefgijkmnopqrstuvwxyz\"",
                "output": "true"
            },
            {
                "input": "[\"word\",\"world\",\"row\"],\"worldabcefghijkmnpqstuvxyz\"",
                "output": "false"
            },
            {
                "input": "[\"apple\",\"app\"],\"abcdefghijklmnopqrstuvwxyz\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic String reverseString(String s) {\n    StringBuilder result = new StringBuilder(s);\n    return result.reverse().toString();\n}\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "python": "\n    ```python\ndef reverse_string(s):\n    return s[::-1]\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n\nstd::string reverseString(const std::string& s) {\n    std::string result = s;\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "js": "\n    ```javascript\nfunction reverseString(s) {\n    return s.split('').reverse().join('');\n}\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    "
    },
    {
        "id": 185,
        "title": "N-Repeated Element in Size 2N Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` with the following properties:\n\n*   `nums.length == 2 * n`.\n*   `nums` contains `n + 1` **unique** elements.\n*   Exactly one element of `nums` is repeated `n` times.\n\nReturn _the element that is repeated_ `n` _times_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,3\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,1,2,5,3,2\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[5,1,5,2,5,3,5,4\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 5000`\n*   `nums.length == 2 * n`\n*   `0 <= nums[i] <= 104`\n*   `nums` contains `n + 1` **unique** elements and one of them is repeated exactly `n` times.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2,3,3]",
                "output": "3"
            },
            {
                "input": "[2,1,2,5,3,2]",
                "output": "2"
            },
            {
                "input": "[5,1,5,2,5,3,5,4]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nboolean isLongPressedName(String name, String typed) {\n    int i = 0, j = 0;\n    while (j < typed.length()) {\n        if (i < name.length() && name.charAt(i) == typed.charAt(j)) {\n            i++;\n        } else if (j == 0 || typed.charAt(j) != typed.charAt(j - 1)) {\n            return false;\n        }\n        j++;\n    }\n    return i == name.length();\n}\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "python": "\n    ```python\ndef isLongPressedName(name: str, typed: str) -> bool:\n    i, j = 0, 0\n    while j < len(typed):\n        if i < len(name) and name[i] == typed[j]:\n            i += 1\n        elif j == 0 or typed[j] != typed[j - 1]:\n            return False\n        j += 1\n    return i == len(name)\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "c++": "\n    ```cpp\nbool isLongPressedName(string name, string typed) {\n    int i = 0, j = 0;\n    while (j < typed.length()) {\n        if (i < name.length() && name[i] == typed[j]) {\n            i++;\n        } else if (j == 0 || typed[j] != typed[j - 1]) {\n            return false;\n        }\n        j++;\n    }\n    return i == name.length();\n}\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "js": "\n    ```javascript\nfunction isLongPressedName(name, typed) {\n    let i = 0, j = 0;\n    while (j < typed.length) {\n        if (i < name.length && name[i] === typed[j]) {\n            i++;\n        } else if (j === 0 || typed[j] !== typed[j - 1]) {\n            return false;\n        }\n        j++;\n    }\n    return i === name.length;\n}\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    "
    },
    {
        "id": 186,
        "title": "Univalued Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "A binary tree is **uni-valued** if every node in the tree has the same value.\n\nGiven the `root` of a binary tree, return `true` _if the given tree is **uni-valued**, or_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,1,1,1,1,null,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,2,2,5,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `0 <= Node.val < 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,1,1,1,1,null,1]",
                "output": "true"
            },
            {
                "input": "[2,2,2,5,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int numUniqueEmails(String[] emails) {\n    Set<String> unique_emails = new HashSet<>();\n\n    for (String email : emails) {\n        String[] parts = email.split(\"@\");\n        String local_name = parts[0], domain_name = parts[1];\n\n        local_name = local_name.replaceAll(\"\\\\+\", \"@\").split(\"@\")[0];\n        local_name = local_name.replaceAll(\"\\\\.\", \"\");\n\n        unique_emails.add(local_name + \"@\" + domain_name);\n    }\n\n    return unique_emails.size();\n}\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "python": "\n    ```python\ndef num_unique_emails(emails):\n    unique_emails = set()\n\n    for email in emails:\n        local_name, domain_name = email.split(\"@\")\n        local_name = local_name.split(\"+\")[0]\n        local_name = local_name.replace(\".\", \"\")\n\n        unique_emails.add(local_name + \"@\" + domain_name)\n\n    return len(unique_emails)\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <set>\n\nint numUniqueEmails(std::vector<std::string>& emails) {\n    std::set<std::string> unique_emails;\n\n    for (auto& email : emails) {\n        std::string local_name, domain_name;\n        bool at_sign_found = false, plus_sign_found = false;\n\n        for (char c : email) {\n            if (!at_sign_found) {\n                if (c == '+') plus_sign_found = true;\n                else if (c == '@') at_sign_found = true;\n                else if (!plus_sign_found && c != '.') local_name += c;\n            }\n            else domain_name += c;\n        }\n\n        unique_emails.insert(local_name + \"@\" + domain_name);\n    }\n\n    return unique_emails.size();\n}\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "js": "\n    ```javascript\nfunction numUniqueEmails(emails) {\n    let unique_emails = new Set();\n\n    emails.forEach((email) => {\n        let [local_name, domain_name] = email.split(\"@\");\n        local_name = local_name.split(\"+\")[0];\n        local_name = local_name.replace(/\\./g, \"\");\n\n        unique_emails.add(local_name + \"@\" + domain_name);\n    });\n\n    return unique_emails.size;\n}\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    "
    },
    {
        "id": 187,
        "title": "Largest Perimeter Triangle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,2\\]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,10\\]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[2,1,2]",
                "output": "5"
            },
            {
                "input": "[1,2,1,10]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minAreaRect(int[][] points) {\n        Set<Pair<Integer, Integer>> pointSet = new HashSet<>();\n        for (int[] point : points) {\n            pointSet.add(new Pair<>(point[0], point[1]));\n        }\n\n        int minArea = Integer.MAX_VALUE;\n        for (int[] p1 : points) {\n            for (int[] p2 : points) {\n                if (p1[0] != p2[0] && p1[1] != p2[1]) {\n                    if (pointSet.contains(new Pair<>(p1[0], p2[1])) && pointSet.contains(new Pair<>(p2[0], p1[1]))) {\n                        minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));\n                    }\n                }\n            }\n        }\n\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\n    }\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "python": "\n    ```python\ndef min_area_rect(points):\n    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n#include <vector>\n\ndouble minAreaRect(std::vector<std::vector<int>>& points) {\n    std::set<std::pair<int, int>> point_set;\n    for (const auto& point : points) {\n        point_set.emplace(point[0], point[1]);\n    }\n\n    double min_area = INT32_MAX;\n    for (const auto& p1 : point_set) {\n        for (const auto& p2 : point_set) {\n            if (p1.first != p2.first && p1.second != p2.second) {\n                if (point_set.count({p1.first, p2.second}) && point_set.count({p2.first, p1.second})) {\n                    min_area = std::min(min_area, abs((p1.first - p2.first) * (p1.second - p2.second)));\n                }\n            }\n        }\n    }\n\n    return min_area == INT32_MAX ? 0 : min_area;\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "js": "\n    ```javascript\nfunction minAreaRect(points) {\n  const pointSet = new Set(points.map(point => point.join(',')));\n  let minArea = Infinity;\n\n  for (const p1 of points) {\n    for (const p2 of points) {\n      if (p1[0] !== p2[0] && p1[1] !== p2[1]) {\n        if (pointSet.has([p1[0], p2[1]].join(',')) && pointSet.has([p2[0], p1[1]].join(','))) {\n          minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));\n        }\n      }\n    }\n  }\n\n  return minArea === Infinity ? 0 : minArea;\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    "
    },
    {
        "id": 188,
        "title": "Squares of a Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in **non-decreasing** order, return _an array of **the squares of each number** sorted in non-decreasing order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-4,-1,0,3,10\\]\n**Output:** \\[0,1,9,16,100\\]\n**Explanation:** After squaring, the array becomes \\[16,1,0,9,100\\].\nAfter sorting, it becomes \\[0,1,9,16,100\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-7,-3,2,3,11\\]\n**Output:** \\[4,9,9,49,121\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in **non-decreasing** order.\n\n**",
            "follow_up": "Follow up:** Squaring each element and sorting the new array is very trivial, could you find an `O(n)` solution using a different approach?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[-4,-1,0,3,10]",
                "output": "[0,1,9,16,100]"
            },
            {
                "input": "[-7,-3,2,3,11]",
                "output": "[4,9,9,49,121]"
            }
        ],
        "java": "\n    ```java\npublic int distinctSubseqII(String s) {\n    int mod = (int) (1e9 + 7);\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    int[] last = new int[26];\n    Arrays.fill(last, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = (dp[i - 1] * 2) % mod;\n        if (last[s.charAt(i - 1) - 'a'] != -1) {\n            dp[i] = (dp[i] - dp[last[s.charAt(i - 1) - 'a']] + mod) % mod;\n        }\n        last[s.charAt(i - 1) - 'a'] = i - 1;\n    }\n\n    dp[n] = (dp[n] - 1 + mod) % mod;\n    return dp[n];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "python": "\n    ```python\ndef distinctSubseqII(s):\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last = [-1] * 26\n\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * 2) % mod\n        if last[ord(s[i - 1]) - ord('a')] != -1:\n            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod\n        last[ord(s[i - 1]) - ord('a')] = i - 1\n\n    dp[n] = (dp[n] - 1 + mod) % mod\n    return dp[n]\n```\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "c++": "\n    ```cpp\n#include <iostream>\n#include <string>\n\nint distinctSubseqII(std::string s) {\n    int mod = 1e9 + 7;\n    int n = s.size();\n    std::vector<int> dp(n + 1);\n    dp[0] = 1;\n    std::vector<int> last(26, -1); \n\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = (dp[i - 1] * 2) % mod;\n        if (last[s[i - 1] - 'a'] != -1) {\n            dp[i] = (dp[i] - dp[last[s[i - 1] - 'a']] + mod) % mod;\n        }\n        last[s[i - 1] - 'a'] = i - 1;\n    }\n\n    dp[n] = (dp[n] - 1 + mod) % mod;\n    return dp[n];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "js": "\n    ```javascript\nfunction distinctSubseqII(s) {\n    const mod = 1e9 + 7;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    const last = new Array(26).fill(-1);\n\n    for (let i = 1; i <= n; ++i) {\n        dp[i] = (dp[i - 1] * 2) % mod;\n        if (last[s.charCodeAt(i - 1) - 'a'.charCodeAt()] !== -1) {\n            dp[i] = (dp[i] - dp[last[s.charCodeAt(i - 1) - 'a'.charCodeAt()]] + mod) % mod;\n        }\n        last[s.charCodeAt(i - 1) - 'a'.charCodeAt()] = i - 1;\n    }\n\n    dp[n] = (dp[n] - 1 + mod) % mod;\n    return dp[n];\n}\n```\n\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    "
    },
    {
        "id": 189,
        "title": "Add to Array-Form of Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "The **array-form** of an integer `num` is an array representing its digits in left to right order.\n\n*   For example, for `num = 1321`, the array form is `[1,3,2,1]`.\n\nGiven `num`, the **array-form** of an integer, and an integer `k`, return _the **array-form** of the integer_ `num + k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = \\[1,2,0,0\\], k = 34\n**Output:** \\[1,2,3,4\\]\n**Explanation:** 1200 + 34 = 1234\n\n",
                "**Example 2:**\n\n**Input:** num = \\[2,7,4\\], k = 181\n**Output:** \\[4,5,5\\]\n**Explanation:** 274 + 181 = 455\n\n",
                "**Example 3:**\n\n**Input:** num = \\[2,1,5\\], k = 806\n**Output:** \\[1,0,2,1\\]\n**Explanation:** 215 + 806 = 1021"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 104`\n*   `0 <= num[i] <= 9`\n*   `num` does not contain any leading zeros except for the zero itself.\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,2,0,0],34",
                "output": "[1,2,3,4]"
            },
            {
                "input": "[2,7,4],181",
                "output": "[4,5,5]"
            },
            {
                "input": "[2,1,5],806",
                "output": "[1,0,2,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int largestComponentSize(int[] nums) {\n        int count = 0;\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\n        Set<Integer> visited = new HashSet<>();\n\n        for (int num : nums) {\n            int prime = primes(num);\n            graph.computeIfAbsent(prime, k -> new HashSet<>()).add(num);\n            if (num != prime) graph.computeIfAbsent(num, k -> new HashSet<>()).add(prime);\n        }\n\n        for (int num : nums) {\n            count = Math.max(count, dfs(num, visited, graph));\n        }\n        return count;\n    }\n\n    private int dfs(int node, Set<Integer> visited, Map<Integer, Set<Integer>> graph) {\n        if (!visited.add(node)) return 0;\n        int res = 1;\n        for (int neighbor : graph.getOrDefault(node, Collections.emptySet())) {\n            res += dfs(neighbor, visited, graph);\n        }\n        return res;\n    }\n\n    private int primes(int n) {\n        for (int i = 2; i * i <= n; ++i) {\n            if (n % i == 0) return i;\n        }\n        return n;\n    }\n}\n```\n    \n    The algorithm uses the following steps:\n\n1. For each number in `nums`, find the smallest prime divisor, which is the prime number that divides the current number.\n2. Construct a graph where the nodes are numbers, and the edges are between each number and its smallest prime divisor.\n3. Perform a depth-first search (DFS) on the graph for each number in `nums`, counting the size of connected components and keeping track of visited nodes.\n4. Return the size of the largest connected component in the graph.\n\nThis algorithm starts by mapping each number to its smallest prime divisor, and then building a graph to model the relationships between the numbers and the divisors. The DFS traversal helps to find connected components, and the largest connected component is returned. The time complexity of this algorithm is O(NW), where N is the size of the nums array, and W is the maximum number in it.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef largestComponentSize(nums):\n    def primes(n):\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return i\n        return n\n\n    def dfs(node, visited, graph):\n        if node in visited:\n            return 0\n        visited.add(node)\n        size = 1\n        for neighbor in graph[node]:\n            size += dfs(neighbor, visited, graph)\n        return size\n\n    graph = defaultdict(set)\n    visited = set()\n\n    for num in nums:\n        prime = primes(num)\n        graph[prime].add(num)\n        if num != prime:\n            graph[num].add(prime)\n\n    count = 0\n    for num in nums:\n        count = max(count, dfs(num, visited, graph))\n\n    return count\n```\n    \n    The algorithm uses the following steps:\n\n1. For each number in `nums`, find the smallest prime divisor, which is the prime number that divides the current number.\n2. Construct a graph where the nodes are numbers, and the edges are between each number and its smallest prime divisor.\n3. Perform a depth-first search (DFS) on the graph for each number in `nums`, counting the size of connected components and keeping track of visited nodes.\n4. Return the size of the largest connected component in the graph.\n\nThis algorithm starts by mapping each number to its smallest prime divisor, and then building a graph to model the relationships between the numbers and the divisors. The DFS traversal helps to find connected components, and the largest connected component is returned. The time complexity of this algorithm is O(NW), where N is the size of the nums array, and W is the maximum number in it.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<unordered_set>\n#include<unordered_map>\n\nusing namespace std;\n\nint primes(int n) {\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return i;\n    }\n    return n;\n}\n\nint largestComponentSize(vector<int>& nums) {\n    int count = 0;\n    unordered_map<int, unordered_set<int>> graph;\n    unordered_set<int> visited;\n    for (int num : nums) {\n        int prime = primes(num);\n        graph[prime].insert(num);\n        if (num != prime) graph[num].insert(prime);\n    }\n\n    function<int(int)> dfs = [&](int node) {\n        if (!visited.insert(node).second) return 0;\n        int res = 1;\n        for (int neighbor : graph[node]) {\n            res += dfs(neighbor);\n        }\n        return res;\n    };\n\n    for (int num : nums) {\n        count = max(count, dfs(num));\n    }\n    return count;\n}\n```\n    \n    The algorithm uses the following steps:\n\n1. For each number in `nums`, find the smallest prime divisor, which is the prime number that divides the current number.\n2. Construct a graph where the nodes are numbers, and the edges are between each number and its smallest prime divisor.\n3. Perform a depth-first search (DFS) on the graph for each number in `nums`, counting the size of connected components and keeping track of visited nodes.\n4. Return the size of the largest connected component in the graph.\n\nThis algorithm starts by mapping each number to its smallest prime divisor, and then building a graph to model the relationships between the numbers and the divisors. The DFS traversal helps to find connected components, and the largest connected component is returned. The time complexity of this algorithm is O(NW), where N is the size of the nums array, and W is the maximum number in it.\n    ",
        "js": "\n    ```javascript\nfunction largestComponentSize(nums) {\n    function primes(n) {\n        for (let i = 2; i * i <= n; ++i) {\n            if (n % i === 0) return i;\n        }\n        return n;\n    }\n\n    function dfs(node, visited, graph) {\n        if (visited.has(node)) return 0;\n        visited.add(node);\n        let size = 1;\n        for (let neighbor of graph[node]) {\n            size += dfs(neighbor, visited, graph);\n        }\n        return size;\n    }\n\n    const graph = new Map();\n    const visited = new Set();\n\n    for (const num of nums) {\n        const prime = primes(num);\n        if (!graph.has(prime)) graph.set(prime, new Set());\n        graph.get(prime).add(num);\n        if (num !== prime) {\n            if (!graph.has(num)) graph.set(num, new Set());\n            graph.get(num).add(prime);\n        }\n    }\n\n    let count = 0;\n    for (const num of nums) {\n        count = Math.max(count, dfs(num, visited, graph));\n    }\n\n    return count;\n}\n```\n    \n    The algorithm uses the following steps:\n\n1. For each number in `nums`, find the smallest prime divisor, which is the prime number that divides the current number.\n2. Construct a graph where the nodes are numbers, and the edges are between each number and its smallest prime divisor.\n3. Perform a depth-first search (DFS) on the graph for each number in `nums`, counting the size of connected components and keeping track of visited nodes.\n4. Return the size of the largest connected component in the graph.\n\nThis algorithm starts by mapping each number to its smallest prime divisor, and then building a graph to model the relationships between the numbers and the divisors. The DFS traversal helps to find connected components, and the largest connected component is returned. The time complexity of this algorithm is O(NW), where N is the size of the nums array, and W is the maximum number in it.\n    "
    },
    {
        "id": 190,
        "title": "Cousins in Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree with unique values and the values of two different nodes of the tree `x` and `y`, return `true` _if the nodes corresponding to the values_ `x` _and_ `y` _in the tree are **cousins**, or_ `false` _otherwise._\n\nTwo nodes of a binary tree are **cousins** if they have the same depth with different parents.\n\nNote that in a binary tree, the root node is at the depth `0`, and children of each depth `k` node are at the depth `k + 1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4\\], x = 4, y = 3\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3,null,4,null,5\\], x = 5, y = 4\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,2,3,null,4\\], x = 2, y = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 100]`.\n*   `1 <= Node.val <= 100`\n*   Each node has a **unique** value.\n*   `x != y`\n*   `x` and `y` are exist in the tree.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,4],4,3",
                "output": "false"
            },
            {
                "input": "[1,2,3,null,4,null,5],5,4",
                "output": "true"
            },
            {
                "input": "[1,2,3,null,4],2,3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int tallestBillboard(int[] rods) {\n    int n = rods.length;\n    int totalLength = Arrays.stream(rods).sum();\n    int[][] dp = new int[n + 1][totalLength + 1];\n    for (int i = 0; i < n + 1; i++) {\n        Arrays.fill(dp[i], -1);\n    }\n    dp[0][0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= totalLength; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (rods[i - 1] <= j) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);\n            if (rods[i - 1] <= totalLength - j) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + rods[i - 1]]);\n        }\n    }\n    \n    return dp[n][0] / 2;\n}\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "python": "\n    ```python\ndef tallestBillboard(rods):\n    n = len(rods)\n    totalLength = sum(rods)\n    dp = [[-1] * (totalLength + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(totalLength + 1):\n            dp[i][j] = dp[i - 1][j]\n            if rods[i - 1] <= j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1])\n            if rods[i - 1] <= totalLength - j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]])\n                \n    return dp[n][0] // 2\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "c++": "\n    ```cpp\nint tallestBillboard(vector<int>& rods) {\n    int n = rods.size();\n    int totalLength = accumulate(rods.begin(), rods.end(), 0);\n    vector<vector<int>> dp(n + 1, vector<int>(totalLength + 1, -1));\n    dp[0][0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= totalLength; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (rods[i - 1] <= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);\n            if (rods[i - 1] <= totalLength - j) dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]]);\n        }\n    }\n    \n    return dp[n][0] / 2;\n}\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "js": "\n    ```javascript\nfunction tallestBillboard(rods) {\n    const n = rods.length;\n    const totalLength = rods.reduce((sum, rod) => sum + rod, 0);\n    const dp = Array.from({length: n + 1}, () => Array(totalLength + 1).fill(-1));\n    \n    dp[0][0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j <= totalLength; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (rods[i - 1] <= j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);\n            }\n            if (rods[i - 1] <= totalLength - j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + rods[i - 1]]);\n            }\n        }\n    }\n    \n    return dp[n][0] / 2;\n}\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    "
    },
    {
        "id": 191,
        "title": "Find the Town Judge",
        "difficulty": "Easy",
        "content": {
            "problem": "In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n\n1.  The town judge trusts nobody.\n2.  Everybody (except for the town judge) trusts the town judge.\n3.  There is exactly one person that satisfies properties **1** and **2**.\n\nYou are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. If a trust relationship does not exist in `trust` array, then such a trust relationship does not exist.\n\nReturn _the label of the town judge if the town judge exists and can be identified, or return_ `-1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, trust = \\[\\[1,2\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 3, trust = \\[\\[1,3\\],\\[2,3\\]\\]\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** n = 3, trust = \\[\\[1,3\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= trust.length <= 104`\n*   `trust[i].length == 2`\n*   All the pairs of `trust` are **unique**.\n*   `ai != bi`\n*   `1 <= ai, bi <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Graph"
        ],
        "example": [
            {
                "input": "2,[[1,2]]",
                "output": "2"
            },
            {
                "input": "3,[[1,3],[2,3]]",
                "output": "3"
            },
            {
                "input": "3,[[1,3],[2,3],[3,1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findJudge(int n, int[][] trust) {\n    int[] trustCounts = new int[n + 1];\n    for (int[] t : trust) {\n        trustCounts[t[0]]--;\n        trustCounts[t[1]]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "python": "\n    ```python\ndef findJudge(n, trust):\n    trust_counts = [0] * (n + 1)\n    for a, b in trust:\n        trust_counts[a] -= 1\n        trust_counts[b] += 1\n    for i in range(1, n + 1):\n        if trust_counts[i] == n - 1:\n            return i\n    return -1\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint findJudge(int n, vector<vector<int>>& trust) {\n    vector<int> trustCounts(n + 1, 0);\n    for (auto& t : trust) {\n        trustCounts[t[0]]--;\n        trustCounts[t[1]]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findJudge(n, trust) {\n    let trustCounts = new Array(n + 1).fill(0);\n    for (let [a, b] of trust) {\n        trustCounts[a]--;\n        trustCounts[b]++;\n    }\n    for (let i = 1; i <= n; i++) {\n        if (trustCounts[i] === n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    "
    },
    {
        "id": 192,
        "title": "Available Captures for Rook",
        "difficulty": "Easy",
        "content": {
            "problem": "On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** In this example, the rook is attacking all the pawns.\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 0\n**Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** The rook is attacking the pawns at positions b5, d6, and f5."
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 8`\n*   `board[i].length == 8`\n*   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\n*   There is exactly one cell with `board[i][j] == 'R'`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
                "output": "3"
            },
            {
                "input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
                "output": "0"
            },
            {
                "input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int regionsBySlashes(String[] grid) {\n    int n = grid.length;\n    int[][] graph = new int[n * 3][n * 3];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i].charAt(j) == '/') {\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;\n            }\n            if (grid[i].charAt(j) == '\\\\') {\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;\n            }\n        }\n    }\n\n    int regions = 0;\n    for (int i = 0; i < n * 3; i++) {\n        for (int j = 0; j < n * 3; j++) {\n            if (graph[i][j] == 0) {\n                regions++;\n                dfs(graph, i, j);\n            }\n        }\n    }\n\n    return regions;\n}\n\nprivate void dfs(int[][] graph, int i, int j) {\n    int n = graph.length;\n    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j] == 1) return;\n\n    graph[i][j] = 1;\n    dfs(graph, i - 1, j);\n    dfs(graph, i + 1, j);\n    dfs(graph, i, j - 1);\n    dfs(graph, i, j + 1);\n}\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "python": "\n    ```python\ndef regionsBySlashes(grid):\n    n = len(grid)\n    graph = [[0] * (n * 3) for _ in range(n * 3)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1\n            if grid[i][j] == '\\\\':\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1\n\n    regions = 0\n    for i in range(n * 3):\n        for j in range(n * 3):\n            if not graph[i][j]:\n                regions += 1\n                dfs(graph, i, j)\n\n    return regions\n\ndef dfs(graph, i, j):\n    n = len(graph)\n    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:\n        return\n\n    graph[i][j] = 1\n    dfs(graph, i - 1, j)\n    dfs(graph, i + 1, j)\n    dfs(graph, i, j - 1)\n    dfs(graph, i, j + 1)\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint regionsBySlashes(std::vector<std::string>& grid) {\n    int n = grid.size();\n    std::vector<std::vector<int>> graph(n * 3, std::vector<int>(n * 3, 0));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == '/') {\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;\n            }\n            if (grid[i][j] == '\\\\') {\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;\n            }\n        }\n    }\n\n    int regions = 0;\n    for (int i = 0; i < n * 3; ++i) {\n        for (int j = 0; j < n * 3; ++j) {\n            if (!graph[i][j]) {\n                regions++;\n                dfs(graph, i, j);\n            }\n        }\n    }\n\n    return regions;\n}\n\nvoid dfs(std::vector<std::vector<int>>& graph, int i, int j) {\n    int n = graph.size();\n    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j]) return;\n    \n    graph[i][j] = 1;\n    dfs(graph, i - 1, j);\n    dfs(graph, i + 1, j);\n    dfs(graph, i, j - 1);\n    dfs(graph, i, j + 1);\n}\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "js": "\n    ```javascript\nfunction regionsBySlashes(grid) {\n    const n = grid.length;\n    const graph = Array.from({ length: n * 3 }, () => Array(n * 3).fill(0));\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '/') {\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;\n            }\n            if (grid[i][j] === '\\\\') {\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;\n            }\n        }\n    }\n\n    let regions = 0;\n    for (let i = 0; i < n * 3; i++) {\n        for (let j = 0; j < n * 3; j++) {\n            if (graph[i][j] === 0) {\n                regions++;\n                dfs(graph, i, j);\n            }\n        }\n    }\n\n    return regions;\n}\n\nfunction dfs(graph, i, j) {\n    const n = graph.length;\n    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j] === 1) return;\n\n    graph[i][j] = 1;\n    dfs(graph, i - 1, j);\n    dfs(graph, i + 1, j);\n    dfs(graph, i, j - 1);\n    dfs(graph, i, j + 1);\n}\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    "
    },
    {
        "id": 193,
        "title": "Find Common Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string array `words`, return _an array of all characters that show up in all strings within the_ `words` _(including duplicates)_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[\"bella\",\"label\",\"roller\"\\]\n**Output:** \\[\"e\",\"l\",\"l\"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[\"cool\",\"lock\",\"cook\"\\]\n**Output:** \\[\"c\",\"o\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"bella\",\"label\",\"roller\"]",
                "output": "[\"e\",\"l\",\"l\"]"
            },
            {
                "input": "[\"cool\",\"lock\",\"cook\"]",
                "output": "[\"c\",\"o\"]"
            }
        ],
        "java": "\n    \n```java\nimport java.util.*;\n\npublic int maxWidthRamp(int[] nums) {\n    Integer[] indices = new Integer[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        indices[i] = i;\n    }\n    \n    Arrays.sort(indices, (i, j) -> nums[i] == nums[j] ? i - j : nums[i] - nums[j]);\n    \n    int maxWidth = 0;\n    int minIndex = Integer.MAX_VALUE;\n    for (int index : indices) {\n        maxWidth = Math.max(maxWidth, index - minIndex);\n        minIndex = Math.min(minIndex, index);\n    }\n    \n    return maxWidth;\n}\n```\n\n    \n    \n1. First, create an array of indices of the input array.\n2. Sort the indices based on its corresponding value in the input array. In case of equal values, sort based on the index itself.\n3. Initialize maxWidth (maximum width of ramp) with 0 and minIndex (smallest index encountered so far) with maximum integer value.\n4. Iterate through the sorted indices array. Each iteration, calculate the width between the current index and minIndex, and update maxWidth if the calculated width is greater than the current max width. Update minIndex with the smallest value between the current index and minIndex.\n5. At the end of the iteration, maxWidth will hold the maximum width of a ramp in the nums array, and this value is returned.\n    ",
        "js": "\n    \n```javascript\nfunction maxWidthRamp(nums) {\n    const indices = [...Array(nums.length).keys()].sort((i, j) => {\n        return nums[i] === nums[j] ? i - j : nums[i] - nums[j];\n    });\n    \n    let maxWidth = 0;\n    let minIndex = Infinity;\n    for (const index of indices) {\n        maxWidth = Math.max(maxWidth, index - minIndex);\n        minIndex = Math.min(minIndex, index);\n    }\n    \n    return maxWidth;\n}\n```\n\n    \n    \n1. First, create an array of indices of the input array.\n2. Sort the indices based on its corresponding value in the input array. In case of equal values, sort based on the index itself.\n3. Initialize maxWidth (maximum width of ramp) with 0 and minIndex (smallest index encountered so far) with maximum integer value.\n4. Iterate through the sorted indices array. Each iteration, calculate the width between the current index and minIndex, and update maxWidth if the calculated width is greater than the current max width. Update minIndex with the smallest value between the current index and minIndex.\n5. At the end of the iteration, maxWidth will hold the maximum width of a ramp in the nums array, and this value is returned.\n    ",
        "c++": "\n    \n```cpp\n#include <vector>\n#include <algorithm>\n\nint maxWidthRamp(std::vector<int>& nums) {\n    std::vector<int> indices(nums.size());\n    for (int i = 0; i < nums.size(); ++i) {\n        indices[i] = i;\n    }\n    \n    std::sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return nums[i] == nums[j] ? i < j : nums[i] < nums[j];\n    });\n    \n    int maxWidth = 0;\n    int minIndex = std::numeric_limits<int>::max();\n    for (int index : indices) {\n        maxWidth = std::max(maxWidth, index - minIndex);\n        minIndex = std::min(minIndex, index);\n    }\n    \n    return maxWidth;\n}\n```\n\n    \n    \n1. First, create an array of indices of the input array.\n2. Sort the indices based on its corresponding value in the input array. In case of equal values, sort based on the index itself.\n3. Initialize maxWidth (maximum width of ramp) with 0 and minIndex (smallest index encountered so far) with maximum integer value.\n4. Iterate through the sorted indices array. Each iteration, calculate the width between the current index and minIndex, and update maxWidth if the calculated width is greater than the current max width. Update minIndex with the smallest value between the current index and minIndex.\n5. At the end of the iteration, maxWidth will hold the maximum width of a ramp in the nums array, and this value is returned.\n    ",
        "python": "\n    \n```python\ndef maxWidthRamp(nums):\n    indices = sorted(range(len(nums)), key=lambda i: (nums[i], i))\n    \n    maxWidth = 0\n    minIndex = float('inf')\n    for index in indices:\n        maxWidth = max(maxWidth, index - minIndex)\n        minIndex = min(minIndex, index)\n    \n    return maxWidth\n```\n\n    \n    \n1. First, create an array of indices of the input array.\n2. Sort the indices based on its corresponding value in the input array. In case of equal values, sort based on the index itself.\n3. Initialize maxWidth (maximum width of ramp) with 0 and minIndex (smallest index encountered so far) with maximum integer value.\n4. Iterate through the sorted indices array. Each iteration, calculate the width between the current index and minIndex, and update maxWidth if the calculated width is greater than the current max width. Update minIndex with the smallest value between the current index and minIndex.\n5. At the end of the iteration, maxWidth will hold the maximum width of a ramp in the nums array, and this value is returned.\n    "
    },
    {
        "id": 194,
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, modify the array in the following way:\n\n*   choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index `i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,3\\], k = 1\n**Output:** 5\n**Explanation:** Choose index 1 and nums becomes \\[4,-2,3\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,-1,0,2\\], k = 3\n**Output:** 6\n**Explanation:** Choose indices (1, 2, 2) and nums becomes \\[3,1,0,2\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,-3,-1,5,-4\\], k = 2\n**Output:** 13\n**Explanation:** Choose indices (1, 4) and nums becomes \\[2,3,-1,5,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-100 <= nums[i] <= 100`\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,2,3],1",
                "output": "5"
            },
            {
                "input": "[3,-1,0,2],3",
                "output": "6"
            },
            {
                "input": "[2,-3,-1,5,-4],2",
                "output": "13"
            }
        ],
        "java": "\n    ```java\npublic boolean isUnivalued(TreeNode root) {\n    return isUnivalued(root, -1);\n}\n\nprivate boolean isUnivalued(TreeNode root, int val) {\n    if (root == null) return true;\n    if (val == -1) val = root.val;\n    return root.val == val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "python": "\n    ```python\ndef is_univalued(root, val=None):\n    if not root:\n        return True\n    if val is None:\n        val = root.val\n    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "c++": "\n    ```cpp\nbool isUnivalued(TreeNode* root, int val = -1) {\n    if (!root) return true;\n    if (val == -1) val = root->val;\n    return root->val == val && isUnivalued(root->left, val) && isUnivalued(root->right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "js": "\n    ```javascript\nfunction isUnivalued(root, val = null) {\n    if (!root) return true;\n    if (val === null) val = root.val;\n    return root.val === val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    "
    },
    {
        "id": 195,
        "title": "Complement of Base 10 Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "The **complement** of an integer is the integer you get when you flip all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n*   For example, The integer `5` is `\"101 \"` in binary and its **complement** is `\"010 \"` which is the integer `2`.\n\nGiven an integer `n`, return _its complement_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 is  \"101 \" in binary, with complement  \"010 \" in binary, which is 2 in base-10.\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** 0\n**Explanation:** 7 is  \"111 \" in binary, with complement  \"000 \" in binary, which is 0 in base-10.\n\n",
                "**Example 3:**\n\n**Input:** n = 10\n**Output:** 5\n**Explanation:** 10 is  \"1010 \" in binary, with complement  \"0101 \" in binary, which is 5 in base-10."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n < 109`\n\n**Note:** This question is the same as 476: [https://leetcode.com/problems/number-complement/](https://leetcode.com/problems/number-complement/)",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "5",
                "output": "2"
            },
            {
                "input": "7",
                "output": "0"
            },
            {
                "input": "10",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> pancakeSort(int[] arr) {\n    List<Integer> flips = new ArrayList<>();\n    for (int size = arr.length; size > 1; --size) {\n        int maxIdx = getMaxIdx(arr, size);\n        flips.add(maxIdx + 1);\n        flips.add(size);\n        reverse(arr, 0, maxIdx);\n        reverse(arr, 0, size - 1);\n    }\n    return flips;\n}\n\nprivate int getMaxIdx(int[] arr, int size) {\n    int maxIdx = 0;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] > arr[maxIdx]) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nprivate void reverse(int[] arr, int start, int end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start++] = arr[end];\n        arr[end--] = temp;\n    }\n}\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "python": "\n    ```python\ndef pancakeSort(arr):\n    flips = []\n    for size in range(len(arr), 1, -1):\n        maxIdx = arr.index(max(arr[:size]))\n        flips.extend([maxIdx + 1, size])\n        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])\n        arr[:size] = reversed(arr[:size])\n    return flips\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pancakeSort(vector<int>& arr) {\n    vector<int> flips;\n    for (int size = arr.size(); size > 1; --size) {\n        int maxIdx = max_element(arr.begin(), arr.begin() + size) - arr.begin();\n        flips.push_back(maxIdx + 1);\n        flips.push_back(size);\n        reverse(arr.begin(), arr.begin() + maxIdx + 1);\n        reverse(arr.begin(), arr.begin() + size);\n    }\n    return flips;\n}\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "js": "\n    ```javascript\nfunction pancakeSort(arr) {\n    const flips = [];\n    for (let size = arr.length; size > 1; --size) {\n        const maxIdx = getMaxIdx(arr, size);\n        flips.push(maxIdx + 1);\n        flips.push(size);\n        reverse(arr, 0, maxIdx);\n        reverse(arr, 0, size - 1);\n    }\n    return flips;\n}\n\nfunction getMaxIdx(arr, size) {\n    let maxIdx = 0;\n    for (let i = 1; i < size; ++i) {\n        if (arr[i] > arr[maxIdx]) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nfunction reverse(arr, start, end) {\n    while (start < end) {\n        const temp = arr[start];\n        arr[start++] = arr[end];\n        arr[end--] = temp;\n    }\n}\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    "
    },
    {
        "id": 196,
        "title": "Partition Array Into Three Parts With Equal Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, return `true` if we can partition the array into three **non-empty** parts with equal sums.\n\nFormally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[0,2,1,-6,6,-7,9,1,2,0,1\\]\n**Output:** true\n**Explanation:** 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[0,2,1,-6,6,7,9,-1,2,0,1\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[3,3,6,5,-2,2,5,1,-9,4\\]\n**Output:** true\n**Explanation:** 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 5 * 104`\n*   `-104 <= arr[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[0,2,1,-6,6,-7,9,1,2,0,1]",
                "output": "true"
            },
            {
                "input": "[0,2,1,-6,6,7,9,-1,2,0,1]",
                "output": "false"
            },
            {
                "input": "[3,3,6,5,-2,2,5,1,-9,4]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic int fib(int n) {\n    if (n <= 1)\n        return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "python": "\n    ```python\ndef fib(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "c++": "\n    ```cpp\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "js": "\n    ```javascript\nfunction fib(n) {\n    if (n <= 1)\n        return n;\n    let a = 0, b = 1, c;\n    for (let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    "
    },
    {
        "id": 197,
        "title": "Binary Prefix Divisible By 5",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a binary array `nums` (**0-indexed**).\n\nWe define `xi` as the number whose binary representation is the subarray `nums[0..i]` (from most-significant-bit to least-significant-bit).\n\n*   For example, if `nums = [1,0,1]`, then `x0 = 1`, `x1 = 2`, and `x2 = 5`.\n\nReturn _an array of booleans_ `answer` _where_ `answer[i]` _is_ `true` _if_ `xi` _is divisible by_ `5`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,1\\]\n**Output:** \\[true,false,false\\]\n**Explanation:** The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.\nOnly the first number is divisible by 5, so answer\\[0\\] is true.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** \\[false,false,false\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[0,1,1]",
                "output": "[true,false,false]"
            },
            {
                "input": "[1,1,1]",
                "output": "[false,false,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int largestPerimeter(int[] nums) {\n    Arrays.sort(nums);\n\n    for (int i = nums.length - 1; i >= 2; --i) {\n        if (nums[i] < nums[i - 1] + nums[i - 2]) {\n            return nums[i] + nums[i - 1] + nums[i - 2];\n        }\n    }\n\n    return 0;\n}\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "python": "\n    ```python\ndef largestPerimeter(nums):\n    nums.sort(reverse=True)\n\n    for i in range(len(nums) - 2):\n        if nums[i] < nums[i + 1] + nums[i + 2]:\n            return nums[i] + nums[i + 1] + nums[i + 2]\n\n    return 0\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint largestPerimeter(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\n\n    for (size_t i = 0; i < nums.size() - 2; ++i) {\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\n            return nums[i] + nums[i + 1] + nums[i + 2];\n        }\n    }\n\n    return 0;\n}\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "js": "\n    ```javascript\nfunction largestPerimeter(nums) {\n    nums.sort((a, b) => b - a);\n\n    for (let i = 0; i < nums.length - 2; ++i) {\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\n            return nums[i] + nums[i + 1] + nums[i + 2];\n        }\n    }\n\n    return 0;\n}\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    "
    },
    {
        "id": 198,
        "title": "Remove Outermost Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "A valid parentheses string is either empty `\" \"`, `\"( \" + A + \") \"`, or `A + B`, where `A` and `B` are valid parentheses strings, and `+` represents string concatenation.\n\n*   For example, `\" \"`, `\"() \"`, `\"(())() \"`, and `\"(()(())) \"` are all valid parentheses strings.\n\nA valid parentheses string `s` is primitive if it is nonempty, and there does not exist a way to split it into `s = A + B`, with `A` and `B` nonempty valid parentheses strings.\n\nGiven a valid parentheses string `s`, consider its primitive decomposition: `s = P1 + P2 + ... + Pk`, where `Pi` are primitive valid parentheses strings.\n\nReturn `s` _after removing the outermost parentheses of every primitive string in the primitive decomposition of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(()())(()) \"\n**Output:**  \"()()() \"\n**Explanation:** \nThe input string is  \"(()())(()) \", with primitive decomposition  \"(()()) \" +  \"(()) \".\nAfter removing outer parentheses of each part, this is  \"()() \" +  \"() \" =  \"()()() \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"(()())(())(()(())) \"\n**Output:**  \"()()()()(()) \"\n**Explanation:** \nThe input string is  \"(()())(())(()(())) \", with primitive decomposition  \"(()()) \" +  \"(()) \" +  \"(()(())) \".\nAfter removing outer parentheses of each part, this is  \"()() \" +  \"() \" +  \"()(()) \" =  \"()()()()(()) \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"()() \"\n**Output:**  \" \"\n**Explanation:** \nThe input string is  \"()() \", with primitive decomposition  \"() \" +  \"() \".\nAfter removing outer parentheses of each part, this is  \" \" +  \" \" =  \" \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'('` or `')'`.\n*   `s` is a valid parentheses string.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"(()())(())\"",
                "output": "\"()()()\""
            },
            {
                "input": "\"(()())(())(()(()))\"",
                "output": "\"()()()()(())\""
            },
            {
                "input": "\"()()\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic int distributeCoins(TreeNode root) {\n    int[] moves = new int[1];\n    distributeCoins(root, moves);\n    return moves[0];\n}\n\nprivate int distributeCoins(TreeNode root, int[] moves) {\n    if (root == null) return 0;\n    int left = distributeCoins(root.left, moves);\n    int right = distributeCoins(root.right, moves);\n    moves[0] += Math.abs(left) + Math.abs(right);\n    return root.val + left + right - 1;\n}\n```\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "python": "\n    ```python\ndef distributeCoins(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left, right = dfs(node.left), dfs(node.right)\n        moves[0] += abs(left) + abs(right)\n        return node.val + left + right - 1\n\n    moves = [0]\n    dfs(root)\n    return moves[0]\n```\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "c++": "\n    ```cpp\nint distributeCoins(TreeNode* root, int &moves) {\n    if (root == nullptr) return 0;\n    int left = distributeCoins(root->left, moves);\n    int right = distributeCoins(root->right, moves);\n    moves += abs(left) + abs(right);\n    return root->val + left + right - 1;\n}\n\nint distributeCoins(TreeNode* root) {\n    int moves = 0;\n    distributeCoins(root, moves);\n    return moves;\n}\n```\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "js": "\n    ```javascript\nfunction distributeCoins(root) {\n    function dfs(node) {\n        if (!node) return 0;\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        moves[0] += Math.abs(left) + Math.abs(right);\n        return node.val + left + right - 1;\n    }\n\n    let moves = [0];\n    dfs(root);\n    return moves[0];\n}\n```\n\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    "
    },
    {
        "id": 199,
        "title": "Sum of Root To Leaf Binary Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the `root` of a binary tree where each node has a value `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n*   For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return _the sum of these numbers_.\n\nThe test cases are generated so that the answer fits in a **32-bits** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,0,1,0,1,0,1\\]\n**Output:** 22\n**Explanation:** (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `Node.val` is `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,0,1,0,1,0,1]",
                "output": "22"
            },
            {
                "input": "[0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int uniquePathsIII(int[][] grid) {\n    int x = 0, y = 0, empty = 1;\n    for (int i = 0; i < grid.length; ++i) {\n        for (int j = 0; j < grid[0].length; ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            } else if (grid[i][j] == 0) {\n                empty++;\n            }\n        }\n    }\n    return dfs(grid, x, y, empty);\n}\n\nprivate int dfs(int[][] grid, int x, int y, int empty) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == -1) {\n        return 0;\n    }\n    if (grid[x][y] == 2) {\n        return empty == -1 ? 1 : 0;\n    }\n    grid[x][y] = -1;\n    int paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);\n    grid[x][y] = 0;\n    return paths;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "python": "\n    ```python\ndef uniquePathsIII(grid):\n    x, y, empty = 0, 0, 1\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                x, y = i, j\n            elif grid[i][j] == 0:\n                empty += 1\n    return dfs(grid, x, y, empty)\n\ndef dfs(grid, x, y, empty):\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:\n        return 0\n    if grid[x][y] == 2:\n        return 1 if empty == -1 else 0\n    grid[x][y] = -1\n    paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1)\n    grid[x][y] = 0\n    return paths\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "c++": "\n    ```cpp\nint dfs(vector<vector<int>>& grid, int x, int y, int empty) {\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) {\n        return 0;\n    }\n    if (grid[x][y] == 2) {\n        return empty == -1 ? 1 : 0;\n    }\n    grid[x][y] = -1;\n    int paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);\n    grid[x][y] = 0;\n    return paths;\n}\n\nint uniquePathsIII(vector<vector<int>>& grid) {\n    int x = 0, y = 0, empty = 1;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                x = i, y = j;\n            } else if (grid[i][j] == 0) {\n                empty++;\n            }\n        }\n    }\n    return dfs(grid, x, y, empty);\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "js": "\n    ```javascript\nfunction uniquePathsIII(grid) {\n    let x = 0, y = 0, empty = 1;\n    for (let i = 0; i < grid.length; ++i) {\n        for (let j = 0; j < grid[0].length; ++j) {\n            if (grid[i][j] === 1) {\n                x = i;\n                y = j;\n            } else if (grid[i][j] === 0) {\n                empty++;\n            }\n        }\n    }\n    return dfs(grid, x, y, empty);\n}\n\nfunction dfs(grid, x, y, empty) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === -1) {\n        return 0;\n    }\n    if (grid[x][y] === 2) {\n        return empty === -1 ? 1 : 0;\n    }\n    grid[x][y] = -1;\n    let paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);\n    grid[x][y] = 0;\n    return paths;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    "
    },
    {
        "id": 200,
        "title": "Divisor Game",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** true\n**Explanation:** Alice chooses 1, and Bob has no more moves.\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** false\n**Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Brainteaser",
            "Game Theory"
        ],
        "example": [
            {
                "input": "2",
                "output": "true"
            },
            {
                "input": "3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int mincostTickets(int[] days, int[] costs) {\n  Set<Integer> travelDays = new HashSet<>();\n  for (int day : days) travelDays.add(day);\n  int[] dp = new int[366];\n\n  for (int i = 1; i <= 365; ++i) {\n    if (!travelDays.contains(i)) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = Math.min(dp[i - 1] + costs[0],\n                   Math.min(dp[Math.max(0, i - 7)] + costs[1],\n                            dp[Math.max(0, i - 30)] + costs[2]));\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "python": "\n    ```python\ndef mincostTickets(days, costs):\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nint mincostTickets(vector<int>& days, vector<int>& costs) {\n  unordered_set<int> travel_days(days.begin(), days.end());\n  vector<int> dp(366, 0);\n\n  for (int i = 1; i <= 365; ++i) {\n    if (travel_days.count(i) == 0) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = min({dp[i - 1] + costs[0],\n                   dp[max(0, i - 7)] + costs[1],\n                   dp[max(0, i - 30)] + costs[2]});\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "js": "\n    ```javascript\nfunction mincostTickets(days, costs) {\n  const travelDays = new Set(days);\n  const dp = new Array(366).fill(0);\n\n  for (let i = 1; i <= 365; ++i) {\n    if (!travelDays.has(i)) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = Math.min(dp[i - 1] + costs[0],\n                   Math.min(dp[Math.max(0, i - 7)] + costs[1],\n                            dp[Math.max(0, i - 30)] + costs[2]));\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    "
    },
    {
        "id": 201,
        "title": "Matrix Cells in Distance Order",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given four integers `row`, `cols`, `rCenter`, and `cCenter`. There is a `rows x cols` matrix and you are on the cell with the coordinates `(rCenter, cCenter)`.\n\nReturn _the coordinates of all cells in the matrix, sorted by their **distance** from_ `(rCenter, cCenter)` _from the smallest distance to the largest distance_. You may return the answer in **any order** that satisfies this condition.\n\nThe **distance** between two cells `(r1, c1)` and `(r2, c2)` is `|r1 - r2| + |c1 - c2|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rows = 1, cols = 2, rCenter = 0, cCenter = 0\n**Output:** \\[\\[0,0\\],\\[0,1\\]\\]\n**Explanation:** The distances from (0, 0) to other cells are: \\[0,1\\]\n\n",
                "**Example 2:**\n\n**Input:** rows = 2, cols = 2, rCenter = 0, cCenter = 1\n**Output:** \\[\\[0,1\\],\\[0,0\\],\\[1,1\\],\\[1,0\\]\\]\n**Explanation:** The distances from (0, 1) to other cells are: \\[0,1,1,2\\]\nThe answer \\[\\[0,1\\],\\[1,1\\],\\[0,0\\],\\[1,0\\]\\] would also be accepted as correct.\n\n",
                "**Example 3:**\n\n**Input:** rows = 2, cols = 3, rCenter = 1, cCenter = 2\n**Output:** \\[\\[1,2\\],\\[0,2\\],\\[1,1\\],\\[0,1\\],\\[1,0\\],\\[0,0\\]\\]\n**Explanation:** The distances from (1, 2) to other cells are: \\[0,1,1,2,2,3\\]\nThere are other answers that would also be accepted as correct, such as \\[\\[1,2\\],\\[1,1\\],\\[0,2\\],\\[1,0\\],\\[0,1\\],\\[0,0\\]\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rows, cols <= 100`\n*   `0 <= rCenter < rows`\n*   `0 <= cCenter < cols`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry",
            "Sorting",
            "Matrix"
        ],
        "example": [
            {
                "input": "1,2,0,0",
                "output": "[[0,0],[0,1]]"
            },
            {
                "input": "2,2,0,1",
                "output": "[[0,1],[0,0],[1,1],[1,0]]"
            },
            {
                "input": "2,3,1,2",
                "output": "[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\npublic class Solution {\n    public String smallestFromLeaf(TreeNode root) {\n        if (root == null) return \"|\";\n        String s = Character.toString((char) (root.val + 'a'));\n        if (root.left == null && root.right == null) return s;\n        String left = smallestFromLeaf(root.left);\n        String right = smallestFromLeaf(root.right);\n        return (left.compareTo(right) <= 0 ? left : right) + s;\n    }\n}\n```\n    \n    We perform a post-order traversal of the tree. If the root is null, we return the largest possible lexicographically ordered string \"|\". If the root is a leaf (both left and right children are null), we return the character equivalent of the node value converted to the corresponding lowercase alphabet character.\n\nWe get the lexicographically smallest strings from both the left and right subtrees (if they exist) and add the current root value's character equivalent to the result. We use the min function to determine the lexicographically smaller string between the two.\n\nNote that we add the current root value's character equivalent to the end of the result string, so that the result string starts with a leaf node and goes to the root node as the function returns. This keeps the lexicographically smaller strings at the beginning and correctly forms the lexicographically smallest string from leaf to root.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        if not root:\n            return \"|\"\n        s = chr(root.val + 97)\n        if not root.left and not root.right:\n            return s\n        left = self.smallestFromLeaf(root.left)\n        right = self.smallestFromLeaf(root.right)\n        return min(left, right) + s\n```\n    \n    We perform a post-order traversal of the tree. If the root is null, we return the largest possible lexicographically ordered string \"|\". If the root is a leaf (both left and right children are null), we return the character equivalent of the node value converted to the corresponding lowercase alphabet character.\n\nWe get the lexicographically smallest strings from both the left and right subtrees (if they exist) and add the current root value's character equivalent to the result. We use the min function to determine the lexicographically smaller string between the two.\n\nNote that we add the current root value's character equivalent to the end of the result string, so that the result string starts with a leaf node and goes to the root node as the function returns. This keeps the lexicographically smaller strings at the beginning and correctly forms the lexicographically smallest string from leaf to root.\n    ",
        "c++": "\n    ```cpp\n#include <climits>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstring smallestFromLeaf(TreeNode* root) {\n    if (!root) return \"|\";\n    string s(1, root->val + 'a');\n    if (!root->left && !root->right) return s;\n    string left = smallestFromLeaf(root->left);\n    string right = smallestFromLeaf(root->right);\n    return min(left, right) + s;\n}\n```\n    \n    We perform a post-order traversal of the tree. If the root is null, we return the largest possible lexicographically ordered string \"|\". If the root is a leaf (both left and right children are null), we return the character equivalent of the node value converted to the corresponding lowercase alphabet character.\n\nWe get the lexicographically smallest strings from both the left and right subtrees (if they exist) and add the current root value's character equivalent to the result. We use the min function to determine the lexicographically smaller string between the two.\n\nNote that we add the current root value's character equivalent to the end of the result string, so that the result string starts with a leaf node and goes to the root node as the function returns. This keeps the lexicographically smaller strings at the beginning and correctly forms the lexicographically smallest string from leaf to root.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction smallestFromLeaf(root) {\n    if (!root) return \"|\";\n    const s = String.fromCharCode(root.val + 97);\n    if (!root.left && !root.right) return s;\n    const left = smallestFromLeaf(root.left);\n    const right = smallestFromLeaf(root.right);\n    return (left < right ? left : right) + s;\n}\n```\n    \n    We perform a post-order traversal of the tree. If the root is null, we return the largest possible lexicographically ordered string \"|\". If the root is a leaf (both left and right children are null), we return the character equivalent of the node value converted to the corresponding lowercase alphabet character.\n\nWe get the lexicographically smallest strings from both the left and right subtrees (if they exist) and add the current root value's character equivalent to the result. We use the min function to determine the lexicographically smaller string between the two.\n\nNote that we add the current root value's character equivalent to the end of the result string, so that the result string starts with a leaf node and goes to the root node as the function returns. This keeps the lexicographically smaller strings at the beginning and correctly forms the lexicographically smallest string from leaf to root.\n    "
    },
    {
        "id": 202,
        "title": "Valid Boomerang",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return `true` _if these points are a **boomerang**_.\n\nA **boomerang** is a set of three points that are **all distinct** and **not in a straight line**.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,3\\],\\[3,2\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `points.length == 3`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,1],[2,3],[3,2]]",
                "output": "true"
            },
            {
                "input": "[[1,1],[2,2],[3,3]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int minKBitFlips(int[] nums, int k) {\n    int n = nums.length, res = 0, flipped = 0;\n    int[] change = new int[n];\n    for (int i = 0; i <= n - k; i++) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) {\n            res++;\n            flipped ^= 1;\n            if (i + k < n) change[i + k] ^= 1;\n        }\n    }\n    for (int i = n - k + 1; i < n; i++) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) return -1;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "python": "\n    ```python\ndef min_k_bit_flips(nums, k):\n    n, res, flipped = len(nums), 0, 0\n    change = [0] * n\n    for i in range(n - k + 1):\n        flipped ^= change[i]\n        if nums[i] == flipped:\n            res += 1\n            flipped ^= 1\n            if i + k < n:\n                change[i + k] ^= 1\n    for i in range(n - k + 1, n):\n        flipped ^= change[i]\n        if nums[i] == flipped:\n            return -1\n    return res\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "c++": "\n    ```cpp\nint minKBitFlips(vector<int>& nums, int k) {\n    int n = nums.size(), res = 0, flipped = 0;\n    vector<int> change(n, 0);\n    for (int i = 0; i <= n - k; i++) {\n        flipped ^= change[i];\n        if (nums[i] ^ flipped == 0) {\n            res++;\n            flipped ^= 1;\n            if (i + k < n) change[i + k] ^= 1;\n        }\n    }\n    for (int i = n - k + 1; i < n; i++) {\n        flipped ^= change[i];\n        if (nums[i] ^ flipped == 0) return -1;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "js": "\n    ```javascript\nfunction minKBitFlips(nums, k) {\n    const n = nums.length;\n    let res = 0, flipped = 0;\n    const change = new Array(n).fill(0);\n    for (let i = 0; i <= n - k; ++i) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) {\n            res++;\n            flipped ^= 1;\n            if (i + k < n) change[i + k] ^= 1;\n        }\n    }\n    for (let i = n - k + 1; i < n; ++i) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) return -1;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    "
    },
    {
        "id": 203,
        "title": "Last Stone Weight",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the weight of the last remaining stone_. If there are no stones left, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:** \nWe combine 7 and 8 to get 1 so the array converts to \\[2,4,1,1,1\\] then,\nwe combine 2 and 4 to get 2 so the array converts to \\[2,1,1,1\\] then,\nwe combine 2 and 1 to get 1 so the array converts to \\[1,1,1\\] then,\nwe combine 1 and 1 to get 0 so the array converts to \\[1\\] then that's the value of the last stone.\n\n",
                "**Example 2:**\n\n**Input:** stones = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[2,7,4,1,8,1]",
                "output": "1"
            },
            {
                "input": "[1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int longestOnes(int[] nums, int k) {\n    int left = 0, right = 0, maxOnes = 0, zeroCount = 0;\n    while (right < nums.length) {\n        if (nums[right] == 0) zeroCount++;\n        while (zeroCount > k) {\n            if (nums[left] == 0) zeroCount--;\n            left++;\n        }\n        maxOnes = Math.max(maxOnes, right - left + 1);\n        right++;\n    }\n    return maxOnes;\n}\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "python": "\n    ```python\ndef longestOnes(nums, k):\n    left, right, max_ones, zero_count = 0, 0, 0, 0\n    while right < len(nums):\n        if nums[right] == 0:\n            zero_count += 1\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n        right += 1\n    return max_ones\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "c++": "\n    ```cpp\nint longestOnes(vector<int>& nums, int k) {\n    int left = 0, right = 0, maxOnes = 0, zeroCount = 0;\n    while (right < nums.size()) {\n        if (nums[right] == 0) zeroCount++;\n        while (zeroCount > k) {\n            if (nums[left] == 0) zeroCount--;\n            left++;\n        }\n        maxOnes = max(maxOnes, right - left + 1);\n        right++;\n    }\n    return maxOnes;\n}\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "js": "\n    ```javascript\nfunction longestOnes(nums, k) {\n    let left = 0, right = 0, maxOnes = 0, zeroCount = 0;\n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        while (zeroCount > k) {\n            if (nums[left] === 0) zeroCount--;\n            left++;\n        }\n        maxOnes = Math.max(maxOnes, right - left + 1);\n        right++;\n    }\n    return maxOnes;\n}\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    "
    },
    {
        "id": 204,
        "title": "Remove All Adjacent Duplicates In String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two **adjacent** and **equal** letters and removing them.\n\nWe repeatedly make **duplicate removals** on `s` until we no longer can.\n\nReturn _the final string after all such duplicate removals have been made_. It can be proven that the answer is **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abbaca \"\n**Output:**  \"ca \"\n**Explanation:** \nFor example, in  \"abbaca \" we could remove  \"bb \" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is  \"aaca \", of which only  \"aa \" is possible, so the final string is  \"ca \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"azxxzy \"\n**Output:**  \"ay \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"abbaca\"",
                "output": "\"ca\""
            },
            {
                "input": "\"azxxzy\"",
                "output": "\"ay\""
            }
        ],
        "java": "\n    ```java\npublic int maxSumAfterKOperations(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    for(int num : nums) pq.add(num);\n    while(k-- > 0){\n        int current = pq.poll();\n        pq.add(-current);\n    }\n    int sum = 0;\n    for(int num : pq) sum += num;\n    return sum;\n}\n```\n    \n    1. Create a min-heap from the given integer array nums.\n2. Iterate k times and for each iteration, do the following:\n   - Pop the smallest element from the min-heap.\n   - Negate the popped element and push it back to the min-heap.\n3. Calculate the sum of the elements in the min-heap and return it.\n\nNote: In JavaScript, we have also created a PriorityQueue class to achieve the functionality of a priority queue like in other languages.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef maxSumAfterKOperations(nums, k):\n    heapq.heapify(nums)\n    for _ in range(k):\n        current = heapq.heappop(nums)\n        heapq.heappush(nums, -current)\n    return sum(nums)\n```\n    \n    1. Create a min-heap from the given integer array nums.\n2. Iterate k times and for each iteration, do the following:\n   - Pop the smallest element from the min-heap.\n   - Negate the popped element and push it back to the min-heap.\n3. Calculate the sum of the elements in the min-heap and return it.\n\nNote: In JavaScript, we have also created a PriorityQueue class to achieve the functionality of a priority queue like in other languages.\n    ",
        "c++": "\n    ```cpp\nint maxSumAfterKOperations(vector<int>& nums, int k) {\n    priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());\n    while(k--){\n        int current = pq.top();\n        pq.pop();\n        pq.push(-current);\n    }\n    return accumulate(nums.begin(), nums.end(), 0);\n}\n```\n    \n    1. Create a min-heap from the given integer array nums.\n2. Iterate k times and for each iteration, do the following:\n   - Pop the smallest element from the min-heap.\n   - Negate the popped element and push it back to the min-heap.\n3. Calculate the sum of the elements in the min-heap and return it.\n\nNote: In JavaScript, we have also created a PriorityQueue class to achieve the functionality of a priority queue like in other languages.\n    ",
        "js": "\n    ```javascript\nfunction maxSumAfterKOperations(nums, k) {\n    const pq = new PriorityQueue(nums, (a, b) => a - b);\n    while(k--){\n        const current = pq.poll();\n        pq.offer(-current);\n    }\n    let sum = 0;\n    while(!pq.isEmpty()){\n        sum += pq.poll();\n    }\n    return sum;\n}\n\nclass PriorityQueue {\n    constructor(data=[], compareFunction=(a, b) => a > b){\n        this.data = data;\n        this.compareFunction = compareFunction;\n        this.heapify();\n    }\n    heapify(){\n        if(this.data.length > 0){\n            for(let i=Math.floor(this.size()/2); i>=0; i--){\n                this.siftDown(i);\n            }\n        }\n    }\n    parent(i){ return Math.floor((i-1)/2);}\n    left(i){ return 2*i + 1;}\n    right(i){ return 2*i + 2;}\n    size(){ return this.data.length;}\n    isEmpty(){ return this.size()==0;}\n    peek(){ return this.data[0];}\n    poll(){\n        const extracted = this.data.shift();\n        if(!this.isEmpty()){\n            this.data.unshift(this.data.pop());\n            this.siftDown(0);\n        }\n        return extracted;\n    }\n    siftDown(i){\n        let minIndex = i;\n        const l = this.left(i);\n        if(l<this.size() && this.compareFunction(this.data[l], this.data[minIndex])) minIndex = l;\n        const r = this.right(i);\n        if(r<this.size() && this.compareFunction(this.data[r], this.data[minIndex])) minIndex = r;\n        if(i!=minIndex){\n            [this.data[i], this.data[minIndex]] = [this.data[minIndex], this.data[i]];\n            this.siftDown(minIndex);\n        }\n    }\n    offer(value){\n        this.data.push(value);\n        this.siftUp(this.size()-1);\n    }\n    siftUp(i){\n        while(i>0 && this.compareFunction(this.data[i], this.data[this.parent(i)])){\n            [this.data[i], this.data[this.parent(i)]] = [this.data[this.parent(i)], this.data[i]];\n            i = this.parent(i);\n        }\n    }\n}\n```\n    \n    1. Create a min-heap from the given integer array nums.\n2. Iterate k times and for each iteration, do the following:\n   - Pop the smallest element from the min-heap.\n   - Negate the popped element and push it back to the min-heap.\n3. Calculate the sum of the elements in the min-heap and return it.\n\nNote: In JavaScript, we have also created a PriorityQueue class to achieve the functionality of a priority queue like in other languages.\n    "
    },
    {
        "id": 205,
        "title": "Height Checker",
        "difficulty": "Easy",
        "content": {
            "problem": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in **non-decreasing order** by height. Let this ordering be represented by the integer array `expected` where `expected[i]` is the expected height of the `ith` student in line.\n\nYou are given an integer array `heights` representing the **current order** that the students are standing in. Each `heights[i]` is the height of the `ith` student in line (**0-indexed**).\n\nReturn _the **number of indices** where_ `heights[i] != expected[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[1,1,4,2,1,3\\]\n**Output:** 3\n**Explanation:** \nheights:  \\[1,1,4,2,1,3\\]\nexpected: \\[1,1,1,2,3,4\\]\nIndices 2, 4, and 5 do not match.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[5,1,2,3,4\\]\n**Output:** 5\n**Explanation:**\nheights:  \\[5,1,2,3,4\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices do not match.\n\n",
                "**Example 3:**\n\n**Input:** heights = \\[1,2,3,4,5\\]\n**Output:** 0\n**Explanation:**\nheights:  \\[1,2,3,4,5\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices match."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 100`\n*   `1 <= heights[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Counting Sort"
        ],
        "example": [
            {
                "input": "[1,1,4,2,1,3]",
                "output": "3"
            },
            {
                "input": "[5,1,2,3,4]",
                "output": "5"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int heightChecker(int[] heights) {\n    int[] expected = heights.clone();\n    Arrays.sort(expected);\n\n    int count = 0;\n    for (int i = 0; i < heights.length; ++i) {\n        if (heights[i] != expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "python": "\n    ```python\ndef height_checker(heights):\n    expected = sorted(heights)\n    \n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n            \n    return count\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> expected = heights;\n    std::sort(expected.begin(), expected.end());\n\n    int count = 0;\n    for (int i = 0; i < heights.size(); ++i) {\n        if (heights[i] != expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "js": "\n    ```javascript\nfunction heightChecker(heights) {\n    const expected = [...heights].sort((a, b) => a - b);\n\n    let count = 0;\n    for (let i = 0; i < heights.length; ++i) {\n        if (heights[i] !== expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    "
    },
    {
        "id": 206,
        "title": "Greatest Common Divisor of Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "For two strings `s` and `t`, we say \"`t` divides `s` \" if and only if `s = t + ... + t` (i.e., `t` is concatenated with itself one or more times).\n\nGiven two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`.",
            "examples": [
                "**Example 1:**\n\n**Input:** str1 =  \"ABCABC \", str2 =  \"ABC \"\n**Output:**  \"ABC \"\n\n",
                "**Example 2:**\n\n**Input:** str1 =  \"ABABAB \", str2 =  \"ABAB \"\n**Output:**  \"AB \"\n\n",
                "**Example 3:**\n\n**Input:** str1 =  \"LEET \", str2 =  \"CODE \"\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= str1.length, str2.length <= 1000`\n*   `str1` and `str2` consist of English uppercase letters.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"ABCABC\",\"ABC\"",
                "output": "\"ABC\""
            },
            {
                "input": "\"ABABAB\",\"ABAB\"",
                "output": "\"AB\""
            },
            {
                "input": "\"LEET\",\"CODE\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Boolean> prefixesDivBy5(int[] nums) {\n    List<Boolean> result = new ArrayList<>();\n    int current = 0;\n    for (int num : nums) {\n        current = ((current << 1) | num) % 5;\n        result.add(current == 0);\n    }\n    return result;\n}\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.##\nEnd ###\n    ",
        "python": "\n    ```python\ndef prefixesDivBy5(nums):\n    result = []\n    current = 0\n    for num in nums:\n        current = ((current << 1) | num) % 5\n        result.append(current == 0)\n    return result\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.##\nEnd ###\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<bool> prefixesDivBy5(std::vector<int>& nums) {\n    std::vector<bool> result;\n    int current = 0;\n    for (int num : nums) {\n        current = ((current << 1) | num) % 5;\n        result.push_back(current == 0);\n    }\n    return result;\n}\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.##\nEnd ###\n    ",
        "js": "\n    ```javascript\nfunction prefixesDivBy5(nums) {\n    let result = [];\n    let current = 0;\n    for (let num of nums) {\n        current = ((current << 1) | num) % 5;\n        result.push(current === 0);\n    }\n    return result;\n}\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.##\nEnd ###\n    "
    },
    {
        "id": 207,
        "title": "Occurrences After Bigram",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `first` and `second`, consider occurrences in some text of the form `\"first second third \"`, where `second` comes immediately after `first`, and `third` comes immediately after `second`.\n\nReturn _an array of all the words_ `third` _for each occurrence of_ `\"first second third \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n**Output:** \\[\"girl\",\"student\"\\]\n\n",
                "**Example 2:**\n\n**Input:** text = \"we will we will rock you\", first = \"we\", second = \"will\"\n**Output:** \\[\"we\",\"rock\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists of lowercase English letters and spaces.\n*   All the words in `text` a separated by **a single space**.\n*   `1 <= first.length, second.length <= 10`\n*   `first` and `second` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"aliceisagoodgirlsheisagoodstudent\",\"a\",\"good\"",
                "output": "[\"girl\",\"student\"]"
            },
            {
                "input": "\"wewillwewillrockyou\",\"we\",\"will\"",
                "output": "[\"we\",\"rock\"]"
            }
        ],
        "java": "\n    ```java\npublic String removeOuterParentheses(String s) {\n    StringBuilder result = new StringBuilder();\n    int opened = 0;\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' && opened++ > 0) {\n            result.append(c);\n        }\n        if (c == ')' && opened-- > 1) {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "python": "\n    ```python\ndef remove_outer_parentheses(s: str) -> str:\n    result = []\n    opened = 0\n\n    for c in s:\n        if c == '(':\n            if opened > 0:\n                result.append(c)\n            opened += 1\n        elif c == ')':\n            if opened > 1:\n                result.append(c)\n            opened -= 1\n\n    return ''.join(result)\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string removeOuterParentheses(std::string s) {\n    std::string result;\n    int opened = 0;\n\n    for (char c : s) {\n        if (c == '(' && opened++ > 0) {\n            result += c;\n        }\n        if (c == ')' && opened-- > 1) {\n            result += c;\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "js": "\n    ```javascript\nfunction removeOuterParentheses(s) {\n    let result = \"\";\n    let opened = 0;\n\n    for (let c of s) {\n        if (c === '(' && opened++ > 0) {\n            result += c;\n        }\n        if (c === ')' && opened-- > 1) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    "
    },
    {
        "id": 208,
        "title": "Duplicate Zeros",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a fixed-length integer array `arr`, duplicate each occurrence of zero, shifting the remaining elements to the right.\n\n**Note** that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,0,2,3,0,4,5,0\\]\n**Output:** \\[1,0,0,2,3,0,0,4\\]\n**Explanation:** After calling your function, the input array is modified to: \\[1,0,0,2,3,0,0,4\\]\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,3\\]\n**Output:** \\[1,2,3\\]\n**Explanation:** After calling your function, the input array is modified to: \\[1,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[1,0,2,3,0,4,5,0]",
                "output": "[1,0,0,2,3,0,0,4]"
            },
            {
                "input": "[1,2,3]",
                "output": "[1,2,3]"
            }
        ],
        "java": "\n    ```java\npublic void duplicateZeros(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] == 0) {\n            for (int j = n - 1; j > i + 1; --j) {\n                arr[j] = arr[j - 1];\n            }\n            arr[++i] = 0;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "python": "\n    ```python\ndef duplicateZeros(arr):\n    n = len(arr)\n    i = 0\n    while i < n - 1:\n        if arr[i] == 0:\n            for j in range(n - 1, i + 1, -1):\n                arr[j] = arr[j - 1]\n            arr[i + 1] = 0\n            i += 1\n        i += 1\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "c++": "\n    ```cpp\nvoid duplicateZeros(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] == 0) {\n            for (int j = n - 1; j > i + 1; --j) {\n                arr[j] = arr[j - 1];\n            }\n            arr[++i] = 0;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "js": "\n    ```javascript\nfunction duplicateZeros(arr) {\n    const n = arr.length;\n    for (let i = 0; i < n - 1; ++i) {\n        if (arr[i] === 0) {\n            for (let j = n - 1; j > i + 1; --j) {\n                arr[j] = arr[j - 1];\n            }\n            arr[++i] = 0;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    "
    },
    {
        "id": 209,
        "title": "Distribute Candies to People",
        "difficulty": "Easy",
        "content": {
            "problem": "We distribute some number of `candies`, to a row of **`n = num_people`** people in the following way:\n\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give `n` candies to the last person.\n\nThen, we go back to the start of the row, giving `n + 1` candies to the first person, `n + 2` candies to the second person, and so on until we give `2 * n` candies to the last person.\n\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\n\nReturn an array (of length `num_people` and sum `candies`) that represents the final distribution of candies.",
            "examples": [
                "**Example 1:**\n\n**Input:** candies = 7, num\\_people = 4\n**Output:** \\[1,2,3,1\\]\n**Explanation:**\nOn the first turn, ans\\[0\\] += 1, and the array is \\[1,0,0,0\\].\nOn the second turn, ans\\[1\\] += 2, and the array is \\[1,2,0,0\\].\nOn the third turn, ans\\[2\\] += 3, and the array is \\[1,2,3,0\\].\nOn the fourth turn, ans\\[3\\] += 1 (because there is only one candy left), and the final array is \\[1,2,3,1\\].\n\n",
                "**Example 2:**\n\n**Input:** candies = 10, num\\_people = 3\n**Output:** \\[5,2,3\\]\n**Explanation:** \nOn the first turn, ans\\[0\\] += 1, and the array is \\[1,0,0\\].\nOn the second turn, ans\\[1\\] += 2, and the array is \\[1,2,0\\].\nOn the third turn, ans\\[2\\] += 3, and the array is \\[1,2,3\\].\nOn the fourth turn, ans\\[0\\] += 4, and the final array is \\[5,2,3\\]."
            ],
            "constraints": "**Constraints:**\n\n*   1 <= candies <= 10^9\n*   1 <= num\\_people <= 1000",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "7,4",
                "output": "[1,2,3,1]"
            },
            {
                "input": "10,3",
                "output": "[5,2,3]"
            }
        ],
        "java": "\n    ```java\npublic int[] distributeCandies(int candies, int num_people) {\n    int[] result = new int[num_people];\n    int i = 0, count = 1;\n\n    while (candies > 0) {\n        result[i % num_people] += Math.min(candies, count);\n        candies -= count;\n        count++;\n        i++;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "python": "\n    ```python\ndef distribute_candies(candies, num_people):\n    result = [0] * num_people\n    i = 0\n    count = 1\n\n    while candies > 0:\n        result[i % num_people] += min(candies, count)\n        candies -= count\n        count += 1\n        i += 1\n\n    return result\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> distributeCandies(int candies, int num_people) {\n    std::vector<int> result(num_people, 0);\n    int i = 0, count = 1;\n\n    while (candies > 0) {\n        result[i % num_people] += std::min(candies, count);\n        candies -= count;\n        count++;\n        i++;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "js": "\n    ```javascript\nfunction distributeCandies(candies, num_people) {\n    const result = new Array(num_people).fill(0);\n    let i = 0, count = 1;\n\n    while (candies > 0) {\n        result[i % num_people] += Math.min(candies, count);\n        candies -= count;\n        count++;\n        i++;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    "
    },
    {
        "id": 210,
        "title": "Defanging an IP Address",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a valid (IPv4) IP `address`, return a defanged version of that IP address.\n\nA _defanged IP address_ replaces every period `\". \"` with `\"[.] \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** address = \"1.1.1.1\"\n**Output:** \"1\\[.\\]1\\[.\\]1\\[.\\]1\"\n\n",
                "**Example 2:**\n\n**Input:** address = \"255.100.50.0\"\n**Output:** \"255\\[.\\]100\\[.\\]50\\[.\\]0\""
            ],
            "constraints": "**Constraints:**\n\n*   The given `address` is a valid IPv4 address.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"1.1.1.1\"",
                "output": "\"1[.]1[.]1[.]1\""
            },
            {
                "input": "\"255.100.50.0\"",
                "output": "\"255[.]100[.]50[.]0\""
            }
        ],
        "java": "\n    ```java\npublic String defangIPaddr(String address) {\n    StringBuilder defanged = new StringBuilder();\n    for (char c : address.toCharArray()) {\n        if (c == '.')\n            defanged.append(\"[.]\");\n        else\n            defanged.append(c);\n    }\n    return defanged.toString();\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "python": "\n    ```python\ndef defangIPaddr(address: str) -> str:\n    return address.replace('.', '[.]')\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring defangIPaddr(string address) {\n    string defanged = \"\";\n    for (char c : address) {\n        if (c == '.')\n            defanged += \"[.]\";\n        else\n            defanged += c;\n    }\n    return defanged;\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "js": "\n    ```javascript\nfunction defangIPaddr(address) {\n    return address.split('.').join('[.]');\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    "
    },
    {
        "id": 211,
        "title": "Relative Sort Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n\nSort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that do not appear in `arr2` should be placed at the end of `arr1` in **ascending** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[2,3,1,3,2,4,6,7,9,2,19\\], arr2 = \\[2,1,4,3,9,6\\]\n**Output:** \\[2,2,2,1,4,3,3,9,6,7,19\\]\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[28,6,22,8,44,17\\], arr2 = \\[22,28,8,6\\]\n**Output:** \\[22,28,8,6,17,44\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 1000`\n*   `0 <= arr1[i], arr2[i] <= 1000`\n*   All the elements of `arr2` are **distinct**.\n*   Each `arr2[i]` is in `arr1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting Sort"
        ],
        "example": [
            {
                "input": "[2,3,1,3,2,4,6,7,9,2,19],[2,1,4,3,9,6]",
                "output": "[2,2,2,1,4,3,3,9,6,7,19]"
            },
            {
                "input": "[28,6,22,8,44,17],[22,28,8,6]",
                "output": "[22,28,8,6,17,44]"
            }
        ],
        "java": "\n    ```java\npublic String longestDupSubstring(String s) {\n    int n = s.length();\n    String longest_duplicate = \"\";\n    for (int length = n - 1; length > 0; --length) {\n        for (int i = 0; i <= n - length; ++i) {\n            String substring = s.substring(i, i + length);\n            if (s.indexOf(substring, i + 1) != -1) {\n                longest_duplicate = substring;\n                return longest_duplicate;\n            }\n        }\n    }\n    return longest_duplicate;\n}\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "python": "\n    ```python\ndef longest_dup_substring(s):\n    n = len(s)\n    longest_duplicate = \"\"\n    for length in range(n - 1, 0, -1):\n        for i in range(n - length + 1):\n            substring = s[i:i + length]\n            if s.find(substring, i + 1) != -1:\n                longest_duplicate = substring\n                return longest_duplicate\n    return longest_duplicate\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string longestDupSubstring(std::string s) {\n    int n = s.length();\n    std::string longest_duplicate;\n    for (int length = n - 1; length > 0; --length) {\n        for (int i = 0; i <= n - length; ++i) {\n            std::string substring = s.substr(i, length);\n            if (s.find(substring, i + 1) != std::string::npos) {\n                longest_duplicate = substring;\n                return longest_duplicate;\n            }\n        }\n    }\n    return longest_duplicate;\n}\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "js": "\n    ```javascript\nfunction longestDupSubstring(s) {\n    const n = s.length;\n    let longest_duplicate = \"\";\n    for (let length = n - 1; length > 0; --length) {\n        for (let i = 0; i <= n - length; ++i) {\n            const substring = s.substring(i, i + length);\n            if (s.indexOf(substring, i + 1) !== -1) {\n                longest_duplicate = substring;\n                return longest_duplicate;\n            }\n        }\n    }\n    return longest_duplicate;\n}\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    "
    },
    {
        "id": 212,
        "title": "Number of Equivalent Domino Pairs",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a list of `dominoes`, `dominoes[i] = [a, b]` is **equivalent to** `dominoes[j] = [c, d]` if and only if either (`a == c` and `b == d`), or (`a == d` and `b == c`) - that is, one domino can be rotated to be equal to another domino.\n\nReturn _the number of pairs_ `(i, j)` _for which_ `0 <= i < j < dominoes.length`_, and_ `dominoes[i]` _is **equivalent to**_ `dominoes[j]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** dominoes = \\[\\[1,2\\],\\[2,1\\],\\[3,4\\],\\[5,6\\]\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** dominoes = \\[\\[1,2\\],\\[1,2\\],\\[1,1\\],\\[1,2\\],\\[2,2\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= dominoes.length <= 4 * 104`\n*   `dominoes[i].length == 2`\n*   `1 <= dominoes[i][j] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[[1,2],[2,1],[3,4],[5,6]]",
                "output": "1"
            },
            {
                "input": "[[1,2],[1,2],[1,1],[1,2],[2,2]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic String removeDuplicates(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == c) {\n            sb.setLength(sb.length() - 1);\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "python": "\n    ```python\ndef remove_duplicates(s: str) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1] == c:\n            stack.pop()\n        else:\n            stack.append(c)\n    return \"\".join(stack)\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string removeDuplicates(std::string s) {\n    std::stack<char> st;\n    for (char c : s) {\n        if (!st.empty() && st.top() == c) {\n            st.pop();\n        } else {\n            st.push(c);\n        }\n    }\n    \n    std::string result;\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "js": "\n    ```javascript\nfunction removeDuplicates(s) {\n    const stack = [];\n    for (const c of s) {\n        if (stack.length > 0 && stack[stack.length - 1] === c) {\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n    return stack.join('');\n}\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    "
    },
    {
        "id": 213,
        "title": "N-th Tribonacci Number",
        "difficulty": "Easy",
        "content": {
            "problem": "The Tribonacci sequence Tn is defined as follows:\n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 4\n**Explanation:**\nT\\_3 = 0 + 1 + 1 = 2\nT\\_4 = 1 + 1 + 2 = 4\n\n",
                "**Example 2:**\n\n**Input:** n = 25\n**Output:** 1389537"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 37`\n*   The answer is guaranteed to fit within a 32-bit integer, ie. `answer <= 2^31 - 1`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "4",
                "output": "4"
            },
            {
                "input": "25",
                "output": "1389537"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int heightChecker(int[] heights) {\n    int[] expected = heights.clone();\n    Arrays.sort(expected);\n    int count = 0;\n    for (int i = 0; i < heights.length; i++) {\n        if (heights[i] != expected[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "python": "\n    ```python\ndef height_checker(heights):\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n    return count\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> expected = heights;\n    std::sort(expected.begin(), expected.end());\n    int count = 0;\n    for (size_t i = 0; i < heights.size(); i++) {\n        if (heights[i] != expected[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "js": "\n    ```javascript\nfunction heightChecker(heights) {\n    const studentsInTheWrongLine = heights\n        .slice()\n        .sort((a, b) => a - b)\n        .reduce((count, height, idx) => {\n            return height === heights[idx] ? count : count + 1;\n        }, 0);\n\n    return studentsInTheWrongLine;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    "
    },
    {
        "id": 214,
        "title": "Day of the Year",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `date` representing a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) date formatted as `YYYY-MM-DD`, return _the day number of the year_.",
            "examples": [
                "**Example 1:**\n\n**Input:** date =  \"2019-01-09 \"\n**Output:** 9\n**Explanation:** Given date is the 9th day of the year in 2019.\n\n",
                "**Example 2:**\n\n**Input:** date =  \"2019-02-10 \"\n**Output:** 41"
            ],
            "constraints": "**Constraints:**\n\n*   `date.length == 10`\n*   `date[4] == date[7] == '-'`, and all other `date[i]`'s are digits\n*   `date` represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"2019-01-09\"",
                "output": "9"
            },
            {
                "input": "\"2019-02-10\"",
                "output": "41"
            }
        ],
        "java": "\n    ```java\npublic int dayOfYear(String date) {\n    int[] daysInMonth = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int year = Integer.parseInt(date.substring(0, 4));\n    int month = Integer.parseInt(date.substring(5, 7));\n    int day = Integer.parseInt(date.substring(8, 10));\n\n    if (isLeapYear(year)) {\n        daysInMonth[1] = 29;\n    }\n\n    int result = 0;\n    for (int i = 0; i < month - 1; ++i) {\n        result += daysInMonth[i];\n    }\n\n    return result + day;\n}\n\npublic boolean isLeapYear(int year) {\n    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n}\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "python": "\n    ```python\ndef is_leap_year(year: int) -> bool:\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef day_of_year(date: str) -> int:\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    year, month, day = int(date[:4]), int(date[5:7]), int(date[8:])\n\n    if is_leap_year(year):\n        days_in_month[1] = 29\n\n    return sum(days_in_month[:month-1]) + day\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool is_leap_year(int year) {\n    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n}\n\nint day_of_year(string date) {\n    vector<int> days_in_month = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int year = stoi(date.substr(0, 4));\n    int month = stoi(date.substr(5, 2));\n    int day = stoi(date.substr(8, 2));\n    \n    if (is_leap_year(year)) {\n        days_in_month[1] = 29;\n    }\n\n    int result = 0;\n    for (int i = 0; i < month - 1; ++i) {\n        result += days_in_month[i];\n    }\n\n    return result + day;\n}\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "js": "\n    ```javascript\nfunction isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\nfunction dayOfYear(date) {\n    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var year = parseInt(date.substr(0, 4));\n    var month = parseInt(date.substr(5, 2));\n    var day = parseInt(date.substr(8, 2));\n    \n    if (isLeapYear(year)) {\n        daysInMonth[1] = 29;\n    }\n\n    var result = 0;\n    for (var i = 0; i < month - 1; ++i) {\n        result += daysInMonth[i];\n    }\n    \n    return result + day;\n}\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    "
    },
    {
        "id": 215,
        "title": "Find Words That Can Be Formed by Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of strings `words` and a string `chars`.\n\nA string is **good** if it can be formed by characters from chars (each character can only be used once).\n\nReturn _the sum of lengths of all good strings in words_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"bt \", \"hat \", \"tree \"\\], chars =  \"atach \"\n**Output:** 6\n**Explanation:** The strings that can be formed are  \"cat \" and  \"hat \" so the answer is 3 + 3 = 6.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"hello \", \"world \", \"leetcode \"\\], chars =  \"welldonehoneyr \"\n**Output:** 10\n**Explanation:** The strings that can be formed are  \"hello \" and  \"world \" so the answer is 5 + 5 = 10."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length, chars.length <= 100`\n*   `words[i]` and `chars` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"cat\",\"bt\",\"hat\",\"tree\"],\"atach\"",
                "output": "6"
            },
            {
                "input": "[\"hello\",\"world\",\"leetcode\"],\"welldonehoneyr\"",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int numTilePossibilities(String tiles) {\n    int[] freq = new int[26];\n    for (char c : tiles.toCharArray()) {\n        freq[c - 'A']++;\n    }\n\n    return numTilePossibilities(freq);\n}\n\nprivate int numTilePossibilities(int[] freq) {\n    int result = 0;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) {\n            freq[i]--;\n            result += 1 + numTilePossibilities(freq);\n            freq[i]++;\n        }\n    }\n    return result;\n}\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "python": "\n    ```python\ndef num_tile_possibilities(tiles: str) -> int:\n    freq = [0] * 26\n    for c in tiles:\n        freq[ord(c) - ord('A')] += 1\n\n    def dfs(freq):\n        result = 0\n        for i in range(26):\n            if freq[i] > 0:\n                freq[i] -= 1\n                result += 1 + dfs(freq)\n                freq[i] += 1\n        return result\n\n    return dfs(freq)\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint numTilePossibilities(std::string tiles) {\n    std::vector<int> freq(26, 0);\n    for (char c : tiles) {\n        freq[c - 'A']++;\n    }\n\n    int result = 0;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i]) {\n            freq[i]--;\n            result += 1 + numTilePossibilities(tiles);\n            freq[i]++;\n        }\n    }\n    return result;\n}\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "js": "\n    ```javascript\nfunction numTilePossibilities(tiles) {\n    const freq = new Array(26).fill(0);\n    for (const c of tiles) {\n        freq[c.charCodeAt(0) - 'A'.charCodeAt(0)]++;\n    }\n\n    function dfs(freq) {\n        let result = 0;\n        for (let i = 0; i < 26; i++) {\n            if (freq[i] > 0) {\n                freq[i]--;\n                result += 1 + dfs(freq);\n                freq[i]++;\n            }\n        }\n        return result;\n    }\n\n    return dfs(freq);\n}\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    "
    },
    {
        "id": 216,
        "title": "Prime Arrangements",
        "difficulty": "Easy",
        "content": {
            "problem": "Return the number of permutations of 1 to `n` so that prime numbers are at prime indices (1-indexed.)\n\n_(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)_\n\nSince the answer may be large, return the answer **modulo `10^9 + 7`**.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 12\n**Explanation:** For example \\[1,2,5,4,3\\] is a valid permutation, but \\[5,2,3,4,1\\] is not because the prime number 5 is at index 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 100\n**Output:** 682289015"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "5",
                "output": "12"
            },
            {
                "input": "100",
                "output": "682289015"
            }
        ],
        "java": "\n    ```java\npublic int numPrimeArrangements(int n) {\n    boolean[] isPrime = new boolean[n + 1];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i <= n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    \n    int primeCount = 0;\n    for (int i = 2; i <= n; i++) {\n        if (isPrime[i]) primeCount++;\n    }\n    int compositeCount = n - primeCount;\n    \n    long res = 1;\n    int MOD = 1000000007;\n    for (int i = 1; i <= primeCount; i++) {\n        res = res * i % MOD;\n    }\n    for (int i = 1; i <= compositeCount; i++) {\n        res = res * i % MOD;\n    }\n    return (int) res;\n}\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "python": "\n    ```python\ndef numPrimeArrangements(n: int) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = sum(1 for i in range(2, n + 1) if is_prime(i))\n    composite_count = n - prime_count\n\n    MOD = 10**9 + 7\n    res = 1\n    for i in range(1, prime_count + 1):\n        res = res * i % MOD\n    for i in range(1, composite_count + 1):\n        res = res * i % MOD\n\n    return res\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint numPrimeArrangements(int n) {\n    vector<bool> is_prime(n + 1, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i <= n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    int prime_count = 0;\n    for (int i = 2; i <= n; i++) {\n        if (is_prime[i]) prime_count++;\n    }\n    int composite_count = n - prime_count;\n    \n    long long res = 1;\n    for (int i = 1; i <= prime_count; i++) {\n        res = res * i % MOD;\n    }\n    for (int i = 1; i <= composite_count; i++) {\n        res = res * i % MOD;\n    }\n    return res;\n}\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "js": "\n    ```javascript\nfunction numPrimeArrangements(n) {\n    function isPrime(num) {\n        if (num < 2) return false;\n        for (let i = 2; i * i <= num; i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    }\n\n    let primeCount = 0;\n    for (let i = 2; i <= n; i++) {\n        if (isPrime(i)) primeCount++;\n    }\n    let compositeCount = n - primeCount;\n\n    const MOD = 10**9 + 7;\n    let res = 1;\n    for (let i = 1; i <= primeCount; i++) {\n        res = res * i % MOD;\n    }\n    for (let i = 1; i <= compositeCount; i++) {\n        res = res * i % MOD;\n    }\n\n    return res;\n}\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    "
    },
    {
        "id": 217,
        "title": "Distance Between Bus Stops",
        "difficulty": "Easy",
        "content": {
            "problem": "A bus has `n` stops numbered from `0` to `n - 1` that form a circle. We know the distance between all pairs of neighboring stops where `distance[i]` is the distance between the stops number `i` and `(i + 1) % n`.\n\nThe bus goes along both directions i.e. clockwise and counterclockwise.\n\nReturn the shortest distance between the given `start` and `destination` stops.",
            "examples": [
                "**Example 1:**\n\n**Input:** distance = \\[1,2,3,4\\], start = 0, destination = 1\n**Output:** 1\n**Explanation:** Distance between 0 and 1 is 1 or 9, minimum is 1.\n\n",
                "**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\], start = 0, destination = 2\n**Output:** 3\n**Explanation:** Distance between 0 and 2 is 3 or 7, minimum is 3.\n\n",
                "**Example 3:**\n\n**Input:** distance = \\[1,2,3,4\\], start = 0, destination = 3\n**Output:** 4\n**Explanation:** Distance between 0 and 3 is 6 or 4, minimum is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 10^4`\n*   `distance.length == n`\n*   `0 <= start, destination < n`\n*   `0 <= distance[i] <= 10^4`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,2,3,4],0,1",
                "output": "1"
            },
            {
                "input": "[1,2,3,4],0,2",
                "output": "3"
            },
            {
                "input": "[1,2,3,4],0,3",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic boolean carPooling(int[][] trips, int capacity) {\n    Map<Integer, Integer> stops = new TreeMap<>();\n    for (int[] t : trips) {\n        stops.put(t[1], stops.getOrDefault(t[1], 0) + t[0]);\n        stops.put(t[2], stops.getOrDefault(t[2], 0) - t[0]);\n    }\n    for (int passengers : stops.values()) {\n        capacity -= passengers;\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "python": "\n    ```python\ndef carPooling(trips, capacity):\n    stops = [0] * 1001\n    for num, start, end in trips:\n        stops[start] += num\n        stops[end] -= num\n    for i in stops:\n        capacity -= i\n        if capacity < 0:\n            return False\n    return True\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool carPooling(std::vector<std::vector<int>>& trips, int capacity) {\n    std::vector<int> stops(1001, 0);\n    for (const std::vector<int>& t : trips) {\n        stops[t[1]] += t[0];\n        stops[t[2]] -= t[0];\n    }\n    for (int i = 0; i < stops.size(); ++i) {\n        capacity -= stops[i];\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "js": "\n    ```javascript\nfunction carPooling(trips, capacity) {\n    const stops = new Array(1001).fill(0);\n    for (const [num, start, end] of trips) {\n        stops[start] += num;\n        stops[end] -= num;\n    }\n    for (const passengers of stops) {\n        capacity -= passengers;\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    "
    },
    {
        "id": 218,
        "title": "Day of the Week",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a date, return the corresponding day of the week for that date.\n\nThe input is given as three integers representing the `day`, `month` and `year` respectively.\n\nReturn the answer as one of the following values `{ \"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"}`.",
            "examples": [
                "**Example 1:**\n\n**Input:** day = 31, month = 8, year = 2019\n**Output:**  \"Saturday \"\n\n",
                "**Example 2:**\n\n**Input:** day = 18, month = 7, year = 1999\n**Output:**  \"Sunday \"\n\n",
                "**Example 3:**\n\n**Input:** day = 15, month = 8, year = 1993\n**Output:**  \"Sunday \""
            ],
            "constraints": "**Constraints:**\n\n*   The given dates are valid dates between the years `1971` and `2100`.",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "31,8,2019",
                "output": "\"Saturday\""
            },
            {
                "input": "18,7,1999",
                "output": "\"Sunday\""
            },
            {
                "input": "15,8,1993",
                "output": "\"Sunday\""
            }
        ],
        "java": "\n    ```java\nimport java.time.LocalDate;\n\npublic String dayOfTheWeek(int day, int month, int year) {\n    LocalDate date = LocalDate.of(year, month, day);\n    int dayOfWeekIndex = date.getDayOfWeek().getValue() % 7;\n    String[] days = {\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"};\n    return days[dayOfWeekIndex];\n}\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "python": "\n    ```python\ndef day_of_the_week(day, month, year):\n    from datetime import date\n    days = [\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"]\n    return days[date(year, month, day).weekday()]\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string dayOfTheWeek(int day, int month, int year) {\n    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    std::string week[] = {\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"};\n    if (year < 1971) year += (1971 - year) / 400 * 400;\n    int sum = -1;\n    for (int i = 1971; i < year; ++i) {\n        sum += 365;\n        if (i % 4 == 0 && (i % 100 != 0 || i % 400 == 0)) ++sum;\n    }\n    for (int i = 1; i < month; ++i) {\n        sum += days[i];\n        if (i == 2 && year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ++sum;\n    }\n    return week[(sum + day) % 7];\n}\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "js": "\n    ```javascript\nfunction dayOfTheWeek(day, month, year) {\n    let days = [\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"];\n    let date = new Date(year, month - 1, day);\n    return days[date.getDay()];\n}\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    "
    },
    {
        "id": 219,
        "title": "Maximum Number of Balloons",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `text`, you want to use the characters of `text` to form as many instances of the word **\"balloon \"** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"nlaebolko \"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** text =  \"loonbalxballpoon \"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** text =  \"leetcode \"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 104`\n*   `text` consists of lower case English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"nlaebolko\"",
                "output": "1"
            },
            {
                "input": "\"loonbalxballpoon\"",
                "output": "2"
            },
            {
                "input": "\"leetcode\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxNumberOfBalloons(String text) {\n    int[] letter_count = new int[5];\n    for (char c : text.toCharArray()) {\n        if (c == 'b') letter_count[0]++;\n        if (c == 'a') letter_count[1]++;\n        if (c == 'l') letter_count[2]++;\n        if (c == 'o') letter_count[3]++;\n        if (c == 'n') letter_count[4]++;\n    }\n    letter_count[2] /= 2;\n    letter_count[3] /= 2;\n    return Arrays.stream(letter_count).min().getAsInt();\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "python": "\n    ```python\ndef max_number_of_balloons(text: str) -> int:\n    letter_count = [0] * 5\n    for c in text:\n        if c == 'b': letter_count[0] += 1\n        if c == 'a': letter_count[1] += 1\n        if c == 'l': letter_count[2] += 1\n        if c == 'o': letter_count[3] += 1\n        if c == 'n': letter_count[4] += 1\n    letter_count[2] //= 2\n    letter_count[3] //= 2\n    return min(letter_count)\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "c++": "\n    ```cpp\nint maxNumberOfBalloons(string text) {\n    int letter_count[5] = {0};\n    for (char c : text) {\n        if (c == 'b') letter_count[0]++;\n        if (c == 'a') letter_count[1]++;\n        if (c == 'l') letter_count[2]++;\n        if (c == 'o') letter_count[3]++;\n        if (c == 'n') letter_count[4]++;\n    }\n    letter_count[2] /= 2;\n    letter_count[3] /= 2;\n    return *min_element(letter_count, letter_count + 5);\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberOfBalloons(text) {\n    const letter_count = [0, 0, 0, 0, 0];\n    for (let c of text) {\n        if (c === 'b') letter_count[0]++;\n        if (c === 'a') letter_count[1]++;\n        if (c === 'l') letter_count[2]++;\n        if (c === 'o') letter_count[3]++;\n        if (c === 'n') letter_count[4]++;\n    }\n    letter_count[2] = Math.floor(letter_count[2] / 2);\n    letter_count[3] = Math.floor(letter_count[3] / 2);\n    return Math.min(...letter_count);\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    "
    },
    {
        "id": 220,
        "title": "Minimum Absolute Difference",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of **distinct** integers `arr`, find all pairs of elements with the minimum absolute difference of any two elements.\n\nReturn a list of pairs in ascending order(with respect to pairs), each pair `[a, b]` follows\n\n*   `a, b` are from `arr`\n*   `a < b`\n*   `b - a` equals to the minimum absolute difference of any two elements in `arr`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[4,2,1,3\\]\n**Output:** \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Explanation:** The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,3,6,10,15\\]\n**Output:** \\[\\[1,3\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[3,8,-10,23,19,-4,-14,27\\]\n**Output:** \\[\\[-14,-10\\],\\[19,23\\],\\[23,27\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= arr.length <= 105`\n*   `-106 <= arr[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,2,1,3]",
                "output": "[[1,2],[2,3],[3,4]]"
            },
            {
                "input": "[1,3,6,10,15]",
                "output": "[[1,3]]"
            },
            {
                "input": "[3,8,-10,23,19,-4,-14,27]",
                "output": "[[-14,-10],[19,23],[23,27]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> minimumAbsDifference(int[] arr) {\n    Arrays.sort(arr);\n    int minDiff = Integer.MAX_VALUE;\n    for (int i = 1; i < arr.length; i++) {\n        minDiff = Math.min(minDiff, arr[i] - arr[i - 1]);\n    }\n\n    List<List<Integer>> result = new ArrayList<>();\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] - arr[i - 1] == minDiff) {\n            result.add(Arrays.asList(arr[i - 1], arr[i]));\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array in ascending order.\n2. Iterate through the sorted array and find the minimum absolute difference between adjacent elements. This value will be the minimum difference between any two elements in the array.\n3. Iterate through the sorted array again and construct the output list by adding pairs of elements with an absolute difference equal to the minimum difference found in step 2.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef minimumAbsDifference(arr: List[int]) -> List[List[int]]:\n    arr.sort()\n    min_diff = min(arr[i] - arr[i - 1] for i in range(1, len(arr)))\n\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == min_diff:\n            result.append([arr[i - 1], arr[i]])\n\n    return result\n```\n    \n    1. Sort the input array in ascending order.\n2. Iterate through the sorted array and find the minimum absolute difference between adjacent elements. This value will be the minimum difference between any two elements in the array.\n3. Iterate through the sorted array again and construct the output list by adding pairs of elements with an absolute difference equal to the minimum difference found in step 2.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n    sort(arr.begin(), arr.end());\n    int minDiff = INT_MAX;\n    for (int i = 1; i < arr.size(); i++) {\n        minDiff = min(minDiff, arr[i] - arr[i - 1]);\n    }\n\n    vector<vector<int>> result;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] - arr[i - 1] == minDiff) {\n            result.push_back({arr[i - 1], arr[i]});\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array in ascending order.\n2. Iterate through the sorted array and find the minimum absolute difference between adjacent elements. This value will be the minimum difference between any two elements in the array.\n3. Iterate through the sorted array again and construct the output list by adding pairs of elements with an absolute difference equal to the minimum difference found in step 2.\n    ",
        "js": "\n    ```javascript\nfunction minimumAbsDifference(arr) {\n    arr.sort((a, b) => a - b);\n    let minDiff = Infinity;\n    for (let i = 1; i < arr.length; i++) {\n        minDiff = Math.min(minDiff, arr[i] - arr[i - 1]);\n    }\n\n    const result = [];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] - arr[i - 1] === minDiff) {\n            result.push([arr[i - 1], arr[i]]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array in ascending order.\n2. Iterate through the sorted array and find the minimum absolute difference between adjacent elements. This value will be the minimum difference between any two elements in the array.\n3. Iterate through the sorted array again and construct the output list by adding pairs of elements with an absolute difference equal to the minimum difference found in step 2.\n    "
    },
    {
        "id": 221,
        "title": "Unique Number of Occurrences",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, return `true` _if the number of occurrences of each value in the array is **unique** or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,2,2,1,1,3\\]\n**Output:** true\n**Explanation:** The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[-3,0,1,-3,1,1,1,-3,10,0\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `-1000 <= arr[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2,2,1,1,3]",
                "output": "true"
            },
            {
                "input": "[1,2]",
                "output": "false"
            },
            {
                "input": "[-3,0,1,-3,1,1,1,-3,10,0]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<TreeNode> delNodes(TreeNode root, int[] to_delete) {\n    List<TreeNode> forest = new ArrayList<>();\n    Set<Integer> toDelete = new HashSet<>();\n    for (int val : to_delete) {\n        toDelete.add(val);\n    }\n    helper(root, true, toDelete, forest);\n    return forest;\n}\n\nprivate TreeNode helper(TreeNode node, boolean isRoot, Set<Integer> toDelete, List<TreeNode> forest) {\n    if (node == null) return null;\n    boolean deleted = toDelete.contains(node.val);\n    if (isRoot && !deleted) forest.add(node);\n    node.left = helper(node.left, deleted, toDelete, forest);\n    node.right = helper(node.right, deleted, toDelete, forest);\n    return deleted ? null : node;\n}\n```\n\n    \n    The algorithm performs a post-order traversal, visiting each node of the tree. It starts with the root of the tree and checks whether it's a root node or not. If it's a root node, it adds the node to the forest; otherwise, it continues traversal. Left and right children are updated for each node. If a node's value is found in the `to_delete` list, this function returns nullptr (Python: None, JavaScript: null, Java: null) otherwise, it returns the current node. This way, the tree nodes will be combined with their new parents after the deletion, and the forest will have the roots of the disjoint trees.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef delNodes(root, to_delete):\n    forest = []\n    to_delete_set = set(to_delete)\n    helper(root, True, to_delete_set, forest)\n    return forest\n\ndef helper(node, isRoot, to_delete, forest):\n    if not node:\n        return None\n    deleted = node.val in to_delete\n    if isRoot and not deleted:\n        forest.append(node)\n    node.left = helper(node.left, deleted, to_delete, forest)\n    node.right = helper(node.right, deleted, to_delete, forest)\n    return None if deleted else node\n```\n\n    \n    The algorithm performs a post-order traversal, visiting each node of the tree. It starts with the root of the tree and checks whether it's a root node or not. If it's a root node, it adds the node to the forest; otherwise, it continues traversal. Left and right children are updated for each node. If a node's value is found in the `to_delete` list, this function returns nullptr (Python: None, JavaScript: null, Java: null) otherwise, it returns the current node. This way, the tree nodes will be combined with their new parents after the deletion, and the forest will have the roots of the disjoint trees.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <memory>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstd::vector<TreeNode*> delNodes(TreeNode* root, std::vector<int>& to_delete) {\n    std::vector<TreeNode*> forest;\n    std::set<int> toDelete(to_delete.begin(), to_delete.end());\n    helper(root, true, toDelete, forest);\n    return forest;\n}\n\nTreeNode* helper(TreeNode* node, bool isRoot, std::set<int>& toDelete, std::vector<TreeNode*>& forest) {\n    if (!node) return nullptr;\n    bool deleted = toDelete.count(node->val);\n    if (isRoot && !deleted) forest.push_back(node);\n    node->left = helper(node->left, deleted, toDelete, forest);\n    node->right = helper(node->right, deleted, toDelete, forest);\n    return deleted ? nullptr : node;\n}\n```\n\n    \n    The algorithm performs a post-order traversal, visiting each node of the tree. It starts with the root of the tree and checks whether it's a root node or not. If it's a root node, it adds the node to the forest; otherwise, it continues traversal. Left and right children are updated for each node. If a node's value is found in the `to_delete` list, this function returns nullptr (Python: None, JavaScript: null, Java: null) otherwise, it returns the current node. This way, the tree nodes will be combined with their new parents after the deletion, and the forest will have the roots of the disjoint trees.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction delNodes(root, to_delete) {\n    const forest = [];\n    const toDeleteSet = new Set(to_delete);\n    helper(root, true, toDeleteSet, forest);\n    return forest;\n}\n\nfunction helper(node, isRoot, toDelete, forest) {\n    if (!node) return null;\n    const deleted = toDelete.has(node.val);\n    if (isRoot && !deleted) forest.push(node);\n    node.left = helper(node.left, deleted, toDelete, forest);\n    node.right = helper(node.right, deleted, toDelete, forest);\n    return deleted ? null : node;\n}\n```\n\n    \n    The algorithm performs a post-order traversal, visiting each node of the tree. It starts with the root of the tree and checks whether it's a root node or not. If it's a root node, it adds the node to the forest; otherwise, it continues traversal. Left and right children are updated for each node. If a node's value is found in the `to_delete` list, this function returns nullptr (Python: None, JavaScript: null, Java: null) otherwise, it returns the current node. This way, the tree nodes will be combined with their new parents after the deletion, and the forest will have the roots of the disjoint trees.\n    "
    },
    {
        "id": 222,
        "title": "Minimum Cost to Move Chips to The Same Position",
        "difficulty": "Easy",
        "content": {
            "problem": "We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.",
            "examples": [
                "**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n",
                "**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n",
                "**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "1"
            },
            {
                "input": "[2,2,2,3,3]",
                "output": "2"
            },
            {
                "input": "[1,1000000000]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic void sortArray(int[] arr1, int[] arr2) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n\n    for (int num : arr1) {\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\n    }\n\n    int index = 0;\n    for (int num : arr2) {\n        while (counts.get(num) > 0) {\n            arr1[index++] = num;\n            counts.put(num, counts.get(num) - 1);\n        }\n    }\n\n    Arrays.sort(arr1, index, arr1.length);\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "python": "\n    ```python\ndef sort_array(arr1, arr2):\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n#include <algorithm>\n\nvoid sortArray(vector<int>& arr1, vector<int>& arr2) {\n    map<int, int> counts;\n\n    for (int num : arr1) {\n        counts[num]++;\n    }\n    int index = 0;\n    for (int num : arr2) {\n        while (counts[num]--) {\n            arr1[index++] = num;\n        }\n    }\n    for (auto &pair : counts) {\n        while (pair.second--) {\n            arr1[index++] = pair.first;\n        }\n    }\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "js": "\n    ```javascript\nfunction sortArray(arr1, arr2) {\n    const counts = new Map();\n\n    for (const num of arr1) {\n        counts.set(num, (counts.get(num) || 0) + 1);\n    }\n\n    const result = [];\n\n    for (const num of arr2) {\n        while (counts.get(num) > 0) {\n            result.push(num);\n            counts.set(num, counts.get(num) - 1);\n        }\n    }\n\n    Array.from(counts.entries())\n        .sort(([a], [b]) => a - b)\n        .forEach(([num, count]) => {\n            while (count--) {\n                result.push(num);\n            }\n        });\n\n    return result;\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    "
    },
    {
        "id": 223,
        "title": "Split a String in Balanced Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "**Balanced** strings are those that have an equal quantity of `'L'` and `'R'` characters.\n\nGiven a **balanced** string `s`, split it into some number of substrings such that:\n\n*   Each substring is balanced.\n\nReturn _the **maximum** number of balanced strings you can obtain._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"RLRRLLRLRL \"\n**Output:** 4\n**Explanation:** s can be split into  \"RL \",  \"RRLL \",  \"RL \",  \"RL \", each substring contains same number of 'L' and 'R'.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"RLRRRLLRLL \"\n**Output:** 2\n**Explanation:** s can be split into  \"RL \",  \"RRRLLRLL \", each substring contains same number of 'L' and 'R'.\nNote that s cannot be split into  \"RL \",  \"RR \",  \"RL \",  \"LR \",  \"LL \", because the 2nd and 5th substrings are not balanced.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LLLLRRRR \"\n**Output:** 1\n**Explanation:** s can be split into  \"LLLLRRRR \"."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 1000`\n*   `s[i]` is either `'L'` or `'R'`.\n*   `s` is a **balanced** string.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Counting"
        ],
        "example": [
            {
                "input": "\"RLRRLLRLRL\"",
                "output": "4"
            },
            {
                "input": "\"RLRRRLLRLL\"",
                "output": "2"
            },
            {
                "input": "\"LLLLRRRR\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findSpecialInteger(int[] arr) {\n    int n = arr.length, requiredCount = n / 4;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "python": "\n    ```python\ndef find_special_integer(arr):\n    n = len(arr)\n    required_count = n // 4\n    for i in range(n):\n        if arr[i] == arr[i + required_count]:\n            return arr[i]\n    return -1\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "c++": "\n    ```cpp\nint findSpecialInteger(const vector<int>& arr) {\n    int n = arr.size(), requiredCount = n / 4;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "js": "\n    ```javascript\nfunction findSpecialInteger(arr) {\n    let n = arr.length, requiredCount = Math.floor(n / 4);\n    for (let i = 0; i < n; i++) {\n        if (arr[i] === arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    "
    },
    {
        "id": 224,
        "title": "Check If It Is a Straight Line",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane.",
            "examples": [
                "**Example 1:**\n\n**Input:** coordinates = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[6,7\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** coordinates = \\[\\[1,1\\],\\[2,2\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[7,7\\]\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= coordinates.length <= 1000`\n*   `coordinates[i].length == 2`\n*   `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`\n*   `coordinates` contains no duplicate point.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]",
                "output": "true"
            },
            {
                "input": "[[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int findBestValue(int[] arr, int target) {\n    int left = 0;\n    int right = 0;\n    for (int num : arr) {\n        right = Math.max(right, num);\n    }\n    int result = -1;\n    int min_diff = Integer.MAX_VALUE;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int sum = 0;\n        for (int num : arr) {\n            sum += Math.min(num, mid);\n        }\n        if (sum == target) {\n            return mid;\n        }\n        else if (sum > target) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n        if (Math.abs(target - sum) < min_diff || Math.abs(target - sum) == min_diff && mid < result) {\n            min_diff = Math.abs(target - sum);\n            result = mid;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "python": "\n    ```python\ndef findBestValue(arr, target):\n    left = 0\n    right = max(arr)\n    result = -1\n    min_diff = float('inf')\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        total_sum = sum(min(x, mid) for x in arr)\n        if total_sum == target:\n            return mid\n        elif total_sum > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n        if abs(target - total_sum) < min_diff or (\n                abs(target - total_sum) == min_diff and mid < result):\n            min_diff = abs(target - total_sum)\n            result = mid\n\n    return result\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "c++": "\n    ```cpp\nint findBestValue(vector<int>& arr, int target) {\n    int left = 0;\n    int right = *max_element(arr.begin(), arr.end());\n    int result, min_diff = INT_MAX;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int sum = 0;\n        for (int num : arr) {\n            sum += min(num, mid);\n        }\n        if (sum == target) {\n            return mid;\n        }\n        else if (sum > target) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n        if (abs(target - sum) < min_diff || abs(target - sum) == min_diff && mid < result) {\n            min_diff = abs(target - sum);\n            result = mid;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "js": "\n    ```javascript\nfunction findBestValue(arr, target) {\n    let left = 0;\n    let right = Math.max(...arr);\n    let result = -1;\n    let min_diff = Infinity;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        let sum = 0;\n        for (let num of arr) {\n            sum += Math.min(num, mid);\n        }\n        if (sum === target) {\n            return mid;\n        }\n        else if (sum > target) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n        if (Math.abs(target - sum) < min_diff || (Math.abs(target - sum) === min_diff && mid < result)) {\n            min_diff = Math.abs(target - sum);\n            result = mid;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    "
    },
    {
        "id": 225,
        "title": "Cells with Odd Values in a Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "There is an `m x n` matrix that is initialized to all `0`'s. There is also a 2D array `indices` where each `indices[i] = [ri, ci]` represents a **0-indexed location** to perform some increment operations on the matrix.\n\nFor each location `indices[i]`, do **both** of the following:\n\n1.  Increment **all** the cells on row `ri`.\n2.  Increment **all** the cells on column `ci`.\n\nGiven `m`, `n`, and `indices`, return _the **number of odd-valued cells** in the matrix after applying the increment to all locations in_ `indices`.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 2, n = 3, indices = \\[\\[0,1\\],\\[1,1\\]\\]\n**Output:** 6\n**Explanation:** Initial matrix = \\[\\[0,0,0\\],\\[0,0,0\\]\\].\nAfter applying first increment it becomes \\[\\[1,2,1\\],\\[0,1,0\\]\\].\nThe final matrix is \\[\\[1,3,1\\],\\[1,3,1\\]\\], which contains 6 odd numbers.\n\n",
                "**Example 2:**\n\n**Input:** m = 2, n = 2, indices = \\[\\[1,1\\],\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** Final matrix = \\[\\[2,2\\],\\[2,2\\]\\]. There are no odd numbers in the final matrix."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 50`\n*   `1 <= indices.length <= 100`\n*   `0 <= ri < m`\n*   `0 <= ci < n`\n\n**",
            "follow_up": "Follow up:** Could you solve this in `O(n + m + indices.length)` time with only `O(n + m)` extra space?"
        },
        "tag": [
            "Array",
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "2,3,[[0,1],[1,1]]",
                "output": "6"
            },
            {
                "input": "2,2,[[1,1],[0,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic String breakPalindrome(String palindrome) {\n    int n = palindrome.length();\n    if (n < 2) return \"\";\n    \n    char[] arr = palindrome.toCharArray();\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != 'a') {\n            arr[i] = 'a';\n            return new String(arr);\n        }\n    }\n    \n    arr[n - 1] = 'b';\n    return new String(arr);\n}\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "python": "\n    ```python\ndef break_palindrome(palindrome: str) -> str:\n    n = len(palindrome)\n    if n < 2:\n        return \"\"\n    \n    palindrome = list(palindrome)\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            palindrome[i] = 'a'\n            return \"\".join(palindrome)\n    \n    palindrome[-1] = 'b'\n    return \"\".join(palindrome)\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string breakPalindrome(std::string palindrome) {\n    int n = palindrome.size();\n    if (n < 2) return \"\";\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (palindrome[i] != 'a') {\n            palindrome[i] = 'a';\n            return palindrome;\n        }\n    }\n    \n    palindrome[n - 1] = 'b';\n    return palindrome;\n}\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "js": "\n    ```javascript\nfunction breakPalindrome(palindrome) {\n    const n = palindrome.length;\n    if (n < 2) return \"\";\n    \n    let arr = palindrome.split(\"\");\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        if (arr[i] !== 'a') {\n            arr[i] = 'a';\n            return arr.join(\"\");\n        }\n    }\n    \n    arr[n - 1] = 'b';\n    return arr.join(\"\");\n}\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    "
    },
    {
        "id": 226,
        "title": "Shift 2D Grid",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a 2D `grid` of size `m x n` and an integer `k`. You need to shift the `grid` `k` times.\n\nIn one shift operation:\n\n*   Element at `grid[i][j]` moves to `grid[i][j + 1]`.\n*   Element at `grid[i][n - 1]` moves to `grid[i + 1][0]`.\n*   Element at `grid[m - 1][n - 1]` moves to `grid[0][0]`.\n\nReturn the _2D grid_ after applying shift operation `k` times.",
            "examples": [
                "**Example 1:**\n\n**Input:** `grid` = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 1\n**Output:** \\[\\[9,1,2\\],\\[3,4,5\\],\\[6,7,8\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** `grid` = \\[\\[3,8,1,9\\],\\[19,7,2,5\\],\\[4,6,11,10\\],\\[12,0,21,13\\]\\], k = 4\n**Output:** \\[\\[12,0,21,13\\],\\[3,8,1,9\\],\\[19,7,2,5\\],\\[4,6,11,10\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** `grid` = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 9\n**Output:** \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 50`\n*   `1 <= n <= 50`\n*   `-1000 <= grid[i][j] <= 1000`\n*   `0 <= k <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]],1",
                "output": "[[9,1,2],[3,4,5],[6,7,8]]"
            },
            {
                "input": "[[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]],4",
                "output": "[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]"
            },
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]],9",
                "output": "[[1,2,3],[4,5,6],[7,8,9]]"
            }
        ],
        "java": "\n    ```java\npublic int dayOfYear(String date) {\n    int year = Integer.parseInt(date.substring(0, 4));\n    int month = Integer.parseInt(date.substring(5, 7));\n    int day = Integer.parseInt(date.substring(8, 10));\n\n    int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n        daysInMonth[2] = 29;\n    }\n\n    int dayOfYear = 0;\n    for (int i = 1; i < month; i++) {\n        dayOfYear += daysInMonth[i];\n    }\n    dayOfYear += day;\n\n    return dayOfYear;\n}\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "python": "\n    ```python\ndef dayOfYear(date: str) -> int:\n    year, month, day = map(int, date.split('-'))\n\n    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        daysInMonth[2] = 29\n\n    dayOfYear = sum(daysInMonth[:month]) + day\n    return dayOfYear\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "c++": "\n    ```cpp\nint dayOfYear(std::string date) {\n    int year = stoi(date.substr(0, 4));\n    int month = stoi(date.substr(5, 2));\n    int day = stoi(date.substr(8, 2));\n\n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n        daysInMonth[2] = 29;\n    }\n\n    int dayOfYear = 0;\n    for (int i = 1; i < month; ++i) {\n        dayOfYear += daysInMonth[i];\n    }\n    dayOfYear += day;\n\n    return dayOfYear;\n}\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "js": "\n    ```javascript\nfunction dayOfYear(date) {\n    let [year, month, day] = date.split('-').map(x => parseInt(x, 10));\n\n    let daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n        daysInMonth[2] = 29;\n    }\n\n    let dayOfYear = 0;\n    for (let i = 1; i < month; i++) {\n        dayOfYear += daysInMonth[i];\n    }\n    dayOfYear += day;\n\n    return dayOfYear;\n}\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    "
    },
    {
        "id": 227,
        "title": "Minimum Time Visiting All Points",
        "difficulty": "Easy",
        "content": {
            "problem": "On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`.\n\nYou can move according to these rules:\n\n*   In `1` second, you can either:\n    *   move vertically by one unit,\n    *   move horizontally by one unit, or\n    *   move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).\n*   You have to visit the points in the same order as they appear in the array.\n*   You are allowed to pass through points that appear later in the order, but these do not count as visits.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,4\\],\\[-1,0\\]\\]\n**Output:** 7\n**Explanation:** One optimal path is **\\[1,1\\]** -> \\[2,2\\] -> \\[3,3\\] -> **\\[3,4\\]** \\-> \\[2,3\\] -> \\[1,2\\] -> \\[0,1\\] -> **\\[-1,0\\]**   \nTime from \\[1,1\\] to \\[3,4\\] = 3 seconds \nTime from \\[3,4\\] to \\[-1,0\\] = 4 seconds\nTotal time = 7 seconds\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[3,2\\],\\[-2,2\\]\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `points.length == n`\n*   `1 <= n <= 100`\n*   `points[i].length == 2`\n*   `-1000 <= points[i][0], points[i][1] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,1],[3,4],[-1,0]]",
                "output": "7"
            },
            {
                "input": "[[3,2],[-2,2]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minTimeToVisitAllPoints(int[][] points) {\n    int time = 0;\n    for (int i = 1; i < points.length; i++) {\n        int dx = Math.abs(points[i][0] - points[i - 1][0]);\n        int dy = Math.abs(points[i][1] - points[i - 1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "python": "\n    ```python\ndef minTimeToVisitAllPoints(points):\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i - 1][0])\n        dy = abs(points[i][1] - points[i - 1][1])\n        time += max(dx, dy)\n    return time\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "c++": "\n    ```cpp\nint minTimeToVisitAllPoints(vector<vector<int>>& points) {\n    int time = 0;\n    for (int i = 1; i < points.size(); i++) {\n        int dx = abs(points[i][0] - points[i - 1][0]);\n        int dy = abs(points[i][1] - points[i - 1][1]);\n        time += max(dx, dy);\n    }\n    return time;\n}\n```\n\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "js": "\n    ```javascript\nfunction minTimeToVisitAllPoints(points) {\n    let time = 0;\n    for (let i = 1; i < points.length; i++) {\n        let dx = Math.abs(points[i][0] - points[i - 1][0]);\n        let dy = Math.abs(points[i][1] - points[i - 1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    "
    },
    {
        "id": 228,
        "title": "Find Winner on a Tic Tac Toe Game",
        "difficulty": "Easy",
        "content": {
            "problem": "**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The rules of Tic-Tac-Toe are:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player `A` always places `'X'` characters, while the second player `B` always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never on filled ones.\n*   The game ends when there are **three** of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi, coli]` indicates that the `ith` move will be played on `grid[rowi][coli]`. return _the winner of the game if it exists_ (`A` or `B`). In case the game ends in a draw return `\"Draw \"`. If there are still movements to play return `\"Pending \"`.\n\nYou can assume that `moves` is valid (i.e., it follows the rules of **Tic-Tac-Toe**), the grid is initially empty, and `A` will play first.",
            "examples": [
                "**Example 1:**\n\n**Input:** moves = \\[\\[0,0\\],\\[2,0\\],\\[1,1\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:**  \"A \"\n**Explanation:** A wins, they always play first.\n\n",
                "**Example 2:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[0,1\\],\\[0,2\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:**  \"B \"\n**Explanation:** B wins.\n\n",
                "**Example 3:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\],\\[1,0\\],\\[1,2\\],\\[2,1\\],\\[0,1\\],\\[0,2\\],\\[2,2\\]\\]\n**Output:**  \"Draw \"\n**Explanation:** The game ends in a draw since there are no moves to make."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= moves.length <= 9`\n*   `moves[i].length == 2`\n*   `0 <= rowi, coli <= 2`\n*   There are no repeated elements on `moves`.\n*   `moves` follow the rules of tic tac toe.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[0,0],[2,0],[1,1],[2,1],[2,2]]",
                "output": "\"A\""
            },
            {
                "input": "[[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]",
                "output": "\"B\""
            },
            {
                "input": "[[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]",
                "output": "\"Draw\""
            }
        ],
        "java": "\n    ```java\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\n    int[] parent = new int[n];\n    Arrays.fill(parent, -1);\n    for (int i = 0; i < n; i++) {\n        if (leftChild[i] != -1) {\n            if (parent[leftChild[i]] != -1) return false;\n            parent[leftChild[i]] = i;\n        }\n        if (rightChild[i] != -1) {\n            if (parent[rightChild[i]] != -1) return false;\n            parent[rightChild[i]] = i;\n        }\n    }\n    int root = -1;\n    for (int i = 0; i < n; i++) {\n        if (parent[i] == -1) {\n            if (root != -1) return false;\n            root = i;\n        }\n    }\n    return root != -1;\n}\n```\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "python": "\n    ```python\ndef validateBinaryTreeNodes(n, leftChild, rightChild):\n    parent = [-1] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            if parent[leftChild[i]] != -1:\n                return False\n            parent[leftChild[i]] = i\n        if rightChild[i] != -1:\n            if parent[rightChild[i]] != -1:\n                return False\n            parent[rightChild[i]] = i\n    \n    root = -1\n    for i in range(n):\n        if parent[i] == -1:\n            if root != -1:\n                return False\n            root = i\n\n    return root != -1\n```\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "c++": "\n    ```cpp\nbool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n    vector<int> parent(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (leftChild[i] != -1) {\n            if (parent[leftChild[i]] != -1) return false;\n            parent[leftChild[i]] = i;\n        }\n        if (rightChild[i] != -1) {\n            if (parent[rightChild[i]] != -1) return false;\n            parent[rightChild[i]] = i;\n        }\n    }\n    int root = -1;\n    for (int i = 0; i < n; ++i) {\n        if (parent[i] == -1) {\n            if (root != -1) return false;\n            root = i;\n        }\n    }\n    return root != -1;\n}\n```\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "js": "\n    ```javascript\nfunction validateBinaryTreeNodes(n, leftChild, rightChild) {\n    const parent = new Array(n).fill(-1);\n    for (let i = 0; i < n; i++) {\n        if (leftChild[i] !== -1) {\n            if (parent[leftChild[i]] !== -1) return false;\n            parent[leftChild[i]] = i;\n        }\n        if (rightChild[i] !== -1) {\n            if (parent[rightChild[i]] !== -1) return false;\n            parent[rightChild[i]] = i;\n        }\n    }\n    let root = -1;\n    for (let i = 0; i < n; i++) {\n        if (parent[i] === -1) {\n            if (root !== -1) return false;\n            root = i;\n        }\n    }\n    return root !== -1;\n}\n```\n\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    "
    },
    {
        "id": 229,
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer number `n`, return the difference between the product of its digits and the sum of its digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 234\n**Output:** 15 \n**Explanation:** \nProduct of digits = 2 \\* 3 \\* 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15\n\n",
                "**Example 2:**\n\n**Input:** n = 4421\n**Output:** 21\n**Explanation:** \nProduct of digits = 4 \\* 4 \\* 2 \\* 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 10^5`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "234",
                "output": "15"
            },
            {
                "input": "4421",
                "output": "21"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Boolean> canMakePaliQueries(String s, int[][] queries) {\n    List<Boolean> result = new ArrayList<>();\n    for (int[] query : queries) {\n        int left = query[0], right = query[1], k = query[2];\n        int[] count = new int[26];\n        for (int i = left; i <= right; i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        int odd_count = 0;\n        for (int i = 0; i < 26; i++) {\n            odd_count += count[i] % 2;\n        }\n        result.add(odd_count / 2 <= k);\n    }\n    return result;\n}\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "python": "\n    ```python\ndef can_make_pali_queries(s, queries):\n    result = []\n    for left, right, k in queries:\n        count = [0] * 26\n        for i in range(left, right + 1):\n            count[ord(s[i]) - ord('a')] += 1\n        odd_count = sum(c % 2 for c in count)\n        result.append(odd_count // 2 <= k)\n    return result\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<bool> canMakePaliQueries(std::string s, std::vector<std::vector<int>>& queries) {\n    std::vector<bool> result;\n    for (auto& query : queries) {\n        int left = query[0], right = query[1], k = query[2];\n        int count[26] = {0};\n        for (int i = left; i <= right; i++) {\n            count[s[i] - 'a']++;\n        }\n        int odd_count = 0;\n        for (int i = 0; i < 26; i++) {\n            odd_count += count[i] % 2;\n        }\n        result.push_back(odd_count / 2 <= k);\n    }\n    return result;\n}\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "js": "\n    ```javascript\nfunction canMakePaliQueries(s, queries) {\n    const result = [];\n    for (const query of queries) {\n        const [left, right, k] = query;\n        const count = Array(26).fill(0);\n        for (let i = left; i <= right; i++) {\n            count[s.charCodeAt(i) - 97]++;\n        }\n        const odd_count = count.reduce((acc, val) => acc + (val % 2), 0);\n        result.push(Math.floor(odd_count / 2) <= k);\n    }\n    return result;\n}\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    "
    },
    {
        "id": 230,
        "title": "Convert Binary Number in a Linked List to Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Given `head` which is a reference node to a singly-linked list. The value of each node in the linked list is either `0` or `1`. The linked list holds the binary representation of a number.\n\nReturn the _decimal value_ of the number in the linked list.\n\nThe **most significant bit** is at the head of the linked list.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,0,1\\]\n**Output:** 5\n**Explanation:** (101) in base 2 = (5) in base 10\n\n",
                "**Example 2:**\n\n**Input:** head = \\[0\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   The Linked List is not empty.\n*   Number of nodes will not exceed `30`.\n*   Each node's value is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Math"
        ],
        "example": [
            {
                "input": "[1,0,1]",
                "output": "5"
            },
            {
                "input": "[0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] arr1, int[] arr2) {\n    int n = arr1.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    for (int a : arr2) {\n        int[] new_dp = new int[n];\n        Arrays.fill(new_dp, Integer.MAX_VALUE);\n        int p = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a < arr1[i]) new_dp[i] = p;\n            if (i > 0 && dp[i - 1] < p) p = dp[i - 1];\n            if (arr1[i] > arr1[i + 1]) return -1;\n        }\n        dp = new_dp;\n    }\n    return dp[n - 1];\n}\n```\n    \n    1. Initialize a `dp` array with the same length as `arr1`, fill it with `infinity`.\n2. Loop through each element in `arr2` (as `a`).\n3. At each iteration, create a new `dp` array called `new_dp`.\n4. Use a variable `p` to track the minimum number of operations needed to make the subarray `arr1[0:i]` strictly increasing.\n5. Loop through each element in `arr1` (as `i`).\n6. If `a` is smaller than the current element in `arr1`, update `new_dp[i]` with the minimum operations `p`.\n7. If we are not at the first element and `dp[i-1]` is smaller than the current minimum operations, update `p`.\n8. Check if the current element is greater than the next one, if so return -1 (impossible to create an increasing array).\n9. After iterating all elements in `arr1`, swap `dp` with `new_dp`.\n10. Finally, return the last element in the `dp` array (minimum operations needed to make the entire arr1 strictly increasing).\n    ",
        "python": "\n    ```python\ndef min_operations(arr1, arr2):\n    n = len(arr1)\n    dp = [float('inf')] * n\n    for a in arr2:\n        new_dp = [float('inf')] * n\n        p = 0\n        for i in range(n):\n            if a < arr1[i]:\n                new_dp[i] = p\n            if i > 0 and dp[i - 1] < p:\n                p = dp[i - 1]\n            if arr1[i] > arr1[i + 1]:\n                return -1\n        dp = new_dp\n    return dp[-1]\n```\n    \n    1. Initialize a `dp` array with the same length as `arr1`, fill it with `infinity`.\n2. Loop through each element in `arr2` (as `a`).\n3. At each iteration, create a new `dp` array called `new_dp`.\n4. Use a variable `p` to track the minimum number of operations needed to make the subarray `arr1[0:i]` strictly increasing.\n5. Loop through each element in `arr1` (as `i`).\n6. If `a` is smaller than the current element in `arr1`, update `new_dp[i]` with the minimum operations `p`.\n7. If we are not at the first element and `dp[i-1]` is smaller than the current minimum operations, update `p`.\n8. Check if the current element is greater than the next one, if so return -1 (impossible to create an increasing array).\n9. After iterating all elements in `arr1`, swap `dp` with `new_dp`.\n10. Finally, return the last element in the `dp` array (minimum operations needed to make the entire arr1 strictly increasing).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\n\nint minOperations(std::vector<int>& arr1, std::vector<int>& arr2) {\n    int n = arr1.size();\n    std::vector<int> dp(n, std::numeric_limits<int>::max());\n    for (int a : arr2) {\n        std::vector<int> new_dp(n, std::numeric_limits<int>::max());\n        int p = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a < arr1[i]) new_dp[i] = p;\n            if (i > 0 && dp[i - 1] < p) p = dp[i - 1];\n            if (arr1[i] > arr1[i + 1]) return -1;\n        }\n        dp.swap(new_dp);\n    }\n    return dp.back();\n}\n```\n    \n    1. Initialize a `dp` array with the same length as `arr1`, fill it with `infinity`.\n2. Loop through each element in `arr2` (as `a`).\n3. At each iteration, create a new `dp` array called `new_dp`.\n4. Use a variable `p` to track the minimum number of operations needed to make the subarray `arr1[0:i]` strictly increasing.\n5. Loop through each element in `arr1` (as `i`).\n6. If `a` is smaller than the current element in `arr1`, update `new_dp[i]` with the minimum operations `p`.\n7. If we are not at the first element and `dp[i-1]` is smaller than the current minimum operations, update `p`.\n8. Check if the current element is greater than the next one, if so return -1 (impossible to create an increasing array).\n9. After iterating all elements in `arr1`, swap `dp` with `new_dp`.\n10. Finally, return the last element in the `dp` array (minimum operations needed to make the entire arr1 strictly increasing).\n    ",
        "js": "\n    ```javascript\nfunction minOperations(arr1, arr2) {\n    const n = arr1.length;\n    const dp = new Array(n).fill(Number.MAX_VALUE);\n    for (const a of arr2) {\n        const new_dp = new Array(n).fill(Number.MAX_VALUE);\n        let p = 0;\n        for (let i = 0; i < n; i++) {\n            if (a < arr1[i]) new_dp[i] = p;\n            if (i > 0 && dp[i - 1] < p) p = dp[i - 1];\n            if (arr1[i] > arr1[i + 1]) return -1;\n        }\n        dp.splice(0, dp.length, ...new_dp);\n    }\n    return dp[n - 1];\n}\n```\n    \n    1. Initialize a `dp` array with the same length as `arr1`, fill it with `infinity`.\n2. Loop through each element in `arr2` (as `a`).\n3. At each iteration, create a new `dp` array called `new_dp`.\n4. Use a variable `p` to track the minimum number of operations needed to make the subarray `arr1[0:i]` strictly increasing.\n5. Loop through each element in `arr1` (as `i`).\n6. If `a` is smaller than the current element in `arr1`, update `new_dp[i]` with the minimum operations `p`.\n7. If we are not at the first element and `dp[i-1]` is smaller than the current minimum operations, update `p`.\n8. Check if the current element is greater than the next one, if so return -1 (impossible to create an increasing array).\n9. After iterating all elements in `arr1`, swap `dp` with `new_dp`.\n10. Finally, return the last element in the `dp` array (minimum operations needed to make the entire arr1 strictly increasing).\n    "
    },
    {
        "id": 231,
        "title": "Find Numbers with Even Number of Digits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of integers, return how many of them contain an **even number** of digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[12,345,2,6,7896\\]\n**Output:** 2\n**Explanation:** \n12 contains 2 digits (even number of digits). \n345 contains 3 digits (odd number of digits). \n2 contains 1 digit (odd number of digits). \n6 contains 1 digit (odd number of digits). \n7896 contains 4 digits (even number of digits). \nTherefore only 12 and 7896 contain an even number of digits.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[555,901,482,1771\\]\n**Output:** 1 \n**Explanation:** \nOnly 1771 contains an even number of digits."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 500`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[12,345,2,6,7896]",
                "output": "2"
            },
            {
                "input": "[555,901,482,1771]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nint minPerimeter(int neededApples) {\n    int layer = 0;\n    int apples = 0;\n\n    while (apples < neededApples) {\n        layer++;\n        apples += 12 * layer;\n    }\n\n    return 8 * layer;\n}\n```\n    \n    To solve this problem, we will start at the center of the garden (0, 0) and expand outwards in layers. Each new layer will enclose a new set of trees, and the number of apples in each tree can be calculated using the formula |i| + |j|. We keep track of the total apples acquired and continue expanding outwards until we have at least the number of apples needed (neededApples).\n\nSince there are 4 corners in the square corresponding to each axis-aligned square plot, and each layer adds 2 trees per corner, we have a total of 8 trees added per layer. Thus, the perimeter added when expanding each layer is 8 units. \n\nIn each layer, we have 12 * layer of apples (this comes from calculating the number of apples added in each side of the square when expanding outwards, which forms a pattern).\n\nThe algorithm works as follows:\n1. Initialize layer to 0 and apples to 0\n2. While apples is less than neededApples, increment layer and add 12 * layer apples to the current count.\n3. Return 8 * layer as the perimeter, as each layer increases the perimeter by 8 units.\n\nThis solution has a linear time complexity with respect to the number of apples needed.\n    ",
        "python": "\n    ```python\ndef min_perimeter(neededApples):\n    layer = 0\n    apples = 0\n\n    while apples < neededApples:\n        layer += 1\n        apples += 12 * layer\n\n    return 8 * layer\n```\n    \n    To solve this problem, we will start at the center of the garden (0, 0) and expand outwards in layers. Each new layer will enclose a new set of trees, and the number of apples in each tree can be calculated using the formula |i| + |j|. We keep track of the total apples acquired and continue expanding outwards until we have at least the number of apples needed (neededApples).\n\nSince there are 4 corners in the square corresponding to each axis-aligned square plot, and each layer adds 2 trees per corner, we have a total of 8 trees added per layer. Thus, the perimeter added when expanding each layer is 8 units. \n\nIn each layer, we have 12 * layer of apples (this comes from calculating the number of apples added in each side of the square when expanding outwards, which forms a pattern).\n\nThe algorithm works as follows:\n1. Initialize layer to 0 and apples to 0\n2. While apples is less than neededApples, increment layer and add 12 * layer apples to the current count.\n3. Return 8 * layer as the perimeter, as each layer increases the perimeter by 8 units.\n\nThis solution has a linear time complexity with respect to the number of apples needed.\n    ",
        "c++": "\n    ```cpp\nint min_perimeter(int neededApples) {\n    int layer = 0;\n    int apples = 0;\n\n    while (apples < neededApples) {\n        layer++;\n        apples += 12 * layer;\n    }\n\n    return 8 * layer;\n}\n```\n    \n    To solve this problem, we will start at the center of the garden (0, 0) and expand outwards in layers. Each new layer will enclose a new set of trees, and the number of apples in each tree can be calculated using the formula |i| + |j|. We keep track of the total apples acquired and continue expanding outwards until we have at least the number of apples needed (neededApples).\n\nSince there are 4 corners in the square corresponding to each axis-aligned square plot, and each layer adds 2 trees per corner, we have a total of 8 trees added per layer. Thus, the perimeter added when expanding each layer is 8 units. \n\nIn each layer, we have 12 * layer of apples (this comes from calculating the number of apples added in each side of the square when expanding outwards, which forms a pattern).\n\nThe algorithm works as follows:\n1. Initialize layer to 0 and apples to 0\n2. While apples is less than neededApples, increment layer and add 12 * layer apples to the current count.\n3. Return 8 * layer as the perimeter, as each layer increases the perimeter by 8 units.\n\nThis solution has a linear time complexity with respect to the number of apples needed.\n    ",
        "js": "\n    ```javascript\nfunction minPerimeter(neededApples) {\n    let layer = 0;\n    let apples = 0;\n\n    while (apples < neededApples) {\n        layer++;\n        apples += 12 * layer;\n    }\n\n    return 8 * layer;\n}\n```\n    \n    To solve this problem, we will start at the center of the garden (0, 0) and expand outwards in layers. Each new layer will enclose a new set of trees, and the number of apples in each tree can be calculated using the formula |i| + |j|. We keep track of the total apples acquired and continue expanding outwards until we have at least the number of apples needed (neededApples).\n\nSince there are 4 corners in the square corresponding to each axis-aligned square plot, and each layer adds 2 trees per corner, we have a total of 8 trees added per layer. Thus, the perimeter added when expanding each layer is 8 units. \n\nIn each layer, we have 12 * layer of apples (this comes from calculating the number of apples added in each side of the square when expanding outwards, which forms a pattern).\n\nThe algorithm works as follows:\n1. Initialize layer to 0 and apples to 0\n2. While apples is less than neededApples, increment layer and add 12 * layer apples to the current count.\n3. Return 8 * layer as the perimeter, as each layer increases the perimeter by 8 units.\n\nThis solution has a linear time complexity with respect to the number of apples needed.\n    "
    },
    {
        "id": 232,
        "title": "Replace Elements with Greatest Element on Right Side",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `arr`, replace every element in that array with the greatest element among the elements to its right, and replace the last element with `-1`.\n\nAfter doing so, return the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[17,18,5,4,6,1\\]\n**Output:** \\[18,6,6,6,1,-1\\]\n**Explanation:** \n- index 0 --> the greatest element to the right of index 0 is index 1 (18).\n- index 1 --> the greatest element to the right of index 1 is index 4 (6).\n- index 2 --> the greatest element to the right of index 2 is index 4 (6).\n- index 3 --> the greatest element to the right of index 3 is index 4 (6).\n- index 4 --> the greatest element to the right of index 4 is index 5 (1).\n- index 5 --> there are no elements to the right of index 5, so we put -1.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[400\\]\n**Output:** \\[-1\\]\n**Explanation:** There are no elements to the right of index 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `1 <= arr[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[17,18,5,4,6,1]",
                "output": "[18,6,6,6,1,-1]"
            },
            {
                "input": "[400]",
                "output": "[-1]"
            }
        ],
        "java": "\n    ```java\npublic int kConcatenationMaxSum(int[] arr, int k) {\n    int M = 1_000_000_007;\n    long sum = 0, maxSum = 0, curMax = 0;\n    for (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n        curMax = Math.max(arr[i], curMax + arr[i]);\n        maxSum = Math.max(maxSum, curMax);\n    }\n    if (k == 1) return (int)(maxSum % M);\n    long twoConcatenation = 0, twoConcatenationMax = 0;\n    for (int i = 0; i < 2 * arr.length; i++) {\n        twoConcatenation = Math.max(arr[i % arr.length], twoConcatenation + arr[i % arr.length]);\n        twoConcatenationMax = Math.max(twoConcatenationMax, twoConcatenation);\n    }\n    return (int)(Math.max(Math.max(maxSum, twoConcatenationMax + (k - 2) * Math.max(0, sum)), 0) % M);\n}\n```\n    \n    1. Calculate the sum of the array elements.\n2. Find the maximum subarray sum using Kadane's algorithm in a single array.\n3. If k is 1, return the maximum subarray sum from the single array.\n4. Concatenate the array twice and find the maximum subarray sum, considering that the subarray can go over the boundaries.\n5. Calculate the final maximum sum by considering the maximum subarray found in the two concatenated arrays, plus the sum of arrays multiplied by (k - 2), if the sum is positive.\n6. Return the maximum sum modulo 1,000,000,007.\n    ",
        "python": "\n    ```python\ndef kConcatenationMaxSum(arr, k):\n    M = 10**9 + 7\n    s = sum(arr)\n    max_sum = max_ending_here = 0\n    for i in range(len(arr) * min(2, k)):\n        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])\n        max_sum = max(max_sum, max_ending_here)\n    return 0 if k == 1 else (((max_sum - max_ending_here) % M) * (k - 2) % M + max_ending_here) % M\n```\n    \n    1. Calculate the sum of the array elements.\n2. Find the maximum subarray sum using Kadane's algorithm in a single array.\n3. If k is 1, return the maximum subarray sum from the single array.\n4. Concatenate the array twice and find the maximum subarray sum, considering that the subarray can go over the boundaries.\n5. Calculate the final maximum sum by considering the maximum subarray found in the two concatenated arrays, plus the sum of arrays multiplied by (k - 2), if the sum is positive.\n6. Return the maximum sum modulo 1,000,000,007.\n    ",
        "c++": "\n    ```cpp\nint kConcatenationMaxSum(vector<int>& arr, int k) {\n    int M = 1e9 + 7;\n    long long sum = 0, maxSum = 0, curMax = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        sum += arr[i];\n        curMax = max(arr[i], curMax + arr[i]);\n        maxSum = max(maxSum, curMax);\n    }\n    if (k == 1) return maxSum % M;\n    long long twoConcatenation = 0, twoConcatenationMax = 0;\n    for (int i = 0; i < 2 * arr.size(); i++) {\n        twoConcatenation = max((long long)arr[i % arr.size()], twoConcatenation + arr[i % arr.size()]);\n        twoConcatenationMax = max(twoConcatenationMax, twoConcatenation);\n    }\n    return max({maxSum, twoConcatenationMax + (k - 2) * max(0LL, sum)}) % M;\n}\n```\n    \n    1. Calculate the sum of the array elements.\n2. Find the maximum subarray sum using Kadane's algorithm in a single array.\n3. If k is 1, return the maximum subarray sum from the single array.\n4. Concatenate the array twice and find the maximum subarray sum, considering that the subarray can go over the boundaries.\n5. Calculate the final maximum sum by considering the maximum subarray found in the two concatenated arrays, plus the sum of arrays multiplied by (k - 2), if the sum is positive.\n6. Return the maximum sum modulo 1,000,000,007.\n    ",
        "js": "\n    ```javascript\nfunction kConcatenationMaxSum(arr, k) {\n    const M = 1_000_000_007;\n    let sum = 0, maxSum = 0, curMax = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum += arr[i];\n        curMax = Math.max(arr[i], curMax + arr[i]);\n        maxSum = Math.max(maxSum, curMax);\n    }\n    if (k === 1) return maxSum % M;\n    let twoConcatenation = 0, twoConcatenationMax = 0;\n    for (let i = 0; i < 2 * arr.length; i++) {\n        twoConcatenation = Math.max(arr[i % arr.length], twoConcatenation + arr[i % arr.length]);\n        twoConcatenationMax = Math.max(twoConcatenationMax, twoConcatenation);\n    }\n    return Math.max(Math.max(maxSum, twoConcatenationMax + (k - 2) * Math.max(0, sum)), 0) % M;\n}\n```\n    \n    1. Calculate the sum of the array elements.\n2. Find the maximum subarray sum using Kadane's algorithm in a single array.\n3. If k is 1, return the maximum subarray sum from the single array.\n4. Concatenate the array twice and find the maximum subarray sum, considering that the subarray can go over the boundaries.\n5. Calculate the final maximum sum by considering the maximum subarray found in the two concatenated arrays, plus the sum of arrays multiplied by (k - 2), if the sum is positive.\n6. Return the maximum sum modulo 1,000,000,007.\n    "
    },
    {
        "id": 233,
        "title": "Find N Unique Integers Sum up to Zero",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return **any** array containing `n` **unique** integers such that they add up to `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** \\[-7,-1,1,3,4\\]\n**Explanation:** These arrays also are accepted \\[-5,-1,1,2,3\\] , \\[-3,-1,2,-2,4\\].\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** \\[-1,0,1\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "5",
                "output": "[-7,-1,1,3,4]"
            },
            {
                "input": "3",
                "output": "[-1,0,1]"
            },
            {
                "input": "1",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic String longestHappyString(int a, int b, int c) {\n    StringBuilder res = new StringBuilder();\n    PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> y[0] - x[0]);\n\n    if (a > 0) pq.offer(new int[]{a, 'a'});\n    if (b > 0) pq.offer(new int[]{b, 'b'});\n    if (c > 0) pq.offer(new int[]{c, 'c'});\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        if (res.length() >= 2 && res.charAt(res.length() - 1) == curr[1] && res.charAt(res.length() - 2) == curr[1]) {\n            if (pq.isEmpty()) break;\n            int[] next = pq.poll();\n            res.append((char) next[1]);\n            if (--next[0] > 0) pq.offer(next);\n            pq.offer(curr);\n        } else {\n            res.append((char) curr[1]);\n            if (--curr[0] > 0) pq.offer(curr);\n        }\n    }\n\n    return res.toString();\n}\n```\n\n    \n    The algorithm uses a priority queue to track the count of each character, sorted in descending order. It then generates the happy string by greedily appending the character with the highest count, as long as it does not violate the \"no three consecutive characters\" rule. If this rule would be violated, it appends the character with the next highest count and puts the current character back in the queue to try later. This process is continued until the queue is empty, and the resulting string is the longest happy string.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef longestHappyString(a, b, c):\n    res = \"\"\n    pq = []\n    if a: heappush(pq, (-a, 'a'))\n    if b: heappush(pq, (-b, 'b'))\n    if c: heappush(pq, (-c, 'c'))\n\n    while pq:\n        curr = heappop(pq)\n        if len(res) >= 2 and res[-1] == curr[1] and res[-2] == curr[1]:\n            if not pq: break\n            next = heappop(pq)\n            res += next[1]\n            if next[0] < -1: heappush(pq, (next[0] + 1, next[1]))\n            heappush(pq, curr)\n        else:\n            res += curr[1]\n            if curr[0] < -1: heappush(pq, (curr[0] + 1, curr[1]))\n\n    return res\n```\n\n    \n    The algorithm uses a priority queue to track the count of each character, sorted in descending order. It then generates the happy string by greedily appending the character with the highest count, as long as it does not violate the \"no three consecutive characters\" rule. If this rule would be violated, it appends the character with the next highest count and puts the current character back in the queue to try later. This process is continued until the queue is empty, and the resulting string is the longest happy string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <queue>\n\nstd::string longestHappyString(int a, int b, int c) {\n    std::string res;\n    using CharCount = std::pair<int, char>;\n    std::priority_queue<CharCount> pq;\n    \n    if (a) pq.push({a, 'a'});\n    if (b) pq.push({b, 'b'});\n    if (c) pq.push({c, 'c'});\n\n    while (!pq.empty()) {\n        auto curr = pq.top(); pq.pop();\n        if (res.size() >= 2 && res[res.size() - 1] == curr.second && res[res.size() - 2] == curr.second) {\n            if (pq.empty()) break;\n            auto next = pq.top(); pq.pop();\n            res += next.second;\n            if (--next.first > 0) pq.push(next);\n            pq.push(curr);\n        } else {\n            res += curr.second;\n            if (--curr.first > 0) pq.push(curr);\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm uses a priority queue to track the count of each character, sorted in descending order. It then generates the happy string by greedily appending the character with the highest count, as long as it does not violate the \"no three consecutive characters\" rule. If this rule would be violated, it appends the character with the next highest count and puts the current character back in the queue to try later. This process is continued until the queue is empty, and the resulting string is the longest happy string.\n    ",
        "js": "\n    ```javascript\nfunction longestHappyString(a, b, c) {\n    let res = \"\";\n    let pq = [];\n\n    if (a) pq.push([-a, 'a']);\n    if (b) pq.push([-b, 'b']);\n    if (c) pq.push([-c, 'c']);\n\n    pq.sort((x, y) => x[0] - y[0]);\n\n    while (pq.length) {\n        let curr = pq.pop();\n        if (res.length >= 2 && res[res.length - 1] === curr[1] && res[res.length - 2] === curr[1]) {\n            if (!pq.length) break;\n            let next = pq.pop();\n            res += next[1];\n            if (next[0] < -1) pq.push([next[0] + 1, next[1]]);\n            pq.push(curr);\n        } else {\n            res += curr[1];\n            if (curr[0] < -1) pq.push([curr[0] + 1, curr[1]]);\n        }\n        pq.sort((x, y) => x[0] - y[0]);\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm uses a priority queue to track the count of each character, sorted in descending order. It then generates the happy string by greedily appending the character with the highest count, as long as it does not violate the \"no three consecutive characters\" rule. If this rule would be violated, it appends the character with the next highest count and puts the current character back in the queue to try later. This process is continued until the queue is empty, and the resulting string is the longest happy string.\n    "
    },
    {
        "id": 234,
        "title": "Decrypt String from Alphabet to Integer Mapping",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` formed by digits and `'#'`. We want to map `s` to English lowercase characters as follows:\n\n*   Characters (`'a'` to `'i'`) are represented by (`'1'` to `'9'`) respectively.\n*   Characters (`'j'` to `'z'`) are represented by (`'10#'` to `'26#'`) respectively.\n\nReturn _the string formed after mapping_.\n\nThe test cases are generated so that a unique mapping will always exist.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"10#11#12 \"\n**Output:**  \"jkab \"\n**Explanation:**  \"j \" ->  \"10# \" ,  \"k \" ->  \"11# \" ,  \"a \" ->  \"1 \" ,  \"b \" ->  \"2 \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"1326# \"\n**Output:**  \"acz \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of digits and the `'#'` letter.\n*   `s` will be a valid string such that mapping is always possible.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"10#11#12\"",
                "output": "\"jkab\""
            },
            {
                "input": "\"1326#\"",
                "output": "\"acz\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n    // Calculate outdegrees and dependencies for groups and items\n    int[] groupOutdegree = new int[m];\n    List<List<Integer>> groupEdges = new ArrayList<>(m);\n    for (int i = 0; i < m; i++) {\n        groupEdges.add(new ArrayList<>());\n    }\n\n    int[] itemOutdegree = new int[n];\n    List<List<Integer>> itemEdges = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n        itemEdges.add(new ArrayList<>());\n    }\n\n    for (int i = 0; i < group.length; i++) {\n        for (int dep : beforeItems.get(i)) {\n            int a = group[i], b = group[dep];\n            if (a != -1 && a != b && !(groupEdges.get(b).size() > 0 && groupEdges.get(b).get(groupEdges.get(b).size() - 1) == a)) {\n                groupEdges.get(b).add(a);\n                groupOutdegree[a]++;\n            }\n            if (a != b) {\n                itemEdges.get(dep).add(i);\n                itemOutdegree[i]++;\n            }\n        }\n    }\n\n    // Topological sort\n    List<Integer> groupOrder = topologicalSort(groupOutdegree, groupEdges);\n    if (groupOrder.size() < m) {\n        return new ArrayList<>();\n    }\n\n    List<Integer> itemOrder = topologicalSort(itemOutdegree, itemEdges);\n    if (itemOrder.size() < n) {\n        return new ArrayList<>();\n    }\n\n    // Combine orders\n    List<Integer> res = new ArrayList<>();\n    for (int gi : groupOrder) {\n        for (int idx : itemOrder) {\n            if (group[idx] == gi) {\n                res.add(idx);\n            }\n        }\n    }\n\n    return res;\n}\n\nprivate List<Integer>\ttopologicalSort(int[] outdegree, List<List<Integer>> edges) {\n    List<Integer> res = new ArrayList<>();\n    Deque<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < outdegree.length; i++) {\n        if (outdegree[i] == 0) {\n            queue.offerLast(i);\n        }\n    }\n\n    while (!queue.isEmpty()) {\n        int u = queue.pollLast();\n        res.add(u);\n\n        for (int v : edges.get(u)) {\n            if (--outdegree[v] == 0) {\n                queue.offerLast(v);\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n1. Calculate the outdegrees and edges for both the groups and the items based on their dependencies.\n2. Perform a topological sort on group dependencies and item dependencies separately. If the topological order of groups or items is not complete, return an empty list because we cannot find a valid solution.\n3. Combine the orders based on grouping. For each group in the order of groups, find the items belonging to that group from itemOrder and add it to the final result.\n4. Return the combined order as the final result.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef sortItems(n, m, group, beforeItems):\n    def topological_sort(outdegree, edges):\n        res = []\n        q = deque([i for i in range(len(outdegree)) if outdegree[i] == 0])\n        while q:\n            u = q.pop()\n            res.append(u)\n            for v in edges[u]:\n                outdegree[v] -= 1\n                if outdegree[v] == 0:\n                    q.append(v)\n        return res\n\n    # Calculate outdegrees and dependencies for groups and items\n    group_outdegree = [0] * m\n    group_edges = defaultdict(list)\n\n    item_outdegree = [0] * n\n    item_edges = defaultdict(list)\n\n    for i in range(n):\n        for dep in beforeItems[i]:\n            a, b = group[i], group[dep]\n            if a != -1 and a != b and not (group_edges[b] and group_edges[b][-1] == a):\n                group_edges[b].append(a)\n                group_outdegree[a] += 1\n            if a != b:\n                item_edges[dep].append(i)\n                item_outdegree[i] += 1\n\n    group_order = topological_sort(group_outdegree, group_edges)\n    if len(group_order) < m:\n        return []\n\n    item_order = topological_sort(item_outdegree, item_edges)\n    if len(item_order) < n:\n        return []\n\n    # Combine orders\n    res = [0] * n\n    idx = 0\n    for gi in group_order:\n        for item_idx in item_order:\n            if group[item_idx] == gi:\n                res[idx] = item_idx\n                idx += 1\n\n    return res\n```\n\n    \n    The algorithm consists of the following steps:\n1. Calculate the outdegrees and edges for both the groups and the items based on their dependencies.\n2. Perform a topological sort on group dependencies and item dependencies separately. If the topological order of groups or items is not complete, return an empty list because we cannot find a valid solution.\n3. Combine the orders based on grouping. For each group in the order of groups, find the items belonging to that group from itemOrder and add it to the final result.\n4. Return the combined order as the final result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sortItems(int n, int m, std::vector<int>& group, std::vector<std::vector<int>>& beforeItems) {\n    // Calculate outdegrees and dependencies for groups and items\n    std::vector<int> groupOutdegree(m, 0);\n    std::vector<std::vector<int>> groupEdges(m);\n    std::vector<int> itemOutdegree(n, 0);\n    std::vector<std::vector<int>> itemEdges(n);\n\n    for (int i = 0; i < group.size(); ++i) {\n        for (const int dep : beforeItems[i]) {\n            int a = group[i], b = group[dep];\n            if (a != -1 && a != b && !groupEdges[b].empty() && groupEdges[b].back() == a) {\n                groupEdges[b].push_back(a);\n                ++groupOutdegree[a];\n            }\n            if (a != b) {\n                itemEdges[dep].push_back(i);\n                ++itemOutdegree[i];\n            }\n        }\n    }\n\n    // Topological sort\n    auto topologicalSort = [](const std::vector<int>& outdegree, const std::vector<std::vector<int>>& edges) {\n        std::vector<int> res, q;\n        for (int i = 0; i < outdegree.size(); ++i)\n            if (outdegree[i] == 0)\n                q.push_back(i);\n\n        while (!q.empty()) {\n            int u = q.back();\n            q.pop_back();\n            res.push_back(u);\n\n            for (const int v : edges[u])\n                if (--const_cast<int&>(outdegree[v]) == 0)\n                    q.push_back(v);\n        }\n        return res;\n    };\n\n    std::vector<int> groupOrder = topologicalSort(groupOutdegree, groupEdges);\n    if (groupOrder.size() < m)\n        return {};\n\n    std::vector<int> itemOrder = topologicalSort(itemOutdegree, itemEdges);\n    if (itemOrder.size() < n)\n        return {};\n\n    // Combine orders\n    std::vector<int> res;\n    for (const int gi : groupOrder)\n        for (const int idx : itemOrder)\n            if (group[idx] == gi)\n                res.push_back(idx);\n\n    return res;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n1. Calculate the outdegrees and edges for both the groups and the items based on their dependencies.\n2. Perform a topological sort on group dependencies and item dependencies separately. If the topological order of groups or items is not complete, return an empty list because we cannot find a valid solution.\n3. Combine the orders based on grouping. For each group in the order of groups, find the items belonging to that group from itemOrder and add it to the final result.\n4. Return the combined order as the final result.\n    ",
        "js": "\n    ```javascript\nfunction sortItems(n, m, group, beforeItems) {\n  function topologicalSort(outdegree, edges) {\n    const res = [];\n    const q = [];\n    for (let i = 0; i < outdegree.length; i++) {\n      if (outdegree[i] === 0) q.push(i);\n    }\n    while (q.length) {\n      const u = q.pop();\n      res.push(u);\n      for (const v of edges.get(u)) {\n        outdegree[v]--;\n        if (outdegree[v] === 0) {\n          q.push(v);\n        }\n      }\n    }\n    return res;\n  }\n\n  // Calculate outdegrees and dependencies for groups and items\n  const groupOutdegree = new Array(m).fill(0);\n  const groupEdges = new Map(Array.from({length: m}, () => []));\n\n  const itemOutdegree = new Array(n).fill(0);\n  const itemEdges = new Map(Array.from({length: n}, () => []));\n\n  for (let i = 0; i < group.length; i++) {\n    for (const dep of beforeItems[i]) {\n      const a = group[i], b = group[dep];\n      if (a !== -1 && a !== b && !(groupEdges.get(b).length > 0 && groupEdges.get(b)[groupEdges.get(b).length - 1] === a)) {\n        groupEdges.get(b).push(a);\n        groupOutdegree[a]++;\n      }\n      if (a !== b) {\n        itemEdges.get(dep).push(i);\n        itemOutdegree[i]++;\n      }\n    }\n  }\n\n  const groupOrder = topologicalSort(groupOutdegree, groupEdges);\n  if (groupOrder.length < m) {\n    return [];\n  }\n\n  const itemOrder = topologicalSort(itemOutdegree, itemEdges);\n  if (itemOrder.length < n) {\n    return [];\n  }\n\n  // Combine orders\n  const res = [];\n  for (const gi of groupOrder) {\n    for (const idx of itemOrder) {\n      if (group[idx] === gi) {\n        res.push(idx);\n      }\n    }\n  }\n\n  return res;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n1. Calculate the outdegrees and edges for both the groups and the items based on their dependencies.\n2. Perform a topological sort on group dependencies and item dependencies separately. If the topological order of groups or items is not complete, return an empty list because we cannot find a valid solution.\n3. Combine the orders based on grouping. For each group in the order of groups, find the items belonging to that group from itemOrder and add it to the final result.\n4. Return the combined order as the final result.\n    "
    },
    {
        "id": 235,
        "title": "Decompress Run-Length Encoded List",
        "difficulty": "Easy",
        "content": {
            "problem": "We are given a list `nums` of integers representing a list compressed with run-length encoding.\n\nConsider each adjacent pair of elements `[freq, val] = [nums[2*i], nums[2*i+1]]` (with `i >= 0`). For each such pair, there are `freq` elements with value `val` concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.\n\nReturn the decompressed list.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[2,4,4,4\\]\n**Explanation:** The first pair \\[1,2\\] means we have freq = 1 and val = 2 so we generate the array \\[2\\].\nThe second pair \\[3,4\\] means we have freq = 3 and val = 4 so we generate \\[4,4,4\\].\nAt the end the concatenation \\[2\\] + \\[4,4,4\\] is \\[2,4,4,4\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,2,3\\]\n**Output:** \\[1,3,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 100`\n*   `nums.length % 2 == 0`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "[2,4,4,4]"
            },
            {
                "input": "[1,1,2,3]",
                "output": "[1,3,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    static final int MOD = (int) 1e9 + 7;\n\n    int addRooms(int idx, List<List<Integer>> children, int[] memo) {\n        if (children.get(idx).isEmpty()) return 1;\n\n        if (memo[idx] != -1) return memo[idx];\n\n        long res = 1;\n        int cnt = 0;\n        for (int child : children.get(idx)) {\n            cnt++;\n            res = (res * addRooms(child, children, memo)) % MOD;\n        }\n\n        for (int i = 2; i <= cnt; i++) {\n            res = (res * i) % MOD;\n        }\n\n        return memo[idx] = (int) res;\n    }\n\n    public int numOfWays(int[] prevRoom) {\n        int n = prevRoom.length;\n        List<List<Integer>> children = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            children.add(new ArrayList<>());\n        }\n        for (int i = 1; i < n; i++) {\n            children.get(prevRoom[i]).add(i);\n        }\n\n        int[] memo = new int[n];\n        Arrays.fill(memo, -1);\n        return addRooms(0, children, memo);\n    }\n}\n```\n    \n    1. Create a function addRooms that takes the room index, the array that stores the room dependencies (children), and the memoization array as inputs.\n2. If there are no dependencies for the current room, return 1.\n3. If the memoization array already has the result for the current room, return it.\n4. Calculate the number of ways to create the directly connected rooms with the current room. Multiplying the results is possible because each new room is created after the current room is completed. Apply the modulo operator at each step.\n5. Factorial of the number of directly connected rooms need to be multiplied since they can be constructed in any order. Apply the modulo operator at each step.\n6. Store the result in the memoization array.\n7. Call the addRooms function with room 0 and return the result.\n    ",
        "python": "\n    ```python\nMOD = 10**9 + 7\n\ndef add_rooms(idx, children, memo):\n    if not children[idx]:\n        return 1\n    if memo[idx] != -1:\n        return memo[idx]\n\n    res = 1\n    cnt = 0\n    for child in children[idx]:\n        cnt += 1\n        res = (res * add_rooms(child, children, memo)) % MOD\n    \n    for i in range(2, cnt + 1):\n        res = (res * i) % MOD\n    \n    memo[idx] = res\n    return res\n\ndef num_of_ways(prev_room):\n    n = len(prev_room)\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[prev_room[i]].append(i)\n\n    memo = [-1] * n\n    return add_rooms(0, children, memo)\n```\n    \n    1. Create a function addRooms that takes the room index, the array that stores the room dependencies (children), and the memoization array as inputs.\n2. If there are no dependencies for the current room, return 1.\n3. If the memoization array already has the result for the current room, return it.\n4. Calculate the number of ways to create the directly connected rooms with the current room. Multiplying the results is possible because each new room is created after the current room is completed. Apply the modulo operator at each step.\n5. Factorial of the number of directly connected rooms need to be multiplied since they can be constructed in any order. Apply the modulo operator at each step.\n6. Store the result in the memoization array.\n7. Call the addRooms function with room 0 and return the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint addRooms(int idx, const vector<vector<int>>& children, vector<int>& memo) {\n    if (children[idx].empty()) return 1;\n    \n    if (memo[idx] != -1) return memo[idx];\n    \n    long long res = 1;\n    int cnt = 0;\n    for (int child : children[idx]) {\n        cnt++;\n        res = (res * addRooms(child, children, memo)) % MOD;\n    }\n    \n    for (int i = 2; i <= cnt; i++) {\n        res = (res * i) % MOD;\n    }\n    \n    return memo[idx] = res;\n}\n\nint numOfWays(vector<int>& prevRoom) {\n    int n = prevRoom.size();\n    vector<vector<int>> children(n);\n    for (int i = 1; i < n; i++) {\n        children[prevRoom[i]].push_back(i);\n    }\n    \n    vector<int> memo(n, -1);\n    return addRooms(0, children, memo);\n}\n```\n    \n    1. Create a function addRooms that takes the room index, the array that stores the room dependencies (children), and the memoization array as inputs.\n2. If there are no dependencies for the current room, return 1.\n3. If the memoization array already has the result for the current room, return it.\n4. Calculate the number of ways to create the directly connected rooms with the current room. Multiplying the results is possible because each new room is created after the current room is completed. Apply the modulo operator at each step.\n5. Factorial of the number of directly connected rooms need to be multiplied since they can be constructed in any order. Apply the modulo operator at each step.\n6. Store the result in the memoization array.\n7. Call the addRooms function with room 0 and return the result.\n    ",
        "js": "\n    ```javascript\nconst MOD = 1e9 + 7;\n\nfunction addRooms(idx, children, memo) {\n    if (children[idx].length === 0) return 1;\n    if (memo[idx] !== -1) return memo[idx];\n\n    let res = 1;\n    let cnt = 0;\n    for (const child of children[idx]) {\n        cnt++;\n        res = (res * addRooms(child, children, memo)) % MOD;\n    }\n\n    for (let i = 2; i <= cnt; i++) {\n        res = (res * i) % MOD;\n    }\n\n    memo[idx] = res;\n    return res;\n}\n\nfunction numOfWays(prevRoom) {\n    const n = prevRoom.length;\n    const children = new Array(n).fill(0).map(() => []);\n    for (let i = 1; i < n; i++) {\n        children[prevRoom[i]].push(i);\n    }\n\n    const memo = new Array(n).fill(-1);\n    return addRooms(0, children, memo);\n}\n```\n    \n    1. Create a function addRooms that takes the room index, the array that stores the room dependencies (children), and the memoization array as inputs.\n2. If there are no dependencies for the current room, return 1.\n3. If the memoization array already has the result for the current room, return it.\n4. Calculate the number of ways to create the directly connected rooms with the current room. Multiplying the results is possible because each new room is created after the current room is completed. Apply the modulo operator at each step.\n5. Factorial of the number of directly connected rooms need to be multiplied since they can be constructed in any order. Apply the modulo operator at each step.\n6. Store the result in the memoization array.\n7. Call the addRooms function with room 0 and return the result.\n    "
    },
    {
        "id": 236,
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "difficulty": "Easy",
        "content": {
            "problem": "**No-Zero integer** is a positive integer that **does not contain any `0`** in its decimal representation.\n\nGiven an integer `n`, return _a list of two integers_ `[a, b]` _where_:\n\n*   `a` and `b` are **No-Zero integers**.\n*   `a + b = n`\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[1,1\\]\n**Explanation:** Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.\n\n",
                "**Example 2:**\n\n**Input:** n = 11\n**Output:** \\[2,9\\]\n**Explanation:** Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 9 = n.\nNote that there are other valid answers as \\[8, 3\\] that can be accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "2",
                "output": "[1,1]"
            },
            {
                "input": "11",
                "output": "[2,9]"
            }
        ],
        "java": "\n    ```java\npublic int[] noZeroIntegers(int n) {\n    for (int a = 1; a < n; ++a) {\n        if (Integer.toString(a).indexOf('0') == -1 &&\n            Integer.toString(n - a).indexOf('0') == -1) {\n            return new int[]{a, n - a};\n        }\n    }\n    return new int[]{0, 0}; // never gets here\n}\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "python": "\n    ```python\ndef no_zero_integers(n: int):\n    for a in range(1, n):\n        if '0' not in str(a) and '0' not in str(n - a):\n            return [a, n - a]\n    return [0, 0]  # never gets here\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "c++": "\n    ```cpp\nstd::vector<int> noZeroIntegers(int n) {\n    for (int a = 1; a < n; ++a) {\n        if (std::to_string(a).find('0') == std::string::npos &&\n            std::to_string(n - a).find('0') == std::string::npos) {\n            return {a, n - a};\n        }\n    }\n    return {0, 0}; // never gets here\n}\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "js": "\n    ```javascript\nfunction noZeroIntegers(n) {\n    for (let a = 1; a < n; ++a) {\n        if (!String(a).includes('0') && !String(n - a).includes('0')) {\n            return [a, n - a];\n        }\n    }\n    return [0, 0]; // never gets here\n}\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    "
    },
    {
        "id": 237,
        "title": "Maximum 69 Number",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer `num` consisting only of digits `6` and `9`.\n\nReturn _the maximum number you can get by changing **at most** one digit (_`6` _becomes_ `9`_, and_ `9` _becomes_ `6`_)_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 9669\n**Output:** 9969\n**Explanation:** \nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666.\nThe maximum number is 9969.\n\n",
                "**Example 2:**\n\n**Input:** num = 9996\n**Output:** 9999\n**Explanation:** Changing the last digit 6 to 9 results in the maximum number.\n\n",
                "**Example 3:**\n\n**Input:** num = 9999\n**Output:** 9999\n**Explanation:** It is better not to apply any change."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 104`\n*   `num` consists of only `6` and `9` digits.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "9669",
                "output": "9969"
            },
            {
                "input": "9996",
                "output": "9999"
            },
            {
                "input": "9999",
                "output": "9999"
            }
        ],
        "java": "\n    ```java\npublic int maximum69Number (int num) {\n    String numStr = Integer.toString(num);\n    char[] numArr = numStr.toCharArray();\n    for (int i = 0; i < numArr.length; i++) {\n        if (numArr[i] == '6') {\n            numArr[i] = '9';\n            break;\n        }\n    }\n    return Integer.parseInt(new String(numArr));\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "python": "\n    ```python\ndef maximum69Number(num: int) -> int:\n    num_str = list(str(num))\n    for i in range(len(num_str)):\n        if num_str[i] == '6':\n            num_str[i] = '9'\n            break\n    return int(''.join(num_str))\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "c++": "\n    ```cpp\nint maximum69Number (int num) {\n    string numStr = to_string(num);\n    for (char &c : numStr) {\n        if (c == '6') {\n            c = '9';\n            break;\n        }\n    }\n    return stoi(numStr);\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "js": "\n    ```javascript\nfunction maximum69Number(num) {\n    let numStr = num.toString();\n    let numArr = Array.from(numStr);\n    for (let i = 0; i < numArr.length; i++) {\n        if (numArr[i] == '6') {\n            numArr[i] = '9';\n            break;\n        }\n    }\n    return parseInt(numArr.join(''));\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    "
    },
    {
        "id": 238,
        "title": "Rank Transform of an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, replace each element with its rank.\n\nThe rank represents how large the element is. The rank has the following rules:\n\n*   Rank is an integer starting from 1.\n*   The larger the element, the larger the rank. If two elements are equal, their rank must be the same.\n*   Rank should be as small as possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[40,10,20,30\\]\n**Output:** \\[4,1,2,3\\]\n**Explanation**: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[100,100,100\\]\n**Output:** \\[1,1,1\\]\n**Explanation**: Same elements share the same rank.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[37,12,28,9,100,56,80,5,12\\]\n**Output:** \\[5,3,4,2,8,6,7,1,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= arr.length <= 105`\n*   `-109 <= arr[i] <= 109`\n\n\\- Every time you are in a cell you will collect all the gold in that cell. - From your position, you can walk one step to the left, right, up, or down. - You can't visit the same cell more than once. - Never visit a cell with 0 gold. - You can start and stop collecting gold from any position in the grid that has some gold.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[40,10,20,30]",
                "output": "[4,1,2,3]"
            },
            {
                "input": "[100,100,100]",
                "output": "[1,1,1]"
            },
            {
                "input": "[37,12,28,9,100,56,80,5,12]",
                "output": "[5,3,4,2,8,6,7,1,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int getMaximumGold(int[][] grid) {\n    int m = grid.length, n = grid[0].length, maxGold = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] != 0) {\n                maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, i, j, m, n));\n            }\n        }\n    }\n    return maxGold;\n}\n\nprivate int getMaximumGoldHelper(int[][] grid, int x, int y, int m, int n) {\n    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) return 0;\n\n    int originalGold = grid[x][y];\n    grid[x][y] = 0;\n\n    int maxGold = 0;\n    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x + 1, y, m, n));\n    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x - 1, y, m, n));\n    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x, y + 1, m, n));\n    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x, y - 1, m, n));\n\n    grid[x][y] = originalGold;\n    return maxGold + originalGold;\n}\n```\n\n    \n    We use a depth-first search (DFS) algorithm to calculate the maximum gold that can be collected in one DFS run, which we do starting from each cell with gold. This algorithm keeps track of the visited cells by changing the gold amount to 0 in the original grid temporarily as part of its recursive computations. As we go through the grid, we store the maximum gold found so far to be returned at the end. Note that the algorithm itself is relatively simple, but the actual implementation varies slightly between languages.\n    ",
        "python": "\n    ```python\ndef getMaximumGold(grid):\n    m, n, max_gold = len(grid), len(grid[0]), 0\n\n    def getMaximumGoldHelper(x, y):\n        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0:\n            return 0\n\n        original_gold = grid[x][y]\n        grid[x][y] = 0\n\n        max_gold = 0\n        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))\n\n        grid[x][y] = original_gold\n        return max_gold + original_gold\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                max_gold = max(max_gold, getMaximumGoldHelper(i, j))\n\n    return max_gold\n```\n\n    \n    We use a depth-first search (DFS) algorithm to calculate the maximum gold that can be collected in one DFS run, which we do starting from each cell with gold. This algorithm keeps track of the visited cells by changing the gold amount to 0 in the original grid temporarily as part of its recursive computations. As we go through the grid, we store the maximum gold found so far to be returned at the end. Note that the algorithm itself is relatively simple, but the actual implementation varies slightly between languages.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint getMaximumGoldHelper(vector<vector<int>> &grid, int x, int y, int m, int n) {\n    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) return 0;\n\n    int originalGold = grid[x][y];\n    grid[x][y] = 0;\n\n    int maxGold = 0;\n    maxGold = max(maxGold, getMaximumGoldHelper(grid, x + 1, y, m, n));\n    maxGold = max(maxGold, getMaximumGoldHelper(grid, x - 1, y, m, n));\n    maxGold = max(maxGold, getMaximumGoldHelper(grid, x, y + 1, m, n));\n    maxGold = max(maxGold, getMaximumGoldHelper(grid, x, y - 1, m, n));\n\n    grid[x][y] = originalGold;\n    return maxGold + originalGold;\n}\n\nint getMaximumGold(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size(), maxGold = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] != 0) {\n                maxGold = max(maxGold, getMaximumGoldHelper(grid, i, j, m, n));\n            }\n        }\n    }\n    return maxGold;\n}\n```\n\n    \n    We use a depth-first search (DFS) algorithm to calculate the maximum gold that can be collected in one DFS run, which we do starting from each cell with gold. This algorithm keeps track of the visited cells by changing the gold amount to 0 in the original grid temporarily as part of its recursive computations. As we go through the grid, we store the maximum gold found so far to be returned at the end. Note that the algorithm itself is relatively simple, but the actual implementation varies slightly between languages.\n    ",
        "js": "\n    ```javascript\nfunction getMaximumGold(grid) {\n    let m = grid.length, n = grid[0].length, maxGold = 0;\n\n    const getMaximumGoldHelper = (x, y) => {\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] === 0) return 0;\n\n        let originalGold = grid[x][y];\n        grid[x][y] = 0;\n\n        let maxGold = 0;\n        maxGold = Math.max(maxGold, getMaximumGoldHelper(x + 1, y));\n        maxGold = Math.max(maxGold, getMaximumGoldHelper(x - 1, y));\n        maxGold = Math.max(maxGold, getMaximumGoldHelper(x, y + 1));\n        maxGold = Math.max(maxGold, getMaximumGoldHelper(x, y - 1));\n\n        grid[x][y] = originalGold;\n        return maxGold + originalGold;\n    };\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] !== 0) {\n                maxGold = Math.max(maxGold, getMaximumGoldHelper(i, j));\n            }\n        }\n    }\n    return maxGold;\n}\n```\n\n    \n    We use a depth-first search (DFS) algorithm to calculate the maximum gold that can be collected in one DFS run, which we do starting from each cell with gold. This algorithm keeps track of the visited cells by changing the gold amount to 0 in the original grid temporarily as part of its recursive computations. As we go through the grid, we store the maximum gold found so far to be returned at the end. Note that the algorithm itself is relatively simple, but the actual implementation varies slightly between languages.\n    "
    },
    {
        "id": 239,
        "title": "Remove Palindromic Subsequences",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` consisting **only** of letters `'a'` and `'b'`. In a single step you can remove one **palindromic subsequence** from `s`.\n\nReturn _the **minimum** number of steps to make the given string empty_.\n\nA string is a **subsequence** of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does **not** necessarily need to be contiguous.\n\nA string is called **palindrome** if is one that reads the same backward as well as forward.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ababa \"\n**Output:** 1\n**Explanation:** s is already a palindrome, so its entirety can be removed in a single step.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abb \"\n**Output:** 2\n**Explanation:**  \"abb \" ->  \"bb \" ->  \" \". \nRemove palindromic subsequence  \"a \" then  \"bb \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"baabb \"\n**Output:** 2\n**Explanation:**  \"baabb \" ->  \"b \" ->  \" \". \nRemove palindromic subsequence  \"baab \" then  \"b \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'a'` or `'b'`.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"ababa\"",
                "output": "1"
            },
            {
                "input": "\"abb\"",
                "output": "2"
            },
            {
                "input": "\"baabb\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countStrings(int n) {\n    int mod = 1000000007;\n    long a = 1, b = 1;\n    for (int i = 0; i < n; i++) {\n        a = (a * 2) % mod;\n        b = (b * 3) % mod;\n    }\n    return (int)((b - a + mod) % mod);\n}\n```\n\n    \n    The problem requires us to find the total number of valid strings of the given length based on certain rules. To solve this, we calculate:\n\n1. `a`: Count of all strings of length n using just 'a'. Each position can be either 'a' or not 'a', so there are 2 possibilities for each position. Therefore, the count is `2^n`.\n2. `b`: Count of all strings of length n using only 'a' and 'b'. Any position can be either 'a', 'b', or neither 'a' nor 'b', so there are 3 possibilities for each position. Therefore, the count is `3^n`.\n\nAs we have already counted the strings with all positions either 'a' or not 'a' in step one, we need to subtract these duplicates. Thus, the answer is the difference (`b - a`) plus the modulo value to make it positive, and the final result is calculated using `% mod`.\n    ",
        "python": "\n    ```python\ndef countStrings(n):\n    mod = 10**9 + 7\n    a, b = 1, 1\n    for _ in range(n):\n        a = (a * 2) % mod\n        b = (b * 3) % mod\n    return (b - a + mod) % mod\n```\n\n    \n    The problem requires us to find the total number of valid strings of the given length based on certain rules. To solve this, we calculate:\n\n1. `a`: Count of all strings of length n using just 'a'. Each position can be either 'a' or not 'a', so there are 2 possibilities for each position. Therefore, the count is `2^n`.\n2. `b`: Count of all strings of length n using only 'a' and 'b'. Any position can be either 'a', 'b', or neither 'a' nor 'b', so there are 3 possibilities for each position. Therefore, the count is `3^n`.\n\nAs we have already counted the strings with all positions either 'a' or not 'a' in step one, we need to subtract these duplicates. Thus, the answer is the difference (`b - a`) plus the modulo value to make it positive, and the final result is calculated using `% mod`.\n    ",
        "c++": "\n    ```cpp\nint countStrings(int n) {\n    const int mod = 1e9 + 7;\n    long long a = 1, b = 1;\n    for (int i = 0; i < n; ++i) {\n        a = (a * 2) % mod;\n        b = (b * 3) % mod;\n    }\n    return (b - a + mod) % mod;\n}\n```\n\n    \n    The problem requires us to find the total number of valid strings of the given length based on certain rules. To solve this, we calculate:\n\n1. `a`: Count of all strings of length n using just 'a'. Each position can be either 'a' or not 'a', so there are 2 possibilities for each position. Therefore, the count is `2^n`.\n2. `b`: Count of all strings of length n using only 'a' and 'b'. Any position can be either 'a', 'b', or neither 'a' nor 'b', so there are 3 possibilities for each position. Therefore, the count is `3^n`.\n\nAs we have already counted the strings with all positions either 'a' or not 'a' in step one, we need to subtract these duplicates. Thus, the answer is the difference (`b - a`) plus the modulo value to make it positive, and the final result is calculated using `% mod`.\n    ",
        "js": "\n    ```javascript\nfunction countStrings(n) {\n    const mod = 1e9 + 7;\n    let a = 1, b = 1;\n    for (let i = 0; i < n; i++) {\n        a = (a * 2) % mod;\n        b = (b * 3) % mod;\n    }\n    return (b - a + mod) % mod;\n}\n```\n\n    \n    The problem requires us to find the total number of valid strings of the given length based on certain rules. To solve this, we calculate:\n\n1. `a`: Count of all strings of length n using just 'a'. Each position can be either 'a' or not 'a', so there are 2 possibilities for each position. Therefore, the count is `2^n`.\n2. `b`: Count of all strings of length n using only 'a' and 'b'. Any position can be either 'a', 'b', or neither 'a' nor 'b', so there are 3 possibilities for each position. Therefore, the count is `3^n`.\n\nAs we have already counted the strings with all positions either 'a' or not 'a' in step one, we need to subtract these duplicates. Thus, the answer is the difference (`b - a`) plus the modulo value to make it positive, and the final result is calculated using `% mod`.\n    "
    },
    {
        "id": 240,
        "title": "The K Weakest Rows in a Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` binary matrix `mat` of `1`'s (representing soldiers) and `0`'s (representing civilians). The soldiers are positioned **in front** of the civilians. That is, all the `1`'s will appear to the **left** of all the `0`'s in each row.\n\nA row `i` is **weaker** than a row `j` if one of the following is true:\n\n*   The number of soldiers in row `i` is less than the number of soldiers in row `j`.\n*   Both rows have the same number of soldiers and `i < j`.\n\nReturn _the indices of the_ `k` _**weakest** rows in the matrix ordered from weakest to strongest_.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \n\\[\\[1,1,0,0,0\\],\n \\[1,1,1,1,0\\],\n \\[1,0,0,0,0\\],\n \\[1,1,0,0,0\\],\n \\[1,1,1,1,1\\]\\], \nk = 3\n**Output:** \\[2,0,3\\]\n**Explanation:** \nThe number of soldiers in each row is: \n- Row 0: 2 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 2 \n- Row 4: 5 \nThe rows ordered from weakest to strongest are \\[2,0,3,1,4\\].\n\n",
                "**Example 2:**\n\n**Input:** mat = \n\\[\\[1,0,0,0\\],\n \\[1,1,1,1\\],\n \\[1,0,0,0\\],\n \\[1,0,0,0\\]\\], \nk = 2\n**Output:** \\[0,2\\]\n**Explanation:** \nThe number of soldiers in each row is: \n- Row 0: 1 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 1 \nThe rows ordered from weakest to strongest are \\[0,2,3,1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `2 <= n, m <= 100`\n*   `1 <= k <= m`\n*   `matrix[i][j]` is either 0 or 1.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "\n[[1,1,0,0,0],\n[1,1,1,1,0],\n[1,0,0,0,0],\n[1,1,0,0,0],\n[1,1,1,1,1]],3",
                "output": "[2,0,3]"
            },
            {
                "input": "\n[[1,0,0,0],\n[1,1,1,1],\n[1,0,0,0],\n[1,0,0,0]],2",
                "output": "[0,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int[] result = new int[k];\n        List<Integer> tmp = new ArrayList<Integer>();\n        for (int i = 0; i < mat.length; i++) {\n            tmp.add(i, mat[i].length - Arrays.binarySearch(mat[i], 0) - 1);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> a - b);\n        pq.addAll(tmp);\n        for (int i = 0; i < k; i++) {\n            result[i] = tmp.indexOf(pq.poll());\n            tmp.set(result[i], -1);\n        }\n        return result;\n    }\n}\n```\n    \n    1. Count the number of soldiers in each row, and store the count along with the index of the row in a list.\n2. Sort the list of pairs by the count of soldiers, and if there is a tie, use the index in ascending order.\n3. Return the indices of the first k elements of the sorted list.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldiers_count = [(sum(row), idx) for idx, row in enumerate(mat)]\n    soldiers_count.sort()\n    return [x[1] for x in soldiers_count[:k]]\n```\n    \n    1. Count the number of soldiers in each row, and store the count along with the index of the row in a list.\n2. Sort the list of pairs by the count of soldiers, and if there is a tie, use the index in ascending order.\n3. Return the indices of the first k elements of the sorted list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n    vector<pair<int, int>> soldiersCount;\n\n    for (int i = 0; i < mat.size(); ++i) {\n        int cnt = count(mat[i].begin(), mat[i].end(), 1);\n        soldiersCount.push_back({cnt, i});\n    }\n    \n    sort(soldiersCount.begin(), soldiersCount.end());\n    vector<int> result(k);\n    for (int i = 0; i < k; ++i) {\n        result[i] = soldiersCount[i].second;\n    }\n    return result;\n}\n```\n    \n    1. Count the number of soldiers in each row, and store the count along with the index of the row in a list.\n2. Sort the list of pairs by the count of soldiers, and if there is a tie, use the index in ascending order.\n3. Return the indices of the first k elements of the sorted list.\n    ",
        "js": "\n    ```javascript\nvar kWeakestRows = function(mat, k) {\n    const soldiersCount = mat.map((row, idx) => [row.filter(x => x === 1).length, idx]);\n    soldiersCount.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    return soldiersCount.slice(0, k).map(x => x[1]);\n};\n```\n    \n    1. Count the number of soldiers in each row, and store the count along with the index of the row in a list.\n2. Sort the list of pairs by the count of soldiers, and if there is a tie, use the index in ascending order.\n3. Return the indices of the first k elements of the sorted list.\n    "
    },
    {
        "id": 241,
        "title": "Number of Steps to Reduce a Number to Zero",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, return _the number of steps to reduce it to zero_.\n\nIn one step, if the current number is even, you have to divide it by `2`, otherwise, you have to subtract `1` from it.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 14\n**Output:** 6\n**Explanation:** \nStep 1) 14 is even; divide by 2 and obtain 7. \nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3. \nStep 4) 3 is odd; subtract 1 and obtain 2. \nStep 5) 2 is even; divide by 2 and obtain 1. \nStep 6) 1 is odd; subtract 1 and obtain 0.\n\n",
                "**Example 2:**\n\n**Input:** num = 8\n**Output:** 4\n**Explanation:** \nStep 1) 8 is even; divide by 2 and obtain 4. \nStep 2) 4 is even; divide by 2 and obtain 2. \nStep 3) 2 is even; divide by 2 and obtain 1. \nStep 4) 1 is odd; subtract 1 and obtain 0.\n\n",
                "**Example 3:**\n\n**Input:** num = 123\n**Output:** 12"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 106`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "14",
                "output": "6"
            },
            {
                "input": "8",
                "output": "4"
            },
            {
                "input": "123",
                "output": "12"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n    List<List<Integer>> result = new ArrayList<>();\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            if (x == 0 && y == 0) continue;\n            int posX = king[0] + x;\n            int posY = king[1] + y;\n            while (posX >= 0 && posY >= 0 && posX < 8 && posY < 8) {\n                for (int[] queen : queens) {\n                    if (posX == queen[0] && posY == queen[1]) {\n                        List<Integer> attackingQueen = new ArrayList<>();\n                        attackingQueen.add(queen[0]);\n                        attackingQueen.add(queen[1]);\n                        result.add(attackingQueen);\n                        break;\n                    }\n                }\n                posX += x;\n                posY += y;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of the following steps: \n1. For each direction, including diagonals, create a loop that starts from the position of the King.\n2. Iterate through the loop, going one cell at a time in the chosen direction.\n3. For each iteration, check if there is a queen on that cell by comparing it to the coordinates of the queens in the input array.\n4. If a queen is found in that cell, add the coordinates of that queen to the result list and break the inner loop.\n5. Continue to the next direction.\n\nThis algorithm ensures that every possible direction is checked from the King's position, and if there's a queen in that direction, it will be added to the resulting list. This way, we get all the queens that can attack the King.\n    ",
        "python": "\n    ```python\ndef queensAttacktheKing(queens, king):\n    result = []\n    for x in range(-1, 2):\n        for y in range(-1, 2):\n            if x == 0 and y == 0:\n                continue\n            posX, posY = king[0] + x, king[1] + y\n            while 0 <= posX < 8 and 0 <= posY < 8:\n                for queen in queens:\n                    if posX == queen[0] and posY == queen[1]:\n                        result.append([queen[0], queen[1]])\n                        break\n                posX += x\n                posY += y\n    return result\n```\n    \n    The algorithm consists of the following steps: \n1. For each direction, including diagonals, create a loop that starts from the position of the King.\n2. Iterate through the loop, going one cell at a time in the chosen direction.\n3. For each iteration, check if there is a queen on that cell by comparing it to the coordinates of the queens in the input array.\n4. If a queen is found in that cell, add the coordinates of that queen to the result list and break the inner loop.\n5. Continue to the next direction.\n\nThis algorithm ensures that every possible direction is checked from the King's position, and if there's a queen in that direction, it will be added to the resulting list. This way, we get all the queens that can attack the King.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> queensAttacktheKing(std::vector<std::vector<int>>& queens, std::vector<int>& king) {\n    std::vector<std::vector<int>> result;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            if (x == 0 && y == 0) continue;\n            int posX = king[0] + x;\n            int posY = king[1] + y;\n            while (posX >= 0 && posY >= 0 && posX < 8 && posY < 8) {\n                for (std::vector<int>& queen : queens) {\n                    if (posX == queen[0] && posY == queen[1]) {\n                        result.push_back({queen[0], queen[1]});\n                        break;\n                    }\n                }\n                posX += x;\n                posY += y;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of the following steps: \n1. For each direction, including diagonals, create a loop that starts from the position of the King.\n2. Iterate through the loop, going one cell at a time in the chosen direction.\n3. For each iteration, check if there is a queen on that cell by comparing it to the coordinates of the queens in the input array.\n4. If a queen is found in that cell, add the coordinates of that queen to the result list and break the inner loop.\n5. Continue to the next direction.\n\nThis algorithm ensures that every possible direction is checked from the King's position, and if there's a queen in that direction, it will be added to the resulting list. This way, we get all the queens that can attack the King.\n    ",
        "js": "\n    ```javascript\nfunction queensAttacktheKing(queens, king) {\n    const result = [];\n    for (let x = -1; x <= 1; x++) {\n        for (let y = -1; y <= 1; y++) {\n            if (x === 0 && y === 0) continue;\n            let posX = king[0] + x;\n            let posY = king[1] + y;\n            while (posX >= 0 && posY >= 0 && posX < 8 && posY < 8) {\n                for (const queen of queens) {\n                    if (posX === queen[0] && posY === queen[1]) {\n                        result.push([queen[0], queen[1]]);\n                        break;\n                    }\n                }\n                posX += x;\n                posY += y;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of the following steps: \n1. For each direction, including diagonals, create a loop that starts from the position of the King.\n2. Iterate through the loop, going one cell at a time in the chosen direction.\n3. For each iteration, check if there is a queen on that cell by comparing it to the coordinates of the queens in the input array.\n4. If a queen is found in that cell, add the coordinates of that queen to the result list and break the inner loop.\n5. Continue to the next direction.\n\nThis algorithm ensures that every possible direction is checked from the King's position, and if there's a queen in that direction, it will be added to the resulting list. This way, we get all the queens that can attack the King.\n    "
    },
    {
        "id": 242,
        "title": "Check If N and Its Double Exist",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `arr` of integers, check if there exist two indices `i` and `j` such that :\n\n*   `i != j`\n*   `0 <= i, j < arr.length`\n*   `arr[i] == 2 * arr[j]`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[10,2,5,3\\]\n**Output:** true\n**Explanation:** For i = 0 and j = 2, arr\\[i\\] == 10 == 2 \\* 5 == 2 \\* arr\\[j\\]\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[3,1,7,11\\]\n**Output:** false\n**Explanation:** There is no i and j that satisfy the conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= arr.length <= 500`\n*   `-103 <= arr[i] <= 103`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[10,2,5,3]",
                "output": "true"
            },
            {
                "input": "[3,1,7,11]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int maxValueInStack(int[] nums, int k) {\n    int n = nums.length;\n    if (k >= n) return -1;\n\n    int max_val = Integer.MIN_VALUE;\n    for (int i = 0; i <= k; ++i) {\n        max_val = Math.max(max_val, nums[i]);\n    }\n    return max_val;\n}\n```\n    \n    We are looking for the maximum `nums[i]` such that `0 <= i <= k`. Iterate through the first `k+1` elements in the array and keep track of the maximum value encountered. If `k >= n`, then it's not possible to have a non-empty pile after k moves, so return `-1` in that case. Otherwise, return the maximum value found. \n    ",
        "python": "\n    ```python\ndef maxValueInStack(nums, k):\n    n = len(nums)\n    if k >= n:\n        return -1\n\n    max_val = float('-inf')\n    for i in range(k+1):\n        max_val = max(max_val, nums[i])\n    return max_val\n```\n    \n    We are looking for the maximum `nums[i]` such that `0 <= i <= k`. Iterate through the first `k+1` elements in the array and keep track of the maximum value encountered. If `k >= n`, then it's not possible to have a non-empty pile after k moves, so return `-1` in that case. Otherwise, return the maximum value found. \n    ",
        "c++": "\n    ```cpp\nint maxValueInStack(vector<int>& nums, int k) {\n    int n = nums.size();\n    if (k >= n) return -1;\n\n    int max_val = INT_MIN;\n    for (int i = 0; i <= k; ++i) {\n        max_val = max(max_val, nums[i]);\n    }\n    return max_val;\n}\n```\n    \n    We are looking for the maximum `nums[i]` such that `0 <= i <= k`. Iterate through the first `k+1` elements in the array and keep track of the maximum value encountered. If `k >= n`, then it's not possible to have a non-empty pile after k moves, so return `-1` in that case. Otherwise, return the maximum value found. \n    ",
        "js": "\n    ```javascript\nfunction maxValueInStack(nums, k) {\n    let n = nums.length;\n    if (k >= n) return -1;\n\n    let max_val = Number.MIN_SAFE_INTEGER;\n    for (let i = 0; i <= k; ++i) {\n        max_val = Math.max(max_val, nums[i]);\n    }\n    return max_val;\n}\n```\n    \n    We are looking for the maximum `nums[i]` such that `0 <= i <= k`. Iterate through the first `k+1` elements in the array and keep track of the maximum value encountered. If `k >= n`, then it's not possible to have a non-empty pile after k moves, so return `-1` in that case. Otherwise, return the maximum value found. \n    "
    },
    {
        "id": 243,
        "title": "Count Negative Numbers in a Sorted Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `m x n` matrix `grid` which is sorted in non-increasing order both row-wise and column-wise, return _the number of **negative** numbers in_ `grid`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[4,3,2,-1\\],\\[3,2,1,-1\\],\\[1,1,-1,-2\\],\\[-1,-1,-2,-3\\]\\]\n**Output:** 8\n**Explanation:** There are 8 negatives number in the matrix.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[3,2\\],\\[1,0\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= grid[i][j] <= 100`\n\n**",
            "follow_up": "Follow up:** Could you find an `O(n + m)` solution?"
        },
        "tag": [
            "Array",
            "Binary Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]",
                "output": "8"
            },
            {
                "input": "[[3,2],[1,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int balancedString(String s) {\n    int n = s.length();\n    HashMap<Character, Integer> freq_map = new HashMap<>();\n    for (char c : s.toCharArray())\n        freq_map.put(c, freq_map.getOrDefault(c, 0) + 1);\n    \n    int i = 0, result = n;\n    for (int j = 0; j < n; j++) {\n        freq_map.put(s.charAt(j), freq_map.get(s.charAt(j)) - 1);\n        while (i < n && freq_map.getOrDefault('Q', 0) <= n / 4 && freq_map.getOrDefault('W', 0) <= n / 4 && freq_map.getOrDefault('E', 0) <= n / 4 && freq_map.getOrDefault('R', 0) <= n / 4) {\n            result = Math.min(result, j - i + 1);\n            freq_map.put(s.charAt(i), freq_map.get(s.charAt(i)) + 1);\n            i++;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Create a frequency map of characters in the given string.\n2. Initialize two pointers, i and j, to traverse the string.\n3. Traverse the string with pointer j and decrease the frequency of the current character.\n4. Check if the frequency of all characters is less than or equal to n/4. If so, update the minimum length of substring.\n5. Increment pointer i while maintaining the frequency map until the frequency of any character becomes more than n/4.\n6. Return the minimum length of substring found.\n    ",
        "python": "\n    ```python\ndef balanced_string(s):\n    n = len(s)\n    freq_map = {}\n    for c in s:\n        freq_map[c] = freq_map.get(c, 0) + 1\n    \n    i = 0\n    result = n\n    for j in range(n):\n        freq_map[s[j]] -= 1\n        while i < n and all(freq_map.get(c, 0) <= n // 4 for c in \"QWER\"):\n            result = min(result, j - i + 1)\n            freq_map[s[i]] += 1\n            i += 1\n    \n    return result\n```\n    \n    1. Create a frequency map of characters in the given string.\n2. Initialize two pointers, i and j, to traverse the string.\n3. Traverse the string with pointer j and decrease the frequency of the current character.\n4. Check if the frequency of all characters is less than or equal to n/4. If so, update the minimum length of substring.\n5. Increment pointer i while maintaining the frequency map until the frequency of any character becomes more than n/4.\n6. Return the minimum length of substring found.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint balancedString(string s) {\n    int n = s.size();\n    unordered_map<char, int> freq_map;\n    for (char c : s)\n        freq_map[c]++;\n    \n    int i = 0, result = n;\n    for (int j = 0; j < n; j++) {\n        freq_map[s[j]]--;\n        while (i < n && freq_map['Q'] <= n / 4 && freq_map['W'] <= n / 4 && freq_map['E'] <= n / 4 && freq_map['R'] <= n / 4) {\n            result = min(result, j - i + 1);\n            freq_map[s[i]]++;\n            i++;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Create a frequency map of characters in the given string.\n2. Initialize two pointers, i and j, to traverse the string.\n3. Traverse the string with pointer j and decrease the frequency of the current character.\n4. Check if the frequency of all characters is less than or equal to n/4. If so, update the minimum length of substring.\n5. Increment pointer i while maintaining the frequency map until the frequency of any character becomes more than n/4.\n6. Return the minimum length of substring found.\n    ",
        "js": "\n    ```javascript\nfunction balancedString(s) {\n    const n = s.length;\n    const freq_map = {};\n    for (const c of s)\n        freq_map[c] = (freq_map[c] || 0) + 1;\n    \n    let i = 0, result = n;\n    for (let j = 0; j < n; j++) {\n        freq_map[s[j]]--;\n        while (i < n && ['Q', 'W', 'E', 'R'].every(c => (freq_map[c] || 0) <= n / 4)) {\n            result = Math.min(result, j - i + 1);\n            freq_map[s[i]]++;\n            i++;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Create a frequency map of characters in the given string.\n2. Initialize two pointers, i and j, to traverse the string.\n3. Traverse the string with pointer j and decrease the frequency of the current character.\n4. Check if the frequency of all characters is less than or equal to n/4. If so, update the minimum length of substring.\n5. Increment pointer i while maintaining the frequency map until the frequency of any character becomes more than n/4.\n6. Return the minimum length of substring found.\n    "
    },
    {
        "id": 244,
        "title": "Sort Integers by The Number of 1 Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `arr`. Sort the integers in the array in ascending order by the number of `1`'s in their binary representation and in case of two or more integers have the same number of `1`'s you have to sort them in ascending order.\n\nReturn _the array after sorting it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[0,1,2,3,4,5,6,7,8\\]\n**Output:** \\[0,1,2,4,8,3,5,6,7\\]\n**Explantion:** \\[0\\] is the only integer with 0 bits.\n\\[1,2,4,8\\] all have 1 bit.\n\\[3,5,6\\] have 2 bits.\n\\[7\\] has 3 bits.\nThe sorted array by bits is \\[0,1,2,4,8,3,5,6,7\\]\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1024,512,256,128,64,32,16,8,4,2,1\\]\n**Output:** \\[1,2,4,8,16,32,64,128,256,512,1024\\]\n**Explantion:** All integers have 1 bit in the binary representation, you should just sort them in ascending order."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 500`\n*   `0 <= arr[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[0,1,2,3,4,5,6,7,8]",
                "output": "[0,1,2,4,8,3,5,6,7]\n**Explantion:**[0]istheonlyintegerwith0bits.\n[1,2,4,8]allhave1bit.\n[3,5,6]have2bits.\n[7]has3bits.\nThesortedarraybybitsis[0,1,2,4,8,3,5,6,7]"
            },
            {
                "input": "[1024,512,256,128,64,32,16,8,4,2,1]",
                "output": "[1,2,4,8,16,32,64,128,256,512,1024]\n**Explantion:**Allintegershave1bitinthebinaryrepresentation,youshouldjustsorttheminascendingorder."
            }
        ],
        "java": "\n    ```java\npublic int minMovesToPalindrome(String s) {\n    char[] chars = s.toCharArray();\n    int moves = 0;\n    int left = 0, right = s.length() - 1;\n\n    while (left < right) {\n        if (chars[left] != chars[right]) {\n            int temp_right = right;\n\n            while (chars[left] != chars[temp_right]) {\n                temp_right--;\n            }\n            char temp = chars[temp_right];\n            System.arraycopy(chars, temp_right + 1, chars, temp_right, right - temp_right);\n            chars[right] = temp;\n            moves += right - temp_right;\n        }\n        left++;\n        right--;\n    }\n\n    return moves;\n}\n```\n    \n    1. Initialize variables `moves` to store the total number of moves, and `left` and `right` pointers for both ends of string s.\n2. Iterate until the `left` pointer is less than `right`.\n   a. If the characters at the left and right pointers are not equal, find the position of the left pointer character in the remaining right section of the string.\n   b. Swap the characters found in the right section with the character at 'right' position.\n   c. Increment the number of moves by the distance between the `right` and the swap position.\n3. Increment the `left` pointer and decrement the `right` pointer after each iteration.\n4. Finally, return the total number of moves.\n    ",
        "python": "\n    ```python\ndef min_moves_to_palindrome(s: str) -> int:\n    moves = 0\n    s = list(s)\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            temp_right = right\n\n            while s[left] != s[temp_right]:\n                temp_right -= 1\n            s.insert(right, s.pop(temp_right))\n            moves += right - temp_right\n        left += 1\n        right -= 1\n\n    return moves\n```\n    \n    1. Initialize variables `moves` to store the total number of moves, and `left` and `right` pointers for both ends of string s.\n2. Iterate until the `left` pointer is less than `right`.\n   a. If the characters at the left and right pointers are not equal, find the position of the left pointer character in the remaining right section of the string.\n   b. Swap the characters found in the right section with the character at 'right' position.\n   c. Increment the number of moves by the distance between the `right` and the swap position.\n3. Increment the `left` pointer and decrement the `right` pointer after each iteration.\n4. Finally, return the total number of moves.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nint min_moves_to_palindrome(string s) {\n    int moves = 0;\n    int left = 0, right = s.length() - 1;\n\n    while (left < right) {\n        if (s[left] != s[right]) {\n            int temp_right = right;\n\n            while (s[left] != s[temp_right]) {\n                temp_right--;\n            }\n            s.erase(s.begin() + temp_right);\n            s.insert(s.begin() + right, s[left]);\n            moves += right - temp_right;\n        }\n        left++;\n        right--;\n    }\n\n    return moves;\n}\n```\n    \n    1. Initialize variables `moves` to store the total number of moves, and `left` and `right` pointers for both ends of string s.\n2. Iterate until the `left` pointer is less than `right`.\n   a. If the characters at the left and right pointers are not equal, find the position of the left pointer character in the remaining right section of the string.\n   b. Swap the characters found in the right section with the character at 'right' position.\n   c. Increment the number of moves by the distance between the `right` and the swap position.\n3. Increment the `left` pointer and decrement the `right` pointer after each iteration.\n4. Finally, return the total number of moves.\n    ",
        "js": "\n    ```javascript\nfunction minMovesToPalindrome(s) {\n    let moves = 0;\n    s = s.split('');\n    let left = 0, right = s.length - 1;\n\n    while (left < right) {\n        if (s[left] !== s[right]) {\n            let temp_right = right;\n\n            while (s[left] !== s[temp_right]) {\n                temp_right--;\n            }\n            s.splice(right, 0, s.splice(temp_right, 1)[0]);\n            moves += right - temp_right;\n        }\n        left++;\n        right--;\n    }\n\n    return moves;\n}\n```\n    \n    1. Initialize variables `moves` to store the total number of moves, and `left` and `right` pointers for both ends of string s.\n2. Iterate until the `left` pointer is less than `right`.\n   a. If the characters at the left and right pointers are not equal, find the position of the left pointer character in the remaining right section of the string.\n   b. Swap the characters found in the right section with the character at 'right' position.\n   c. Increment the number of moves by the distance between the `right` and the swap position.\n3. Increment the `left` pointer and decrement the `right` pointer after each iteration.\n4. Finally, return the total number of moves.\n    "
    },
    {
        "id": 245,
        "title": "Number of Days Between Two Dates",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a program to count the number of days between two dates.\n\nThe two dates are given as strings, their format is `YYYY-MM-DD` as shown in the examples.",
            "examples": [
                "**Example 1:**\n\n**Input:** date1 = \"2019-06-29\", date2 = \"2019-06-30\"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** date1 = \"2020-01-15\", date2 = \"2019-12-31\"\n**Output:** 15"
            ],
            "constraints": "**Constraints:**\n\n*   The given dates are valid dates between the years `1971` and `2100`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"2019-06-29\",\"2019-06-30\"",
                "output": "1"
            },
            {
                "input": "\"2020-01-15\",\"2019-12-31\"",
                "output": "15"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic int maxLength(List<String> arr) {\n    List<String> dp = new ArrayList<>();\n    dp.add(\"\");\n    int maxLen = 0;\n    for (String s : arr) {\n        if (new HashSet<Character>(s.chars().mapToObj(c -> (char) c).collect(Collectors.toSet())).size() < s.length()) continue;\n        for (int i = dp.size() - 1; i >= 0; --i) {\n            String tmp = dp.get(i) + s;\n            if (tmp.chars().distinct().count() == tmp.length()) {\n                dp.add(tmp);\n                maxLen = Math.max(maxLen, tmp.length());\n            }\n        }\n    }\n    return maxLen;\n}\n```\n    \n    The algorithm initializes a list called 'dp' containing an empty string. Then, for each string s in the input array 'arr', it checks whether the string has unique characters by comparing its length with the length of a set that contains its individual characters.\n\nIf the string has unique characters, it iterates through the dp list in reverse order, forming a new string by concatenating the current string from the dp list and s. The algorithm checks if this new concatenated string has unique characters. If it does, it appends the concatenated string to the dp list and updates the maximum length of unique characters seen so far.\n\nBy the end of this process, the algorithm returns the maximum length of unique characters in a concatenated string from the subsequence of arr.\n    ",
        "python": "\n    ```python\ndef maxLength(arr):\n    dp = ['']\n    maxLen = 0\n\n    for s in arr:\n        if len(set(s)) < len(s): continue\n        for i in range(len(dp) - 1, -1, -1):\n            tmp = dp[i] + s\n            if len(set(tmp)) == len(tmp):\n                dp.append(tmp)\n                maxLen = max(maxLen, len(tmp))\n                \n    return maxLen\n```\n    \n    The algorithm initializes a list called 'dp' containing an empty string. Then, for each string s in the input array 'arr', it checks whether the string has unique characters by comparing its length with the length of a set that contains its individual characters.\n\nIf the string has unique characters, it iterates through the dp list in reverse order, forming a new string by concatenating the current string from the dp list and s. The algorithm checks if this new concatenated string has unique characters. If it does, it appends the concatenated string to the dp list and updates the maximum length of unique characters seen so far.\n\nBy the end of this process, the algorithm returns the maximum length of unique characters in a concatenated string from the subsequence of arr.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint maxLength(std::vector<std::string>& arr) {\n    std::vector<std::string> dp = {\"\"};\n\n    int maxLen = 0;\n    for (std::string s : arr) {\n        if (std::unordered_set<char>(s.begin(), s.end()).size() < s.size()) continue;\n        for (int i = dp.size() - 1; i >= 0; --i) {\n            std::string tmp = dp[i] + s;\n            if (std::unordered_set<char>(tmp.begin(), tmp.end()).size() == tmp.size()) {\n                dp.push_back(tmp);\n                maxLen = std::max(maxLen, (int)tmp.size());\n            }\n        }\n    }\n    \n    return maxLen;\n}\n```\n    \n    The algorithm initializes a list called 'dp' containing an empty string. Then, for each string s in the input array 'arr', it checks whether the string has unique characters by comparing its length with the length of a set that contains its individual characters.\n\nIf the string has unique characters, it iterates through the dp list in reverse order, forming a new string by concatenating the current string from the dp list and s. The algorithm checks if this new concatenated string has unique characters. If it does, it appends the concatenated string to the dp list and updates the maximum length of unique characters seen so far.\n\nBy the end of this process, the algorithm returns the maximum length of unique characters in a concatenated string from the subsequence of arr.\n    ",
        "js": "\n    ```javascript\nfunction maxLength(arr) {\n    let dp = [''];\n    let maxLen = 0;\n\n    arr.forEach(s => {\n        if (new Set(s).size < s.length) return;\n        for (let i = dp.length - 1; i >= 0; --i) {\n            let tmp = dp[i] + s;\n            if (new Set(tmp).size === tmp.length) {\n                dp.push(tmp);\n                maxLen = Math.max(maxLen, tmp.length);\n            }\n        }\n    });\n\n    return maxLen;\n}\n```\n    \n    The algorithm initializes a list called 'dp' containing an empty string. Then, for each string s in the input array 'arr', it checks whether the string has unique characters by comparing its length with the length of a set that contains its individual characters.\n\nIf the string has unique characters, it iterates through the dp list in reverse order, forming a new string by concatenating the current string from the dp list and s. The algorithm checks if this new concatenated string has unique characters. If it does, it appends the concatenated string to the dp list and updates the maximum length of unique characters seen so far.\n\nBy the end of this process, the algorithm returns the maximum length of unique characters in a concatenated string from the subsequence of arr.\n    "
    },
    {
        "id": 246,
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the array `nums`, for each `nums[i]` find out how many numbers in the array are smaller than it. That is, for each `nums[i]` you have to count the number of valid `j's` such that `j != i` **and** `nums[j] < nums[i]`.\n\nReturn the answer in an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[8,1,2,2,3\\]\n**Output:** \\[4,0,1,1,3\\]\n**Explanation:** \nFor nums\\[0\\]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums\\[1\\]=1 does not exist any smaller number than it.\nFor nums\\[2\\]=2 there exist one smaller number than it (1). \nFor nums\\[3\\]=2 there exist one smaller number than it (1). \nFor nums\\[4\\]=3 there exist three smaller numbers than it (1, 2 and 2).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,5,4,8\\]\n**Output:** \\[2,1,0,3\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,7,7,7\\]\n**Output:** \\[0,0,0,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 500`\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[8,1,2,2,3]",
                "output": "[4,0,1,1,3]"
            },
            {
                "input": "[6,5,4,8]",
                "output": "[2,1,0,3]"
            },
            {
                "input": "[7,7,7,7]",
                "output": "[0,0,0,0]"
            }
        ],
        "java": "\n    ```java\npublic int[] smallerNumbersThanCurrent(int[] nums) {\n    int[] result = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        int count = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (i != j && nums[j] < nums[i]) {\n                count++;\n            }\n        }\n        result[i] = count;\n    }\n    return result;\n}\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    ",
        "python": "\n    ```python\ndef smallerNumbersThanCurrent(nums):\n    result = []\n    for i in range(len(nums)):\n        count = 0\n        for j in range(len(nums)):\n            if i != j and nums[j] < nums[i]:\n                count += 1\n        result.append(count)\n    return result\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n    vector<int> result(nums.size());\n    for (int i = 0; i < nums.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < nums.size(); j++) {\n            if (i != j && nums[j] < nums[i]) {\n                count++;\n            }\n        }\n        result[i] = count;\n    }\n    return result;\n}\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    ",
        "js": "\n    ```javascript\nfunction smallerNumbersThanCurrent(nums) {\n    let result = [];\n    for (let i = 0; i < nums.length; i++) {\n        let count = 0;\n        for (let j = 0; j < nums.length; j++) {\n            if (i !== j && nums[j] < nums[i]) {\n                count++;\n            }\n        }\n        result.push(count);\n    }\n    return result;\n}\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    "
    },
    {
        "id": 247,
        "title": "Increasing Decreasing String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s`. Reorder the string using the following algorithm:\n\n1.  Pick the **smallest** character from `s` and **append** it to the result.\n2.  Pick the **smallest** character from `s` which is greater than the last appended character to the result and **append** it.\n3.  Repeat step 2 until you cannot pick more characters.\n4.  Pick the **largest** character from `s` and **append** it to the result.\n5.  Pick the **largest** character from `s` which is smaller than the last appended character to the result and **append** it.\n6.  Repeat step 5 until you cannot pick more characters.\n7.  Repeat the steps from 1 to 6 until you pick all characters from `s`.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n\nReturn _the result string after sorting_ `s` _with this algorithm_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaaabbbbcccc \"\n**Output:**  \"abccbaabccba \"\n**Explanation:** After steps 1, 2 and 3 of the first iteration, result =  \"abc \"\nAfter steps 4, 5 and 6 of the first iteration, result =  \"abccba \"\nFirst iteration is done. Now s =  \"aabbcc \" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result =  \"abccbaabc \"\nAfter steps 4, 5 and 6 of the second iteration, result =  \"abccbaabccba \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"rat \"\n**Output:**  \"art \"\n**Explanation:** The word  \"rat \" becomes  \"art \" after re-ordering it with the mentioned algorithm."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"aaaabbbbcccc\"",
                "output": "\"abccbaabccba\""
            },
            {
                "input": "\"rat\"",
                "output": "\"art\""
            }
        ],
        "java": "\n    ```java\npublic int numberOfSubarrays(int[] nums, int k) {\n    int n = nums.length, result = 0, count = 0;\n    int[] oddCount = new int[n + 1];\n\n    oddCount[0] = 1;\n    for (int i = 0; i < n; i++) {\n        count += nums[i] % 2;\n        if (count >= k) result += oddCount[count - k];\n        oddCount[count]++;\n    }\n\n    return result;\n}\n```\n    \n    1. Initialize array `oddCount` with a size of `n+1` and set `oddCount[0]` to 1.\n2. Initialize `count` and `result` to 0.\n3. Iterate through the input array `nums`.\n4. For each element, increment `count` by the value of the element modulo 2 (if the element is odd, it increments by 1, otherwise by 0).\n5. If `count` is greater than or equal to `k`, increment `result` by the value of `oddCount[count - k]`.\n6. Increment `oddCount[count]`.\n7. After iteration, return `result` as the number of nice sub-arrays.\n\nThis algorithm works by tracking the number of odd elements within a subarray and storing the cumulative sums in the `oddCount` array. By iterating through the input array and incrementing the count, the algorithm determines whether a subarray is nice by checking if the count is greater than or equal to `k` and updating the result accordingly.\n    ",
        "python": "\n    ```python\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    result = count = 0\n    odd_count = [0] * (n + 1)\n\n    odd_count[0] = 1\n    for num in nums:\n        count += num % 2\n        if count >= k:\n            result += odd_count[count - k]\n        odd_count[count] += 1\n\n    return result\n```\n    \n    1. Initialize array `oddCount` with a size of `n+1` and set `oddCount[0]` to 1.\n2. Initialize `count` and `result` to 0.\n3. Iterate through the input array `nums`.\n4. For each element, increment `count` by the value of the element modulo 2 (if the element is odd, it increments by 1, otherwise by 0).\n5. If `count` is greater than or equal to `k`, increment `result` by the value of `oddCount[count - k]`.\n6. Increment `oddCount[count]`.\n7. After iteration, return `result` as the number of nice sub-arrays.\n\nThis algorithm works by tracking the number of odd elements within a subarray and storing the cumulative sums in the `oddCount` array. By iterating through the input array and incrementing the count, the algorithm determines whether a subarray is nice by checking if the count is greater than or equal to `k` and updating the result accordingly.\n    ",
        "c++": "\n    ```cpp\nint numberOfSubarrays(vector<int>& nums, int k) {\n    int n = nums.size(), result = 0, count = 0;\n    vector<int> oddCount(n + 1, 0);\n\n    oddCount[0] = 1;\n    for (int i = 0; i < n; i++) {\n        count += nums[i] % 2;\n        if (count >= k) result += oddCount[count - k];\n        oddCount[count]++;\n    }\n\n    return result;\n}\n```\n    \n    1. Initialize array `oddCount` with a size of `n+1` and set `oddCount[0]` to 1.\n2. Initialize `count` and `result` to 0.\n3. Iterate through the input array `nums`.\n4. For each element, increment `count` by the value of the element modulo 2 (if the element is odd, it increments by 1, otherwise by 0).\n5. If `count` is greater than or equal to `k`, increment `result` by the value of `oddCount[count - k]`.\n6. Increment `oddCount[count]`.\n7. After iteration, return `result` as the number of nice sub-arrays.\n\nThis algorithm works by tracking the number of odd elements within a subarray and storing the cumulative sums in the `oddCount` array. By iterating through the input array and incrementing the count, the algorithm determines whether a subarray is nice by checking if the count is greater than or equal to `k` and updating the result accordingly.\n    ",
        "js": "\n    ```javascript\nfunction numberOfSubarrays(nums, k) {\n    let n = nums.length, result = 0, count = 0;\n    let oddCount = new Array(n + 1).fill(0);\n\n    oddCount[0] = 1;\n    for (let i = 0; i < n; i++) {\n        count += nums[i] % 2;\n        if (count >= k) result += oddCount[count - k];\n        oddCount[count]++;\n    }\n\n    return result;\n}\n```\n    \n    1. Initialize array `oddCount` with a size of `n+1` and set `oddCount[0]` to 1.\n2. Initialize `count` and `result` to 0.\n3. Iterate through the input array `nums`.\n4. For each element, increment `count` by the value of the element modulo 2 (if the element is odd, it increments by 1, otherwise by 0).\n5. If `count` is greater than or equal to `k`, increment `result` by the value of `oddCount[count - k]`.\n6. Increment `oddCount[count]`.\n7. After iteration, return `result` as the number of nice sub-arrays.\n\nThis algorithm works by tracking the number of odd elements within a subarray and storing the cumulative sums in the `oddCount` array. By iterating through the input array and incrementing the count, the algorithm determines whether a subarray is nice by checking if the count is greater than or equal to `k` and updating the result accordingly.\n    "
    },
    {
        "id": 248,
        "title": "Generate a String With Characters That Have Odd Counts",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, _return a string with `n` characters such that each character in such string occurs **an odd number of times**_.\n\nThe returned string must contain only lowercase English letters. If there are multiples valid strings, return **any** of them.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:**  \"pppz \"\n**Explanation:**  \"pppz \" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as  \"ohhh \" and  \"love \".\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:**  \"xy \"\n**Explanation:**  \"xy \" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as  \"ag \" and  \"ur \".\n\n",
                "**Example 3:**\n\n**Input:** n = 7\n**Output:**  \"holasss \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 500`",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "4",
                "output": "\"pppz\""
            },
            {
                "input": "2",
                "output": "\"xy\""
            },
            {
                "input": "7",
                "output": "\"holasss\""
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public String generateTheString(int n) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < n - 1; i++)\n            result.append('a');\n        if (n % 2 == 0)\n            result.append('b');\n        else\n            result.append('a');\n        return result.toString();\n    }\n}\n```\n    \n    The algorithm to solve this problem is straightforward. We initialize the result with a single character (lowercase 'a') repeated `n` times. If the given integer `n` is even, replace the last character with a different character (lowercase 'b') to make sure that each character occurrence is odd. The resulting string contains each character an odd number of times, satisfying the problem's constraints.\n    ",
        "python": "\n    ```python\ndef generateTheString(n: int) -> str:\n    result = 'a' * n\n    if n % 2 == 0:\n        result = result[:-1] + 'b'\n    return result\n```\n    \n    The algorithm to solve this problem is straightforward. We initialize the result with a single character (lowercase 'a') repeated `n` times. If the given integer `n` is even, replace the last character with a different character (lowercase 'b') to make sure that each character occurrence is odd. The resulting string contains each character an odd number of times, satisfying the problem's constraints.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring generateTheString(int n) {\n    string result(n, 'a');\n    if (n % 2 == 0)\n        result[n - 1] = 'b';\n    return result;\n}\n```\n    \n    The algorithm to solve this problem is straightforward. We initialize the result with a single character (lowercase 'a') repeated `n` times. If the given integer `n` is even, replace the last character with a different character (lowercase 'b') to make sure that each character occurrence is odd. The resulting string contains each character an odd number of times, satisfying the problem's constraints.\n    ",
        "js": "\n    ```javascript\nfunction generateTheString(n) {\n    let result = 'a'.repeat(n);\n    if (n % 2 === 0) {\n        result = result.slice(0, -1) + 'b';\n    }\n    return result;\n}\n```\n    \n    The algorithm to solve this problem is straightforward. We initialize the result with a single character (lowercase 'a') repeated `n` times. If the given integer `n` is even, replace the last character with a different character (lowercase 'b') to make sure that each character occurrence is odd. The resulting string contains each character an odd number of times, satisfying the problem's constraints.\n    "
    },
    {
        "id": 249,
        "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two binary trees `original` and `cloned` and given a reference to a node `target` in the original tree.\n\nThe `cloned` tree is a **copy of** the `original` tree.\n\nReturn _a reference to the same node_ in the `cloned` tree.\n\n**Note** that you are **not allowed** to change any of the two trees or the `target` node and the answer **must be** a reference to a node in the `cloned` tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** tree = \\[7,4,3,null,null,6,19\\], target = 3\n**Output:** 3\n**Explanation:** In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n\n",
                "**Example 2:**\n\n**Input:** tree = \\[7\\], target =  7\n**Output:** 7\n\n",
                "**Example 3:**\n\n**Input:** tree = \\[8,null,6,null,5,null,4,null,3,null,2,null,1\\], target = 4\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the `tree` is in the range `[1, 104]`.\n*   The values of the nodes of the `tree` are unique.\n*   `target` node is a node from the `original` tree and is not `null`.\n\n**",
            "follow_up": "Follow up:** Could you solve the problem if repeated values on the tree are allowed?"
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[7,4,3,null,null,6,19],3",
                "output": "3"
            },
            {
                "input": "[7],7",
                "output": "7"
            },
            {
                "input": "[8,null,6,null,5,null,4,null,3,null,2,null,1],4",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int[][] reconstructMatrix(int upper, int lower, int[] colsum) {\n    int[][] result = new int[2][colsum.length];\n    \n    for (int i = 0; i < colsum.length; i++) {\n        if (colsum[i] == 2) {\n            result[0][i] = 1;\n            result[1][i] = 1;\n            upper--;\n            lower--;\n        } else if (colsum[i] == 1) {\n            if (upper > lower) {\n                result[0][i] = 1;\n                upper--;\n            } else {\n                result[1][i] = 1;\n                lower--;\n            }\n        }\n        \n        if (upper < 0 || lower < 0) {\n            return new int[][]{};\n        }\n    }\n    \n    if (upper > 0 || lower > 0) {\n        return new int[][]{};\n    }\n    \n    return result;\n}\n```\n    \n    First, initialize an empty 2D array with 2 rows and \"n\" columns, where \"n\" is the length of the `colsum` array.\n\nIterate through the `colsum` array, and for each element:\n1. If the element is equal to 2, set both the upper row and lower row values to 1, and decrement both `upper` and `lower`.\n2. If the element is equal to 1, check if `upper` is greater than `lower`. If so, set the value in the upper row to 1 and decrement `upper`, otherwise set the value in the lower row to 1 and decrement `lower`.\n\nAt any point, if either `upper` or `lower` becomes negative, return an empty array as there is no valid solution.\n\nFinally, if either `upper` or `lower` is still greater than 0, return an empty array as there is no valid solution. Otherwise, return the reconstructed 2D array.\n    ",
        "python": "\n    ```python\ndef reconstructMatrix(upper, lower, colsum):\n    result = [[0] * len(colsum) for _ in range(2)]\n    \n    for i in range(len(colsum)):\n        if colsum[i] == 2:\n            result[0][i] = 1\n            result[1][i] = 1\n            upper -= 1\n            lower -= 1\n        elif colsum[i] == 1:\n            if upper > lower:\n                result[0][i] = 1\n                upper -= 1\n            else:\n                result[1][i] = 1\n                lower -= 1\n        \n        if upper < 0 or lower < 0:\n            return []\n    \n    if upper > 0 or lower > 0:\n        return []\n    \n    return result\n```\n    \n    First, initialize an empty 2D array with 2 rows and \"n\" columns, where \"n\" is the length of the `colsum` array.\n\nIterate through the `colsum` array, and for each element:\n1. If the element is equal to 2, set both the upper row and lower row values to 1, and decrement both `upper` and `lower`.\n2. If the element is equal to 1, check if `upper` is greater than `lower`. If so, set the value in the upper row to 1 and decrement `upper`, otherwise set the value in the lower row to 1 and decrement `lower`.\n\nAt any point, if either `upper` or `lower` becomes negative, return an empty array as there is no valid solution.\n\nFinally, if either `upper` or `lower` is still greater than 0, return an empty array as there is no valid solution. Otherwise, return the reconstructed 2D array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) {\n    vector<vector<int>> result(2, vector<int>(colsum.size(), 0));\n    \n    for (int i = 0; i < colsum.size(); i++) {\n        if (colsum[i] == 2) {\n            result[0][i] = 1;\n            result[1][i] = 1;\n            upper--;\n            lower--;\n        } else if (colsum[i] == 1) {\n            if (upper > lower) {\n                result[0][i] = 1;\n                upper--;\n            } else {\n                result[1][i] = 1;\n                lower--;\n            }\n        }\n        \n        if (upper < 0 || lower < 0) {\n            return {};\n        }\n    }\n    \n    if (upper > 0 || lower > 0) {\n        return {};\n    }\n    \n    return result;\n}\n```\n    \n    First, initialize an empty 2D array with 2 rows and \"n\" columns, where \"n\" is the length of the `colsum` array.\n\nIterate through the `colsum` array, and for each element:\n1. If the element is equal to 2, set both the upper row and lower row values to 1, and decrement both `upper` and `lower`.\n2. If the element is equal to 1, check if `upper` is greater than `lower`. If so, set the value in the upper row to 1 and decrement `upper`, otherwise set the value in the lower row to 1 and decrement `lower`.\n\nAt any point, if either `upper` or `lower` becomes negative, return an empty array as there is no valid solution.\n\nFinally, if either `upper` or `lower` is still greater than 0, return an empty array as there is no valid solution. Otherwise, return the reconstructed 2D array.\n    ",
        "js": "\n    ```javascript\nfunction reconstructMatrix(upper, lower, colsum) {\n    const result = Array.from({length: 2}, () => Array(colsum.length).fill(0));\n\n    for (let i = 0; i < colsum.length; i++) {\n        if (colsum[i] === 2) {\n            result[0][i] = 1;\n            result[1][i] = 1;\n            upper--;\n            lower--;\n        } else if (colsum[i] === 1) {\n            if (upper > lower) {\n                result[0][i] = 1;\n                upper--;\n            } else {\n                result[1][i] = 1;\n                lower--;\n            }\n        }\n\n        if (upper < 0 || lower < 0) {\n            return [];\n        }\n    }\n\n    if (upper > 0 || lower > 0) {\n        return [];\n    }\n\n    return result;\n}\n```\n    \n    First, initialize an empty 2D array with 2 rows and \"n\" columns, where \"n\" is the length of the `colsum` array.\n\nIterate through the `colsum` array, and for each element:\n1. If the element is equal to 2, set both the upper row and lower row values to 1, and decrement both `upper` and `lower`.\n2. If the element is equal to 1, check if `upper` is greater than `lower`. If so, set the value in the upper row to 1 and decrement `upper`, otherwise set the value in the lower row to 1 and decrement `lower`.\n\nAt any point, if either `upper` or `lower` becomes negative, return an empty array as there is no valid solution.\n\nFinally, if either `upper` or `lower` is still greater than 0, return an empty array as there is no valid solution. Otherwise, return the reconstructed 2D array.\n    "
    },
    {
        "id": 250,
        "title": "Lucky Numbers in a Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an `m x n` matrix of **distinct** numbers, return _all **lucky numbers** in the matrix in **any** order_.\n\nA **lucky number** is an element of the matrix such that it is the minimum element in its row and maximum in its column.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[3,7,8\\],\\[9,11,13\\],\\[15,16,17\\]\\]\n**Output:** \\[15\\]\n**Explanation:** 15 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,10,4,2\\],\\[9,3,8,7\\],\\[15,16,17,12\\]\\]\n**Output:** \\[12\\]\n**Explanation:** 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[7,8\\],\\[1,2\\]\\]\n**Output:** \\[7\\]\n**Explanation:** 7 is the only lucky number since it is the minimum in its row and the maximum in its column."
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= n, m <= 50`\n*   `1 <= matrix[i][j] <= 105`.\n*   All elements in the matrix are distinct.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[3,7,8],[9,11,13],[15,16,17]]",
                "output": "[15]"
            },
            {
                "input": "[[1,10,4,2],[9,3,8,7],[15,16,17,12]]",
                "output": "[12]"
            },
            {
                "input": "[[7,8],[1,2]]",
                "output": "[7]"
            }
        ],
        "java": "\n    ```java\nint[] dx = {-1, 1, 0, 0};\nint[] dy = {0, 0, -1, 1};\n\nvoid dfs(int[][] grid, int x, int y) {\n    int n = grid.length, m = grid[0].length;\n    grid[x][y] = 1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == 0) {\n            dfs(grid, nx, ny);\n        }\n    }\n}\n\npublic int closedIsland(int[][] grid) {\n    int n = grid.length, m = grid[0].length;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                if (grid[i][j] == 0) {\n                    dfs(grid, i, j);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int i = 1; i < n - 1; i++) {\n        for (int j = 1; j < m - 1; j++) {\n            if (grid[i][j] == 0) {\n                dfs(grid, i, j);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    1. First, create a DFS function that traverses the grid and marks 0s as 1s if they are part of an island.\n2. For each cell in the border of the grid, if it's a 0, use the DFS function to mark all border-connected islands (removing them from consideration).\n3. Traverse the inner cells of the grid (excluding outer border cells) and use DFS to find closed islands by marking connected 0s as 1s. Increment the result counter for each closed island found.\n4. Return the result (number of closed islands).\n    ",
        "python": "\n    ```python\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\ndef dfs(grid, x, y):\n    n, m = len(grid), len(grid[0])\n    grid[x][y] = 1\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:\n            dfs(grid, nx, ny)\n\ndef closedIsland(grid):\n    n, m = len(grid), len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                if grid[i][j] == 0:\n                    dfs(grid, i, j)\n    res = 0\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if grid[i][j] == 0:\n                dfs(grid, i, j)\n                res += 1\n    return res\n```\n\n    \n    1. First, create a DFS function that traverses the grid and marks 0s as 1s if they are part of an island.\n2. For each cell in the border of the grid, if it's a 0, use the DFS function to mark all border-connected islands (removing them from consideration).\n3. Traverse the inner cells of the grid (excluding outer border cells) and use DFS to find closed islands by marking connected 0s as 1s. Increment the result counter for each closed island found.\n4. Return the result (number of closed islands).\n    ",
        "c++": "\n    ```cpp\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    int n = grid.size(), m = grid[0].size();\n    grid[x][y] = 1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == 0) {\n            dfs(grid, nx, ny);\n        }\n    }\n}\n\nint closedIsland(vector<vector<int>>& grid) {\n    int n = grid.size(), m = grid[0].size();\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                if (grid[i][j] == 0) {\n                    dfs(grid, i, j);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int i = 1; i < n - 1; i++) {\n        for (int j = 1; j < m - 1; j++) {\n            if (grid[i][j] == 0) {\n                dfs(grid, i, j);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    1. First, create a DFS function that traverses the grid and marks 0s as 1s if they are part of an island.\n2. For each cell in the border of the grid, if it's a 0, use the DFS function to mark all border-connected islands (removing them from consideration).\n3. Traverse the inner cells of the grid (excluding outer border cells) and use DFS to find closed islands by marking connected 0s as 1s. Increment the result counter for each closed island found.\n4. Return the result (number of closed islands).\n    ",
        "js": "\n    ```javascript\nconst dx = [-1, 1, 0, 0];\nconst dy = [0, 0, -1, 1];\n\nfunction dfs(grid, x, y) {\n    const n = grid.length, m = grid[0].length;\n    grid[x][y] = 1;\n    for (let i = 0; i < 4; i++) {\n        const nx = x + dx[i], ny = y + dy[i];\n        if (0 <= nx && nx < n && 0 <= ny && ny < m && grid[nx][ny] === 0) {\n            dfs(grid, nx, ny);\n        }\n    }\n}\n\nfunction closedIsland(grid) {\n    const n = grid.length, m = grid[0].length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i === 0 || i === n - 1 || j === 0 || j === m - 1) {\n                if (grid[i][j] === 0) {\n                    dfs(grid, i, j);\n                }\n            }\n        }\n    }\n    let res = 0;\n    for (let i = 1; i < n - 1; i++) {\n        for (let j = 1; j < m - 1; j++) {\n            if (grid[i][j] === 0) {\n                dfs(grid, i, j);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    1. First, create a DFS function that traverses the grid and marks 0s as 1s if they are part of an island.\n2. For each cell in the border of the grid, if it's a 0, use the DFS function to mark all border-connected islands (removing them from consideration).\n3. Traverse the inner cells of the grid (excluding outer border cells) and use DFS to find closed islands by marking connected 0s as 1s. Increment the result counter for each closed island found.\n4. Return the result (number of closed islands).\n    "
    },
    {
        "id": 251,
        "title": "Find the Distance Value Between Two Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `arr1` and `arr2`, and the integer `d`, _return the distance value between the two arrays_.\n\nThe distance value is defined as the number of elements `arr1[i]` such that there is not any element `arr2[j]` where `|arr1[i]-arr2[j]| <= d`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[4,5,8\\], arr2 = \\[10,9,1,8\\], d = 2\n**Output:** 2\n**Explanation:** \nFor arr1\\[0\\]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1\\[1\\]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1\\[2\\]=8 we have:\n**|8-10|=2 <= d=2**\n**|8-9|=1 <= d=2**\n|8-1|=7 > d=2\n**|8-8|=0 <= d=2**\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[1,4,2,3\\], arr2 = \\[-4,-3,6,10,20,30\\], d = 3\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** arr1 = \\[2,1,100,3\\], arr2 = \\[-5,-2,10,-3,7\\], d = 6\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 500`\n*   `-1000 <= arr1[i], arr2[j] <= 1000`\n*   `0 <= d <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,5,8],[10,9,1,8],2",
                "output": "2"
            },
            {
                "input": "[1,4,2,3],[-4,-3,6,10,20,30],3",
                "output": "2"
            },
            {
                "input": "[2,1,100,3],[-5,-2,10,-3,7],6",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\n    int distance = 0;\n    for (int a : arr1) {\n        boolean found = true;\n        for (int b : arr2) {\n            if (Math.abs(a - b) <= d) {\n                found = false;\n                break;\n            }\n        }\n        if (found) distance++;\n    }\n    return distance;\n}\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    ",
        "python": "\n    ```python\ndef findTheDistanceValue(arr1, arr2, d):\n    distance = 0\n    for a in arr1:\n        found = True\n        for b in arr2:\n            if abs(a - b) <= d:\n                found = False\n                break\n        if found:\n            distance += 1\n    return distance\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    ",
        "c++": "\n    ```cpp\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n    int distance = 0;\n    for (int a : arr1) {\n        bool found = true;\n        for (int b : arr2) {\n            if (abs(a - b) <= d) {\n                found = false;\n                break;\n            }\n        }\n        if (found) distance++;\n    }\n    return distance;\n}\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    ",
        "js": "\n    ```javascript\nfunction findTheDistanceValue(arr1, arr2, d) {\n    let distance = 0;\n    for (let a of arr1) {\n        let found = true;\n        for (let b of arr2) {\n            if (Math.abs(a - b) <= d) {\n                found = false;\n                break;\n            }\n        }\n        if (found) distance++;\n    }\n    return distance;\n}\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    "
    },
    {
        "id": 252,
        "title": "Find Lucky Integer in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, a **lucky integer** is an integer that has a frequency in the array equal to its value.\n\nReturn _the largest **lucky integer** in the array_. If there is no **lucky integer** return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,2,3,4\\]\n**Output:** 2\n**Explanation:** The only lucky number in the array is 2 because frequency\\[2\\] == 2.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,2,3,3,3\\]\n**Output:** 3\n**Explanation:** 1, 2 and 3 are all lucky numbers, return the largest of them.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[2,2,2,3,3\\]\n**Output:** -1\n**Explanation:** There are no lucky numbers in the array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 500`\n*   `1 <= arr[i] <= 500`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[2,2,3,4]",
                "output": "2"
            },
            {
                "input": "[1,2,2,3,3,3]",
                "output": "3"
            },
            {
                "input": "[2,2,2,3,3]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findLucky(int[] arr) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int num : arr) {\n        freq.put(num, freq.getOrDefault(num, 0) + 1);\n    }\n    int maxLucky = -1;\n    for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n        if (entry.getKey().equals(entry.getValue())) {\n            maxLucky = Math.max(maxLucky, entry.getKey());\n        }\n    }\n    return maxLucky;\n}\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    ",
        "python": "\n    ```python\ndef find_lucky(arr):\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    max_lucky = -1\n    for num, count in freq.items():\n        if num == count:\n            max_lucky = max(max_lucky, num)\n    return max_lucky\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    ",
        "c++": "\n    ```cpp\nint findLucky(vector<int>& arr) {\n    unordered_map<int, int> freq;\n    for (int num : arr) {\n        freq[num]++;\n    }\n    int maxLucky = -1;\n    for (auto& pair : freq) {\n        if (pair.first == pair.second) {\n            maxLucky = max(maxLucky, pair.first);\n        }\n    }\n    return maxLucky;\n}\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    ",
        "js": "\n    ```javascript\nfunction findLucky(arr) {\n    const freq = {};\n    for (const num of arr) {\n        if (!freq[num]) {\n            freq[num] = 0;\n        }\n        freq[num]++;\n    }\n    let maxLucky = -1;\n    for (const [num, count] of Object.entries(freq)) {\n        if ( parseInt(num) === count) {\n            maxLucky = Math.max(maxLucky, parseInt(num));\n        }\n    }\n    return maxLucky;\n}\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    "
    },
    {
        "id": 253,
        "title": "Count Largest Group",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `n`.\n\nEach number from `1` to `n` is grouped according to the sum of its digits.\n\nReturn _the number of groups that have the largest size_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13\n**Output:** 4\n**Explanation:** There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n\\[1,10\\], \\[2,11\\], \\[3,12\\], \\[4,13\\], \\[5\\], \\[6\\], \\[7\\], \\[8\\], \\[9\\].\nThere are 4 groups with largest size.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are 2 groups \\[1\\], \\[2\\] of size 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math"
        ],
        "example": [
            {
                "input": "13",
                "output": "4"
            },
            {
                "input": "2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countLargestGroup(int n) {\n    int[] groups = new int[37];\n    int largest_group_size = 0;\n    int count_largest_groups = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int sum = 0, num = i;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        groups[sum]++;\n        if (groups[sum] > largest_group_size) {\n            largest_group_size = groups[sum];\n            count_largest_groups = 1;\n        } else if (groups[sum] == largest_group_size) {\n            count_largest_groups++;\n        }\n    }\n    return count_largest_groups;\n}\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "python": "\n    ```python\ndef countLargestGroup(n: int) -> int:\n    groups = [0] * 37\n    largest_group_size = 0\n    count_largest_groups = 0\n\n    for i in range(1, n + 1):\n        sum_of_digits = sum(map(int, str(i)))\n        groups[sum_of_digits] += 1\n        if groups[sum_of_digits] > largest_group_size:\n            largest_group_size = groups[sum_of_digits]\n            count_largest_groups = 1\n        elif groups[sum_of_digits] == largest_group_size:\n            count_largest_groups += 1\n\n    return count_largest_groups\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "c++": "\n    ```cpp\nint countLargestGroup(int n) {\n    std::vector<int> groups(37, 0);\n    int largest_group_size = 0;\n    int count_largest_groups = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        int sum = 0, num = i;\n        while (num) {\n            sum += num % 10;\n            num /= 10;\n        }\n        groups[sum]++;\n        if (groups[sum] > largest_group_size) {\n            largest_group_size = groups[sum];\n            count_largest_groups = 1;\n        } else if (groups[sum] == largest_group_size) {\n            count_largest_groups++;\n        }\n    }\n    return count_largest_groups;\n}\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "js": "\n    ```javascript\nfunction countLargestGroup(n) {\n    const groups = new Array(37).fill(0);\n    let largest_group_size = 0;\n    let count_largest_groups = 0;\n\n    for (let i = 1; i <= n; i++) {\n        const sum = i.toString().split('').reduce((a, b) => a + parseInt(b), 0);\n        groups[sum]++;\n        if (groups[sum] > largest_group_size) {\n            largest_group_size = groups[sum];\n            count_largest_groups = 1;\n        } else if (groups[sum] === largest_group_size) {\n            count_largest_groups++;\n        }\n    }\n    return count_largest_groups;\n};\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    "
    },
    {
        "id": 254,
        "title": "Minimum Subsequence in Non-Increasing Order",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the array `nums`, obtain a subsequence of the array whose sum of elements is **strictly greater** than the sum of the non included elements in such subsequence.\n\nIf there are multiple solutions, return the subsequence with **minimum size** and if there still exist multiple solutions, return the subsequence with the **maximum total sum** of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.\n\nNote that the solution with the given constraints is guaranteed to be **unique**. Also return the answer sorted in **non-increasing** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,10,9,8\\]\n**Output:** \\[10,9\\] \n**Explanation:** The subsequences \\[10,9\\] and \\[10,8\\] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence \\[10,9\\] has the maximum total sum of its elements. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,4,7,6,7\\]\n**Output:** \\[7,7,6\\] \n**Explanation:** The subsequence \\[7,7\\] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence \\[7,6,7\\] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 500`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,3,10,9,8]",
                "output": "[10,9]"
            },
            {
                "input": "[4,4,7,6,7]",
                "output": "[7,7,6]"
            }
        ],
        "java": "\n    ```java\npublic int minChangesToDivideString(String s, int k) {\n    int n = s.length();\n    if (n % k != 0) return -1;\n    int chunkCount = n / k;\n    int res = 0;\n    for (int i = 0; i < k; ++i) {\n        int[] counts = new int[26];\n        for (int j = i; j < n; j += k) {\n            ++counts[s.charAt(j) - 'a'];\n        }\n        int maxCount = Arrays.stream(counts).max().getAsInt();\n        res += chunkCount - maxCount;\n    }\n    return res;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    ",
        "python": "\n    ```python\ndef min_changes_to_divide_string(s, k):\n    n = len(s)\n    if n % k != 0:\n        return -1\n    chunk_count = n // k\n    res = 0\n    for i in range(k):\n        counts = [0] * 26\n        for j in range(i, n, k):\n            counts[ord(s[j]) - ord('a')] += 1\n        max_count = max(counts)\n        res += chunk_count - max_count\n    return res\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    ",
        "c++": "\n    ```cpp\nint min_changes_to_divide_string(const std::string& s, int k) {\n    int n = s.length();\n    if (n % k != 0) return -1;\n    int chunk_count = n / k;\n    int res = 0;\n    for (int i = 0; i < k; ++i) {\n        int counts[26] = {0};\n        for (int j = i; j < n; j += k) {\n            ++counts[s[j] - 'a'];\n        }\n        int max_count = *std::max_element(counts, counts + 26);\n        res += chunk_count - max_count;\n    }\n    return res;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    ",
        "js": "\n    ```javascript\nfunction minChangesToDivideString(s, k) {\n    let n = s.length;\n    if (n % k !== 0) {\n        return -1;\n    }\n    let chunkCount = n / k;\n    let res = 0;\n    for (let i = 0; i < k; ++i) {\n        let counts = new Array(26).fill(0);\n        for (let j = i; j < n; j += k) {\n            ++counts[s.charCodeAt(j) - 'a'.charCodeAt(0)];\n        }\n        let maxCount = Math.max(...counts);\n        res += chunkCount - maxCount;\n    }\n    return res;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    "
    },
    {
        "id": 255,
        "title": "String Matching in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of string `words`, return _all strings in_ `words` _that is a **substring** of another word_. You can return the answer in **any order**.\n\nA **substring** is a contiguous sequence of characters within a string",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"mass \", \"as \", \"hero \", \"superhero \"\\]\n**Output:** \\[ \"as \", \"hero \"\\]\n**Explanation:**  \"as \" is substring of  \"mass \" and  \"hero \" is substring of  \"superhero \".\n\\[ \"hero \", \"as \"\\] is also a valid answer.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"leetcode \", \"et \", \"code \"\\]\n**Output:** \\[ \"et \", \"code \"\\]\n**Explanation:**  \"et \",  \"code \" are substring of  \"leetcode \".\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"blue \", \"green \", \"bu \"\\]\n**Output:** \\[\\]\n**Explanation:** No string of words is substring of another string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 30`\n*   `words[i]` contains only lowercase English letters.\n*   All the strings of `words` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "[\"mass\",\"as\",\"hero\",\"superhero\"]",
                "output": "[\"as\",\"hero\"]"
            },
            {
                "input": "[\"leetcode\",\"et\",\"code\"]",
                "output": "[\"et\",\"code\"]"
            },
            {
                "input": "[\"blue\",\"green\",\"bu\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.lang.Math;\n\npublic int smallestDivisor(int[] nums, int threshold) {\n    int left = 1, right = 1000000;\n    while (left < right) {\n        int mid = (left + right) / 2;\n        int sum = 0;\n        for (int n : nums) {\n            sum += Math.ceil(1.0 * n / mid);\n        }\n        if (sum > threshold) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    We will use a binary search to find the smallest divisor. Define the search range initially from 1 to 1,000,000 (10^6). Calculate the middle value 'mid' between the given search range (left and right), and then get the sum of division results using that middle value in the array. If the sum of the division results is greater than the given threshold, that means the divisor must be larger, so we update the left boundary to be equal to 'mid' + 1. If the sum is less than or equal to the threshold, it means the divisor can be smaller or the value itself, so we update the right boundary to be equal to 'mid'. We repeat this process until the left and right boundaries are equal, and the final answer will be the left boundary.\n    ",
        "python": "\n    ```python\nimport math\n\ndef smallest_divisor(nums, threshold):\n    left, right = 1, 10**6\n    while left < right:\n        mid = (left + right) // 2\n        total = sum(math.ceil(n / mid) for n in nums)\n        if total > threshold:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n```\n    \n    We will use a binary search to find the smallest divisor. Define the search range initially from 1 to 1,000,000 (10^6). Calculate the middle value 'mid' between the given search range (left and right), and then get the sum of division results using that middle value in the array. If the sum of the division results is greater than the given threshold, that means the divisor must be larger, so we update the left boundary to be equal to 'mid' + 1. If the sum is less than or equal to the threshold, it means the divisor can be smaller or the value itself, so we update the right boundary to be equal to 'mid'. We repeat this process until the left and right boundaries are equal, and the final answer will be the left boundary.\n    ",
        "c++": "\n    ```cpp\n#include <cmath>\n#include <vector>\n\nint smallestDivisor(std::vector<int>& nums, int threshold) {\n    int left = 1, right = 1e6;\n    while (left < right) {\n        int mid = (left + right) / 2;\n        int sum = 0;\n        for (int n : nums) {\n            sum += std::ceil(1.0 * n / mid);\n        }\n        if (sum > threshold) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    We will use a binary search to find the smallest divisor. Define the search range initially from 1 to 1,000,000 (10^6). Calculate the middle value 'mid' between the given search range (left and right), and then get the sum of division results using that middle value in the array. If the sum of the division results is greater than the given threshold, that means the divisor must be larger, so we update the left boundary to be equal to 'mid' + 1. If the sum is less than or equal to the threshold, it means the divisor can be smaller or the value itself, so we update the right boundary to be equal to 'mid'. We repeat this process until the left and right boundaries are equal, and the final answer will be the left boundary.\n    ",
        "js": "\n    ```javascript\nfunction smallestDivisor(nums, threshold) {\n    let left = 1, right = 10**6;\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let sum = nums.reduce((acc, n) => acc + Math.ceil(n / mid), 0);\n        if (sum > threshold) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    We will use a binary search to find the smallest divisor. Define the search range initially from 1 to 1,000,000 (10^6). Calculate the middle value 'mid' between the given search range (left and right), and then get the sum of division results using that middle value in the array. If the sum of the division results is greater than the given threshold, that means the divisor must be larger, so we update the left boundary to be equal to 'mid' + 1. If the sum is less than or equal to the threshold, it means the divisor can be smaller or the value itself, so we update the right boundary to be equal to 'mid'. We repeat this process until the left and right boundaries are equal, and the final answer will be the left boundary.\n    "
    },
    {
        "id": 256,
        "title": "Minimum Value to Get Positive Step by Step Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, you start with an initial **positive** value _startValue__._\n\nIn each iteration, you calculate the step by step sum of _startValue_ plus elements in `nums` (from left to right).\n\nReturn the minimum **positive** value of _startValue_ such that the step by step sum is never less than 1.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-3,2,-3,4,2\\]\n**Output:** 5\n**Explanation:** If you choose startValue = 4, in the third iteration your step by step sum is less than 1.\n**step by step sum**\n**startValue = 4 | startValue = 5 | nums**\n  (4 **\\-3** ) = 1  | (5 **\\-3** ) = 2    |  -3\n  (1 **+2** ) = 3  | (2 **+2** ) = 4    |   2\n  (3 **\\-3** ) = 0  | (4 **\\-3** ) = 1    |  -3\n  (0 **+4** ) = 4  | (1 **+4** ) = 5    |   4\n  (4 **+2** ) = 6  | (5 **+2** ) = 7    |   2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 1\n**Explanation:** Minimum start value should be positive. \n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,-2,-3\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `-100 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[-3,2,-3,4,2]",
                "output": "5"
            },
            {
                "input": "[1,2]",
                "output": "1"
            },
            {
                "input": "[1,-2,-3]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int maxSideLength(int[][] mat, int threshold) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int ans = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1];\n            int k = ans + 1;\n            if (i >= k && j >= k && dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold) {\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    We use dynamic programming to solve this problem. First, we create a 2D dp array of size (m+1) x (n+1) initialized with 0. The dp array stores the sum of all elements above and left of the current cell, including the current cell. Then, we iterate through each cell in the input matrix, and compute the sums for the dp array.\n\nAt each cell, we check if there is a possibility of extending the side length of the square. We do this by checking if the current cell's row and column are greater than or equal to the side length we are checking for (ans + 1). If true, we check if the sum of the square with side length (ans + 1) is less than or equal to the threshold. The sum is computed using the dp array's values by adding the top-left and bottom-right corners and subtracting the bottom-left and top-right corners. If the sum is within the threshold, we increment the ans variable.\n\nFinally, we return the ans variable which stores the maximum side-length of a square with sum less than or equal to the threshold.\n    ",
        "python": "\n    ```python\ndef maxSideLength(mat, threshold):\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    ans = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]\n            k = ans + 1\n            if i >= k and j >= k and dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold:\n                ans += 1\n\n    return ans\n```\n    \n    We use dynamic programming to solve this problem. First, we create a 2D dp array of size (m+1) x (n+1) initialized with 0. The dp array stores the sum of all elements above and left of the current cell, including the current cell. Then, we iterate through each cell in the input matrix, and compute the sums for the dp array.\n\nAt each cell, we check if there is a possibility of extending the side length of the square. We do this by checking if the current cell's row and column are greater than or equal to the side length we are checking for (ans + 1). If true, we check if the sum of the square with side length (ans + 1) is less than or equal to the threshold. The sum is computed using the dp array's values by adding the top-left and bottom-right corners and subtracting the bottom-left and top-right corners. If the sum is within the threshold, we increment the ans variable.\n\nFinally, we return the ans variable which stores the maximum side-length of a square with sum less than or equal to the threshold.\n    ",
        "c++": "\n    ```cpp\nint maxSideLength(vector<vector<int>>& mat, int threshold) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int ans = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = mat[i-1][j-1] + dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1];\n            int k = ans + 1;\n            if (i >= k && j >= k && dp[i][j] - dp[i][j-k] - dp[i-k][j] + dp[i-k][j-k] <= threshold) {\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    We use dynamic programming to solve this problem. First, we create a 2D dp array of size (m+1) x (n+1) initialized with 0. The dp array stores the sum of all elements above and left of the current cell, including the current cell. Then, we iterate through each cell in the input matrix, and compute the sums for the dp array.\n\nAt each cell, we check if there is a possibility of extending the side length of the square. We do this by checking if the current cell's row and column are greater than or equal to the side length we are checking for (ans + 1). If true, we check if the sum of the square with side length (ans + 1) is less than or equal to the threshold. The sum is computed using the dp array's values by adding the top-left and bottom-right corners and subtracting the bottom-left and top-right corners. If the sum is within the threshold, we increment the ans variable.\n\nFinally, we return the ans variable which stores the maximum side-length of a square with sum less than or equal to the threshold.\n    ",
        "js": "\n    ```javascript\nfunction maxSideLength(mat, threshold) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let ans = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1];\n            const k = ans + 1;\n            if (i >= k && j >= k && dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold) {\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    We use dynamic programming to solve this problem. First, we create a 2D dp array of size (m+1) x (n+1) initialized with 0. The dp array stores the sum of all elements above and left of the current cell, including the current cell. Then, we iterate through each cell in the input matrix, and compute the sums for the dp array.\n\nAt each cell, we check if there is a possibility of extending the side length of the square. We do this by checking if the current cell's row and column are greater than or equal to the side length we are checking for (ans + 1). If true, we check if the sum of the square with side length (ans + 1) is less than or equal to the threshold. The sum is computed using the dp array's values by adding the top-left and bottom-right corners and subtracting the bottom-left and top-right corners. If the sum is within the threshold, we increment the ans variable.\n\nFinally, we return the ans variable which stores the maximum side-length of a square with sum less than or equal to the threshold.\n    "
    },
    {
        "id": 257,
        "title": "Reformat The String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an alphanumeric string `s`. (**Alphanumeric string** is a string consisting of lowercase English letters and digits).\n\nYou have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.\n\nReturn _the reformatted string_ or return **an empty string** if it is impossible to reformat the string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"a0b1c2 \"\n**Output:**  \"0a1b2c \"\n**Explanation:** No two adjacent characters have the same type in  \"0a1b2c \".  \"a0b1c2 \",  \"0a1b2c \",  \"0c2a1b \" are also valid permutations.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"leetcode \"\n**Output:**  \" \"\n**Explanation:**  \"leetcode \" has only characters so we cannot separate them by digits.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"1229857369 \"\n**Output:**  \" \"\n**Explanation:**  \"1229857369 \" has only digits so we cannot separate them by characters."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of only lowercase English letters and/or digits.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"a0b1c2\"",
                "output": "\"0a1b2c\""
            },
            {
                "input": "\"leetcode\"",
                "output": "\"\""
            },
            {
                "input": "\"1229857369\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic String reformat(String s) {\n    Queue<Character> letters = new LinkedList<>();\n    Queue<Character> digits = new LinkedList<>();\n\n    for (char c : s.toCharArray()) {\n        if (Character.isLetter(c)) letters.add(c);\n        else digits.add(c);\n    }\n\n    if (Math.abs(letters.size() - digits.size()) > 1) return \"\";\n\n    StringBuilder result = new StringBuilder();\n    boolean useLetter = letters.size() > digits.size();\n\n    while (!letters.isEmpty() || !digits.isEmpty()) {\n        if (useLetter) {\n            result.append(letters.poll());\n        } else {\n            result.append(digits.poll());\n        }\n        useLetter = !useLetter;\n    }\n\n    return result.toString();\n}\n```\n    \n    The algorithm first separates the input string `s` into two queues, `letters` and `digits`. This can be done by iterating through the input string `s` and checking if each character is a letter or digit. Then it checks if the difference between the number of letters and digits is greater than 1. If so, it returns an empty string as it is impossible to reformat the string with no two adjacent characters having the same type.\n\nIf the difference is not greater than 1, the algorithm initializes an empty result string or list. Then, it checks which type (letter or digit) has more elements, and iterates through the queues, alternating between types (letters and digits) and inserting the next character of the current type into the result. This ensures no two adjacent characters have the same type. Finally, the algorithm returns the result in the appropriate type (string or list, depending on the language).\n\nThe algorithm's complexity is O(n), where n is the length of the input string `s`.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef reformat(s: str) -> str:\n    letters, digits = deque(), deque()\n\n    for c in s:\n        if c.isalpha():\n            letters.append(c)\n        else:\n            digits.append(c)\n\n    if abs(len(letters) - len(digits)) > 1:\n        return \"\"\n\n    result = []\n    use_letter = len(letters) > len(digits)\n\n    while letters or digits:\n        if use_letter:\n            result.append(letters.popleft())\n        else:\n            result.append(digits.popleft())\n        use_letter = not use_letter\n\n    return ''.join(result)\n```\n    \n    The algorithm first separates the input string `s` into two queues, `letters` and `digits`. This can be done by iterating through the input string `s` and checking if each character is a letter or digit. Then it checks if the difference between the number of letters and digits is greater than 1. If so, it returns an empty string as it is impossible to reformat the string with no two adjacent characters having the same type.\n\nIf the difference is not greater than 1, the algorithm initializes an empty result string or list. Then, it checks which type (letter or digit) has more elements, and iterates through the queues, alternating between types (letters and digits) and inserting the next character of the current type into the result. This ensures no two adjacent characters have the same type. Finally, the algorithm returns the result in the appropriate type (string or list, depending on the language).\n\nThe algorithm's complexity is O(n), where n is the length of the input string `s`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <queue>\n\nstd::string reformat(std::string s) {\n    std::queue<char> letters, digits;\n\n    for (char c : s) {\n        if (isalpha(c)) letters.push(c);\n        else digits.push(c);\n    }\n\n    if (abs((int)(letters.size() - digits.size())) > 1) return \"\";\n\n    std::string result = \"\";\n    bool use_letter = letters.size() > digits.size();\n\n    while (!letters.empty() || !digits.empty()) {\n        if (use_letter) {\n            result += letters.front();\n            letters.pop();\n        } else {\n            result += digits.front();\n            digits.pop();\n        }\n        use_letter = !use_letter;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first separates the input string `s` into two queues, `letters` and `digits`. This can be done by iterating through the input string `s` and checking if each character is a letter or digit. Then it checks if the difference between the number of letters and digits is greater than 1. If so, it returns an empty string as it is impossible to reformat the string with no two adjacent characters having the same type.\n\nIf the difference is not greater than 1, the algorithm initializes an empty result string or list. Then, it checks which type (letter or digit) has more elements, and iterates through the queues, alternating between types (letters and digits) and inserting the next character of the current type into the result. This ensures no two adjacent characters have the same type. Finally, the algorithm returns the result in the appropriate type (string or list, depending on the language).\n\nThe algorithm's complexity is O(n), where n is the length of the input string `s`.\n    ",
        "js": "\n    ```javascript\nfunction reformat(s) {\n    const letters = [], digits = [];\n\n    for (const c of s) {\n        if (c.charCodeAt(0) > 57) letters.push(c);\n        else digits.push(c);\n    }\n\n    if (Math.abs(letters.length - digits.length) > 1) return \"\";\n\n    let result = \"\";\n    let useLetter = letters.length > digits.length;\n\n    while (letters.length || digits.length) {\n        if (useLetter) {\n            result += letters.shift();\n        } else {\n            result += digits.shift();\n        }\n        useLetter = !useLetter;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first separates the input string `s` into two queues, `letters` and `digits`. This can be done by iterating through the input string `s` and checking if each character is a letter or digit. Then it checks if the difference between the number of letters and digits is greater than 1. If so, it returns an empty string as it is impossible to reformat the string with no two adjacent characters having the same type.\n\nIf the difference is not greater than 1, the algorithm initializes an empty result string or list. Then, it checks which type (letter or digit) has more elements, and iterates through the queues, alternating between types (letters and digits) and inserting the next character of the current type into the result. This ensures no two adjacent characters have the same type. Finally, the algorithm returns the result in the appropriate type (string or list, depending on the language).\n\nThe algorithm's complexity is O(n), where n is the length of the input string `s`.\n    "
    },
    {
        "id": 258,
        "title": "Maximum Score After Splitting a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` of zeros and ones, _return the maximum score after splitting the string into two **non-empty** substrings_ (i.e. **left** substring and **right** substring).\n\nThe score after splitting a string is the number of **zeros** in the **left** substring plus the number of **ones** in the **right** substring.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"011101 \"\n**Output:** 5 \n**Explanation:** \nAll possible ways of splitting s into two non-empty substrings are:\nleft =  \"0 \" and right =  \"11101 \", score = 1 + 4 = 5 \nleft =  \"01 \" and right =  \"1101 \", score = 1 + 3 = 4 \nleft =  \"011 \" and right =  \"101 \", score = 1 + 2 = 3 \nleft =  \"0111 \" and right =  \"01 \", score = 1 + 1 = 2 \nleft =  \"01110 \" and right =  \"1 \", score = 2 + 1 = 3\n\n",
                "**Example 2:**\n\n**Input:** s =  \"00111 \"\n**Output:** 5\n**Explanation:** When left =  \"00 \" and right =  \"111 \", we get the maximum score = 2 + 3 = 5\n\n",
                "**Example 3:**\n\n**Input:** s =  \"1111 \"\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 500`\n*   The string `s` consists of characters `'0'` and `'1'` only.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "\"011101\"",
                "output": "5"
            },
            {
                "input": "\"00111\"",
                "output": "5"
            },
            {
                "input": "\"1111\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeMap;\n\npublic boolean isPossibleDivide(int[] nums, int k) {\n    TreeMap<Integer, Integer> counts = new TreeMap<>();\n    for (int num : nums) counts.put(num, counts.getOrDefault(num, 0) + 1);\n    \n    for (int key : counts.keySet()) {\n        if (counts.get(key) > 0) {\n            for (int i = k - 1; i >= 0; --i) {\n                if (!counts.containsKey(key + i) || counts.get(key + i) < counts.get(key)) return false;\n                counts.put(key + i, counts.get(key + i) - counts.get(key));\n            }\n        }\n    }\n    \n    return true;\n}\n```\n    \n    1. Create a count map that counts the occurrences of each integer in the input array.\n2. Iterate through the keys in ascending order.\n3. For each key, if its value is greater than 0, try to find k-1 integers that are consecutive to the current integer.\n4. While iterating the keys, check if the occurrences of all consecutive integers are equal to or greater than the occurrences of the current integer. If not, return false as it isn't possible to divide the array into sets of k consecutive numbers. If everything passes through, return true.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef is_possible_divide(nums: List[int], k: int) -> bool:\n    counts = Counter(nums)\n    \n    for key in sorted(counts):\n        if counts[key] > 0:\n            for i in range(k-1, -1, -1):\n                if counts[key+i] < counts[key]:\n                    return False\n                counts[key+i] -= counts[key]\n    \n    return True\n```\n    \n    1. Create a count map that counts the occurrences of each integer in the input array.\n2. Iterate through the keys in ascending order.\n3. For each key, if its value is greater than 0, try to find k-1 integers that are consecutive to the current integer.\n4. While iterating the keys, check if the occurrences of all consecutive integers are equal to or greater than the occurrences of the current integer. If not, return false as it isn't possible to divide the array into sets of k consecutive numbers. If everything passes through, return true.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n\nbool isPossibleDivide(std::vector<int>& nums, int k) {\n    std::map<int, int> counts;\n    for (int num : nums) counts[num]++;\n    \n    for (auto it = counts.begin(); it != counts.end(); ++it) {\n        if (it->second > 0) {\n            for (int i = k - 1; i >= 0; --i) {\n                if ((counts[it->first + i] -= it->second) < 0) return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```\n    \n    1. Create a count map that counts the occurrences of each integer in the input array.\n2. Iterate through the keys in ascending order.\n3. For each key, if its value is greater than 0, try to find k-1 integers that are consecutive to the current integer.\n4. While iterating the keys, check if the occurrences of all consecutive integers are equal to or greater than the occurrences of the current integer. If not, return false as it isn't possible to divide the array into sets of k consecutive numbers. If everything passes through, return true.\n    ",
        "js": "\n    ```javascript\nfunction isPossibleDivide(nums, k) {\n    const counts = new Map();\n    for (const num of nums) counts.set(num, (counts.get(num) || 0) + 1);\n    \n    for (const [key, value] of [...counts.entries()].sort((a, b) => a[0] - b[0])) {\n        if (value > 0) {\n            for (let i = k - 1; i >= 0; --i) {\n                if ((counts.get(key + i) || 0) < value) return false;\n                counts.set(key + i, counts.get(key + i) - value);\n            }\n        }\n    }\n    \n    return true;\n}\n```\n    \n    1. Create a count map that counts the occurrences of each integer in the input array.\n2. Iterate through the keys in ascending order.\n3. For each key, if its value is greater than 0, try to find k-1 integers that are consecutive to the current integer.\n4. While iterating the keys, check if the occurrences of all consecutive integers are equal to or greater than the occurrences of the current integer. If not, return false as it isn't possible to divide the array into sets of k consecutive numbers. If everything passes through, return true.\n    "
    },
    {
        "id": 259,
        "title": "Kids With the Greatest Number of Candies",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` kids with candies. You are given an integer array `candies`, where each `candies[i]` represents the number of candies the `ith` kid has, and an integer `extraCandies`, denoting the number of extra candies that you have.\n\nReturn _a boolean array_ `result` _of length_ `n`_, where_ `result[i]` _is_ `true` _if, after giving the_ `ith` _kid all the_ `extraCandies`_, they will have the **greatest** number of candies among all the kids__, or_ `false` _otherwise_.\n\nNote that **multiple** kids can have the **greatest** number of candies.",
            "examples": [
                "**Example 1:**\n\n**Input:** candies = \\[2,3,5,1,3\\], extraCandies = 3\n**Output:** \\[true,true,true,false,true\\] \n**Explanation:** If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n\n",
                "**Example 2:**\n\n**Input:** candies = \\[4,2,1,1,2\\], extraCandies = 1\n**Output:** \\[true,false,false,false,false\\] \n**Explanation:** There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n\n",
                "**Example 3:**\n\n**Input:** candies = \\[12,1,12\\], extraCandies = 10\n**Output:** \\[true,false,true\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == candies.length`\n*   `2 <= n <= 100`\n*   `1 <= candies[i] <= 100`\n*   `1 <= extraCandies <= 50`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[2,3,5,1,3],3",
                "output": "[true,true,true,false,true]"
            },
            {
                "input": "[4,2,1,1,2],1",
                "output": "[true,false,false,false,false]"
            },
            {
                "input": "[12,1,12],10",
                "output": "[true,false,true]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class DAGAncestors {\n    public static void findAncestors(int node, List<List<Integer>> adjList, boolean[] visited, List<Integer> ancestors) {\n        if (visited[node]) return;\n        visited[node] = true;\n        for (int ancestor : adjList.get(node)) {\n            ancestors.add(ancestor);\n            findAncestors(ancestor, adjList, visited, ancestors);\n        }\n    }\n\n    public static List<List<Integer>> findAncestorsInDAG(int n, int[][] edges) {\n        List<List<Integer>> adjList = new ArrayList<>();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n; ++i) {\n            adjList.add(new ArrayList<>());\n            ans.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            adjList.get(edge[1]).add(edge[0]);\n        }\n        for (int i = 0; i < n; ++i) {\n            boolean[] visited = new boolean[n];\n            findAncestors(i, adjList, visited, ans.get(i));\n            Collections.sort(ans.get(i));\n        }\n        return ans;\n    }\n}\n```\n\n    \n    The algorithm works by iterating over all the given nodes and finding the ancestors of each node.\n1. Create an adjacency list representation of the graph where the keys are the nodes and the values are lists of their parents.\n2. For each node `i` in the graph, perform a Depth-First Search using a helper function `findAncestors()`, to explore all the ancestors by traversing the parent nodes.\n3. During the search, maintain a `visited` array to prevent infinite loops and avoid visiting already visited nodes.\n4. Append the ancestors of each node to a list and sort it in ascending order.\n5. Return the list of ancestors for all nodes as a nested list.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef find_ancestors(node, adj_list, visited, ans):\n    if visited[node]:\n        return\n    visited[node] = True\n    for ancestor in adj_list[node]:\n        ans.append(ancestor)\n        find_ancestors(ancestor, adj_list, visited, ans)\n\ndef find_ancestors_in_dag(n, edges):\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[1]].append(edge[0])\n    ans = []\n    for i in range(n):\n        visited = [False] * n\n        ancestors = []\n        find_ancestors(i, adj_list, visited, ancestors)\n        ans.append(sorted(ancestors))\n    return ans\n```\n\n    \n    The algorithm works by iterating over all the given nodes and finding the ancestors of each node.\n1. Create an adjacency list representation of the graph where the keys are the nodes and the values are lists of their parents.\n2. For each node `i` in the graph, perform a Depth-First Search using a helper function `findAncestors()`, to explore all the ancestors by traversing the parent nodes.\n3. During the search, maintain a `visited` array to prevent infinite loops and avoid visiting already visited nodes.\n4. Append the ancestors of each node to a list and sort it in ascending order.\n5. Return the list of ancestors for all nodes as a nested list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid findAncestors(int node, vector<vector<int>>& adj_list, vector<bool>& visited, vector<int>& ans) {\n    if (visited[node]) return;\n    visited[node] = true;\n    for (int ancestor : adj_list[node]) {\n        ans.push_back(ancestor);\n        findAncestors(ancestor, adj_list, visited, ans);\n    }\n}\n\nvector<vector<int>> findAncestorsInDAG(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> adj_list(n), ans(n);\n    for (vector<int>& edge : edges) {\n        adj_list[edge[1]].push_back(edge[0]);\n    }\n    for (int i = 0; i < n; ++i) {\n        vector<bool> visited(n, false);\n        findAncestors(i, adj_list, visited, ans[i]);\n        sort(ans[i].begin(), ans[i].end());\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm works by iterating over all the given nodes and finding the ancestors of each node.\n1. Create an adjacency list representation of the graph where the keys are the nodes and the values are lists of their parents.\n2. For each node `i` in the graph, perform a Depth-First Search using a helper function `findAncestors()`, to explore all the ancestors by traversing the parent nodes.\n3. During the search, maintain a `visited` array to prevent infinite loops and avoid visiting already visited nodes.\n4. Append the ancestors of each node to a list and sort it in ascending order.\n5. Return the list of ancestors for all nodes as a nested list.\n    ",
        "js": "\n    ```javascript\nfunction findAncestors(node, adjList, visited, ancestors) {\n    if (visited[node]) return;\n    visited[node] = true;\n    for (const ancestor of adjList[node]) {\n        ancestors.push(ancestor);\n        findAncestors(ancestor, adjList, visited, ancestors);\n    }\n}\n\nfunction findAncestorsInDAG(n, edges) {\n    const adjList = new Array(n).fill(0).map(() => []);\n    const ans = new Array(n).fill(0).map(() => []);\n    for (const edge of edges) {\n        adjList[edge[1]].push(edge[0]);\n    }\n    for (let i = 0; i < n; ++i) {\n        const visited = new Array(n).fill(false);\n        findAncestors(i, adjList, visited, ans[i]);\n        ans[i].sort((a, b) => a - b);\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm works by iterating over all the given nodes and finding the ancestors of each node.\n1. Create an adjacency list representation of the graph where the keys are the nodes and the values are lists of their parents.\n2. For each node `i` in the graph, perform a Depth-First Search using a helper function `findAncestors()`, to explore all the ancestors by traversing the parent nodes.\n3. During the search, maintain a `visited` array to prevent infinite loops and avoid visiting already visited nodes.\n4. Append the ancestors of each node to a list and sort it in ascending order.\n5. Return the list of ancestors for all nodes as a nested list.\n    "
    },
    {
        "id": 260,
        "title": "Destination City",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the array `paths`, where `paths[i] = [cityAi, cityBi]` means there exists a direct path going from `cityAi` to `cityBi`. _Return the destination city, that is, the city without any path outgoing to another city._\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.",
            "examples": [
                "**Example 1:**\n\n**Input:** paths = \\[\\[ \"London \", \"New York \"\\],\\[ \"New York \", \"Lima \"\\],\\[ \"Lima \", \"Sao Paulo \"\\]\\]\n**Output:**  \"Sao Paulo \" \n**Explanation:** Starting at  \"London \" city you will reach  \"Sao Paulo \" city which is the destination city. Your trip consist of:  \"London \" ->  \"New York \" ->  \"Lima \" ->  \"Sao Paulo \".\n\n",
                "**Example 2:**\n\n**Input:** paths = \\[\\[ \"B \", \"C \"\\],\\[ \"D \", \"B \"\\],\\[ \"C \", \"A \"\\]\\]\n**Output:**  \"A \"\n**Explanation:** All possible trips are: \n \"D \" ->  \"B \" ->  \"C \" ->  \"A \". \n \"B \" ->  \"C \" ->  \"A \". \n \"C \" ->  \"A \". \n \"A \". \nClearly the destination city is  \"A \".\n\n",
                "**Example 3:**\n\n**Input:** paths = \\[\\[ \"A \", \"Z \"\\]\\]\n**Output:**  \"Z \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= paths.length <= 100`\n*   `paths[i].length == 2`\n*   `1 <= cityAi.length, cityBi.length <= 10`\n*   `cityAi != cityBi`\n*   All strings consist of lowercase and uppercase English letters and the space character.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[[\"London\",\"NewYork\"],[\"NewYork\",\"Lima\"],[\"Lima\",\"SaoPaulo\"]]",
                "output": "\"SaoPaulo\""
            },
            {
                "input": "[[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]",
                "output": "\"A\""
            },
            {
                "input": "[[\"A\",\"Z\"]]",
                "output": "\"Z\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\n    Set<Integer> visited = new HashSet<>();\n    Queue<int[]> q = new LinkedList<>();\n    Map<String, Integer> videoFreq = new HashMap<>();\n\n    q.offer(new int[]{id, 0});\n    visited.add(id);\n\n    while (!q.isEmpty()) {\n        int[] pair = q.poll();\n        int currentId = pair[0];\n        int currentLevel = pair[1];\n\n        if (currentLevel == level) {\n            for (String video : watchedVideos.get(currentId)) {\n                videoFreq.put(video, videoFreq.getOrDefault(video, 0) + 1);\n            }\n        } else if (currentLevel < level) {\n            for (int friendId : friends[currentId]) {\n                if (!visited.contains(friendId)) {\n                    visited.add(friendId);\n                    q.offer(new int[]{friendId, currentLevel + 1});\n                }\n            }\n        }\n    }\n\n    List<String> result = new ArrayList<>(videoFreq.keySet());\n\n    result.sort((a, b) -> {\n        if (videoFreq.get(a).equals(videoFreq.get(b))) {\n            return a.compareTo(b);\n        } else {\n            return videoFreq.get(a) - videoFreq.get(b);\n        }\n    });\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize a visited set to keep track of the visited person ids, and a queue, which stores pairs containing the person id and the level or search depth.\n2. Push the given id and level 0 onto the queue and mark the id visited.\n3. While there are still unprocessed items in the queue, check the current level of the person in the queue. \n  a) If the current level is equal to the given level, increment the count of each video watched by this person in a frequency map.\n  b) If the current level is less than the given level, iterate through the friends of the current person and push those friends' ids in the queue with the incremented level if they haven't been visited yet, and mark them visited.\n4. Create a result list from the keys in the frequency map.\n5. Sort the result list based on the frequency of the videos and their names.\n6. Return the sorted result list.\n\nThis algorithm has a breadth-first search (BFS) traversal through the connections, which helps in finding the shortest path.\n    ",
        "python": "\n    ```python\nfrom collections import deque\nfrom collections import defaultdict\n\ndef watched_videos_by_friends(watched_videos, friends, id, level):\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result\n```\n    \n    The algorithm works as follows:\n1. Initialize a visited set to keep track of the visited person ids, and a queue, which stores pairs containing the person id and the level or search depth.\n2. Push the given id and level 0 onto the queue and mark the id visited.\n3. While there are still unprocessed items in the queue, check the current level of the person in the queue. \n  a) If the current level is equal to the given level, increment the count of each video watched by this person in a frequency map.\n  b) If the current level is less than the given level, iterate through the friends of the current person and push those friends' ids in the queue with the incremented level if they haven't been visited yet, and mark them visited.\n4. Create a result list from the keys in the frequency map.\n5. Sort the result list based on the frequency of the videos and their names.\n6. Return the sorted result list.\n\nThis algorithm has a breadth-first search (BFS) traversal through the connections, which helps in finding the shortest path.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\n    unordered_set<int> visited;\n    queue<pair<int, int>> q;\n    unordered_map<string, int> video_freq;\n\n    q.push({id, 0});\n    visited.insert(id);\n\n    while (!q.empty()) {\n        int current_id = q.front().first;\n        int current_level = q.front().second;\n        q.pop();\n\n        if (current_level == level) {\n            for (const string& video : watchedVideos[current_id]) {\n                video_freq[video]++;\n            }\n        } else if (current_level < level) {\n            for (int friend_id : friends[current_id]) {\n                if (visited.find(friend_id) == visited.end()) {\n                    visited.insert(friend_id);\n                    q.push({friend_id, current_level + 1});\n                }\n            }\n        }\n    }\n\n    vector<string> result;\n    for (const auto& p : video_freq) {\n        result.push_back(p.first);\n    }\n\n    sort(result.begin(), result.end(), [&video_freq](const string& a, const string& b) {\n        if (video_freq[a] == video_freq[b]) {\n            return a < b;\n        } else {\n            return video_freq[a] < video_freq[b];\n        }\n    });\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize a visited set to keep track of the visited person ids, and a queue, which stores pairs containing the person id and the level or search depth.\n2. Push the given id and level 0 onto the queue and mark the id visited.\n3. While there are still unprocessed items in the queue, check the current level of the person in the queue. \n  a) If the current level is equal to the given level, increment the count of each video watched by this person in a frequency map.\n  b) If the current level is less than the given level, iterate through the friends of the current person and push those friends' ids in the queue with the incremented level if they haven't been visited yet, and mark them visited.\n4. Create a result list from the keys in the frequency map.\n5. Sort the result list based on the frequency of the videos and their names.\n6. Return the sorted result list.\n\nThis algorithm has a breadth-first search (BFS) traversal through the connections, which helps in finding the shortest path.\n    ",
        "js": "\n    ```javascript\nfunction watchedVideosByFriends(watchedVideos, friends, id, level) {\n    const visited = new Set();\n    const q = [{ id, level: 0 }];\n    const videoFreq = new Map();\n\n    while (q.length !== 0) {\n        const { id: currentId, level: currentLevel } = q.shift();\n\n        if (currentLevel === level) {\n            for (const video of watchedVideos[currentId]) {\n                videoFreq.set(video, (videoFreq.get(video) || 0) + 1);\n            }\n        } else if (currentLevel < level) {\n            for (const friendId of friends[currentId]) {\n                if (!visited.has(friendId)) {\n                    visited.add(friendId);\n                    q.push({ id: friendId, level: currentLevel + 1 });\n                }\n            }\n        }\n    }\n\n    const result = Array.from(videoFreq.keys());\n    result.sort((a, b) => {\n        if (videoFreq.get(a) === videoFreq.get(b)) {\n            return a.localeCompare(b);\n        } else {\n            return videoFreq.get(a) - videoFreq.get(b);\n         }\n    });\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize a visited set to keep track of the visited person ids, and a queue, which stores pairs containing the person id and the level or search depth.\n2. Push the given id and level 0 onto the queue and mark the id visited.\n3. While there are still unprocessed items in the queue, check the current level of the person in the queue. \n  a) If the current level is equal to the given level, increment the count of each video watched by this person in a frequency map.\n  b) If the current level is less than the given level, iterate through the friends of the current person and push those friends' ids in the queue with the incremented level if they haven't been visited yet, and mark them visited.\n4. Create a result list from the keys in the frequency map.\n5. Sort the result list based on the frequency of the videos and their names.\n6. Return the sorted result list.\n\nThis algorithm has a breadth-first search (BFS) traversal through the connections, which helps in finding the shortest path.\n    "
    },
    {
        "id": 261,
        "title": "Consecutive Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "The **power** of the string is the maximum length of a non-empty substring that contains only one unique character.\n\nGiven a string `s`, return _the **power** of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leetcode \"\n**Output:** 2\n**Explanation:** The substring  \"ee \" is of length 2 with the character 'e' only.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abbcccddddeeeeedcba \"\n**Output:** 5\n**Explanation:** The substring  \"eeeee \" is of length 5 with the character 'e' only."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"leetcode\"",
                "output": "2"
            },
            {
                "input": "\"abbcccddddeeeeedcba\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\ndouble angleClock(int hour, int minutes) {\n    double minuteAngle = 6 * minutes;\n    double hourAngle = 30 * hour + 0.5 * minutes;\n    double angle = Math.abs(hourAngle - minuteAngle);\n    return Math.min(angle, 360 - angle);\n}\n```\n    \n    Here is the algorithm to find the smaller angle between the hour and the minute hand:\n\n1. Calculate the angle of the minute hand from the 12 o'clock position. Since each minute mark is 6 degrees apart (360/60), multiply the provided minutes by 6 to find the angle.\n2. Calculate the angle of the hour hand from the 12 o'clock position. Each hour mark is 30 degrees apart (360/12). Multiply the provided hours by 30, but also add half a degree for each minute passed as the hour hand moves slightly with each passing minute.\n3. Find the absolute difference between the hour and minute hand angles.\n4. Return the minimum of the calculated angle and 360 minus the calculated angle, as the target angle should always be the smaller angle formed between the clock hands.\n    ",
        "python": "\n    ```python\ndef angleClock(hour: int, minutes: int) -> float:\n    minute_angle = 6 * minutes\n    hour_angle = 30 * hour + 0.5 * minutes\n    angle = abs(hour_angle - minute_angle)\n    return min(angle, 360 - angle)\n```\n    \n    Here is the algorithm to find the smaller angle between the hour and the minute hand:\n\n1. Calculate the angle of the minute hand from the 12 o'clock position. Since each minute mark is 6 degrees apart (360/60), multiply the provided minutes by 6 to find the angle.\n2. Calculate the angle of the hour hand from the 12 o'clock position. Each hour mark is 30 degrees apart (360/12). Multiply the provided hours by 30, but also add half a degree for each minute passed as the hour hand moves slightly with each passing minute.\n3. Find the absolute difference between the hour and minute hand angles.\n4. Return the minimum of the calculated angle and 360 minus the calculated angle, as the target angle should always be the smaller angle formed between the clock hands.\n    ",
        "c++": "\n    ```cpp\ndouble angleClock(int hour, int minutes) {\n    double minuteAngle = 6 * minutes;\n    double hourAngle = 30 * hour + 0.5 * minutes;\n    double angle = abs(hourAngle - minuteAngle);\n    return min(angle, 360 - angle);\n}\n```\n    \n    Here is the algorithm to find the smaller angle between the hour and the minute hand:\n\n1. Calculate the angle of the minute hand from the 12 o'clock position. Since each minute mark is 6 degrees apart (360/60), multiply the provided minutes by 6 to find the angle.\n2. Calculate the angle of the hour hand from the 12 o'clock position. Each hour mark is 30 degrees apart (360/12). Multiply the provided hours by 30, but also add half a degree for each minute passed as the hour hand moves slightly with each passing minute.\n3. Find the absolute difference between the hour and minute hand angles.\n4. Return the minimum of the calculated angle and 360 minus the calculated angle, as the target angle should always be the smaller angle formed between the clock hands.\n    ",
        "js": "\n    ```javascript\nfunction angleClock(hour, minutes) {\n    let minuteAngle = 6 * minutes;\n    let hourAngle = 30 * hour + 0.5 * minutes;\n    let angle = Math.abs(hourAngle - minuteAngle);\n    return Math.min(angle, 360 - angle);\n}\n```\n    \n    Here is the algorithm to find the smaller angle between the hour and the minute hand:\n\n1. Calculate the angle of the minute hand from the 12 o'clock position. Since each minute mark is 6 degrees apart (360/60), multiply the provided minutes by 6 to find the angle.\n2. Calculate the angle of the hour hand from the 12 o'clock position. Each hour mark is 30 degrees apart (360/12). Multiply the provided hours by 30, but also add half a degree for each minute passed as the hour hand moves slightly with each passing minute.\n3. Find the absolute difference between the hour and minute hand angles.\n4. Return the minimum of the calculated angle and 360 minus the calculated angle, as the target angle should always be the smaller angle formed between the clock hands.\n    "
    },
    {
        "id": 262,
        "title": "Number of Students Doing Homework at a Given Time",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `startTime` and `endTime` and given an integer `queryTime`.\n\nThe `ith` student started doing their homework at the time `startTime[i]` and finished it at time `endTime[i]`.\n\nReturn _the number of students_ doing their homework at time `queryTime`. More formally, return the number of students where `queryTime` lays in the interval `[startTime[i], endTime[i]]` inclusive.",
            "examples": [
                "**Example 1:**\n\n**Input:** startTime = \\[1,2,3\\], endTime = \\[3,2,7\\], queryTime = 4\n**Output:** 1\n**Explanation:** We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n\n",
                "**Example 2:**\n\n**Input:** startTime = \\[4\\], endTime = \\[4\\], queryTime = 4\n**Output:** 1\n**Explanation:** The only student was doing their homework at the queryTime."
            ],
            "constraints": "**Constraints:**\n\n*   `startTime.length == endTime.length`\n*   `1 <= startTime.length <= 100`\n*   `1 <= startTime[i] <= endTime[i] <= 1000`\n*   `1 <= queryTime <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,2,3],[3,2,7],4",
                "output": "1"
            },
            {
                "input": "[4],[4],4",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic TreeNode removeLeafNodes(TreeNode root, int target) {\n    if (root == null) return null;\n    root.left = removeLeafNodes(root.left, target);\n    root.right = removeLeafNodes(root.right, target);\n    if (root.left == null && root.right == null && root.val == target) {\n        return null;\n    }\n    return root;\n}\n```\n\n    \n    We traverse the binary tree using a depth-first search (DFS) approach. We use a recursion to visit left and right children of each node.\n\n1. If the root node is null, return null.\n2. Call `removeLeafNodes` recursively and update left and right children.\n3. After updating children, check if the current node is a leaf node (i.e., both children are null) and its value equals the target. If so, delete it (return null); otherwise, return the current node.\n4. Repeat this process until deleted leaf nodes can no longer create new leaf nodes with the target value.\n    ",
        "python": "\n    ```python\ndef removeLeafNodes(root, target):\n    if not root:\n        return None\n    root.left = removeLeafNodes(root.left, target)\n    root.right = removeLeafNodes(root.right, target)\n    if not root.left and not root.right and root.val == target:\n        return None\n    return root\n```\n\n    \n    We traverse the binary tree using a depth-first search (DFS) approach. We use a recursion to visit left and right children of each node.\n\n1. If the root node is null, return null.\n2. Call `removeLeafNodes` recursively and update left and right children.\n3. After updating children, check if the current node is a leaf node (i.e., both children are null) and its value equals the target. If so, delete it (return null); otherwise, return the current node.\n4. Repeat this process until deleted leaf nodes can no longer create new leaf nodes with the target value.\n    ",
        "c++": "\n    ```cpp\nTreeNode* removeLeafNodes(TreeNode* root, int target) {\n    if (!root) return nullptr;\n    root->left = removeLeafNodes(root->left, target);\n    root->right = removeLeafNodes(root->right, target);\n    if (!root->left && !root->right && root->val == target) {\n        return nullptr;\n    }\n    return root;\n}\n```\n\n    \n    We traverse the binary tree using a depth-first search (DFS) approach. We use a recursion to visit left and right children of each node.\n\n1. If the root node is null, return null.\n2. Call `removeLeafNodes` recursively and update left and right children.\n3. After updating children, check if the current node is a leaf node (i.e., both children are null) and its value equals the target. If so, delete it (return null); otherwise, return the current node.\n4. Repeat this process until deleted leaf nodes can no longer create new leaf nodes with the target value.\n    ",
        "js": "\n    ```javascript\nfunction removeLeafNodes(root, target) {\n    if (!root) return null;\n    root.left = removeLeafNodes(root.left, target);\n    root.right = removeLeafNodes(root.right, target);\n    if (!root.left && !root.right && root.val === target) {\n        return null;\n    }\n    return root;\n}\n```\n\n    \n    We traverse the binary tree using a depth-first search (DFS) approach. We use a recursion to visit left and right children of each node.\n\n1. If the root node is null, return null.\n2. Call `removeLeafNodes` recursively and update left and right children.\n3. After updating children, check if the current node is a leaf node (i.e., both children are null) and its value equals the target. If so, delete it (return null); otherwise, return the current node.\n4. Repeat this process until deleted leaf nodes can no longer create new leaf nodes with the target value.\n    "
    },
    {
        "id": 263,
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `sentence` that consists of some words separated by a **single space**, and a `searchWord`, check if `searchWord` is a prefix of any word in `sentence`.\n\nReturn _the index of the word in_ `sentence` _(**1-indexed**) where_ `searchWord` _is a prefix of this word_. If `searchWord` is a prefix of more than one word, return the index of the first word **(minimum index)**. If there is no such word return `-1`.\n\nA **prefix** of a string `s` is any leading contiguous substring of `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence =  \"i love eating burger \", searchWord =  \"burg \"\n**Output:** 4\n**Explanation:**  \"burg \" is prefix of  \"burger \" which is the 4th word in the sentence.\n\n",
                "**Example 2:**\n\n**Input:** sentence =  \"this problem is an easy problem \", searchWord =  \"pro \"\n**Output:** 2\n**Explanation:**  \"pro \" is prefix of  \"problem \" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.\n\n",
                "**Example 3:**\n\n**Input:** sentence =  \"i am tired \", searchWord =  \"you \"\n**Output:** -1\n**Explanation:**  \"you \" is not a prefix of any word in the sentence."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 100`\n*   `1 <= searchWord.length <= 10`\n*   `sentence` consists of lowercase English letters and spaces.\n*   `searchWord` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"iloveeatingburger\",\"burg\"",
                "output": "4"
            },
            {
                "input": "\"thisproblemisaneasyproblem\",\"pro\"",
                "output": "2"
            },
            {
                "input": "\"iamtired\",\"you\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n    List<int[]> filteredRestaurants = new ArrayList<>();\n    for (int[] r : restaurants) {\n        if ((veganFriendly == 0 || r[2] == veganFriendly) && r[3] <= maxPrice && r[4] <= maxDistance) {\n            filteredRestaurants.add(r);\n        }\n    }\n    Collections.sort(filteredRestaurants, (a, b) -> a[1] == b[1] ? b[0] - a[0] : b[1] - a[1]);\n    List<Integer> ids = new ArrayList<>();\n    for (int[] r : filteredRestaurants) {\n        ids.add(r[0]);\n    }\n    return ids;\n}\n```\n    \n    The algorithm filters the given restaurants by checking each restaurant's vegan-friendly status, price, and distance. If the veganFriendly input is 0, the restaurant is considered regardless of its vegan-friendly status. If it is 1, only those restaurants with a vegan-friendly status of 1 are considered. Additionally, the restaurant's price and distance must be less than or equal to the given maxPrice and maxDistance, respectively. After filtering, the restaurants are sorted based on their ratings in descending order, and if two restaurants have the same rating, they are sorted by their IDs in descending order. Finally, the list of restaurant IDs is returned.\n    ",
        "python": "\n    ```python\ndef filter_restaurants(restaurants, vegan_friendly, max_price, max_distance):\n    def custom_compare(a, b):\n        if a[1] == b[1]:\n            return b[0] - a[0]\n        return b[1] - a[1]\n\n    filtered_restaurants = [\n        r for r in restaurants\n        if (vegan_friendly == 0 or r[2] == vegan_friendly) and r[3] <= max_price and r[4] <= max_distance\n    ]\n\n    filtered_restaurants.sort(key=lambda r: (r[1], r[0]), reverse=True)\n\n    return [r[0] for r in filtered_restaurants]\n```\n    \n    The algorithm filters the given restaurants by checking each restaurant's vegan-friendly status, price, and distance. If the veganFriendly input is 0, the restaurant is considered regardless of its vegan-friendly status. If it is 1, only those restaurants with a vegan-friendly status of 1 are considered. Additionally, the restaurant's price and distance must be less than or equal to the given maxPrice and maxDistance, respectively. After filtering, the restaurants are sorted based on their ratings in descending order, and if two restaurants have the same rating, they are sorted by their IDs in descending order. Finally, the list of restaurant IDs is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool customCompare(vector<int>& a, vector<int>& b) {\n    if (a[1] == b[1]) return a[0] > b[0];\n    return a[1] > b[1];\n}\n\nvector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n    vector<vector<int>> filteredRestaurants;\n    for (auto& r : restaurants) {\n        if ((veganFriendly == 0 || r[2] == veganFriendly) && r[3] <= maxPrice && r[4] <= maxDistance) {\n            filteredRestaurants.push_back(r);\n        }\n    }\n    sort(filteredRestaurants.begin(), filteredRestaurants.end(), customCompare);\n    vector<int> ids;\n    for (auto& r : filteredRestaurants) {\n        ids.push_back(r[0]);\n    }\n    return ids;\n}\n```\n    \n    The algorithm filters the given restaurants by checking each restaurant's vegan-friendly status, price, and distance. If the veganFriendly input is 0, the restaurant is considered regardless of its vegan-friendly status. If it is 1, only those restaurants with a vegan-friendly status of 1 are considered. Additionally, the restaurant's price and distance must be less than or equal to the given maxPrice and maxDistance, respectively. After filtering, the restaurants are sorted based on their ratings in descending order, and if two restaurants have the same rating, they are sorted by their IDs in descending order. Finally, the list of restaurant IDs is returned.\n    ",
        "js": "\n    ```javascript\nfunction filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance) {\n    const filteredRestaurants = restaurants.filter(r => (veganFriendly === 0 || r[2] === veganFriendly) && r[3] <= maxPrice && r[4] <= maxDistance);\n    filteredRestaurants.sort((a, b) => a[1] === b[1] ? b[0] - a[0] : b[1] - a[1]);\n\n    return filteredRestaurants.map(r => r[0]);\n}\n```\n    \n    The algorithm filters the given restaurants by checking each restaurant's vegan-friendly status, price, and distance. If the veganFriendly input is 0, the restaurant is considered regardless of its vegan-friendly status. If it is 1, only those restaurants with a vegan-friendly status of 1 are considered. Additionally, the restaurant's price and distance must be less than or equal to the given maxPrice and maxDistance, respectively. After filtering, the restaurants are sorted based on their ratings in descending order, and if two restaurants have the same rating, they are sorted by their IDs in descending order. Finally, the list of restaurant IDs is returned.\n    "
    },
    {
        "id": 264,
        "title": "Make Two Arrays Equal by Reversing Subarrays",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays of equal length `target` and `arr`. In one step, you can select any **non-empty subarray** of `arr` and reverse it. You are allowed to make any number of steps.\n\nReturn `true` _if you can make_ `arr` _equal to_ `target` _or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = \\[1,2,3,4\\], arr = \\[2,4,1,3\\]\n**Output:** true\n**Explanation:** You can follow the next steps to convert arr to target:\n1- Reverse subarray \\[2,4,1\\], arr becomes \\[1,4,2,3\\]\n2- Reverse subarray \\[4,2\\], arr becomes \\[1,2,4,3\\]\n3- Reverse subarray \\[4,3\\], arr becomes \\[1,2,3,4\\]\nThere are multiple ways to convert arr to target, this is not the only way to do so.\n\n",
                "**Example 2:**\n\n**Input:** target = \\[7\\], arr = \\[7\\]\n**Output:** true\n**Explanation:** arr is equal to target without any reverses.\n\n",
                "**Example 3:**\n\n**Input:** target = \\[3,7,9\\], arr = \\[3,7,11\\]\n**Output:** false\n**Explanation:** arr does not have value 9 and it can never be converted to target."
            ],
            "constraints": "**Constraints:**\n\n*   `target.length == arr.length`\n*   `1 <= target.length <= 1000`\n*   `1 <= target[i] <= 1000`\n*   `1 <= arr[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3,4],[2,4,1,3]",
                "output": "true"
            },
            {
                "input": "[7],[7]",
                "output": "true"
            },
            {
                "input": "[3,7,9],[3,7,11]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int numberOfSubstrings(String s) {\n    int res = 0, left = 0;\n    int[] count = new int[3];\n    \n    for (int right = 0; right < s.length(); right++) {\n        count[s.charAt(right) - 'a']++;\n        \n        while (count[0] > 0 && count[1] > 0 && count[2] > 0) {\n            count[s.charAt(left++) - 'a']--;\n        }\n        \n        res += left;\n    }\n    \n    return res;\n}\n```\n    \n    1. Initialize three pointers `res`, `i` (or `left`), and a count list, where `res` is the result of total numbers of substrings containing a, b, and c.\n2. Iterate through the string `s`, increment the count of the current character.\n3. Use a while loop inside the iteration to check if all characters' count values are greater than 0.\n4. If all are greater than 0, continuously decrease the count of the character at the current index `i` while incrementing the `i`.\n5. For each iteration, increase the result `res` by `i` (or `left`).\n6. Return the result `res`.\n\nThe algorithm uses a sliding window method to keep track of the substrings. The complexity is O(N), where N is the length of the string s.\n    ",
        "python": "\n    ```python\ndef numberOfSubstrings(s: str) -> int:\n    res, i, count = 0, 0, [0, 0, 0]\n    \n    for j, ch in enumerate(s):\n        count[ord(ch) - ord('a')] += 1\n        \n        while count[0] > 0 and count[1] > 0 and count[2] > 0:\n            count[ord(s[i]) - ord('a')] -= 1\n            i += 1\n            \n        res += i\n    \n    return res\n```\n    \n    1. Initialize three pointers `res`, `i` (or `left`), and a count list, where `res` is the result of total numbers of substrings containing a, b, and c.\n2. Iterate through the string `s`, increment the count of the current character.\n3. Use a while loop inside the iteration to check if all characters' count values are greater than 0.\n4. If all are greater than 0, continuously decrease the count of the character at the current index `i` while incrementing the `i`.\n5. For each iteration, increase the result `res` by `i` (or `left`).\n6. Return the result `res`.\n\nThe algorithm uses a sliding window method to keep track of the substrings. The complexity is O(N), where N is the length of the string s.\n    ",
        "c++": "\n    ```cpp\nint numberOfSubstrings(string s) {\n    int res = 0, i = 0;\n    vector<int> count(3, 0);\n    \n    for (int j = 0; j < s.length(); j++) {\n        count[s[j] - 'a']++;\n        \n        while(count[0] > 0 && count[1] > 0 && count[2] > 0) {\n            count[s[i++] - 'a']--;\n        }\n        \n        res += i;\n    }\n    \n    return res;\n}\n```\n    \n    1. Initialize three pointers `res`, `i` (or `left`), and a count list, where `res` is the result of total numbers of substrings containing a, b, and c.\n2. Iterate through the string `s`, increment the count of the current character.\n3. Use a while loop inside the iteration to check if all characters' count values are greater than 0.\n4. If all are greater than 0, continuously decrease the count of the character at the current index `i` while incrementing the `i`.\n5. For each iteration, increase the result `res` by `i` (or `left`).\n6. Return the result `res`.\n\nThe algorithm uses a sliding window method to keep track of the substrings. The complexity is O(N), where N is the length of the string s.\n    ",
        "js": "\n    ```javascript\nfunction numberOfSubstrings(s) {\n    let res = 0, left = 0;\n    let count = [0, 0, 0];\n\n    for (let right = 0; right < s.length; right++) {\n        count[s.charCodeAt(right) - 'a'.charCodeAt(0)]++;\n\n        while (count[0] > 0 && count[1] > 0 && count[2] > 0) {\n            count[s.charCodeAt(left) - 'a'.charCodeAt(0)]--;\n            left++;\n        }\n\n        res += left;\n    }\n\n    return res;\n}\n```\n    \n    1. Initialize three pointers `res`, `i` (or `left`), and a count list, where `res` is the result of total numbers of substrings containing a, b, and c.\n2. Iterate through the string `s`, increment the count of the current character.\n3. Use a while loop inside the iteration to check if all characters' count values are greater than 0.\n4. If all are greater than 0, continuously decrease the count of the character at the current index `i` while incrementing the `i`.\n5. For each iteration, increase the result `res` by `i` (or `left`).\n6. Return the result `res`.\n\nThe algorithm uses a sliding window method to keep track of the substrings. The complexity is O(N), where N is the length of the string s.\n    "
    },
    {
        "id": 265,
        "title": "Maximum Product of Two Elements in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the array of integers `nums`, you will choose two different indices `i` and `j` of that array. _Return the maximum value of_ `(nums[i]-1)*(nums[j]-1)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,4,5,2\\]\n**Output:** 12 \n**Explanation:** If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums\\[1\\]-1)\\*(nums\\[2\\]-1) = (4-1)\\*(5-1) = 3\\*4 = 12. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,4,5\\]\n**Output:** 16\n**Explanation:** Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)\\*(5-1) = 16.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,7\\]\n**Output:** 12"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 500`\n*   `1 <= nums[i] <= 10^3`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[3,4,5,2]",
                "output": "12"
            },
            {
                "input": "[1,5,4,5]",
                "output": "16"
            },
            {
                "input": "[3,7]",
                "output": "12"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic int minSetSize(int[] arr) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    for (int value : arr)\n        count.put(value, count.getOrDefault(value, 0) + 1);\n\n    ArrayList<Integer> freq = new ArrayList<>(count.values());\n    Collections.sort(freq, Collections.reverseOrder());\n\n    int removed = 0, setSize = 0;\n    for (int f : freq) {\n        removed += f;\n        setSize++;\n        if (removed * 2 >= arr.length)\n            return setSize;\n    }\n\n    return 0;\n}\n```\n\n    \n    1. Create a map (or dictionary) to store the count of each unique integer in the input array.\n2. Iterate through the input array, incrementing the count for each number in the map.\n3. Create an array (or list) of the counts in the map, sorted in descending order.\n4. Initialize variables `removed` and `setSize` to zero. `removed` tracks the number of elements removed so far, and `setSize` is the size of the set of integers.\n5. Iterate through the sorted count array, adding the count to the `removed` variable and incrementing `setSize`. If the number of `removed` elements is at least half the size of the input array, return `setSize`.\n6. If the loop completes without returning, return 0.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef minSetSize(arr):\n    count = Counter(arr)\n    freq = list(count.values())\n    freq.sort(reverse=True)\n\n    removed, setSize = 0, 0\n    for f in freq:\n        removed += f\n        setSize += 1\n        if removed * 2 >= len(arr):\n            return setSize\n\n    return 0\n```\n\n    \n    1. Create a map (or dictionary) to store the count of each unique integer in the input array.\n2. Iterate through the input array, incrementing the count for each number in the map.\n3. Create an array (or list) of the counts in the map, sorted in descending order.\n4. Initialize variables `removed` and `setSize` to zero. `removed` tracks the number of elements removed so far, and `setSize` is the size of the set of integers.\n5. Iterate through the sorted count array, adding the count to the `removed` variable and incrementing `setSize`. If the number of `removed` elements is at least half the size of the input array, return `setSize`.\n6. If the loop completes without returning, return 0.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nint minSetSize(std::vector<int>& arr) {\n    std::unordered_map<int, int> count;\n    for (auto value : arr)\n        count[value]++;\n\n    std::vector<int> freq;\n    for (auto& entry : count)\n        freq.push_back(entry.second);\n\n    std::sort(freq.rbegin(), freq.rend());\n\n    int removed = 0, setSize = 0;\n    for (auto f : freq) {\n        removed += f;\n        setSize++;\n        if (removed * 2 >= arr.size())\n            return setSize;\n    }\n\n    return 0;\n}\n```\n\n    \n    1. Create a map (or dictionary) to store the count of each unique integer in the input array.\n2. Iterate through the input array, incrementing the count for each number in the map.\n3. Create an array (or list) of the counts in the map, sorted in descending order.\n4. Initialize variables `removed` and `setSize` to zero. `removed` tracks the number of elements removed so far, and `setSize` is the size of the set of integers.\n5. Iterate through the sorted count array, adding the count to the `removed` variable and incrementing `setSize`. If the number of `removed` elements is at least half the size of the input array, return `setSize`.\n6. If the loop completes without returning, return 0.\n    ",
        "js": "\n    ```javascript\nfunction minSetSize(arr) {\n    const count = new Map();\n    for (const value of arr)\n        count.set(value, (count.get(value) || 0) + 1);\n\n    const freq = Array.from(count.values());\n    freq.sort((a, b) => b - a);\n\n    let removed = 0, setSize = 0;\n    for (const f of freq) {\n        removed += f;\n        setSize++;\n        if (removed * 2 >= arr.length)\n            return setSize;\n    }\n\n    return 0;\n}\n```\n\n    \n    1. Create a map (or dictionary) to store the count of each unique integer in the input array.\n2. Iterate through the input array, incrementing the count for each number in the map.\n3. Create an array (or list) of the counts in the map, sorted in descending order.\n4. Initialize variables `removed` and `setSize` to zero. `removed` tracks the number of elements removed so far, and `setSize` is the size of the set of integers.\n5. Iterate through the sorted count array, adding the count to the `removed` variable and incrementing `setSize`. If the number of `removed` elements is at least half the size of the input array, return `setSize`.\n6. If the loop completes without returning, return 0.\n    "
    },
    {
        "id": 266,
        "title": "Shuffle the Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the array `nums` consisting of `2n` elements in the form `[x1,x2,...,xn,y1,y2,...,yn]`.\n\n_Return the array in the form_ `[x1,y1,x2,y2,...,xn,yn]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,5,1,3,4,7\\], n = 3\n**Output:** \\[2,3,5,4,1,7\\] \n**Explanation:** Since x1\\=2, x2\\=5, x3\\=1, y1\\=3, y2\\=4, y3\\=7 then the answer is \\[2,3,5,4,1,7\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,4,3,2,1\\], n = 4\n**Output:** \\[1,4,2,3,3,2,4,1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,2,2\\], n = 2\n**Output:** \\[1,2,1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 500`\n*   `nums.length == 2n`\n*   `1 <= nums[i] <= 10^3`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[2,5,1,3,4,7],3",
                "output": "[2,3,5,4,1,7]"
            },
            {
                "input": "[1,2,3,4,4,3,2,1],4",
                "output": "[1,4,2,3,3,2,4,1]"
            },
            {
                "input": "[1,1,2,2],2",
                "output": "[1,2,1,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.TreeMap;\n\npublic class TweetCounts {\n    public void recordTweet(String tweetName, int time) {\n        tweetRecords.computeIfAbsent(tweetName, k -> new TreeMap<>())\n        .compute(time, (k, v) -> v == null ? 1 : v + 1);\n    }\n\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\n        int interval;\n        if (freq.equals(\"minute\")) interval = 60;\n        else if (freq.equals(\"hour\")) interval = 3600;\n        else interval = 86400;\n\n        List<Integer> result = new ArrayList<>((endTime - startTime) / interval + 1);\n        for (int i = 0; i < (endTime - startTime) / interval + 1; i++) result.add(0);\n\n        if (!tweetRecords.containsKey(tweetName)) return result;\n\n        for (int time : tweetRecords.get(tweetName).navigableKeySet()) {\n            if (time >= startTime && time <= endTime) {\n                result.set((time - startTime) / interval,\n                        result.get((time - startTime) / interval) + tweetRecords.get(tweetName).get(time));\n            }\n        }\n\n        return result;\n    }\n\n    private HashMap<String, TreeMap<Integer, Integer>> tweetRecords = new HashMap<>();\n}\n```\n\n    \n    The `TweetCounts` class holds a data structure to store the frequency of tweet occurrences at a certain timestamp. This data structure is created as a nested map (unordered_map in C++), where the outer map uses `tweetName` as key, and the inner map uses time (in seconds) as key and count of tweets at that time as value. Whenever a new tweet is recorded, the count is incremented for the corresponding`tweetName` and time.\n\nThe `getTweetCountsPerFrequency` function accepts the frequency (minute, hour or day), `tweetName`, startTime and endTime as parameters. It calculates the interval in seconds based on the given frequency, and initializes an empty result vector, which will store the count of tweets for each partitioned chunk.\n\nIterate through the time and count pairs for the given `tweetName`. If the time lies within startTime and endTime, the count is added to the appropriate index in the result vector.\n\nFinally, return the result vector.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweet_records = defaultdict(lambda: defaultdict(int))\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweet_records[tweetName][time] += 1\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq == \"minute\":\n            interval = 60\n        elif freq == \"hour\":\n            interval = 3600\n        else:\n            interval = 86400\n\n        result = [0] * ((endTime - startTime) // interval + 1)\n        for time, count in self.tweet_records[tweetName].items():\n            if startTime <= time <= endTime:\n                result[(time - startTime) // interval] += count\n\n        return result\n```\n\n    \n    The `TweetCounts` class holds a data structure to store the frequency of tweet occurrences at a certain timestamp. This data structure is created as a nested map (unordered_map in C++), where the outer map uses `tweetName` as key, and the inner map uses time (in seconds) as key and count of tweets at that time as value. Whenever a new tweet is recorded, the count is incremented for the corresponding`tweetName` and time.\n\nThe `getTweetCountsPerFrequency` function accepts the frequency (minute, hour or day), `tweetName`, startTime and endTime as parameters. It calculates the interval in seconds based on the given frequency, and initializes an empty result vector, which will store the count of tweets for each partitioned chunk.\n\nIterate through the time and count pairs for the given `tweetName`. If the time lies within startTime and endTime, the count is added to the appropriate index in the result vector.\n\nFinally, return the result vector.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <map>\n\nclass TweetCounts {\npublic:\n    void recordTweet(string tweetName, int time) {\n        tweetRecords[tweetName][time]++;\n    }\n\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\n        int interval;\n        if(freq == \"minute\") interval = 60;\n        else if(freq == \"hour\") interval = 3600;\n        else interval = 86400;\n\n        vector<int> result((endTime - startTime) / interval + 1);\n        for(const auto &timeCount : tweetRecords[tweetName]) {\n            int time = timeCount.first, count = timeCount.second;\n            if(time >= startTime && time <= endTime) {\n                result[(time - startTime) / interval] += count;\n            }\n        }\n\n        return result;\n    }\n\nprivate:\n    unordered_map<string, map<int, int>> tweetRecords;\n};\n```\n\n    \n    The `TweetCounts` class holds a data structure to store the frequency of tweet occurrences at a certain timestamp. This data structure is created as a nested map (unordered_map in C++), where the outer map uses `tweetName` as key, and the inner map uses time (in seconds) as key and count of tweets at that time as value. Whenever a new tweet is recorded, the count is incremented for the corresponding`tweetName` and time.\n\nThe `getTweetCountsPerFrequency` function accepts the frequency (minute, hour or day), `tweetName`, startTime and endTime as parameters. It calculates the interval in seconds based on the given frequency, and initializes an empty result vector, which will store the count of tweets for each partitioned chunk.\n\nIterate through the time and count pairs for the given `tweetName`. If the time lies within startTime and endTime, the count is added to the appropriate index in the result vector.\n\nFinally, return the result vector.\n    ",
        "js": "\n    ```javascript\nclass TweetCounts {\n    constructor() {\n        this.tweetRecords = new Map();\n    }\n\n    recordTweet(tweetName, time) {\n        if (!this.tweetRecords.has(tweetName)) {\n            this.tweetRecords.set(tweetName, new Map());\n        }\n        const tweetTimeMap = this.tweetRecords.get(tweetName);\n        tweetTimeMap.set(time, (tweetTimeMap.get(time) || 0) + 1);\n    }\n\n    getTweetCountsPerFrequency(freq, tweetName, startTime, endTime) {\n        const interval = freq === \"minute\" ? 60 : freq === \"hour\" ? 3600 : 86400;\n        const result = new Array(Math.floor((endTime - startTime) / interval) + 1).fill(0);\n        if (!this.tweetRecords.has(tweetName)) return result;\n        const tweetTimeMap = this.tweetRecords.get(tweetName);\n\n        for (const [time, count] of tweetTimeMap.entries()) {\n            if (time >= startTime && time <= endTime) {\n                result[Math.floor((time - startTime) / interval)] += count;\n            }\n        }\n\n        return result;\n    }\n}\n```\n\n    \n    The `TweetCounts` class holds a data structure to store the frequency of tweet occurrences at a certain timestamp. This data structure is created as a nested map (unordered_map in C++), where the outer map uses `tweetName` as key, and the inner map uses time (in seconds) as key and count of tweets at that time as value. Whenever a new tweet is recorded, the count is incremented for the corresponding`tweetName` and time.\n\nThe `getTweetCountsPerFrequency` function accepts the frequency (minute, hour or day), `tweetName`, startTime and endTime as parameters. It calculates the interval in seconds based on the given frequency, and initializes an empty result vector, which will store the count of tweets for each partitioned chunk.\n\nIterate through the time and count pairs for the given `tweetName`. If the time lies within startTime and endTime, the count is added to the appropriate index in the result vector.\n\nFinally, return the result vector.\n    "
    },
    {
        "id": 267,
        "title": "Final Prices With a Special Discount in a Shop",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `prices` where `prices[i]` is the price of the `ith` item in a shop.\n\nThere is a special discount for items in the shop. If you buy the `ith` item, then you will receive a discount equivalent to `prices[j]` where `j` is the minimum index such that `j > i` and `prices[j] <= prices[i]`. Otherwise, you will not receive any discount at all.\n\nReturn an integer array `answer` where `answer[i]` is the final price you will pay for the `ith` item of the shop, considering the special discount.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[8,4,6,2,3\\]\n**Output:** \\[4,2,4,2,3\\]\n**Explanation:** \nFor item 0 with price\\[0\\]=8 you will receive a discount equivalent to prices\\[1\\]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price\\[1\\]=4 you will receive a discount equivalent to prices\\[3\\]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price\\[2\\]=6 you will receive a discount equivalent to prices\\[3\\]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** \\[1,2,3,4,5\\]\n**Explanation:** In this case, for all items, you will not receive any discount at all.\n\n",
                "**Example 3:**\n\n**Input:** prices = \\[10,1,1,6\\]\n**Output:** \\[9,0,1,6\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 500`\n*   `1 <= prices[i] <= 1000`\n\nThe left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[8,4,6,2,3]",
                "output": "[4,2,4,2,3]"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "[1,2,3,4,5]"
            },
            {
                "input": "[10,1,1,6]",
                "output": "[9,0,1,6]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int maxSumBST(TreeNode root) {\n    int[] maxSum = new int[1];\n    helper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int[] helper(TreeNode node, int[] maxSum) {\n    if (node == null) {\n        return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 1};\n    }\n\n    int[] left = helper(node.left, maxSum);\n    int[] right = helper(node.right, maxSum);\n\n    if (left[3] != 0 && right[3] != 0 && node.val > left[1] && node.val < right[0]) {\n        int sum = node.val + left[2] + right[2];\n        maxSum[0] = Math.max(maxSum[0], sum);\n        return new int[]{Math.min(node.val, left[0]), Math.max(node.val, right[1]), sum, 1};\n    }\n\n    return new int[]{0, 0, 0, 0};\n}\n```\n    \n    We perform a post-order traversal of the tree, as we need information about both the left and right children of a node to determine if the current node's subtree is also a BST.\n\nFor every node, we recursively call the helper function for its left and right children, getting their min key, max key, sum of keys, and a boolean representing if the subtree rooted at these children is a BST or not.\n\nWe then check if the current node's subtree can be considered as a BST. If it is true, we update the maximum sum if needed using the sum of the keys in the current subtree. In any case, we return the minimum and maximum keys, the sum of the keys, and a boolean indicating if the current subtree is a BST or not.\n\nAfter the post-order traversal is complete, we return the maximum sum found.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxSumBST(root):\n    def helper(node):\n        if not node:\n            return float('inf'), float('-inf'), 0, True\n\n        left_min, left_max, left_sum, is_left_bst = helper(node.left)\n        right_min, right_max, right_sum, is_right_bst = helper(node.right)\n\n        if is_left_bst and is_right_bst and node.val > left_max and node.val < right_min:\n            sum_ = node.val + left_sum + right_sum\n            max_sum[0] = max(max_sum[0], sum_)\n            return min(node.val, left_min), max(node.val, right_max), sum_, True\n\n        return 0, 0, 0, False\n\n    max_sum = [0]\n    helper(root)\n    return max_sum[0]\n```\n    \n    We perform a post-order traversal of the tree, as we need information about both the left and right children of a node to determine if the current node's subtree is also a BST.\n\nFor every node, we recursively call the helper function for its left and right children, getting their min key, max key, sum of keys, and a boolean representing if the subtree rooted at these children is a BST or not.\n\nWe then check if the current node's subtree can be considered as a BST. If it is true, we update the maximum sum if needed using the sum of the keys in the current subtree. In any case, we return the minimum and maximum keys, the sum of the keys, and a boolean indicating if the current subtree is a BST or not.\n\nAfter the post-order traversal is complete, we return the maximum sum found.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint maxSumBST(TreeNode* root) {\n    int max_sum = 0;\n    helper(root, max_sum);\n    return max_sum;\n}\n\ntuple<int, int, int, bool> helper(TreeNode* node, int& max_sum) {\n    if (node == nullptr) {\n        return {INT_MAX, INT_MIN, 0, true};\n    }\n\n    auto[left_min, left_max, left_sum, is_left_bst] = helper(node->left, max_sum);\n    auto[right_min, right_max, right_sum, is_right_bst] = helper(node->right, max_sum);\n\n    if (is_left_bst && is_right_bst && node->val > left_max && node->val < right_min) {\n        int sum = node->val + left_sum + right_sum;\n        max_sum = max(max_sum, sum);\n        return {min(node->val, left_min), max(node->val, right_max), sum, true};\n    }\n\n    return {0, 0, 0, false};\n}\n```\n    \n    We perform a post-order traversal of the tree, as we need information about both the left and right children of a node to determine if the current node's subtree is also a BST.\n\nFor every node, we recursively call the helper function for its left and right children, getting their min key, max key, sum of keys, and a boolean representing if the subtree rooted at these children is a BST or not.\n\nWe then check if the current node's subtree can be considered as a BST. If it is true, we update the maximum sum if needed using the sum of the keys in the current subtree. In any case, we return the minimum and maximum keys, the sum of the keys, and a boolean indicating if the current subtree is a BST or not.\n\nAfter the post-order traversal is complete, we return the maximum sum found.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n}\n\nfunction maxSumBST(root) {\n    let maxSum = [0];\n    helper(root, maxSum);\n    return maxSum[0];\n}\n\nfunction helper(node, maxSum) {\n    if (!node) {\n        return [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, 0, true];\n    }\n\n    let left = helper(node.left, maxSum);\n    let right = helper(node.right, maxSum);\n\n    if (left[3] && right[3] && node.val > left[1] && node.val < right[0]) {\n        let sum = node.val + left[2] + right[2];\n        maxSum[0] = Math.max(maxSum[0], sum);\n        return [Math.min(node.val, left[0]), Math.max(node.val, right[1]), sum, true];\n    }\n\n    return [0, 0, 0, false];\n}\n```\n\n    \n    We perform a post-order traversal of the tree, as we need information about both the left and right children of a node to determine if the current node's subtree is also a BST.\n\nFor every node, we recursively call the helper function for its left and right children, getting their min key, max key, sum of keys, and a boolean representing if the subtree rooted at these children is a BST or not.\n\nWe then check if the current node's subtree can be considered as a BST. If it is true, we update the maximum sum if needed using the sum of the keys in the current subtree. In any case, we return the minimum and maximum keys, the sum of the keys, and a boolean indicating if the current subtree is a BST or not.\n\nAfter the post-order traversal is complete, we return the maximum sum found.\n    "
    },
    {
        "id": 268,
        "title": "Running Sum of 1d Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums`. We define a running sum of an array as `runningSum[i] = sum(nums[0]...nums[i])`.\n\nReturn the running sum of `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[1,3,6,10\\]\n**Explanation:** Running sum is obtained as follows: \\[1, 1+2, 1+2+3, 1+2+3+4\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,1\\]\n**Output:** \\[1,2,3,4,5\\]\n**Explanation:** Running sum is obtained as follows: \\[1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,1,2,10,1\\]\n**Output:** \\[3,4,6,16,17\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-10^6 <= nums[i] <= 10^6`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "[1,3,6,10]"
            },
            {
                "input": "[1,1,1,1,1]",
                "output": "[1,2,3,4,5]"
            },
            {
                "input": "[3,1,2,10,1]",
                "output": "[3,4,6,16,17]"
            }
        ],
        "java": "\n    ```java\npublic int[] runningSum(int[] nums) {\n    for(int i = 1; i < nums.length; i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    ",
        "python": "\n    ```python\ndef runningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    return nums\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nstd::vector<int> runningSum(std::vector<int>& nums) {\n    for(int i = 1; i < nums.size(); i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    ",
        "js": "\n    ```javascript\nfunction runningSum(nums) {\n    for(let i = 1; i < nums.length; i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    "
    },
    {
        "id": 269,
        "title": "XOR Operation in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `n` and an integer `start`.\n\nDefine an array `nums` where `nums[i] = start + 2 * i` (**0-indexed**) and `n == nums.length`.\n\nReturn _the bitwise XOR of all elements of_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, start = 0\n**Output:** 8\n**Explanation:** Array nums is equal to \\[0, 2, 4, 6, 8\\] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere  \"^ \" corresponds to bitwise XOR operator.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, start = 3\n**Output:** 8\n**Explanation:** Array nums is equal to \\[3, 5, 7, 9\\] where (3 ^ 5 ^ 7 ^ 9) = 8."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= start <= 1000`\n*   `n == nums.length`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "5,0",
                "output": "8"
            },
            {
                "input": "4,3",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\n    int count = 0;\n    for (int i = 0; i < arr1.length; i++) {\n        boolean valid = true;\n        for (int j = 0; j < arr2.length; j++) {\n            if (Math.abs(arr1[i] - arr2[j]) <= d) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm starts by initializing a variable `count` to store the number of elements obeying the given constraints. For every element `arr1[i]`, iterate through every element `arr2[j]`. Check if `|arr1[i] - arr2[j]| <= d`. If this condition is true, the current element `arr1[i]` is not valid, so set `valid` to false and break out of the inner loop. If the entire inner loop is exhausted and all elements `arr2[j]` did not meet this condition, the current `arr1[i]` is valid and increments the count. Return the count at the end.\n    ",
        "python": "\n    ```python\ndef findTheDistanceValue(arr1, arr2, d):\n    count = 0\n    for i in arr1:\n        valid = True\n        for j in arr2:\n            if abs(i - j) <= d:\n                valid = False\n                break\n        if valid:\n            count += 1\n    return count\n```\n    \n    The algorithm starts by initializing a variable `count` to store the number of elements obeying the given constraints. For every element `arr1[i]`, iterate through every element `arr2[j]`. Check if `|arr1[i] - arr2[j]| <= d`. If this condition is true, the current element `arr1[i]` is not valid, so set `valid` to false and break out of the inner loop. If the entire inner loop is exhausted and all elements `arr2[j]` did not meet this condition, the current `arr1[i]` is valid and increments the count. Return the count at the end.\n    ",
        "c++": "\n    ```cpp\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n    int count = 0;\n    for (int i = 0; i < arr1.size(); i++) {\n        bool valid = true;\n        for (int j = 0; j < arr2.size(); j++) {\n            if (abs(arr1[i] - arr2[j]) <= d) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm starts by initializing a variable `count` to store the number of elements obeying the given constraints. For every element `arr1[i]`, iterate through every element `arr2[j]`. Check if `|arr1[i] - arr2[j]| <= d`. If this condition is true, the current element `arr1[i]` is not valid, so set `valid` to false and break out of the inner loop. If the entire inner loop is exhausted and all elements `arr2[j]` did not meet this condition, the current `arr1[i]` is valid and increments the count. Return the count at the end.\n    ",
        "js": "\n    ```javascript\nfunction findTheDistanceValue(arr1, arr2, d) {\n    let count = 0;\n    for (let i = 0; i < arr1.length; i++) {\n        let valid = true;\n        for (let j = 0; j < arr2.length; j++) {\n            if (Math.abs(arr1[i] - arr2[j]) <= d) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm starts by initializing a variable `count` to store the number of elements obeying the given constraints. For every element `arr1[i]`, iterate through every element `arr2[j]`. Check if `|arr1[i] - arr2[j]| <= d`. If this condition is true, the current element `arr1[i]` is not valid, so set `valid` to false and break out of the inner loop. If the entire inner loop is exhausted and all elements `arr2[j]` did not meet this condition, the current `arr1[i]` is valid and increments the count. Return the count at the end.\n    "
    },
    {
        "id": 270,
        "title": "Average Salary Excluding the Minimum and Maximum Salary",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of **unique** integers `salary` where `salary[i]` is the salary of the `ith` employee.\n\nReturn _the average salary of employees excluding the minimum and maximum salary_. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** salary = \\[4000,3000,1000,2000\\]\n**Output:** 2500.00000\n**Explanation:** Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n\n",
                "**Example 2:**\n\n**Input:** salary = \\[1000,2000,3000\\]\n**Output:** 2000.00000\n**Explanation:** Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= salary.length <= 100`\n*   `1000 <= salary[i] <= 106`\n*   All the integers of `salary` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4000,3000,1000,2000]",
                "output": "2500.00000"
            },
            {
                "input": "[1000,2000,3000]",
                "output": "2000.00000"
            }
        ],
        "java": "\n    ```java\npublic int countPrefixAligned(int[] flips) {\n    int count = 0;\n    for (int i = 0; i < flips.length; i++) {\n        if (flips[i] == i + 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given `flips` list (or array) and, at each step, checks if the value of `flips[i]` is equal to the 1-indexed position (i.e., `i+1`). If the condition is true, it means that the bit is flipped at the correct position to make the binary string prefix-aligned at that step, so we increment the counter. At the end of the loop, the counter represents the total number of prefix-aligned steps in the flipping process.\n    ",
        "python": "\n    ```python\ndef count_prefix_aligned(flips):\n    count = 0\n    for i in range(len(flips)):\n        if flips[i] == i + 1:\n            count += 1\n    return count\n```\n    \n    The algorithm iterates through the given `flips` list (or array) and, at each step, checks if the value of `flips[i]` is equal to the 1-indexed position (i.e., `i+1`). If the condition is true, it means that the bit is flipped at the correct position to make the binary string prefix-aligned at that step, so we increment the counter. At the end of the loop, the counter represents the total number of prefix-aligned steps in the flipping process.\n    ",
        "c++": "\n    ```cpp\nint countPrefixAligned(const vector<int>& flips) {\n    int count = 0;\n    for (int i = 0; i < flips.size(); i++) {\n        if (flips[i] == i + 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given `flips` list (or array) and, at each step, checks if the value of `flips[i]` is equal to the 1-indexed position (i.e., `i+1`). If the condition is true, it means that the bit is flipped at the correct position to make the binary string prefix-aligned at that step, so we increment the counter. At the end of the loop, the counter represents the total number of prefix-aligned steps in the flipping process.\n    ",
        "js": "\n    ```javascript\nfunction countPrefixAligned(flips) {\n    let count = 0;\n    for (let i = 0; i < flips.length; i++) {\n        if (flips[i] === i + 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given `flips` list (or array) and, at each step, checks if the value of `flips[i]` is equal to the 1-indexed position (i.e., `i+1`). If the condition is true, it means that the bit is flipped at the correct position to make the binary string prefix-aligned at that step, so we increment the counter. At the end of the loop, the counter represents the total number of prefix-aligned steps in the flipping process.\n    "
    },
    {
        "id": 271,
        "title": "Path Crossing",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `path`, where `path[i] = 'N'`, `'S'`, `'E'` or `'W'`, each representing moving one unit north, south, east, or west, respectively. You start at the origin `(0, 0)` on a 2D plane and walk on the path specified by `path`.\n\nReturn `true` _if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited_. Return `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input:** path =  \"NES \"\n**Output:** false \n**Explanation:** Notice that the path doesn't cross any point more than once.\n\n",
                "**Example 2:**\n\n**Input:** path =  \"NESWW \"\n**Output:** true\n**Explanation:** Notice that the path visits the origin twice."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= path.length <= 104`\n*   `path[i]` is either `'N'`, `'S'`, `'E'`, or `'W'`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"NES\"",
                "output": "false"
            },
            {
                "input": "\"NESWW\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> luckyNumbers(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    List<Integer> luckyNumbers = new ArrayList<>();\n\n    for (int i = 0; i < m; i++) {\n        int minRow = matrix[i][0];\n        int minRowIndex = 0;\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] < minRow) {\n                minRow = matrix[i][j];\n                minRowIndex = j;\n            }\n        }\n\n        boolean isLucky = true;\n        for (int k = 0; k < m; k++) {\n            if (matrix[k][minRowIndex] > minRow) {\n                isLucky = false;\n                break;\n            }\n        }\n\n        if (isLucky)\n            luckyNumbers.add(minRow);\n    }\n\n    return luckyNumbers;\n}\n```\n    \n    1. Initialize a list `lucky_numbers` to store the final lucky numbers from the matrix.\n2. Iterate through all rows in the matrix, and for each row:\n   - Find the minimum element `min_row` in the row and its index `min_row_idx`.\n   - Check if `min_row` is the maximum element in its column `min_row_idx`. If so, add `min_row` to the list of `lucky_numbers`.\n3. Return the `lucky_numbers` list.\n    ",
        "python": "\n    ```python\ndef lucky_numbers(matrix):\n    m, n = len(matrix), len(matrix[0])\n    lucky_numbers = []\n\n    for i in range(m):\n        min_row = min(matrix[i])\n        min_row_idx = matrix[i].index(min_row)\n        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))\n\n        if is_lucky:\n            lucky_numbers.append(min_row)\n\n    return lucky_numbers\n```\n    \n    1. Initialize a list `lucky_numbers` to store the final lucky numbers from the matrix.\n2. Iterate through all rows in the matrix, and for each row:\n   - Find the minimum element `min_row` in the row and its index `min_row_idx`.\n   - Check if `min_row` is the maximum element in its column `min_row_idx`. If so, add `min_row` to the list of `lucky_numbers`.\n3. Return the `lucky_numbers` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> luckyNumbers(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    vector<int> lucky_numbers;\n    for (int i = 0; i < m; ++i) {\n        int min_row = matrix[i][0], min_row_idx = 0;\n        for (int j = 0; j < n; ++j) {\n            if (matrix[i][j] < min_row) {\n                min_row = matrix[i][j];\n                min_row_idx = j;\n            }\n        }\n        bool is_lucky = true;\n        for (int k = 0; k < m; ++k) {\n            if (matrix[k][min_row_idx] > min_row) {\n                is_lucky = false;\n                break;\n            }\n        }\n        if (is_lucky)\n            lucky_numbers.push_back(min_row);\n    }\n    return lucky_numbers;\n}\n```\n    \n    1. Initialize a list `lucky_numbers` to store the final lucky numbers from the matrix.\n2. Iterate through all rows in the matrix, and for each row:\n   - Find the minimum element `min_row` in the row and its index `min_row_idx`.\n   - Check if `min_row` is the maximum element in its column `min_row_idx`. If so, add `min_row` to the list of `lucky_numbers`.\n3. Return the `lucky_numbers` list.\n    ",
        "js": "\n    ```javascript\nfunction luckyNumbers(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    const luckyNumbers = [];\n\n    for (let i = 0; i < m; i++) {\n        let minRow = matrix[i][0];\n        let minRowIndex = 0;\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] < minRow) {\n                minRow = matrix[i][j];\n                minRowIndex = j;\n            }\n        }\n\n        let isLucky = true;\n        for (let k = 0; k < m; k++) {\n            if (matrix[k][minRowIndex] > minRow) {\n                isLucky = false;\n                break;\n            }\n        }\n\n        if (isLucky)\n            luckyNumbers.push(minRow);\n    }\n\n    return luckyNumbers;\n}\n```\n    \n    1. Initialize a list `lucky_numbers` to store the final lucky numbers from the matrix.\n2. Iterate through all rows in the matrix, and for each row:\n   - Find the minimum element `min_row` in the row and its index `min_row_idx`.\n   - Check if `min_row` is the maximum element in its column `min_row_idx`. If so, add `min_row` to the list of `lucky_numbers`.\n3. Return the `lucky_numbers` list.\n    "
    },
    {
        "id": 272,
        "title": "Can Make Arithmetic Progression From Sequence",
        "difficulty": "Easy",
        "content": {
            "problem": "A sequence of numbers is called an **arithmetic progression** if the difference between any two consecutive elements is the same.\n\nGiven an array of numbers `arr`, return `true` _if the array can be rearranged to form an **arithmetic progression**. Otherwise, return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[3,5,1\\]\n**Output:** true\n**Explanation:** We can reorder the elements as \\[1,3,5\\] or \\[5,3,1\\] with differences 2 and -2 respectively, between each consecutive elements.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,4\\]\n**Output:** false\n**Explanation:** There is no way to reorder the elements to obtain an arithmetic progression."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= arr.length <= 1000`\n*   `-106 <= arr[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,5,1]",
                "output": "true"
            },
            {
                "input": "[1,2,4]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean canConstruct(String s, int k) {\n    int[] charCounts = new int[26];\n\n    for (char c : s.toCharArray()) \n        charCounts[c - 'a']++;\n\n    int oddCount = 0;\n    for (int count : charCounts) \n        oddCount += count % 2;\n\n    return oddCount <= k && k <= s.length();\n}\n```\n\n    \n    The algorithm counts the occurrences of each character in the input string s. For each character count, it checks if it is odd - if so, it increases the odd count.\n\nThen, the function checks if the odd count is less than or equal to k (the number of palindrome strings required) and if k is less than or equal to the length of the input string s. If both these conditions are satisfied, the function returns true, meaning it is possible to construct k palindrome strings using all the characters in s. Otherwise, it returns false. \n    ",
        "python": "\n    ```python\ndef can_construct(s, k):\n    char_counts = [0] * 26\n\n    for c in s:\n        char_counts[ord(c) - ord('a')] += 1\n\n    odd_count = sum(count % 2 for count in char_counts)\n\n    return odd_count <= k <= len(s)\n```\n\n    \n    The algorithm counts the occurrences of each character in the input string s. For each character count, it checks if it is odd - if so, it increases the odd count.\n\nThen, the function checks if the odd count is less than or equal to k (the number of palindrome strings required) and if k is less than or equal to the length of the input string s. If both these conditions are satisfied, the function returns true, meaning it is possible to construct k palindrome strings using all the characters in s. Otherwise, it returns false. \n    ",
        "c++": "\n    ```cpp\nbool canConstruct(std::string s, int k) {\n    int char_counts[26] = {0};\n\n    for (char c : s) \n        char_counts[c - 'a']++;\n\n    int odd_count = 0;\n    for (int count : char_counts) \n        odd_count += count % 2;\n\n    return odd_count <= k && k <= s.length();\n}\n```\n\n    \n    The algorithm counts the occurrences of each character in the input string s. For each character count, it checks if it is odd - if so, it increases the odd count.\n\nThen, the function checks if the odd count is less than or equal to k (the number of palindrome strings required) and if k is less than or equal to the length of the input string s. If both these conditions are satisfied, the function returns true, meaning it is possible to construct k palindrome strings using all the characters in s. Otherwise, it returns false. \n    ",
        "js": "\n    ```javascript\nfunction canConstruct(s, k) {\n    let charCounts = new Array(26).fill(0);\n\n    for (let c of s) \n        charCounts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    let oddCount = charCounts.reduce((acc, count) => acc + (count % 2), 0);\n\n    return oddCount <= k && k <= s.length;\n}\n```\n\n    \n    The algorithm counts the occurrences of each character in the input string s. For each character count, it checks if it is odd - if so, it increases the odd count.\n\nThen, the function checks if the odd count is less than or equal to k (the number of palindrome strings required) and if k is less than or equal to the length of the input string s. If both these conditions are satisfied, the function returns true, meaning it is possible to construct k palindrome strings using all the characters in s. Otherwise, it returns false. \n    "
    },
    {
        "id": 273,
        "title": "Reformat Date",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `date` string in the form `Day Month Year`, where:\n\n*   `Day` is in the set `{ \"1st \", \"2nd \", \"3rd \", \"4th \", ..., \"30th \", \"31st \"}`.\n*   `Month` is in the set `{ \"Jan \", \"Feb \", \"Mar \", \"Apr \", \"May \", \"Jun \", \"Jul \", \"Aug \", \"Sep \", \"Oct \", \"Nov \", \"Dec \"}`.\n*   `Year` is in the range `[1900, 2100]`.\n\nConvert the date string to the format `YYYY-MM-DD`, where:\n\n*   `YYYY` denotes the 4 digit year.\n*   `MM` denotes the 2 digit month.\n*   `DD` denotes the 2 digit day.",
            "examples": [
                "**Example 1:**\n\n**Input:** date =  \"20th Oct 2052 \"\n**Output:**  \"2052-10-20 \"\n\n",
                "**Example 2:**\n\n**Input:** date =  \"6th Jun 1933 \"\n**Output:**  \"1933-06-06 \"\n\n",
                "**Example 3:**\n\n**Input:** date =  \"26th May 1960 \"\n**Output:**  \"1960-05-26 \""
            ],
            "constraints": "**Constraints:**\n\n*   The given dates are guaranteed to be valid, so no error handling is necessary.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"20thOct2052\"",
                "output": "\"2052-10-20\""
            },
            {
                "input": "\"6thJun1933\"",
                "output": "\"1933-06-06\""
            },
            {
                "input": "\"26thMay1960\"",
                "output": "\"1960-05-26\""
            }
        ],
        "java": "\n    ```java\npublic boolean hasValidPath(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    boolean[][] visited = new boolean[m][n];\n\n    return dfs(grid, 0, 0, m, n, visited);\n}\n\nprivate boolean dfs(int[][] grid, int x, int y, int m, int n, boolean[][] visited) {\n    if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) return false;\n    if (x == m - 1 && y == n - 1) return true;\n    \n    visited[x][y] = true;\n\n    int[] next_x = {-1, 0, 1, 0};\n    int[] next_y = {0, 1, 0, -1};\n\n    for (int i = 0; i < 4; i++) {\n        int dx = x + next_x[i];\n        int dy = y + next_y[i];\n\n        if (dfs(grid, dx, dy, m, n, visited)) return true;\n    }\n\n    return false;\n}\n```\n    \n    The algorithm performs a depth-first search through the grid starting from the upper-left cell (0,0), marking each visited cell in a separate grid. It iterates 4 different directions for each cell, checking boundaries, and continuing its search if a valid path is found from the next cell in the given direction.\n\nThe DFS continues until it reaches the bottom-right cell (m-1, n-1), at which point it returns true. If the algorithm cannot find a path to the bottom-right cell, it returns false.\n    ",
        "python": "\n    ```python\ndef hasValidPath(grid):\n    m, n = len(grid), len(grid[0])\n    visited = [[False for _ in range(n)] for _ in range(m)]\n\n    return dfs(grid, 0, 0, m, n, visited)\n\ndef dfs(grid, x, y, m, n, visited):\n    if x < 0 or y < 0 or x >= m or y >= n or visited[x][y]:\n        return False\n    if x == m - 1 and y == n - 1:\n        return True\n    \n    visited[x][y] = True\n\n    next_x = [-1, 0, 1, 0]\n    next_y = [0, 1, 0, -1]\n\n    for i in range(4):\n        dx = x + next_x[i]\n        dy = y + next_y[i]\n\n        if dfs(grid, dx, dy, m, n, visited):\n            return True\n\n    return False\n```\n    \n    The algorithm performs a depth-first search through the grid starting from the upper-left cell (0,0), marking each visited cell in a separate grid. It iterates 4 different directions for each cell, checking boundaries, and continuing its search if a valid path is found from the next cell in the given direction.\n\nThe DFS continues until it reaches the bottom-right cell (m-1, n-1), at which point it returns true. If the algorithm cannot find a path to the bottom-right cell, it returns false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool hasValidPath(std::vector<std::vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));\n\n    return dfs(grid, 0, 0, m, n, visited);\n}\n\nbool dfs(std::vector<std::vector<int>>& grid, int x, int y, int m, int n, std::vector<std::vector<bool>>& visited) {\n    if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) return false;\n    if (x == m - 1 && y == n - 1) return true;\n    \n    visited[x][y] = true;\n\n    int next_x[4] = {-1, 0, 1, 0};\n    int next_y[4] = {0, 1, 0, -1};\n\n    for (int i = 0; i < 4; i++) {\n        int dx = x + next_x[i];\n        int dy = y + next_y[i];\n\n        if (dfs(grid, dx, dy, m, n, visited)) return true;\n    }\n\n    return false;\n}\n```\n    \n    The algorithm performs a depth-first search through the grid starting from the upper-left cell (0,0), marking each visited cell in a separate grid. It iterates 4 different directions for each cell, checking boundaries, and continuing its search if a valid path is found from the next cell in the given direction.\n\nThe DFS continues until it reaches the bottom-right cell (m-1, n-1), at which point it returns true. If the algorithm cannot find a path to the bottom-right cell, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction hasValidPath(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const visited = new Array(m).fill(null).map(() => new Array(n).fill(false));\n\n    return dfs(grid, 0, 0, m, n, visited);\n}\n\nfunction dfs(grid, x, y, m, n, visited) {\n    if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) return false;\n    if (x === m - 1 && y === n - 1) return true;\n\n    visited[x][y] = true;\n\n    const next_x = [-1, 0, 1, 0];\n    const next_y = [0, 1, 0, -1];\n\n    for (let i = 0; i < 4; i++) {\n        const dx = x + next_x[i];\n        const dy = y + next_y[i];\n\n        if (dfs(grid, dx, dy, m, n, visited)) return true;\n    }\n\n    return false;\n}\n```\n    \n    The algorithm performs a depth-first search through the grid starting from the upper-left cell (0,0), marking each visited cell in a separate grid. It iterates 4 different directions for each cell, checking boundaries, and continuing its search if a valid path is found from the next cell in the given direction.\n\nThe DFS continues until it reaches the bottom-right cell (m-1, n-1), at which point it returns true. If the algorithm cannot find a path to the bottom-right cell, it returns false.\n    "
    },
    {
        "id": 274,
        "title": "Number of Good Pairs",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, return _the number of **good pairs**_.\n\nA pair `(i, j)` is called _good_ if `nums[i] == nums[j]` and `i` < `j`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1,1,3\\]\n**Output:** 4\n**Explanation:** There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1\\]\n**Output:** 6\n**Explanation:** Each pair in the array are _good_.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,2,3,1,1,3]",
                "output": "4"
            },
            {
                "input": "[1,1,1,1]",
                "output": "6"
            },
            {
                "input": "[1,2,3]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass UndergroundSystem {\n    private Map<Integer, Pair<String, Integer>> checkInData;\n    private Map<String, Pair<Integer, Integer>> travelData;\n\n    public UndergroundSystem() {\n        checkInData = new HashMap<>();\n        travelData = new HashMap<>();\n    }\n\n    public void checkIn(int id, String stationName, int t) {\n        checkInData.put(id, new Pair<>(stationName, t));\n    }\n\n    public void checkOut(int id, String stationName, int t) {\n        String startStation = checkInData.get(id).getKey();\n        int startTime = checkInData.get(id).getValue();\n        String route = startStation + \"_\" + stationName;\n        int totalTime = travelData.getOrDefault(route, new Pair<>(0, 0)).getKey() + (t - startTime);\n        int numTrips = travelData.getOrDefault(route, new Pair<>(0, 0)).getValue() + 1;\n        travelData.put(route, new Pair<>(totalTime, numTrips));\n    }\n\n    public double getAverageTime(String startStation, String endStation) {\n        String route = startStation + \"_\" + endStation;\n        double totalTime = travelData.get(route).getKey();\n        int numTrips = travelData.get(route).getValue();\n        return totalTime / numTrips;\n    }\n}\n```\n    \n    The algorithm uses two nested hashmaps (in Python, two nested dictionaries) to keep track of check-in/check-out data and travel-time data:\n\n1. The `check_in_data` hashmap stores the traveler's check-in station and time, with their ID as the key.\n2. When a user checks out, the starting station and check-in time are retrieved from `check_in_data` and combined with the check-out station and time to create a route key. The route key is then used to store the total travel time and the number of trips taken for that route in the `travel_data` hashmap.\n3. To retrieve the average time between two stations, the algorithm looks up the total time and trip count for the requested route and divides the total time by the trip count.\n\nThe algorithm has an O(1) average complexity for all operations (check-in, check-out, and getAverageTime) as it relies on hashing lookups and updates.\n    ",
        "python": "\n    ```python\nclass UndergroundSystem:\n    def __init__(self):\n        self.check_in_data = {}\n        self.travel_data = {}\n\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n        self.check_in_data[id] = (stationName, t)\n\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n        start_station, start_time = self.check_in_data[id]\n        route = (start_station, stationName)\n        if route not in self.travel_data:\n            self.travel_data[route] = [0, 0]\n        self.travel_data[route][0] += t - start_time\n        self.travel_data[route][1] += 1\n\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        route = (startStation, endStation)\n        total_time, num_trips = self.travel_data[route]\n        return total_time / num_trips\n```\n    \n    The algorithm uses two nested hashmaps (in Python, two nested dictionaries) to keep track of check-in/check-out data and travel-time data:\n\n1. The `check_in_data` hashmap stores the traveler's check-in station and time, with their ID as the key.\n2. When a user checks out, the starting station and check-in time are retrieved from `check_in_data` and combined with the check-out station and time to create a route key. The route key is then used to store the total travel time and the number of trips taken for that route in the `travel_data` hashmap.\n3. To retrieve the average time between two stations, the algorithm looks up the total time and trip count for the requested route and divides the total time by the trip count.\n\nThe algorithm has an O(1) average complexity for all operations (check-in, check-out, and getAverageTime) as it relies on hashing lookups and updates.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\n\nclass UndergroundSystem {\npublic:\n    unordered_map<int, pair<string, int>> check_in_data;\n    unordered_map<string, pair<int, int>> travel_data;\n\n    UndergroundSystem() {}\n\n    void checkIn(int id, string stationName, int t) {\n        check_in_data[id] = {stationName, t};\n    }\n\n    void checkOut(int id, string stationName, int t) {\n        string startStation = check_in_data[id].first;\n        int startTime = check_in_data[id].second;\n        string route = startStation + \"_\" + stationName;\n        travel_data[route].first += (t - startTime);\n        travel_data[route].second += 1;\n    }\n\n    double getAverageTime(string startStation, string endStation) {\n        string route = startStation + \"_\" + endStation;\n        return (double)travel_data[route].first / travel_data[route].second;\n    }\n};\n```\n    \n    The algorithm uses two nested hashmaps (in Python, two nested dictionaries) to keep track of check-in/check-out data and travel-time data:\n\n1. The `check_in_data` hashmap stores the traveler's check-in station and time, with their ID as the key.\n2. When a user checks out, the starting station and check-in time are retrieved from `check_in_data` and combined with the check-out station and time to create a route key. The route key is then used to store the total travel time and the number of trips taken for that route in the `travel_data` hashmap.\n3. To retrieve the average time between two stations, the algorithm looks up the total time and trip count for the requested route and divides the total time by the trip count.\n\nThe algorithm has an O(1) average complexity for all operations (check-in, check-out, and getAverageTime) as it relies on hashing lookups and updates.\n    ",
        "js": "\n    ```javascript\nclass UndergroundSystem {\n    constructor() {\n        this.checkInData = new Map();\n        this.travelData = new Map();\n    }\n\n    checkIn(id, stationName, t) {\n        this.checkInData.set(id, [stationName, t]);\n    }\n\n    checkOut(id, stationName, t) {\n        const [startStation, startTime] = this.checkInData.get(id);\n        const route = `${startStation}_${stationName}`;\n        const travelInfo = this.travelData.get(route) || [0, 0];\n        this.travelData.set(route, [travelInfo[0] + t - startTime, travelInfo[1] + 1]);\n    }\n\n    getAverageTime(startStation, endStation) {\n        const route = `${startStation}_${endStation}`;\n        const [totalTime, numTrips] = this.travelData.get(route);\n        return totalTime / numTrips;\n    }\n}\n```\n    \n    The algorithm uses two nested hashmaps (in Python, two nested dictionaries) to keep track of check-in/check-out data and travel-time data:\n\n1. The `check_in_data` hashmap stores the traveler's check-in station and time, with their ID as the key.\n2. When a user checks out, the starting station and check-in time are retrieved from `check_in_data` and combined with the check-out station and time to create a route key. The route key is then used to store the total travel time and the number of trips taken for that route in the `travel_data` hashmap.\n3. To retrieve the average time between two stations, the algorithm looks up the total time and trip count for the requested route and divides the total time by the trip count.\n\nThe algorithm has an O(1) average complexity for all operations (check-in, check-out, and getAverageTime) as it relies on hashing lookups and updates.\n    "
    },
    {
        "id": 275,
        "title": "Water Bottles",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `numBottles` water bottles that are initially full of water. You can exchange `numExchange` empty water bottles from the market with one full water bottle.\n\nThe operation of drinking a full water bottle turns it into an empty bottle.\n\nGiven the two integers `numBottles` and `numExchange`, return _the **maximum** number of water bottles you can drink_.",
            "examples": [
                "**Example 1:**\n\n**Input:** numBottles = 9, numExchange = 3\n**Output:** 13\n**Explanation:** You can exchange 3 empty bottles to get 1 full water bottle.\nNumber of water bottles you can drink: 9 + 3 + 1 = 13.\n\n",
                "**Example 2:**\n\n**Input:** numBottles = 15, numExchange = 4\n**Output:** 19\n**Explanation:** You can exchange 4 empty bottles to get 1 full water bottle. \nNumber of water bottles you can drink: 15 + 3 + 1 = 19."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= numBottles <= 100`\n*   `2 <= numExchange <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "9,3",
                "output": "13"
            },
            {
                "input": "15,4",
                "output": "19"
            }
        ],
        "java": "\n    ```java\npublic int numWaterBottles(int numBottles, int numExchange) {\n    int totalBottles = numBottles;\n    while (numBottles >= numExchange) {\n        int newBottles = numBottles / numExchange;\n        totalBottles += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return totalBottles;\n}\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    ",
        "python": "\n    ```python\ndef numWaterBottles(numBottles: int, numExchange: int) -> int:\n    totalBottles = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        totalBottles += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return totalBottles\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    ",
        "c++": "\n    ```cpp\nint numWaterBottles(int numBottles, int numExchange) {\n    int totalBottles = numBottles;\n    while (numBottles >= numExchange) {\n        int newBottles = numBottles / numExchange;\n        totalBottles += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return totalBottles;\n}\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    ",
        "js": "\n    ```javascript\nfunction numWaterBottles(numBottles, numExchange) {\n    let totalBottles = numBottles;\n    while (numBottles >= numExchange) {\n        let newBottles = Math.floor(numBottles / numExchange);\n        totalBottles += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return totalBottles;\n}\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    "
    },
    {
        "id": 276,
        "title": "Count Odd Numbers in an Interval Range",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two non-negative integers `low` and `high`. Return the _count of odd numbers between_ `low` _and_ `high` _(inclusive)_.",
            "examples": [
                "**Example 1:**\n\n**Input:** low = 3, high = 7\n**Output:** 3\n**Explanation:** The odd numbers between 3 and 7 are \\[3,5,7\\].\n\n",
                "**Example 2:**\n\n**Input:** low = 8, high = 10\n**Output:** 1\n**Explanation:** The odd numbers between 8 and 10 are \\[9\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= low <= high <= 10^9`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "3,7",
                "output": "3"
            },
            {
                "input": "8,10",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int countOdds(int low, int high) {\n    return (high - low) / 2 + ((low % 2 == 1 || high % 2 == 1) ? 1 : 0);\n}\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "python": "\n    ```python\ndef count_odds(low, high):\n    return (high - low) // 2 + (1 if low % 2 == 1 or high % 2 == 1 else 0)\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "c++": "\n    ```cpp\nint count_odds(int low, int high) {\n    return (high - low) / 2 + ((low % 2 == 1 || high % 2 == 1) ? 1 : 0);\n}\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "js": "\n    ```javascript\nfunction countOdds(low, high) {\n    return Math.floor((high - low) / 2) + ((low % 2 === 1 || high % 2 === 1) ? 1 : 0);\n}\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    "
    },
    {
        "id": 277,
        "title": "Shuffle String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` and an integer array `indices` of the **same length**. The string `s` will be shuffled such that the character at the `ith` position moves to `indices[i]` in the shuffled string.\n\nReturn _the shuffled string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"codeleet \", `indices` = \\[4,5,6,7,0,2,1,3\\]\n**Output:**  \"leetcode \"\n**Explanation:** As shown,  \"codeleet \" becomes  \"leetcode \" after shuffling.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abc \", `indices` = \\[0,1,2\\]\n**Output:**  \"abc \"\n**Explanation:** After shuffling, each character remains in its position."
            ],
            "constraints": "**Constraints:**\n\n*   `s.length == indices.length == n`\n*   `1 <= n <= 100`\n*   `s` consists of only lowercase English letters.\n*   `0 <= indices[i] < n`\n*   All values of `indices` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "\"codeleet\",[4,5,6,7,0,2,1,3]",
                "output": "\"leetcode\""
            },
            {
                "input": "\"abc\",[0,1,2]",
                "output": "\"abc\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\n    int maxCandies = 0;\n    for (int candy : candies) {\n        maxCandies = Math.max(candy, maxCandies);\n    }\n\n    List<Boolean> result = new ArrayList<>();\n    for (int candy : candies) {\n        result.add(candy + extraCandies >= maxCandies);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first finds the maximum number of candies any kid has by iterating over the candies array. Then, it iterates over the candies array again, checking if the number of candies a particular kid has plus the extra candies is greater than or equal to the maximum number of candies. If it is, it adds `true` to the result array, otherwise `false`. This result array is returned. The algorithm has a time complexity of O(n), where n is the length of the candies array.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef kids_with_candies(candies: List[int], extra_candies: int) -> List[bool]:\n    max_candies = max(candies)\n    result = [candy + extra_candies >= max_candies for candy in candies]\n    return result\n```\n    \n    The algorithm first finds the maximum number of candies any kid has by iterating over the candies array. Then, it iterates over the candies array again, checking if the number of candies a particular kid has plus the extra candies is greater than or equal to the maximum number of candies. If it is, it adds `true` to the result array, otherwise `false`. This result array is returned. The algorithm has a time complexity of O(n), where n is the length of the candies array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n    int max_candies = *max_element(candies.begin(), candies.end());\n    vector<bool> result(candies.size());\n\n    for (int i = 0; i < candies.size(); i++) {\n        result[i] = (candies[i] + extraCandies >= max_candies);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first finds the maximum number of candies any kid has by iterating over the candies array. Then, it iterates over the candies array again, checking if the number of candies a particular kid has plus the extra candies is greater than or equal to the maximum number of candies. If it is, it adds `true` to the result array, otherwise `false`. This result array is returned. The algorithm has a time complexity of O(n), where n is the length of the candies array.\n    ",
        "js": "\n    ```javascript\nfunction kidsWithCandies(candies, extraCandies) {\n    let maxCandies = Math.max(...candies);\n    let result = candies.map(candy => candy + extraCandies >= maxCandies);\n    return result;\n}\n```\n    \n    The algorithm first finds the maximum number of candies any kid has by iterating over the candies array. Then, it iterates over the candies array again, checking if the number of candies a particular kid has plus the extra candies is greater than or equal to the maximum number of candies. If it is, it adds `true` to the result array, otherwise `false`. This result array is returned. The algorithm has a time complexity of O(n), where n is the length of the candies array.\n    "
    },
    {
        "id": 278,
        "title": "Count Good Triplets",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, and three integers `a`, `b` and `c`. You need to find the number of good triplets.\n\nA triplet `(arr[i], arr[j], arr[k])` is **good** if the following conditions are true:\n\n*   `0 <= i < j < k < arr.length`\n*   `|arr[i] - arr[j]| <= a`\n*   `|arr[j] - arr[k]| <= b`\n*   `|arr[i] - arr[k]| <= c`\n\nWhere `|x|` denotes the absolute value of `x`.\n\nReturn _the number of good triplets_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[3,0,1,1,9,7\\], a = 7, b = 2, c = 3\n**Output:** 4\n**Explanation:** There are 4 good triplets: \\[(3,0,1), (3,0,1), (3,1,1), (0,1,1)\\].\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,1,2,2,3\\], a = 0, b = 0, c = 1\n**Output:** 0\n**Explanation:** No triplet satisfies all conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 100`\n*   `0 <= arr[i] <= 1000`\n*   `0 <= a, b, c <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[3,0,1,1,9,7],7,2,3",
                "output": "4"
            },
            {
                "input": "[1,1,2,2,3],0,0,1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint minNumberOfFrogs(String croakOfFrogs) {\n    int[] counts = new int[5];\n    int max_frogs = 0;\n\n    for (char c : croakOfFrogs.toCharArray()) {\n        int index = \"croak\".indexOf(c);\n        if (index == 0) {\n            counts[0]++;\n            max_frogs = Math.max(max_frogs, counts[0]);\n        } else if (counts[index - 1] > 0) {\n            counts[index - 1]--;\n            counts[index]++;\n        } else {\n            return -1;\n        }\n    }\n\n    if (counts[0] == counts[4]) {\n        return max_frogs;\n    } else {\n        return -1;\n    }\n}\n```\n    \n    The algorithm starts by initializing an array `counts` with five elements and `max_frogs` to zero. It iterates through the given string `croakOfFrogs`. For each character, it finds its index in the string \"croak\":\n\n- If the character is a 'c', it increases the first element of `counts` and updates the `max_frogs`.\n- If the character is one of 'r', 'o', 'a', or 'k', it checks if the previous letter in \"croak\" has a non-zero count in the `counts` array. If it does, it transfers the count of the previous letter to the count of the current character; otherwise, it returns -1, as the string does not represent a valid croak sequence.\n\nAfter iterating through the entire string, the algorithm checks if the count of 'c's is equal to the count of 'k's, which indicates that all frog croaks are completed. If so, it returns the value of `max_frogs`; otherwise, it returns -1.\n    ",
        "python": "\n    ```python\ndef minNumberOfFrogs(croakOfFrogs: str) -> int:\n    counts = [0] * 5\n    max_frogs = 0\n\n    for c in croakOfFrogs:\n        index = \"croak\".find(c)\n        if index == 0:\n            counts[0] += 1\n            max_frogs = max(max_frogs, counts[0])\n        elif counts[index - 1] > 0:\n            counts[index - 1] -= 1\n            counts[index] += 1\n        else:\n            return -1\n\n    if counts[0] == counts[4]:\n        return max_frogs\n    else:\n        return -1\n```\n    \n    The algorithm starts by initializing an array `counts` with five elements and `max_frogs` to zero. It iterates through the given string `croakOfFrogs`. For each character, it finds its index in the string \"croak\":\n\n- If the character is a 'c', it increases the first element of `counts` and updates the `max_frogs`.\n- If the character is one of 'r', 'o', 'a', or 'k', it checks if the previous letter in \"croak\" has a non-zero count in the `counts` array. If it does, it transfers the count of the previous letter to the count of the current character; otherwise, it returns -1, as the string does not represent a valid croak sequence.\n\nAfter iterating through the entire string, the algorithm checks if the count of 'c's is equal to the count of 'k's, which indicates that all frog croaks are completed. If so, it returns the value of `max_frogs`; otherwise, it returns -1.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nint minNumberOfFrogs(std::string croakOfFrogs) {\n    int counts[5] = {0}, max_frogs = 0;\n\n    for (char c : croakOfFrogs) {\n        int index = std::string(\"croak\").find(c);\n        if (index == 0) {\n            counts[0]++;\n            max_frogs = std::max(max_frogs, counts[0]);\n        } else if (counts[index - 1] > 0) {\n            counts[index - 1]--;\n            counts[index]++;\n        } else {\n            return -1;\n        }\n    }\n\n    if (counts[0] == counts[4]) {\n        return max_frogs;\n    } else {\n        return -1;\n    }\n}\n```\n    \n    The algorithm starts by initializing an array `counts` with five elements and `max_frogs` to zero. It iterates through the given string `croakOfFrogs`. For each character, it finds its index in the string \"croak\":\n\n- If the character is a 'c', it increases the first element of `counts` and updates the `max_frogs`.\n- If the character is one of 'r', 'o', 'a', or 'k', it checks if the previous letter in \"croak\" has a non-zero count in the `counts` array. If it does, it transfers the count of the previous letter to the count of the current character; otherwise, it returns -1, as the string does not represent a valid croak sequence.\n\nAfter iterating through the entire string, the algorithm checks if the count of 'c's is equal to the count of 'k's, which indicates that all frog croaks are completed. If so, it returns the value of `max_frogs`; otherwise, it returns -1.\n    ",
        "js": "\n    ```javascript\nfunction minNumberOfFrogs(croakOfFrogs) {\n    let counts = Array(5).fill(0);\n    let max_frogs = 0;\n\n    for (let c of croakOfFrogs) {\n        let index = \"croak\".indexOf(c);\n        if (index === 0) {\n            counts[0]++;\n            max_frogs = Math.max(max_frogs, counts[0]);\n        } else if (counts[index - 1] > 0) {\n            counts[index - 1]--;\n            counts[index]++;\n        } else {\n            return -1;\n        }\n    }\n\n    if (counts[0] === counts[4]) {\n        return max_frogs;\n    } else {\n        return -1;\n    }\n}\n```\n    \n    The algorithm starts by initializing an array `counts` with five elements and `max_frogs` to zero. It iterates through the given string `croakOfFrogs`. For each character, it finds its index in the string \"croak\":\n\n- If the character is a 'c', it increases the first element of `counts` and updates the `max_frogs`.\n- If the character is one of 'r', 'o', 'a', or 'k', it checks if the previous letter in \"croak\" has a non-zero count in the `counts` array. If it does, it transfers the count of the previous letter to the count of the current character; otherwise, it returns -1, as the string does not represent a valid croak sequence.\n\nAfter iterating through the entire string, the algorithm checks if the count of 'c's is equal to the count of 'k's, which indicates that all frog croaks are completed. If so, it returns the value of `max_frogs`; otherwise, it returns -1.\n    "
    },
    {
        "id": 279,
        "title": "Kth Missing Positive Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `arr` of positive integers sorted in a **strictly increasing order**, and an integer `k`.\n\nReturn _the_ `kth` _**positive** integer that is **missing** from this array._",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,3,4,7,11\\], k = 5\n**Output:** 9\n**Explanation:** The missing positive integers are \\[1,5,6,8,9,10,12,13,...\\]. The 5th missing positive integer is 9.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,3,4\\], k = 2\n**Output:** 6\n**Explanation:** The missing positive integers are \\[5,6,7,...\\]. The 2nd missing positive integer is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 1000`\n*   `1 <= k <= 1000`\n*   `arr[i] < arr[j]` for `1 <= i < j <= arr.length`\n\n**",
            "follow_up": "Follow up:**\n\nCould you solve this problem in less than O(n) complexity?"
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[2,3,4,7,11],5",
                "output": "9"
            },
            {
                "input": "[1,2,3,4],2",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> findDiagonalOrder(List<List<Integer>> nums) {\n    List<Integer> res = new ArrayList<>();\n    int m = nums.size();\n    HashMap<Integer, List<Integer>> diagonals = new HashMap<>();\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < nums.get(i).size(); j++) {\n            int key = i + j;\n            if (!diagonals.containsKey(key)) {\n                diagonals.put(key, new ArrayList<>());\n            }\n            diagonals.get(key).add(nums.get(i).get(j));\n        }\n    }\n\n    for (int key : diagonals.keySet()) {\n        List<Integer> diag = diagonals.get(key);\n        Collections.reverse(diag);\n        res.addAll(diag);\n    }\n\n    return res;\n}\n```\n    \n    First, we iterate through the 2D array nums using nested loops over `i` and `j`. At each loop iteration, we insert the current element nums[i][j] into diagonals[i + j] list for a specific diagonal associated with (i + j). If the list doesn't exist, we create it.\n\nThen, we iterate through the diagonals and reverse the order of each diagonal list because elements with larger row index should come first in the result. We use `std::reverse()` in C++, `Collections.reverse()` in Java, `reversed()` in Python, and `Array.prototype.reverse()` in JavaScript.\n\nFinally, we concatenate the reversed diagonal lists to form the result array using `std::vector::insert()` in C++, `List.addAll()` in Java, `list.extend()` in Python, and by using the spread operator (`...`) in JavaScript.\n    ",
        "python": "\n    ```python\ndef find_diagonal_order(nums):\n    diagonals = {}\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if i + j not in diagonals:\n                diagonals[i + j] = []\n            diagonals[i + j].append(nums[i][j])\n\n    res = []\n    for key in diagonals:\n        res.extend(reversed(diagonals[key]))\n\n    return res\n```\n    \n    First, we iterate through the 2D array nums using nested loops over `i` and `j`. At each loop iteration, we insert the current element nums[i][j] into diagonals[i + j] list for a specific diagonal associated with (i + j). If the list doesn't exist, we create it.\n\nThen, we iterate through the diagonals and reverse the order of each diagonal list because elements with larger row index should come first in the result. We use `std::reverse()` in C++, `Collections.reverse()` in Java, `reversed()` in Python, and `Array.prototype.reverse()` in JavaScript.\n\nFinally, we concatenate the reversed diagonal lists to form the result array using `std::vector::insert()` in C++, `List.addAll()` in Java, `list.extend()` in Python, and by using the spread operator (`...`) in JavaScript.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> findDiagonalOrder(std::vector<std::vector<int>>& nums) {\n    std::vector<int> res;\n    int m = nums.size();\n    std::map<int, std::vector<int>> diagonals;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < nums[i].size(); j++) {\n            diagonals[i + j].push_back(nums[i][j]);\n        }\n    }\n\n    for (auto& diag : diagonals) {\n        std::reverse(diag.second.begin(), diag.second.end());\n        res.insert(res.end(), diag.second.begin(), diag.second.end());\n    }\n\n    return res;\n}\n```\n    \n    First, we iterate through the 2D array nums using nested loops over `i` and `j`. At each loop iteration, we insert the current element nums[i][j] into diagonals[i + j] list for a specific diagonal associated with (i + j). If the list doesn't exist, we create it.\n\nThen, we iterate through the diagonals and reverse the order of each diagonal list because elements with larger row index should come first in the result. We use `std::reverse()` in C++, `Collections.reverse()` in Java, `reversed()` in Python, and `Array.prototype.reverse()` in JavaScript.\n\nFinally, we concatenate the reversed diagonal lists to form the result array using `std::vector::insert()` in C++, `List.addAll()` in Java, `list.extend()` in Python, and by using the spread operator (`...`) in JavaScript.\n    ",
        "js": "\n    ```javascript\nfunction findDiagonalOrder(nums) {\n    const diagonals = {};\n    const m = nums.length;\n    const res = [];\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < nums[i].length; j++) {\n            if (!diagonals[i + j]) {\n                diagonals[i + j] = [];\n            }\n            diagonals[i + j].push(nums[i][j]);\n        }\n    }\n\n    for (const key in diagonals) {\n        res.push(...diagonals[key].reverse());\n    }\n\n    return res;\n}\n```\n    \n    First, we iterate through the 2D array nums using nested loops over `i` and `j`. At each loop iteration, we insert the current element nums[i][j] into diagonals[i + j] list for a specific diagonal associated with (i + j). If the list doesn't exist, we create it.\n\nThen, we iterate through the diagonals and reverse the order of each diagonal list because elements with larger row index should come first in the result. We use `std::reverse()` in C++, `Collections.reverse()` in Java, `reversed()` in Python, and `Array.prototype.reverse()` in JavaScript.\n\nFinally, we concatenate the reversed diagonal lists to form the result array using `std::vector::insert()` in C++, `List.addAll()` in Java, `list.extend()` in Python, and by using the spread operator (`...`) in JavaScript.\n    "
    },
    {
        "id": 280,
        "title": "Make The String Great",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` of lower and upper case English letters.\n\nA good string is a string which doesn't have **two adjacent characters** `s[i]` and `s[i + 1]` where:\n\n*   `0 <= i <= s.length - 2`\n*   `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**.\n\nTo make the string good, you can choose **two adjacent** characters that make the string bad and remove them. You can keep doing this until the string becomes good.\n\nReturn _the string_ after making it good. The answer is guaranteed to be unique under the given constraints.\n\n**Notice** that an empty string is also good.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leEeetcode \"\n**Output:**  \"leetcode \"\n**Explanation:** In the first step, either you choose i = 1 or i = 2, both will result  \"leEeetcode \" to be reduced to  \"leetcode \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abBAcC \"\n**Output:**  \" \"\n**Explanation:** We have many possible scenarios, and all lead to the same answer. For example:\n \"abBAcC \" -->  \"aAcC \" -->  \"cC \" -->  \" \"\n \"abBAcC \" -->  \"abBA \" -->  \"aA \" -->  \" \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"s \"\n**Output:**  \"s \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only lower and upper case English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"leEeetcode\"",
                "output": "\"leetcode\""
            },
            {
                "input": "\"abBAcC\"",
                "output": "\"\""
            },
            {
                "input": "\"s\"",
                "output": "\"s\""
            }
        ],
        "java": "\n    ```java\npublic int goodNodes(TreeNode root) {\n    return goodNodes(root, Integer.MIN_VALUE);\n}\n\nprivate int goodNodes(TreeNode root, int maxVal) {\n    if (root == null) return 0;\n    int result = 0;\n    if (root.val >= maxVal) {\n        result = 1;\n        maxVal = root.val;\n    }\n    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal);\n}\n```\n    \n    The algorithm performs a depth-first search on the given binary tree. In order to traverse the tree and count the good nodes, the recursive `goodNodes` function is called, passing the current node and the maximum value found up to the current node.\n\n1. If the current root is null, return 0 (no good nodes found).\n2. Initialize a `result` variable to store the number of good nodes.\n3. Check if the current node's value is greater or equal to the maximum value found so far. If it is, increment `result` by 1 and set `maxVal` to the current node's value.\n4. Return the `result` plus the sum of the good nodes found in both the left and right child subtrees.\n\nThe base case for the recursion is when the root is null, in which case the function returns 0. This ensures that the function eventually terminates.\n\nWhen all nodes of the binary tree have been visited, the function returns the total number of good nodes.\n    ",
        "python": "\n    ```python\ndef goodNodes(root, maxVal=float('-inf')):\n    if not root:\n        return 0\n    result = 0\n    if root.val >= maxVal:\n        result = 1\n        maxVal = root.val\n    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal)\n```\n    \n    The algorithm performs a depth-first search on the given binary tree. In order to traverse the tree and count the good nodes, the recursive `goodNodes` function is called, passing the current node and the maximum value found up to the current node.\n\n1. If the current root is null, return 0 (no good nodes found).\n2. Initialize a `result` variable to store the number of good nodes.\n3. Check if the current node's value is greater or equal to the maximum value found so far. If it is, increment `result` by 1 and set `maxVal` to the current node's value.\n4. Return the `result` plus the sum of the good nodes found in both the left and right child subtrees.\n\nThe base case for the recursion is when the root is null, in which case the function returns 0. This ensures that the function eventually terminates.\n\nWhen all nodes of the binary tree have been visited, the function returns the total number of good nodes.\n    ",
        "c++": "\n    ```cpp\nint goodNodes(TreeNode* root, int maxVal = INT_MIN) {\n    if (!root) return 0;\n    int result = 0;\n    if (root->val >= maxVal) {\n        result = 1;\n        maxVal = root->val;\n    }\n    return result + goodNodes(root->left, maxVal) + goodNodes(root->right, maxVal);\n}\n```\n    \n    The algorithm performs a depth-first search on the given binary tree. In order to traverse the tree and count the good nodes, the recursive `goodNodes` function is called, passing the current node and the maximum value found up to the current node.\n\n1. If the current root is null, return 0 (no good nodes found).\n2. Initialize a `result` variable to store the number of good nodes.\n3. Check if the current node's value is greater or equal to the maximum value found so far. If it is, increment `result` by 1 and set `maxVal` to the current node's value.\n4. Return the `result` plus the sum of the good nodes found in both the left and right child subtrees.\n\nThe base case for the recursion is when the root is null, in which case the function returns 0. This ensures that the function eventually terminates.\n\nWhen all nodes of the binary tree have been visited, the function returns the total number of good nodes.\n    ",
        "js": "\n    ```javascript\nfunction goodNodes(root, maxVal = Number.MIN_SAFE_INTEGER) {\n    if (!root) return 0;\n    let result = 0;\n    if (root.val >= maxVal) {\n        result = 1;\n        maxVal = root.val;\n    }\n    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal);\n}\n```\n    \n    The algorithm performs a depth-first search on the given binary tree. In order to traverse the tree and count the good nodes, the recursive `goodNodes` function is called, passing the current node and the maximum value found up to the current node.\n\n1. If the current root is null, return 0 (no good nodes found).\n2. Initialize a `result` variable to store the number of good nodes.\n3. Check if the current node's value is greater or equal to the maximum value found so far. If it is, increment `result` by 1 and set `maxVal` to the current node's value.\n4. Return the `result` plus the sum of the good nodes found in both the left and right child subtrees.\n\nThe base case for the recursion is when the root is null, in which case the function returns 0. This ensures that the function eventually terminates.\n\nWhen all nodes of the binary tree have been visited, the function returns the total number of good nodes.\n    "
    },
    {
        "id": 281,
        "title": "Three Consecutive Odds",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,6,4,1\\]\n**Output:** false\n**Explanation:** There are no three consecutive odds.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,34,3,4,5,7,23,12\\]\n**Output:** true\n**Explanation:** \\[5,7,23\\] are three consecutive odds."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[2,6,4,1]",
                "output": "false"
            },
            {
                "input": "[1,2,34,3,4,5,7,23,12]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic int kthSmallest(int[][] mat, int k) {\n    int m = mat.length, n = mat[0].length;\n    \n    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparing(a -> a[0]));\n    minHeap.offer(new int[]{mat[0][0], 0, 0});\n    \n    boolean[][] visited = new boolean[m][n];\n    visited[0][0] = true;\n    \n    int res = 0;\n    while (k-- > 0) {\n        int[] cur = minHeap.poll();\n        res = cur[0];\n        int i = cur[1], j = cur[2];\n        \n        if (i < m - 1 && !visited[i+1][j]) {\n            minHeap.offer(new int[]{res - mat[i][j] + mat[i + 1][j], i + 1, j});\n            visited[i+1][j] = true;\n        }\n        if (j < n - 1 && !visited[i][j+1]) {\n            minHeap.offer(new int[]{res - mat[i][j] + mat[i][j + 1], i, j + 1});\n            visited[i][j+1] = true;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm uses a min-heap data structure initialized with the smallest element (top-left corner) of the matrix. We maintain a matrix `visited` of booleans that tells if an element of the matrix is in the heap.\n\nIn each iteration, the algorithm pops the smallest element from the min-heap, updates the result, and inserts the elements below and to the right of the matrix, if they have not been visited yet. This process is repeated k times. After the kth iteration, the result holds the sum of the kth smallest array.\n\nThe algorithm has a time complexity of O(k * (m + n)), since in the worst case we have to visit all elements of all rows and columns m and n times (when k = m * n).\n\nNote that in JavaScript, we do not use a priority queue implementation. Instead, we add elements to the array and sort the array each time after adding elements. This gives slightly worse performance in practice, but for the given problem size, it should suffice.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef kthSmallest(mat, k):\n    m, n = len(mat), len(mat[0])\n    \n    minHeap = [(mat[0][0], 0, 0)]\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    visited[0][0] = True\n    \n    for _ in range(k):\n        res, i, j = heapq.heappop(minHeap)\n        \n        if i < m - 1 and not visited[i+1][j]:\n            heapq.heappush(minHeap, (res - mat[i][j] + mat[i + 1][j], i + 1, j))\n            visited[i+1][j] = True\n        if j < n - 1 and not visited[i][j+1]:\n            heapq.heappush(minHeap, (res - mat[i][j] + mat[i][j + 1], i, j + 1))\n            visited[i][j+1] = True\n            \n    return res\n```\n    \n    The algorithm uses a min-heap data structure initialized with the smallest element (top-left corner) of the matrix. We maintain a matrix `visited` of booleans that tells if an element of the matrix is in the heap.\n\nIn each iteration, the algorithm pops the smallest element from the min-heap, updates the result, and inserts the elements below and to the right of the matrix, if they have not been visited yet. This process is repeated k times. After the kth iteration, the result holds the sum of the kth smallest array.\n\nThe algorithm has a time complexity of O(k * (m + n)), since in the worst case we have to visit all elements of all rows and columns m and n times (when k = m * n).\n\nNote that in JavaScript, we do not use a priority queue implementation. Instead, we add elements to the array and sort the array each time after adding elements. This gives slightly worse performance in practice, but for the given problem size, it should suffice.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nint kthSmallest(const std::vector<std::vector<int>>& mat, int k) {\n    int m = mat.size(), n = mat[0].size();\n    \n    auto comp = [&](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] > b[0];\n    };\n    \n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(comp)> minHeap(comp);\n    minHeap.push({mat[0][0], 0, 0});\n    \n    std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));\n    visited[0][0] = true;\n    \n    int res;\n    while (k--) {\n        auto cur = minHeap.top(); minHeap.pop();\n        res = cur[0];\n        int i = cur[1], j = cur[2];\n        \n        if (i < m - 1 && !visited[i+1][j]) {\n            minHeap.push({res - mat[i][j] + mat[i + 1][j], i + 1, j});\n            visited[i+1][j] = true;\n        }\n        if (j < n - 1 && !visited[i][j+1]) {\n            minHeap.push({res - mat[i][j] + mat[i][j + 1], i, j + 1});\n            visited[i][j+1] = true;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm uses a min-heap data structure initialized with the smallest element (top-left corner) of the matrix. We maintain a matrix `visited` of booleans that tells if an element of the matrix is in the heap.\n\nIn each iteration, the algorithm pops the smallest element from the min-heap, updates the result, and inserts the elements below and to the right of the matrix, if they have not been visited yet. This process is repeated k times. After the kth iteration, the result holds the sum of the kth smallest array.\n\nThe algorithm has a time complexity of O(k * (m + n)), since in the worst case we have to visit all elements of all rows and columns m and n times (when k = m * n).\n\nNote that in JavaScript, we do not use a priority queue implementation. Instead, we add elements to the array and sort the array each time after adding elements. This gives slightly worse performance in practice, but for the given problem size, it should suffice.\n    ",
        "js": "\n    ```javascript\nfunction kthSmallest(mat, k) {\n    const m = mat.length, n = mat[0].length;\n    \n    const minHeap = [[mat[0][0], 0, 0]].sort((a, b) => a[0] - b[0]);\n    const visited = Array(m).fill().map(_ => Array(n).fill(false));\n    visited[0][0] = true;\n    \n    let res = 0;\n    while (k-- > 0) {\n        const [val, i, j] = minHeap.shift();\n        res = val;\n        \n        if (i < m - 1 && !visited[i+1][j]) {\n            minHeap.push([res - mat[i][j] + mat[i + 1][j], i + 1, j]);\n            visited[i+1][j] = true;\n        }\n        if (j < n - 1 && !visited[i][j+1]) {\n            minHeap.push([res - mat[i][j] + mat[i][j + 1], i, j + 1]);\n            visited[i][j+1] = true;\n        }\n        \n        minHeap.sort((a, b) => a[0] - b[0]);\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm uses a min-heap data structure initialized with the smallest element (top-left corner) of the matrix. We maintain a matrix `visited` of booleans that tells if an element of the matrix is in the heap.\n\nIn each iteration, the algorithm pops the smallest element from the min-heap, updates the result, and inserts the elements below and to the right of the matrix, if they have not been visited yet. This process is repeated k times. After the kth iteration, the result holds the sum of the kth smallest array.\n\nThe algorithm has a time complexity of O(k * (m + n)), since in the worst case we have to visit all elements of all rows and columns m and n times (when k = m * n).\n\nNote that in JavaScript, we do not use a priority queue implementation. Instead, we add elements to the array and sort the array each time after adding elements. This gives slightly worse performance in practice, but for the given problem size, it should suffice.\n    "
    },
    {
        "id": 282,
        "title": "Thousand Separator",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, add a dot ( \". \") as the thousands separator and return it in string format.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 987\n**Output:**  \"987 \"\n\n",
                "**Example 2:**\n\n**Input:** n = 1234\n**Output:**  \"1.234 \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "987",
                "output": "\"987\""
            },
            {
                "input": "1234",
                "output": "\"1.234\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic boolean canBeEqual(int[] target, int[] arr) {\n    Arrays.sort(target);\n    Arrays.sort(arr);\n    return Arrays.equals(target, arr);\n}\n```\n\n    \n    The basic idea behind the solution is to compare the sorted versions of the input arrays `target` and `arr`. If they are equal after sorting, it means that we can obtain `target` from `arr` by reversing any number of sub-arrays, since we can sort `arr` by reversing sub-arrays of length 2.\n\n1. Sort the input arrays `target` and `arr`.\n2. Compare the sorted arrays for equality.\n3. If the sorted arrays are equal, return `true`; otherwise, return `false`.\n\nThe time complexity is O(n log n) as the solution involves sorting the arrays, and the space complexity is O(log n) for the sorting operations.\n    ",
        "python": "\n    ```python\ndef can_be_equal(target, arr):\n    target.sort()\n    arr.sort()\n    return target == arr\n```\n\n    \n    The basic idea behind the solution is to compare the sorted versions of the input arrays `target` and `arr`. If they are equal after sorting, it means that we can obtain `target` from `arr` by reversing any number of sub-arrays, since we can sort `arr` by reversing sub-arrays of length 2.\n\n1. Sort the input arrays `target` and `arr`.\n2. Compare the sorted arrays for equality.\n3. If the sorted arrays are equal, return `true`; otherwise, return `false`.\n\nThe time complexity is O(n log n) as the solution involves sorting the arrays, and the space complexity is O(log n) for the sorting operations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool canBeEqual(std::vector<int>& target, std::vector<int>& arr) {\n    std::sort(target.begin(), target.end());\n    std::sort(arr.begin(), arr.end());\n    return target == arr;\n}\n```\n\n    \n    The basic idea behind the solution is to compare the sorted versions of the input arrays `target` and `arr`. If they are equal after sorting, it means that we can obtain `target` from `arr` by reversing any number of sub-arrays, since we can sort `arr` by reversing sub-arrays of length 2.\n\n1. Sort the input arrays `target` and `arr`.\n2. Compare the sorted arrays for equality.\n3. If the sorted arrays are equal, return `true`; otherwise, return `false`.\n\nThe time complexity is O(n log n) as the solution involves sorting the arrays, and the space complexity is O(log n) for the sorting operations.\n    ",
        "js": "\n    ```javascript\nfunction canBeEqual(target, arr) {\n    target.sort((a, b) => a - b);\n    arr.sort((a, b) => a - b);\n    return JSON.stringify(target) === JSON.stringify(arr);\n}\n```\n\n    \n    The basic idea behind the solution is to compare the sorted versions of the input arrays `target` and `arr`. If they are equal after sorting, it means that we can obtain `target` from `arr` by reversing any number of sub-arrays, since we can sort `arr` by reversing sub-arrays of length 2.\n\n1. Sort the input arrays `target` and `arr`.\n2. Compare the sorted arrays for equality.\n3. If the sorted arrays are equal, return `true`; otherwise, return `false`.\n\nThe time complexity is O(n log n) as the solution involves sorting the arrays, and the space complexity is O(log n) for the sorting operations.\n    "
    },
    {
        "id": 283,
        "title": "Detect Pattern of Length M Repeated K or More Times",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of positive integers `arr`, find a pattern of length `m` that is repeated `k` or more times.\n\nA **pattern** is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times **consecutively** without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn `true` _if there exists a pattern of length_ `m` _that is repeated_ `k` _or more times, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,2,4,4,4,4\\], m = 1, k = 3\n**Output:** true\n**Explanation:** The pattern **(4)** of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,1,2,1,1,1,3\\], m = 2, k = 2\n**Output:** true\n**Explanation:** The pattern **(1,2)** of length 2 is repeated 2 consecutive times. Another valid pattern **(2,1) is** also repeated 2 times.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[1,2,1,2,1,3\\], m = 2, k = 3\n**Output:** false\n**Explanation:** The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= arr.length <= 100`\n*   `1 <= arr[i] <= 100`\n*   `1 <= m <= 100`\n*   `2 <= k <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[1,2,4,4,4,4],1,3",
                "output": "true"
            },
            {
                "input": "[1,2,1,2,1,1,1,3],2,2",
                "output": "true"
            },
            {
                "input": "[1,2,1,2,1,3],2,3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int isPrefixOfWord(String sentence, String searchWord) {\n    String[] words = sentence.split(\" \");\n    for (int i = 0; i < words.length; i++) {\n        if (words[i].startsWith(searchWord)) {\n            return i + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Split the given sentence into words based on the space delimiter.\n2. Iterate over the list of words.\n3. For each word, check if the searchWord is a prefix (using substring in C++, `startsWith()` in Java and JavaScript, and `startswith()` in Python).\n4. If the searchWord is a prefix of the current word, return the current index (1-indexed).\n5. If no word has searchWord as a prefix, return -1.\n    ",
        "python": "\n    ```python\ndef is_prefix_of_word(sentence: str, search_word: str) -> int:\n    words = sentence.split(' ')\n    for index, word in enumerate(words, start=1):\n        if word.startswith(search_word):\n            return index\n    return -1\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Split the given sentence into words based on the space delimiter.\n2. Iterate over the list of words.\n3. For each word, check if the searchWord is a prefix (using substring in C++, `startsWith()` in Java and JavaScript, and `startswith()` in Python).\n4. If the searchWord is a prefix of the current word, return the current index (1-indexed).\n5. If no word has searchWord as a prefix, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n\nint isPrefixOfWord(std::string sentence, std::string searchWord) {\n    std::istringstream iss(sentence);\n    std::string word;\n    int index = 1;\n    while (iss >> word) {\n        if (word.substr(0, searchWord.size()) == searchWord) {\n            return index;\n        }\n        index++;\n    }\n    return -1;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Split the given sentence into words based on the space delimiter.\n2. Iterate over the list of words.\n3. For each word, check if the searchWord is a prefix (using substring in C++, `startsWith()` in Java and JavaScript, and `startswith()` in Python).\n4. If the searchWord is a prefix of the current word, return the current index (1-indexed).\n5. If no word has searchWord as a prefix, return -1.\n    ",
        "js": "\n    ```javascript\nfunction isPrefixOfWord(sentence, searchWord) {\n    const words = sentence.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n        if (words[i].startsWith(searchWord)) {\n            return i + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Split the given sentence into words based on the space delimiter.\n2. Iterate over the list of words.\n3. For each word, check if the searchWord is a prefix (using substring in C++, `startsWith()` in Java and JavaScript, and `startswith()` in Python).\n4. If the searchWord is a prefix of the current word, return the current index (1-indexed).\n5. If no word has searchWord as a prefix, return -1.\n    "
    },
    {
        "id": 284,
        "title": "Matrix Diagonal Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a square matrix `mat`, return the sum of the matrix diagonals.\n\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[**1**,2,**3**\\],\n              \\[4,**5**,6\\],\n              \\[**7**,8,**9**\\]\\]\n**Output:** 25\n**Explanation:** Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat\\[1\\]\\[1\\] = 5 is counted only once.\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[**1**,1,1,**1**\\],\n              \\[1,**1**,**1**,1\\],\n              \\[1,**1**,**1**,1\\],\n              \\[**1**,1,1,**1**\\]\\]\n**Output:** 8\n\n",
                "**Example 3:**\n\n**Input:** mat = \\[\\[**5**\\]\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `n == mat.length == mat[i].length`\n*   `1 <= n <= 100`\n*   `1 <= mat[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[**1**,2,**3**],\n[4,**5**,6],\n[**7**,8,**9**]]",
                "output": "25"
            },
            {
                "input": "[[**1**,1,1,**1**],\n[1,**1**,**1**,1],\n[1,**1**,**1**,1],\n[**1**,1,1,**1**]]",
                "output": "8"
            },
            {
                "input": "[[**5**]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nclass SubrectangleQueries {\n    int[][] rectangle;\n\n    public SubrectangleQueries(int[][] rectangle) {\n        this.rectangle = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i = row1; i <= row2; i++) {\n            for(int j = col1; j <= col2; j++) {\n                rectangle[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        return rectangle[row][col];\n    }\n}\n```\n    \n    The algorithm creates a class `SubrectangleQueries` that takes a 2D matrix called `rectangle` as input. It has two methods: `updateSubrectangle` and `getValue`. \n\n`updateSubrectangle()` takes five parameters: row1, col1, row2, col2, and newValue. It iterates over the subrectangle with top-left corner (row1, col1) and bottom-right corner (row2, col2) and updates all the values inside it to newValue.\n\n`getValue()` is a simple getter function that takes row and col as parameters and returns the value located at rectangle[row][col].\n    ",
        "python": "\n    ```python\nclass SubrectangleQueries:\n    def __init__(self, rectangle: List[List[int]]):\n        self.rectangle = rectangle\n\n    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:\n        for i in range(row1, row2 + 1):\n            for j in range(col1, col2 + 1):\n                self.rectangle[i][j] = newValue\n\n    def getValue(self, row: int, col: int) -> int:\n        return self.rectangle[row][col]\n```\n    \n    The algorithm creates a class `SubrectangleQueries` that takes a 2D matrix called `rectangle` as input. It has two methods: `updateSubrectangle` and `getValue`. \n\n`updateSubrectangle()` takes five parameters: row1, col1, row2, col2, and newValue. It iterates over the subrectangle with top-left corner (row1, col1) and bottom-right corner (row2, col2) and updates all the values inside it to newValue.\n\n`getValue()` is a simple getter function that takes row and col as parameters and returns the value located at rectangle[row][col].\n    ",
        "c++": "\n    ```cpp\nclass SubrectangleQueries {\npublic:\n    vector<vector<int>> rectangle;\n    SubrectangleQueries(vector<vector<int>>& rectangle) {\n        this->rectangle = rectangle;\n    }\n    \n    void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i = row1; i <= row2; i++) {\n            for(int j = col1; j <= col2; j++) {\n                rectangle[i][j] = newValue;\n            }\n        }\n    }\n    \n    int getValue(int row, int col) {\n        return rectangle[row][col];\n    }\n};\n```\n    \n    The algorithm creates a class `SubrectangleQueries` that takes a 2D matrix called `rectangle` as input. It has two methods: `updateSubrectangle` and `getValue`. \n\n`updateSubrectangle()` takes five parameters: row1, col1, row2, col2, and newValue. It iterates over the subrectangle with top-left corner (row1, col1) and bottom-right corner (row2, col2) and updates all the values inside it to newValue.\n\n`getValue()` is a simple getter function that takes row and col as parameters and returns the value located at rectangle[row][col].\n    ",
        "js": "\n    ```javascript\nclass SubrectangleQueries {\n    constructor(rectangle) {\n        this.rectangle = rectangle;\n    }\n    \n    updateSubrectangle(row1, col1, row2, col2, newValue) {\n        for(let i = row1; i <= row2; i++) {\n            for(let j = col1; j <= col2; j++) {\n                this.rectangle[i][j] = newValue;\n            }\n        }\n    }\n    \n    getValue(row, col) {\n        return this.rectangle[row][col];\n    }\n}\n```\n\n    \n    The algorithm creates a class `SubrectangleQueries` that takes a 2D matrix called `rectangle` as input. It has two methods: `updateSubrectangle` and `getValue`. \n\n`updateSubrectangle()` takes five parameters: row1, col1, row2, col2, and newValue. It iterates over the subrectangle with top-left corner (row1, col1) and bottom-right corner (row2, col2) and updates all the values inside it to newValue.\n\n`getValue()` is a simple getter function that takes row and col as parameters and returns the value located at rectangle[row][col].\n    "
    },
    {
        "id": 285,
        "title": "Special Positions in a Binary Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an `m x n` binary matrix `mat`, return _the number of special positions in_ `mat`_._\n\nA position `(i, j)` is called **special** if `mat[i][j] == 1` and all other elements in row `i` and column `j` are `0` (rows and columns are **0-indexed**).",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,0,0\\],\\[0,0,1\\],\\[1,0,0\\]\\]\n**Output:** 1\n**Explanation:** (1, 2) is a special position because mat\\[1\\]\\[2\\] == 1 and all other elements in row 1 and column 2 are 0.\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,0,0\\],\\[0,1,0\\],\\[0,0,1\\]\\]\n**Output:** 3\n**Explanation:** (0, 0), (1, 1) and (2, 2) are special positions."
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 100`\n*   `mat[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,0,0],[0,0,1],[1,0,0]]",
                "output": "1"
            },
            {
                "input": "[[1,0,0],[0,1,0],[0,0,1]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass BrowserHistory {\n    int currentIndex;\n    List<String> history;\n\n    public BrowserHistory(String homepage) {\n        this.currentIndex = 0;\n        this.history = new ArrayList<>();\n        history.add(homepage);\n    }\n\n    public void visit(String url) {\n        while (history.size() > currentIndex + 1) {\n            history.remove(history.size()-1);\n        }\n        history.add(url);\n        currentIndex++;\n    }\n\n    public String back(int steps) {\n        currentIndex -= Math.min(steps, currentIndex);\n        return history.get(currentIndex);\n    }\n\n    public String forward(int steps) {\n        currentIndex += Math.min(steps, history.size() - 1 - currentIndex);\n        return history.get(currentIndex);\n    }\n}\n```\n\n    \n    We have a BrowserHistory class which will keep track of visited urls as well as the current index of the history. \n\nWhenever the object of the class is instantiated, we pass the homepage and store it in the history (array, list or vector) at 0 index.\n\nFor \"visit(url)\" function:\n- We will first resize the history (if needed) so that all the urls after the current index are removed, as whenever we visit a new URL, the forward history should be cleared. After that, we will append the new url and increment the current index.\n\nFor the \"back(steps)\" function:\n- We move the current index by the minimum of `steps` and the current index which ensures that the current index never goes below 0. And then, the function returns the URL at the updated index.\n\nFor the \"forward(steps)\" function:\n- We move the current index by the minimum of `steps` and the difference between the size of history and current index-1 (to ensure it doesn't exceed the index range). And then, return the URL at the updated index.\n    ",
        "python": "\n    ```python\nclass BrowserHistory:\n\n    def __init__(self, homepage: str):\n        self.history = [homepage]\n        self.current_index = 0\n\n    def visit(self, url: str):\n        self.history = self.history[:self.current_index + 1]\n        self.history.append(url)\n        self.current_index += 1\n\n    def back(self, steps: int) -> str:\n        self.current_index -= min(steps, self.current_index)\n        return self.history[self.current_index]\n\n    def forward(self, steps:int) -> str:\n        self.current_index += min(steps, len(self.history) - 1 - self.current_index)\n        return self.history[self.current_index]\n```\n\n    \n    We have a BrowserHistory class which will keep track of visited urls as well as the current index of the history. \n\nWhenever the object of the class is instantiated, we pass the homepage and store it in the history (array, list or vector) at 0 index.\n\nFor \"visit(url)\" function:\n- We will first resize the history (if needed) so that all the urls after the current index are removed, as whenever we visit a new URL, the forward history should be cleared. After that, we will append the new url and increment the current index.\n\nFor the \"back(steps)\" function:\n- We move the current index by the minimum of `steps` and the current index which ensures that the current index never goes below 0. And then, the function returns the URL at the updated index.\n\nFor the \"forward(steps)\" function:\n- We move the current index by the minimum of `steps` and the difference between the size of history and current index-1 (to ensure it doesn't exceed the index range). And then, return the URL at the updated index.\n    ",
        "c++": "\n    ```cpp\nclass BrowserHistory {\npublic:\n    int currentIndex;\n    vector<string> history;\n\n    BrowserHistory(string homepage) {\n        history.push_back(homepage);\n        currentIndex = 0;\n    }\n\n    void visit(string url) {\n        history.resize(currentIndex + 1);\n        history.push_back(url);\n        currentIndex++;\n    }\n\n    string back(int steps) {\n        currentIndex -= min(steps, currentIndex);\n        return history[currentIndex];\n    }\n\n    string forward(int steps) {\n        currentIndex += min(steps, (int)(history.size() - 1 - currentIndex));\n        return history[currentIndex];\n    }\n};\n```\n\n    \n    We have a BrowserHistory class which will keep track of visited urls as well as the current index of the history. \n\nWhenever the object of the class is instantiated, we pass the homepage and store it in the history (array, list or vector) at 0 index.\n\nFor \"visit(url)\" function:\n- We will first resize the history (if needed) so that all the urls after the current index are removed, as whenever we visit a new URL, the forward history should be cleared. After that, we will append the new url and increment the current index.\n\nFor the \"back(steps)\" function:\n- We move the current index by the minimum of `steps` and the current index which ensures that the current index never goes below 0. And then, the function returns the URL at the updated index.\n\nFor the \"forward(steps)\" function:\n- We move the current index by the minimum of `steps` and the difference between the size of history and current index-1 (to ensure it doesn't exceed the index range). And then, return the URL at the updated index.\n    ",
        "js": "\n    ```javascript\nclass BrowserHistory {\n    constructor(homepage) {\n        this.history = [homepage];\n        this.currentIndex = 0;\n    }\n\n    visit(url) {\n        this.history = this.history.slice(0, this.currentIndex + 1);\n        this.history.push(url);\n        this.currentIndex++;\n    }\n\n    back(steps) {\n        this.currentIndex -= Math.min(steps, this.currentIndex);\n        return this.history[this.currentIndex];\n    }\n\n    forward(steps) {\n        this.currentIndex += Math.min(steps, this.history.length - 1 - this.currentIndex);\n        return this.history[this.currentIndex];\n    }\n}\n```\n    \n    We have a BrowserHistory class which will keep track of visited urls as well as the current index of the history. \n\nWhenever the object of the class is instantiated, we pass the homepage and store it in the history (array, list or vector) at 0 index.\n\nFor \"visit(url)\" function:\n- We will first resize the history (if needed) so that all the urls after the current index are removed, as whenever we visit a new URL, the forward history should be cleared. After that, we will append the new url and increment the current index.\n\nFor the \"back(steps)\" function:\n- We move the current index by the minimum of `steps` and the current index which ensures that the current index never goes below 0. And then, the function returns the URL at the updated index.\n\nFor the \"forward(steps)\" function:\n- We move the current index by the minimum of `steps` and the difference between the size of history and current index-1 (to ensure it doesn't exceed the index range). And then, return the URL at the updated index.\n    "
    },
    {
        "id": 286,
        "title": "Sum of All Odd Length Subarrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of positive integers `arr`, return _the sum of all possible **odd-length subarrays** of_ `arr`.\n\nA **subarray** is a contiguous subsequence of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,4,2,5,3\\]\n**Output:** 58\n**Explanation:** The odd-length subarrays of arr and their sums are:\n\\[1\\] = 1\n\\[4\\] = 4\n\\[2\\] = 2\n\\[5\\] = 5\n\\[3\\] = 3\n\\[1,4,2\\] = 7\n\\[4,2,5\\] = 11\n\\[2,5,3\\] = 10\n\\[1,4,2,5,3\\] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2\\]\n**Output:** 3\n**Explanation:** There are only 2 subarrays of odd length, \\[1\\] and \\[2\\]. Their sum is 3.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[10,11,12\\]\n**Output:** 66"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 100`\n*   `1 <= arr[i] <= 1000`\n\n**",
            "follow_up": "Follow up:**\n\nCould you solve this problem in O(n) time complexity?"
        },
        "tag": [
            "Array",
            "Math",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,4,2,5,3]",
                "output": "58"
            },
            {
                "input": "[1,2]",
                "output": "3"
            },
            {
                "input": "[10,11,12]",
                "output": "66"
            }
        ],
        "java": "\n    ```java\npublic int sumOddLengthSubarrays(int[] arr) {\n    int sum = 0, n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int oddSubarrays = ((i + 1) * (n - i) + 1) / 2;\n        sum += arr[i] * oddSubarrays;\n    }\n    return sum;\n}\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef sumOddLengthSubarrays(arr):\n    sum = 0\n    n = len(arr)\n    for i in range(n):\n        oddSubarrays = ((i + 1) * (n - i) + 1) // 2\n        sum += arr[i] * oddSubarrays\n    return sum\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint sumOddLengthSubarrays(vector<int>& arr) {\n    int sum = 0, n = arr.size();\n    for (int i = 0; i < n; i++) {\n        int oddSubarrays = ((i + 1) * (n - i) + 1) / 2;\n        sum += arr[i] * oddSubarrays;\n    }\n    return sum;\n}\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction sumOddLengthSubarrays(arr) {\n    let sum = 0, n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let oddSubarrays = Math.floor(((i + 1) * (n - i) + 1) / 2);\n        sum += arr[i] * oddSubarrays;\n    }\n    return sum;\n}\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    "
    },
    {
        "id": 287,
        "title": "Rearrange Spaces Between Words",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `text` of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that `text` **contains at least one word**.\n\nRearrange the spaces so that there is an **equal** number of spaces between every pair of adjacent words and that number is **maximized**. If you cannot redistribute all the spaces equally, place the **extra spaces at the end**, meaning the returned string should be the same length as `text`.\n\nReturn _the string after rearranging the spaces_.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"  this   is  a sentence  \"\n**Output:**  \"this   is   a   sentence \"\n**Explanation:** There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.\n\n",
                "**Example 2:**\n\n**Input:** text =  \" practice   makes   perfect \"\n**Output:**  \"practice   makes   perfect  \"\n**Explanation:** There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 100`\n*   `text` consists of lowercase English letters and `' '`.\n*   `text` contains at least one word.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"thisisasentence\"",
                "output": "\"thisisasentence\""
            },
            {
                "input": "\"practicemakesperfect\"",
                "output": "\"practicemakesperfect\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String reorderSpaces(String text) {\n    int spaces = 0, words = 0;\n\n    for (char c : text.toCharArray()) {\n        if (c == ' ') spaces++;\n    }\n    \n    String[] splitText = text.trim().split(\"\\\\s+\");\n    List<String> wordList = new ArrayList<>();\n    for (String word : splitText) {\n        wordList.add(word);\n        words++;\n    }\n    \n    int spacesBetweenWords = words == 1 ? 0 : spaces / (words - 1);\n    int extraSpaces = words == 1 ? spaces : spaces % (words - 1);\n    \n    StringBuilder result = new StringBuilder();\n\n    for (int i = 0; i < words; i++) {\n        result.append(wordList.get(i));\n        if (i != words - 1) {\n            result.append(\" \".repeat(spacesBetweenWords));\n        } else {\n            result.append(\" \".repeat(extraSpaces));\n        }\n    }\n    \n    return result.toString();\n}\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    ",
        "python": "\n    ```python\ndef reorderSpaces(text):\n    spaces = text.count(' ')\n    words = text.split()\n    num_words = len(words)\n    \n    if num_words == 1:\n        spaces_between_words = 0\n    else:\n        spaces_between_words = spaces // (num_words - 1)\n    \n    extra_spaces = spaces - spaces_between_words * (num_words - 1)\n\n    return (' ' * spaces_between_words).join(words) + ' ' * extra_spaces\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string reorderSpaces(std::string text) {\n    int spaces = 0, words = 0;\n\n    for (char c : text) {\n        if (c == ' ') spaces++;\n    }\n    \n    std::istringstream iss(text);\n    std::vector<std::string> wordList;\n    std::string word;\n\n    while (iss >> word) {\n        wordList.push_back(word);\n        words++;\n    }\n    \n    int spacesBetweenWords = words == 1 ? 0 : spaces / (words - 1);\n    int extraSpaces = words == 1 ? spaces : spaces % (words - 1);\n    \n    std::string result;\n\n    for (int i = 0; i < words; i++) {\n        result += wordList[i];\n        if (i != words - 1) {\n            result.append(spacesBetweenWords, ' ');\n        } else {\n            result.append(extraSpaces, ' ');\n        }\n    }\n    \n    return result;\n}\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    ",
        "js": "\n    ```javascript\nfunction reorderSpaces(text) {\n    const spaces = text.split(' ').length - 1;\n    const words = text.trim().split(/\\s+/);\n    const numWords = words.length;\n    \n    const spacesBetweenWords = numWords === 1 ? 0 : Math.floor(spaces / (numWords - 1));\n    const extraSpaces = spaces - spacesBetweenWords * (numWords - 1);\n    \n    return words.join(' '.repeat(spacesBetweenWords)) + ' '.repeat(extraSpaces);\n}\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    "
    },
    {
        "id": 288,
        "title": "Crawler Log Folder",
        "difficulty": "Easy",
        "content": {
            "problem": "The Leetcode file system keeps a log each time some user performs a _change folder_ operation.\n\nThe operations are described below:\n\n*   `\"../ \"` : Move to the parent folder of the current folder. (If you are already in the main folder, **remain in the same folder**).\n*   `\"./ \"` : Remain in the same folder.\n*   `\"x/ \"` : Move to the child folder named `x` (This folder is **guaranteed to always exist**).\n\nYou are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step.\n\nThe file system starts in the main folder, then the operations in `logs` are performed.\n\nReturn _the minimum number of operations needed to go back to the main folder after the change folder operations._",
            "examples": [
                "**Example 1:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"../ \", \"d21/ \", \"./ \"\\]\n**Output:** 2\n**Explanation:** Use this change folder operation  \"../ \" 2 times and go back to the main folder.\n\n",
                "**Example 2:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"./ \", \"d3/ \", \"../ \", \"d31/ \"\\]\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** logs = \\[ \"d1/ \", \"../ \", \"../ \", \"../ \"\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= logs.length <= 103`\n*   `2 <= logs[i].length <= 10`\n*   `logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`.\n*   `logs[i]` follows the format described in the statement.\n*   Folder names consist of lowercase English letters and digits.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "[\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]",
                "output": "2"
            },
            {
                "input": "[\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]",
                "output": "3"
            },
            {
                "input": "[\"d1/\",\"../\",\"../\",\"../\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(String[] logs) {\n    int depth = 0;\n    for (String log : logs) {\n        if (log.equals(\"../\")) {\n            depth = Math.max(0, depth - 1);\n        } else if (!log.equals(\"./\")) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    ",
        "python": "\n    ```python\ndef minOperations(logs):\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            depth = max(0, depth - 1)\n        elif log != \"./\":\n            depth += 1\n    return depth\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<string>& logs) {\n    int depth = 0;\n    for (const string& log : logs) {\n        if (log == \"../\") {\n            depth = max(0, depth - 1);\n        } else if (log != \"./\") {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(logs) {\n    let depth = 0;\n    for (const log of logs) {\n        if (log === \"../\") {\n            depth = Math.max(0, depth - 1);\n        } else if (log !== \"./\") {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    "
    },
    {
        "id": 289,
        "title": "Design Parking System",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\n\nImplement the `ParkingSystem` class:\n\n*   `ParkingSystem(int big, int medium, int small)` Initializes object of the `ParkingSystem` class. The number of slots for each parking space are given as part of the constructor.\n*   `bool addCar(int carType)` Checks whether there is a parking space of `carType` for the car that wants to get into the parking lot. `carType` can be of three kinds: big, medium, or small, which are represented by `1`, `2`, and `3` respectively. **A car can only park in a parking space of its** `carType`. If there is no space available, return `false`, else park the car in that size space and return `true`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"ParkingSystem \",  \"addCar \",  \"addCar \",  \"addCar \",  \"addCar \"\\]\n\\[\\[1, 1, 0\\], \\[1\\], \\[2\\], \\[3\\], \\[1\\]\\]\n**Output**\n\\[null, true, true, false, false\\]\n\n**Explanation**\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= big, medium, small <= 1000`\n*   `carType` is `1`, `2`, or `3`\n*   At most `1000` calls will be made to `addCar`",
            "follow_up": null
        },
        "tag": [
            "Design",
            "Simulation",
            "Counting"
        ],
        "example": [
            {
                "input": "]\n],],],],]]",
                "output": "**Output**\n[null,true,true,false,false]"
            }
        ],
        "java": "\n    ```java\npublic int[] runningSum(int[] nums) {\n    for (int i = 1; i < nums.length; i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The algorithm iterates over the input array starting from the second element (i = 1). In each iteration, it adds the (i-1)-th element to the i-th element of the array (nums[i] += nums[i-1]).\n\nThis operation computes the running sum of the array by essentially summing up every previous element with the current element. This is an in-place operation, and the modified input array is returned as output.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array, as the loop iterates once over each of the n elements in the array. The space complexity is O(1), since it only modifies the input array in-place and requires no additional memory.\n    ",
        "python": "\n    ```python\ndef runningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    return nums\n```\n    \n    The algorithm iterates over the input array starting from the second element (i = 1). In each iteration, it adds the (i-1)-th element to the i-th element of the array (nums[i] += nums[i-1]).\n\nThis operation computes the running sum of the array by essentially summing up every previous element with the current element. This is an in-place operation, and the modified input array is returned as output.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array, as the loop iterates once over each of the n elements in the array. The space complexity is O(1), since it only modifies the input array in-place and requires no additional memory.\n    ",
        "c++": "\n    ```cpp\nvector<int> runningSum(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The algorithm iterates over the input array starting from the second element (i = 1). In each iteration, it adds the (i-1)-th element to the i-th element of the array (nums[i] += nums[i-1]).\n\nThis operation computes the running sum of the array by essentially summing up every previous element with the current element. This is an in-place operation, and the modified input array is returned as output.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array, as the loop iterates once over each of the n elements in the array. The space complexity is O(1), since it only modifies the input array in-place and requires no additional memory.\n    ",
        "js": "\n    ```javascript\nfunction runningSum(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The algorithm iterates over the input array starting from the second element (i = 1). In each iteration, it adds the (i-1)-th element to the i-th element of the array (nums[i] += nums[i-1]).\n\nThis operation computes the running sum of the array by essentially summing up every previous element with the current element. This is an in-place operation, and the modified input array is returned as output.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array, as the loop iterates once over each of the n elements in the array. The space complexity is O(1), since it only modifies the input array in-place and requires no additional memory.\n    "
    },
    {
        "id": 290,
        "title": "Special Array With X Elements Greater Than or Equal X",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `nums` of non-negative integers. `nums` is considered **special** if there exists a number `x` such that there are **exactly** `x` numbers in `nums` that are **greater than or equal to** `x`.\n\nNotice that `x` **does not** have to be an element in `nums`.\n\nReturn `x` _if the array is **special**, otherwise, return_ `-1`. It can be proven that if `nums` is special, the value for `x` is **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,5\\]\n**Output:** 2\n**Explanation:** There are 2 values (3 and 5) that are greater than or equal to 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0\\]\n**Output:** -1\n**Explanation:** No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,4,3,0,4\\]\n**Output:** 3\n**Explanation:** There are 3 values that are greater than or equal to 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,5]",
                "output": "2"
            },
            {
                "input": "[0,0]",
                "output": "-1"
            },
            {
                "input": "[0,4,3,0,4]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int specialArray(int[] nums) {\n    int max_val = Arrays.stream(nums).max().orElse(0);\n    for (int x = 1; x <= max_val; ++x) {\n        int count = 0;\n        for (int num : nums) {\n            if (num >= x) count++;\n        }\n        if (count == x) return x;\n    }\n    return -1;\n}\n```\n    \n    1. Find the maximum value in the input array `nums`.\n2. Iterate through the range `[1, max_val]` (both inclusive) and for each value of `x`, count the elements greater than or equal to `x` in the input array.\n3. If the count of such elements is equal to `x`, return `x`.\n4. If no such `x` is found, return `-1`.\n    ",
        "python": "\n    ```python\ndef specialArray(nums):\n    max_val = max(nums)\n    for x in range(1, max_val + 1):\n        count = sum([1 for num in nums if num >= x])\n        if count == x:\n            return x\n    return -1\n```\n    \n    1. Find the maximum value in the input array `nums`.\n2. Iterate through the range `[1, max_val]` (both inclusive) and for each value of `x`, count the elements greater than or equal to `x` in the input array.\n3. If the count of such elements is equal to `x`, return `x`.\n4. If no such `x` is found, return `-1`.\n    ",
        "c++": "\n    ```cpp\nint specialArray(vector<int>& nums) {\n    int max_val = *max_element(nums.begin(), nums.end());\n    for (int x = 1; x <= max_val; ++x) {\n        int count = 0;\n        for (int num : nums) {\n            if (num >= x) count++;\n        }\n        if (count == x) return x;\n    }\n    return -1;\n}\n```\n    \n    1. Find the maximum value in the input array `nums`.\n2. Iterate through the range `[1, max_val]` (both inclusive) and for each value of `x`, count the elements greater than or equal to `x` in the input array.\n3. If the count of such elements is equal to `x`, return `x`.\n4. If no such `x` is found, return `-1`.\n    ",
        "js": "\n    ```javascript\nfunction specialArray(nums) {\n    let max_val = Math.max(...nums);\n    for (let x = 1; x <= max_val; ++x) {\n        let count = 0;\n        for (let num of nums) {\n            if (num >= x) count++;\n        }\n        if (count === x) return x;\n    }\n    return -1;\n}\n```\n    \n    1. Find the maximum value in the input array `nums`.\n2. Iterate through the range `[1, max_val]` (both inclusive) and for each value of `x`, count the elements greater than or equal to `x` in the input array.\n3. If the count of such elements is equal to `x`, return `x`.\n4. If no such `x` is found, return `-1`.\n    "
    },
    {
        "id": 291,
        "title": "Maximum Nesting Depth of the Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "A string is a **valid parentheses string** (denoted **VPS**) if it meets one of the following:\n\n*   It is an empty string `\" \"`, or a single character not equal to `\"( \"` or `\") \"`,\n*   It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are **VPS**'s, or\n*   It can be written as `(A)`, where `A` is a **VPS**.\n\nWe can similarly define the **nesting depth** `depth(S)` of any VPS `S` as follows:\n\n*   `depth( \" \") = 0`\n*   `depth(C) = 0`, where `C` is a string with a single character not equal to `\"( \"` or `\") \"`.\n*   `depth(A + B) = max(depth(A), depth(B))`, where `A` and `B` are **VPS**'s.\n*   `depth( \"( \" + A + \") \") = 1 + depth(A)`, where `A` is a **VPS**.\n\nFor example, `\" \"`, `\"()() \"`, and `\"()(()()) \"` are **VPS**'s (with nesting depths 0, 1, and 2), and `\")( \"` and `\"(() \"` are not **VPS**'s.\n\nGiven a **VPS** represented as string `s`, return _the **nesting depth** of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(1+(2\\*3)+((8)/4))+1 \"\n**Output:** 3\n**Explanation:** Digit 8 is inside of 3 nested parentheses in the string.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"(1)+((2))+(((3))) \"\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of digits `0-9` and characters `'+'`, `'-'`, `'*'`, `'/'`, `'('`, and `')'`.\n*   It is guaranteed that parentheses expression `s` is a **VPS**.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"(1+(2*3)+((8)/4))+1\"",
                "output": "3"
            },
            {
                "input": "\"(1)+((2))+(((3)))\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int maxDepth(String s) {\n    int depth = 0, maxDepth = 0;\n\n    for (char c : s.toCharArray()) {\n        if (c == '(') {\n            depth++;\n            maxDepth = Math.max(depth, maxDepth);\n        } else if (c == ')') {\n            depth--;\n        }\n    }\n\n    return maxDepth;\n}\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    ",
        "python": "\n    ```python\ndef maxDepth(s: str) -> int:\n    depth = 0\n    max_depth = 0\n\n    for c in s:\n        if c == '(':\n            depth += 1\n            max_depth = max(depth, max_depth)\n        elif c == ')':\n            depth -= 1\n\n    return max_depth\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    ",
        "c++": "\n    ```cpp\nint maxDepth(std::string s) {\n    int depth = 0, max_depth = 0;\n\n    for (char c : s) {\n        if (c == '(') {\n            depth++;\n            max_depth = std::max(depth, max_depth);\n        } else if (c == ')') {\n            depth--;\n        }\n    }\n\n    return max_depth;\n}\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    ",
        "js": "\n    ```javascript\nfunction maxDepth(s) {\n    let depth = 0, maxDepth = 0;\n\n    for (const c of s) {\n        if (c === '(') {\n            depth++;\n            maxDepth = Math.max(depth, maxDepth);\n        } else if (c === ')') {\n            depth--;\n        }\n    }\n\n    return maxDepth;\n}\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    "
    },
    {
        "id": 292,
        "title": "Mean of Array After Removing Some Elements",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `arr`, return _the mean of the remaining integers after removing the smallest `5%` and the largest `5%` of the elements._\n\nAnswers within `10-5` of the **actual answer** will be considered accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3\\]\n**Output:** 2.00000\n**Explanation:** After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0\\]\n**Output:** 4.00000\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4\\]\n**Output:** 4.77778"
            ],
            "constraints": "**Constraints:**\n\n*   `20 <= arr.length <= 1000`\n*   `arr.length` **is a multiple** of `20`.\n*   `0 <= arr[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]",
                "output": "2.00000"
            },
            {
                "input": "[6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]",
                "output": "4.00000"
            },
            {
                "input": "[6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]",
                "output": "4.77778"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic boolean isPathCrossing(String path) {\n    Set<String> visited = new HashSet<>();\n    int x = 0, y = 0;\n    visited.add(x + \",\" + y);\n    for (char dir : path.toCharArray()) {\n        if (dir == 'N') y++;\n        else if (dir == 'S') y--;\n        else if (dir == 'E') x++;\n        else if (dir == 'W') x--;\n        String location = x + \",\" + y;\n        if (visited.contains(location)) return true;\n        visited.add(location);\n    }\n    return false;\n}\n```\n    \n    1. Initialize a visited set including the starting location (0,0).\n2. Iterate through each character in the `path`.\n3. Update the coordinates (x, y) as per the direction.\n4. Check if the updated location is already in the visited set, then return true.\n5. Add the updated location to the visited set.\n6. After iterating through the entire path return false if no crossing has occurred.\n    ",
        "python": "\n    ```python\ndef is_path_crossing(path: str) -> bool:\n    visited = {(0, 0)}\n    x, y = 0, 0\n    for dir in path:\n        if dir == 'N': y += 1\n        elif dir == 'S': y -= 1\n        elif dir == 'E': x += 1\n        elif dir == 'W': x -= 1\n        if (x, y) in visited: return True\n        visited.add((x, y))\n    return False\n```\n    \n    1. Initialize a visited set including the starting location (0,0).\n2. Iterate through each character in the `path`.\n3. Update the coordinates (x, y) as per the direction.\n4. Check if the updated location is already in the visited set, then return true.\n5. Add the updated location to the visited set.\n6. After iterating through the entire path return false if no crossing has occurred.\n    ",
        "c++": "\n    ```cpp\nbool isPathCrossing(string path) {\n    set<pair<int, int>> visited;\n    int x = 0, y = 0;\n    visited.insert({x, y});\n    for (char dir : path) {\n        if (dir == 'N') y++;\n        else if (dir == 'S') y--;\n        else if (dir == 'E') x++;\n        else if (dir == 'W') x--;\n        if (visited.count({x, y})) return true;\n        visited.insert({x, y});\n    }\n    return false;\n}\n```\n    \n    1. Initialize a visited set including the starting location (0,0).\n2. Iterate through each character in the `path`.\n3. Update the coordinates (x, y) as per the direction.\n4. Check if the updated location is already in the visited set, then return true.\n5. Add the updated location to the visited set.\n6. After iterating through the entire path return false if no crossing has occurred.\n    ",
        "js": "\n    ```javascript\nfunction isPathCrossing(path) {\n    const visited = new Set(['0,0']);\n    let x = 0, y = 0;\n    for (const dir of path) {\n        if (dir === 'N') y++;\n        else if (dir === 'S') y--;\n        else if (dir === 'E') x++;\n        else if (dir === 'W') x--;\n        const location = `${x},${y}`;\n        if (visited.has(location)) return true;\n        visited.add(location);\n    }\n    return false;\n}\n```\n    \n    1. Initialize a visited set including the starting location (0,0).\n2. Iterate through each character in the `path`.\n3. Update the coordinates (x, y) as per the direction.\n4. Check if the updated location is already in the visited set, then return true.\n5. Add the updated location to the visited set.\n6. After iterating through the entire path return false if no crossing has occurred.\n    "
    },
    {
        "id": 293,
        "title": "Largest Substring Between Two Equal Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest substring between two equal characters, excluding the two characters._ If there is no such substring return `-1`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \"\n**Output:** 0\n**Explanation:** The optimal substring here is an empty substring between the two `'a's`.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abca \"\n**Output:** 2\n**Explanation:** The optimal substring here is  \"bc \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"cbzxy \"\n**Output:** -1\n**Explanation:** There are no characters that appear twice in s."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `s` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"aa\"",
                "output": "0"
            },
            {
                "input": "\"abca\"",
                "output": "2"
            },
            {
                "input": "\"cbzxy\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int maxLengthBetweenEqualCharacters(String s) {\n    int result = -1;\n    HashMap<Character, Integer> char_map = new HashMap<>();\n\n    for (int i = 0; i < s.length(); ++i) {\n        if (!char_map.containsKey(s.charAt(i))) {\n            char_map.put(s.charAt(i), i);\n        } else {\n            result = Math.max(result, i - char_map.get(s.charAt(i)) - 1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "python": "\n    ```python\ndef maxLengthBetweenEqualCharacters(s: str) -> int:\n    result = -1\n    char_map = {}\n\n    for i, c in enumerate(s):\n        if c not in char_map:\n            char_map[c] = i\n        else:\n            result = max(result, i - char_map[c] - 1)\n\n    return result\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "c++": "\n    ```cpp\nint maxLengthBetweenEqualCharacters(std::string s) {\n    int result = -1;\n    std::unordered_map<char, int> char_map;\n\n    for (int i = 0; i < s.length(); ++i) {\n        if (char_map.find(s[i]) == char_map.end()) {\n            char_map[s[i]] = i;\n        } else {\n            result = std::max(result, i - char_map[s[i]] - 1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "js": "\n    ```javascript\nfunction maxLengthBetweenEqualCharacters(s) {\n    let result = -1;\n    let char_map = {};\n\n    for (let i = 0; i < s.length; ++i) {\n        let c = s.charAt(i);\n        if (!char_map.hasOwnProperty(c)) {\n            char_map[c] = i;\n        } else {\n            result = Math.max(result, i - char_map[c] - 1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    "
    },
    {
        "id": 294,
        "title": "Slowest Key",
        "difficulty": "Easy",
        "content": {
            "problem": "A newly designed keypad was tested, where a tester pressed a sequence of `n` keys, one at a time.\n\nYou are given a string `keysPressed` of length `n`, where `keysPressed[i]` was the `ith` key pressed in the testing sequence, and a sorted list `releaseTimes`, where `releaseTimes[i]` was the time the `ith` key was released. Both arrays are **0-indexed**. The `0th` key was pressed at the time `0`, and every subsequent key was pressed at the **exact** time the previous key was released.\n\nThe tester wants to know the key of the keypress that had the **longest duration**. The `ith` keypress had a **duration** of `releaseTimes[i] - releaseTimes[i - 1]`, and the `0th` keypress had a duration of `releaseTimes[0]`.\n\nNote that the same key could have been pressed multiple times during the test, and these multiple presses of the same key **may not** have had the same **duration**.\n\n_Return the key of the keypress that had the **longest duration**. If there are multiple such keypresses, return the lexicographically largest key of the keypresses._",
            "examples": [
                "**Example 1:**\n\n**Input:** releaseTimes = \\[9,29,49,50\\], keysPressed =  \"cbcd \"\n**Output:**  \"c \"\n**Explanation:** The keypresses were as follows:\nKeypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).\nKeypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\nKeypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\nKeypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\nThe longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.\n'c' is lexicographically larger than 'b', so the answer is 'c'.\n\n",
                "**Example 2:**\n\n**Input:** releaseTimes = \\[12,23,36,46,62\\], keysPressed =  \"spuda \"\n**Output:**  \"a \"\n**Explanation:** The keypresses were as follows:\nKeypress for 's' had a duration of 12.\nKeypress for 'p' had a duration of 23 - 12 = 11.\nKeypress for 'u' had a duration of 36 - 23 = 13.\nKeypress for 'd' had a duration of 46 - 36 = 10.\nKeypress for 'a' had a duration of 62 - 46 = 16.\nThe longest of these was the keypress for 'a' with duration 16."
            ],
            "constraints": "**Constraints:**\n\n*   `releaseTimes.length == n`\n*   `keysPressed.length == n`\n*   `2 <= n <= 1000`\n*   `1 <= releaseTimes[i] <= 109`\n*   `releaseTimes[i] < releaseTimes[i+1]`\n*   `keysPressed` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[9,29,49,50],\"cbcd\"",
                "output": "\"c\""
            },
            {
                "input": "[12,23,36,46,62],\"spuda\"",
                "output": "\"a\""
            }
        ],
        "java": "\n    ```java\npublic String minInteger(String num, int k) {\n    if (k == 0) return num;\n    int n = num.length();\n    char[] arr = num.toCharArray();\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = i + 1; j < n && j - i <= k; ++j) {\n            if (arr[j] < arr[idx]) {\n                idx = j;\n            }\n        }\n        char minDigit = arr[idx];\n        for (int j = idx; j > i; --j) {\n            arr[j] = arr[j - 1];\n        }\n        arr[i] = minDigit;\n        k -= idx - i;\n    }\n    return new String(arr);\n}\n```\n    \n    1. If `k` is 0, return the input `num` directly as there's no swap operation allowed.\n2. Convert the input `num` to an array or a list in each language.\n3. Iterate through each digit of the number (outer loop).\n4. For each digit, find the minimum digit within the range allowed by `k` (inner loop).\n5. Swap the found minimum digit to the current digit position (updating the array or list by shifting digits), and update `k` value accordingly.\n6. Convert the updated array or list back to string and return.\n    ",
        "python": "\n    ```python\ndef minInteger(num: str, k: int) -> str:\n    if k == 0:\n        return num\n    num = list(num)\n    n = len(num)\n    for i in range(n):\n        idx = i\n        for j in range(i + 1, n):\n            if j - i > k:\n                break\n            if num[j] < num[idx]:\n                idx = j\n        min_digit = num[idx]\n        for j in range(idx, i, -1):\n            num[j] = num[j - 1]\n        num[i] = min_digit\n        k -= idx - i\n    return ''.join(num)\n```\n    \n    1. If `k` is 0, return the input `num` directly as there's no swap operation allowed.\n2. Convert the input `num` to an array or a list in each language.\n3. Iterate through each digit of the number (outer loop).\n4. For each digit, find the minimum digit within the range allowed by `k` (inner loop).\n5. Swap the found minimum digit to the current digit position (updating the array or list by shifting digits), and update `k` value accordingly.\n6. Convert the updated array or list back to string and return.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring minInteger(string num, int k) {\n    if (k == 0) return num;\n    int n = num.size();\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = i + 1; j < n && j - i <= k; ++j) {\n            if (num[j] < num[idx]) {\n                idx = j;\n            }\n        }\n        char minDigit = num[idx];\n        for (int j = idx; j > i; --j) {\n            num[j] = num[j - 1];\n        }\n        num[i] = minDigit;\n        k -= idx - i;\n    }\n    return num;\n}\n```\n    \n    1. If `k` is 0, return the input `num` directly as there's no swap operation allowed.\n2. Convert the input `num` to an array or a list in each language.\n3. Iterate through each digit of the number (outer loop).\n4. For each digit, find the minimum digit within the range allowed by `k` (inner loop).\n5. Swap the found minimum digit to the current digit position (updating the array or list by shifting digits), and update `k` value accordingly.\n6. Convert the updated array or list back to string and return.\n    ",
        "js": "\n    ```javascript\nfunction minInteger(num, k) {\n    if (k === 0) return num;\n    num = num.split('');\n    const n = num.length;\n    for (let i = 0; i < n; ++i) {\n        let idx = i;\n        for (let j = i + 1; j < n && j - i <= k; ++j) {\n            if (num[j] < num[idx]) {\n                idx = j;\n            }\n        }\n        const minDigit = num[idx];\n        for (let j = idx; j > i; --j) {\n            num[j] = num[j - 1];\n        }\n        num[i] = minDigit;\n        k -= idx - i;\n    }\n    return num.join('');\n}\n```\n    \n    1. If `k` is 0, return the input `num` directly as there's no swap operation allowed.\n2. Convert the input `num` to an array or a list in each language.\n3. Iterate through each digit of the number (outer loop).\n4. For each digit, find the minimum digit within the range allowed by `k` (inner loop).\n5. Swap the found minimum digit to the current digit position (updating the array or list by shifting digits), and update `k` value accordingly.\n6. Convert the updated array or list back to string and return.\n    "
    },
    {
        "id": 295,
        "title": "Sort Array by Increasing Frequency",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, sort the array in **increasing** order based on the frequency of the values. If multiple values have the same frequency, sort them in **decreasing** order.\n\nReturn the _sorted array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2,2,2,3\\]\n**Output:** \\[3,1,1,2,2,2\\]\n**Explanation:** '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,1,3,2\\]\n**Output:** \\[1,3,3,2,2\\]\n**Explanation:** '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,1,-6,4,5,-6,1,4,1\\]\n**Output:** \\[5,-1,4,4,-6,-6,1,1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `-100 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,1,2,2,2,3]",
                "output": "[3,1,1,2,2,2]"
            },
            {
                "input": "[2,3,1,3,2]",
                "output": "[1,3,3,2,2]"
            },
            {
                "input": "[-1,1,-6,4,5,-6,1,4,1]",
                "output": "[5,-1,4,4,-6,-6,1,1,1]"
            }
        ],
        "java": "\n    ```java\npublic int numSub(String s) {\n    int mod = 1000000007;\n    long result = 0;\n    int count = 0;\n    for (char c : s.toCharArray()) {\n        count = (c == '1') ? count + 1 : 0;\n        result = (result + count) % mod;\n    }\n    return (int)result;\n}\n```\n    \n    The algorithm is a single-pass algorithm that iterates over the binary string `s` and calculates the number of contiguous \"1\" substrings seen so far. We use a variable `count` to track the length of the current run of \"1\"s. For each character `c` in `s`:\n- If `c` is \"1\", we increment `count` as we have a longer run of 1's, and add the `count` to the `result`. The notion here is that until this run of 1s breaks, any new 1 being added increases the total number of substrings by the entire size of the current window.\n- If `c` is not a \"1\", we reset the `count` to 0 as the sequence is broken.\n\nFinally, we take the result modulo 10^9 + 7 and return it. \n    ",
        "python": "\n    ```python\ndef num_sub(s: str) -> int:\n    mod = 1000000007\n    result = 0\n    count = 0\n    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod\n    return result\n```\n    \n    The algorithm is a single-pass algorithm that iterates over the binary string `s` and calculates the number of contiguous \"1\" substrings seen so far. We use a variable `count` to track the length of the current run of \"1\"s. For each character `c` in `s`:\n- If `c` is \"1\", we increment `count` as we have a longer run of 1's, and add the `count` to the `result`. The notion here is that until this run of 1s breaks, any new 1 being added increases the total number of substrings by the entire size of the current window.\n- If `c` is not a \"1\", we reset the `count` to 0 as the sequence is broken.\n\nFinally, we take the result modulo 10^9 + 7 and return it. \n    ",
        "c++": "\n    ```cpp\nint numSub(string s) {\n    int mod = 1000000007;\n    long long result = 0;\n    int count = 0;\n    for (char c : s) {\n        count = (c == '1') ? count + 1 : 0;\n        result = (result + count) % mod;\n    }\n    return result;\n}\n```\n    \n    The algorithm is a single-pass algorithm that iterates over the binary string `s` and calculates the number of contiguous \"1\" substrings seen so far. We use a variable `count` to track the length of the current run of \"1\"s. For each character `c` in `s`:\n- If `c` is \"1\", we increment `count` as we have a longer run of 1's, and add the `count` to the `result`. The notion here is that until this run of 1s breaks, any new 1 being added increases the total number of substrings by the entire size of the current window.\n- If `c` is not a \"1\", we reset the `count` to 0 as the sequence is broken.\n\nFinally, we take the result modulo 10^9 + 7 and return it. \n    ",
        "js": "\n    ```javascript\nfunction numSub(s) {\n    const mod = 1000000007;\n    let result = 0;\n    let count = 0;\n    for (let c of s) {\n        count = (c === '1') ? count + 1 : 0;\n        result = (result + count) % mod;\n    }\n    return result;\n}\n```\n    \n    The algorithm is a single-pass algorithm that iterates over the binary string `s` and calculates the number of contiguous \"1\" substrings seen so far. We use a variable `count` to track the length of the current run of \"1\"s. For each character `c` in `s`:\n- If `c` is \"1\", we increment `count` as we have a longer run of 1's, and add the `count` to the `result`. The notion here is that until this run of 1s breaks, any new 1 being added increases the total number of substrings by the entire size of the current window.\n- If `c` is not a \"1\", we reset the `count` to 0 as the sequence is broken.\n\nFinally, we take the result modulo 10^9 + 7 and return it. \n    "
    },
    {
        "id": 296,
        "title": "Check Array Formation Through Concatenation",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of **distinct** integers `arr` and an array of integer arrays `pieces`, where the integers in `pieces` are **distinct**. Your goal is to form `arr` by concatenating the arrays in `pieces` **in any order**. However, you are **not** allowed to reorder the integers in each array `pieces[i]`.\n\nReturn `true` _if it is possible_ _to form the array_ `arr` _from_ `pieces`. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[15,88\\], pieces = \\[\\[88\\],\\[15\\]\\]\n**Output:** true\n**Explanation:** Concatenate \\[15\\] then \\[88\\]\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[49,18,16\\], pieces = \\[\\[16,18,49\\]\\]\n**Output:** false\n**Explanation:** Even though the numbers match, we cannot reorder pieces\\[0\\].\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[91,4,64,78\\], pieces = \\[\\[78\\],\\[4,64\\],\\[91\\]\\]\n**Output:** true\n**Explanation:** Concatenate \\[91\\] then \\[4,64\\] then \\[78\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pieces.length <= arr.length <= 100`\n*   `sum(pieces[i].length) == arr.length`\n*   `1 <= pieces[i].length <= arr.length`\n*   `1 <= arr[i], pieces[i][j] <= 100`\n*   The integers in `arr` are **distinct**.\n*   The integers in `pieces` are **distinct** (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[15,88],[[88],[15]]",
                "output": "true"
            },
            {
                "input": "[49,18,16],[[16,18,49]]",
                "output": "false"
            },
            {
                "input": "[91,4,64,78],[[78],[4,64],[91]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic boolean canFormArray(int[] arr, int[][] pieces) {\n    Map<Integer, int[]> map = new HashMap<>();\n    for (int[] piece : pieces) {\n        map.put(piece[0], piece);\n    }\n\n    int i = 0;\n    while (i < arr.length) {\n        if (!map.containsKey(arr[i])) {\n            return false;\n        }\n        int[] piece = map.get(arr[i]);\n        for (int j = 0; j < piece.length; ++j) {\n            if (piece[j] != arr[i]) {\n                return false;\n            }\n            ++i;\n        }\n    }\n    return true;\n}\n```\n\n    \n    1. First, create a hash map (or, in Python, a dictionary) to store each `piece` in `pieces`, indexed by its first element.\n2. Initialize a variable `i` to iterate through the `arr` array.\n3. Use a while loop to check each element in `arr` with the help of the hash map. If the element is not in the hash map, return `false` because it means we can't form the array.\n4. If the element is found in the hash map, get the associated piece in `pieces`.\n5. Use a nested loop (or iterator) to iterate through the elements of the found piece, comparing them with the corresponding elements in `arr`. If they don't match, return `false`. Otherwise, increment the index `i`.\n6. If we successfully iterate through the entire `arr` array, return `true`.\n    ",
        "python": "\n    ```python\ndef canFormArray(arr, pieces):\n    map = {piece[0]: piece for piece in pieces}\n\n    i = 0\n    while i < len(arr):\n        if arr[i] not in map:\n            return False\n        piece = map[arr[i]]\n        for num in piece:\n            if num != arr[i]:\n                return False\n            i += 1\n    return True\n```\n\n    \n    1. First, create a hash map (or, in Python, a dictionary) to store each `piece` in `pieces`, indexed by its first element.\n2. Initialize a variable `i` to iterate through the `arr` array.\n3. Use a while loop to check each element in `arr` with the help of the hash map. If the element is not in the hash map, return `false` because it means we can't form the array.\n4. If the element is found in the hash map, get the associated piece in `pieces`.\n5. Use a nested loop (or iterator) to iterate through the elements of the found piece, comparing them with the corresponding elements in `arr`. If they don't match, return `false`. Otherwise, increment the index `i`.\n6. If we successfully iterate through the entire `arr` array, return `true`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nbool canFormArray(std::vector<int>& arr, std::vector<std::vector<int>>& pieces) {\n    std::unordered_map<int, std::vector<int>> map;\n    for (auto& piece : pieces) {\n        map[piece[0]] = piece;\n    }\n\n    int i = 0;\n    while (i < arr.size()) {\n        if (map.find(arr[i]) == map.end()) {\n            return false;\n        }\n        std::vector<int>& piece = map[arr[i]];\n        for (int j = 0; j < piece.size(); ++j) {\n            if (piece[j] != arr[i]) {\n                return false;\n            }\n            ++i;\n        }\n    }\n    return true;\n}\n```\n\n    \n    1. First, create a hash map (or, in Python, a dictionary) to store each `piece` in `pieces`, indexed by its first element.\n2. Initialize a variable `i` to iterate through the `arr` array.\n3. Use a while loop to check each element in `arr` with the help of the hash map. If the element is not in the hash map, return `false` because it means we can't form the array.\n4. If the element is found in the hash map, get the associated piece in `pieces`.\n5. Use a nested loop (or iterator) to iterate through the elements of the found piece, comparing them with the corresponding elements in `arr`. If they don't match, return `false`. Otherwise, increment the index `i`.\n6. If we successfully iterate through the entire `arr` array, return `true`.\n    ",
        "js": "\n    ```javascript\nfunction canFormArray(arr, pieces) {\n    const map = new Map(pieces.map(piece => [piece[0], piece]));\n\n    let i = 0;\n    while (i < arr.length) {\n        if (!map.has(arr[i])) {\n            return false;\n        }\n        const piece = map.get(arr[i]);\n        for (const num of piece) {\n            if (num !== arr[i]) {\n                return false;\n            }\n            i++;\n        }\n    }\n    return true;\n}\n```\n\n    \n    1. First, create a hash map (or, in Python, a dictionary) to store each `piece` in `pieces`, indexed by its first element.\n2. Initialize a variable `i` to iterate through the `arr` array.\n3. Use a while loop to check each element in `arr` with the help of the hash map. If the element is not in the hash map, return `false` because it means we can't form the array.\n4. If the element is found in the hash map, get the associated piece in `pieces`.\n5. Use a nested loop (or iterator) to iterate through the elements of the found piece, comparing them with the corresponding elements in `arr`. If they don't match, return `false`. Otherwise, increment the index `i`.\n6. If we successfully iterate through the entire `arr` array, return `true`.\n    "
    },
    {
        "id": 297,
        "title": "Get Maximum in Generated Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `n`. A **0-indexed** integer array `nums` of length `n + 1` is generated in the following way:\n\n*   `nums[0] = 0`\n*   `nums[1] = 1`\n*   `nums[2 * i] = nums[i]` when `2 <= 2 * i <= n`\n*   `nums[2 * i + 1] = nums[i] + nums[i + 1]` when `2 <= 2 * i + 1 <= n`\n\nReturn _the **maximum** integer in the array_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7\n**Output:** 3\n**Explanation:** According to the given rules:\n  nums\\[0\\] = 0\n  nums\\[1\\] = 1\n  nums\\[(1 \\* 2) = 2\\] = nums\\[1\\] = 1\n  nums\\[(1 \\* 2) + 1 = 3\\] = nums\\[1\\] + nums\\[2\\] = 1 + 1 = 2\n  nums\\[(2 \\* 2) = 4\\] = nums\\[2\\] = 1\n  nums\\[(2 \\* 2) + 1 = 5\\] = nums\\[2\\] + nums\\[3\\] = 1 + 2 = 3\n  nums\\[(3 \\* 2) = 6\\] = nums\\[3\\] = 2\n  nums\\[(3 \\* 2) + 1 = 7\\] = nums\\[3\\] + nums\\[4\\] = 2 + 1 = 3\nHence, nums = \\[0,1,1,2,1,3,2,3\\], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** According to the given rules, nums = \\[0,1,1\\]. The maximum is max(0,1,1) = 1.\n\n",
                "**Example 3:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** According to the given rules, nums = \\[0,1,1,2\\]. The maximum is max(0,1,1,2) = 2."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "7",
                "output": "3"
            },
            {
                "input": "2",
                "output": "1"
            },
            {
                "input": "3",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int findKthPositive(int[] arr, int k) {\n    int i = 0, num = 1;\n    while (k > 0) {\n        if (i < arr.length && arr[i] == num) {\n            i++;\n        } else {\n            k--;\n        }\n        num++;\n    }\n    return num - 1;\n}\n```\n    \n    1. Initialize two pointers `i` and `num`. `i` is used to iterate through the input array `arr`, and `num` is used to check if the integer is in the array.\n2. Use a while loop that runs until `k` becomes 0. Inside the loop, we do the following:\n   - Check if the current value of `num` is in the array (i.e., if `arr[i] == num`). If it is, increment `i`. This means the current value of `num` is not a missing number.\n   - If the current value of `num` is not in the array, decrement `k`. This means we found one missing number.\n   - Increment `num`.\n3. When the loop ends, `k` becomes 0, meaning we found the kth missing number. The value of `num - 1` is the kth missing positive integer. Return this value.\n    ",
        "python": "\n    ```python\ndef findKthPositive(arr, k):\n    i, num = 0, 1\n    while k > 0:\n        if i < len(arr) and arr[i] == num:\n            i += 1\n        else:\n            k -= 1\n        num += 1\n    return num - 1\n```\n    \n    1. Initialize two pointers `i` and `num`. `i` is used to iterate through the input array `arr`, and `num` is used to check if the integer is in the array.\n2. Use a while loop that runs until `k` becomes 0. Inside the loop, we do the following:\n   - Check if the current value of `num` is in the array (i.e., if `arr[i] == num`). If it is, increment `i`. This means the current value of `num` is not a missing number.\n   - If the current value of `num` is not in the array, decrement `k`. This means we found one missing number.\n   - Increment `num`.\n3. When the loop ends, `k` becomes 0, meaning we found the kth missing number. The value of `num - 1` is the kth missing positive integer. Return this value.\n    ",
        "c++": "\n    ```cpp\nint findKthPositive(vector<int>& arr, int k) {\n    int i = 0, num = 1;\n    while (k > 0) {\n        if (i < arr.size() && arr[i] == num) {\n            i++;\n        } else {\n            k--;\n        }\n        num++;\n    }\n    return num - 1;\n}\n```\n    \n    1. Initialize two pointers `i` and `num`. `i` is used to iterate through the input array `arr`, and `num` is used to check if the integer is in the array.\n2. Use a while loop that runs until `k` becomes 0. Inside the loop, we do the following:\n   - Check if the current value of `num` is in the array (i.e., if `arr[i] == num`). If it is, increment `i`. This means the current value of `num` is not a missing number.\n   - If the current value of `num` is not in the array, decrement `k`. This means we found one missing number.\n   - Increment `num`.\n3. When the loop ends, `k` becomes 0, meaning we found the kth missing number. The value of `num - 1` is the kth missing positive integer. Return this value.\n    ",
        "js": "\n    ```javascript\nfunction findKthPositive(arr, k) {\n    let i = 0, num = 1;\n    while (k > 0) {\n        if (i < arr.length && arr[i] === num) {\n            i++;\n        } else {\n            k--;\n        }\n        num++;\n    }\n    return num - 1;\n}\n```\n    \n    1. Initialize two pointers `i` and `num`. `i` is used to iterate through the input array `arr`, and `num` is used to check if the integer is in the array.\n2. Use a while loop that runs until `k` becomes 0. Inside the loop, we do the following:\n   - Check if the current value of `num` is in the array (i.e., if `arr[i] == num`). If it is, increment `i`. This means the current value of `num` is not a missing number.\n   - If the current value of `num` is not in the array, decrement `k`. This means we found one missing number.\n   - Increment `num`.\n3. When the loop ends, `k` becomes 0, meaning we found the kth missing number. The value of `num - 1` is the kth missing positive integer. Return this value.\n    "
    },
    {
        "id": 298,
        "title": "Defuse the Bomb",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a **circular** array `code` of length of `n` and a key `k`.\n\nTo decrypt the code, you must replace every number. All the numbers are replaced **simultaneously**.\n\n*   If `k > 0`, replace the `ith` number with the sum of the **next** `k` numbers.\n*   If `k < 0`, replace the `ith` number with the sum of the **previous** `k` numbers.\n*   If `k == 0`, replace the `ith` number with `0`.\n\nAs `code` is circular, the next element of `code[n-1]` is `code[0]`, and the previous element of `code[0]` is `code[n-1]`.\n\nGiven the **circular** array `code` and an integer key `k`, return _the decrypted code to defuse the bomb_!",
            "examples": [
                "**Example 1:**\n\n**Input:** code = \\[5,7,1,4\\], k = 3\n**Output:** \\[12,10,16,13\\]\n**Explanation:** Each number is replaced by the sum of the next 3 numbers. The decrypted code is \\[7+1+4, 1+4+5, 4+5+7, 5+7+1\\]. Notice that the numbers wrap around.\n\n",
                "**Example 2:**\n\n**Input:** code = \\[1,2,3,4\\], k = 0\n**Output:** \\[0,0,0,0\\]\n**Explanation:** When k is zero, the numbers are replaced by 0. \n\n",
                "**Example 3:**\n\n**Input:** code = \\[2,4,9,3\\], k = -2\n**Output:** \\[12,5,6,13\\]\n**Explanation:** The decrypted code is \\[3+9, 2+3, 4+2, 9+4\\]. Notice that the numbers wrap around again. If k is negative, the sum is of the **previous** numbers."
            ],
            "constraints": "**Constraints:**\n\n*   `n == code.length`\n*   `1 <= n <= 100`\n*   `1 <= code[i] <= 100`\n*   `-(n - 1) <= k <= n - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[5,7,1,4],3",
                "output": "[12,10,16,13]"
            },
            {
                "input": "[1,2,3,4],0",
                "output": "[0,0,0,0]"
            },
            {
                "input": "[2,4,9,3],-2",
                "output": "[12,5,6,13]"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(String target) {\n    int operations = 0;\n    char current_bit = '0';\n    for (char bit : target.toCharArray()) {\n        if (bit != current_bit) {\n            operations++;\n            current_bit = bit;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the target binary string, keeping track of the current bit. Whenever it encounters a bit in the target string that is different from the current one, it increments the operation counter and updates the current bit. By following this approach, we ensure that we only need to flip bits when necessary, resulting in the minimum number of operations.\n    ",
        "python": "\n    ```python\ndef minOperations(target: str) -> int:\n    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations\n```\n    \n    The algorithm iterates through the target binary string, keeping track of the current bit. Whenever it encounters a bit in the target string that is different from the current one, it increments the operation counter and updates the current bit. By following this approach, we ensure that we only need to flip bits when necessary, resulting in the minimum number of operations.\n    ",
        "c++": "\n    ```cpp\nint minOperations(string target) {\n    int operations = 0;\n    char current_bit = '0';\n    for (char bit : target) {\n        if (bit != current_bit) {\n            operations++;\n            current_bit = bit;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the target binary string, keeping track of the current bit. Whenever it encounters a bit in the target string that is different from the current one, it increments the operation counter and updates the current bit. By following this approach, we ensure that we only need to flip bits when necessary, resulting in the minimum number of operations.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(target) {\n    let operations = 0;\n    let current_bit = '0';\n    for (let bit of target) {\n        if (bit !== current_bit) {\n            operations++;\n            current_bit = bit;\n        }\n    }\n    return operations;\n}\n```\n\n    \n    The algorithm iterates through the target binary string, keeping track of the current bit. Whenever it encounters a bit in the target string that is different from the current one, it increments the operation counter and updates the current bit. By following this approach, we ensure that we only need to flip bits when necessary, resulting in the minimum number of operations.\n    "
    },
    {
        "id": 299,
        "title": "Design an Ordered Stream",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a stream of `n` `(idKey, value)` pairs arriving in an **arbitrary** order, where `idKey` is an integer between `1` and `n` and `value` is a string. No two pairs have the same `id`.\n\nDesign a stream that returns the values in **increasing order of their IDs** by returning a **chunk** (list) of values after each insertion. The concatenation of all the **chunks** should result in a list of the sorted values.\n\nImplement the `OrderedStream` class:\n\n*   `OrderedStream(int n)` Constructs the stream to take `n` values.\n*   `String[] insert(int idKey, String value)` Inserts the pair `(idKey, value)` into the stream, then returns the **largest possible chunk** of currently inserted values that appear next in the order.",
            "examples": [
                "**Example:**\n\n**Input**\n\\[ \"OrderedStream \",  \"insert \",  \"insert \",  \"insert \",  \"insert \",  \"insert \"\\]\n\\[\\[5\\], \\[3,  \"ccccc \"\\], \\[1,  \"aaaaa \"\\], \\[2,  \"bbbbb \"\\], \\[5,  \"eeeee \"\\], \\[4,  \"ddddd \"\\]\\]\n**Output**\n\\[null, \\[\\], \\[ \"aaaaa \"\\], \\[ \"bbbbb \",  \"ccccc \"\\], \\[\\], \\[ \"ddddd \",  \"eeeee \"\\]\\]\n\n**Explanation**\n// Note that the values ordered by ID is \\[ \"aaaaa \",  \"bbbbb \",  \"ccccc \",  \"ddddd \",  \"eeeee \"\\].\nOrderedStream os = new OrderedStream(5);\nos.insert(3,  \"ccccc \"); // Inserts (3,  \"ccccc \"), returns \\[\\].\nos.insert(1,  \"aaaaa \"); // Inserts (1,  \"aaaaa \"), returns \\[ \"aaaaa \"\\].\nos.insert(2,  \"bbbbb \"); // Inserts (2,  \"bbbbb \"), returns \\[ \"bbbbb \",  \"ccccc \"\\].\nos.insert(5,  \"eeeee \"); // Inserts (5,  \"eeeee \"), returns \\[\\].\nos.insert(4,  \"ddddd \"); // Inserts (4,  \"ddddd \"), returns \\[ \"ddddd \",  \"eeeee \"\\].\n// Concatentating all the chunks returned:\n// \\[\\] + \\[ \"aaaaa \"\\] + \\[ \"bbbbb \",  \"ccccc \"\\] + \\[\\] + \\[ \"ddddd \",  \"eeeee \"\\] = \\[ \"aaaaa \",  \"bbbbb \",  \"ccccc \",  \"ddddd \",  \"eeeee \"\\]\n// The resulting order is the same as the order above."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `1 <= id <= n`\n*   `value.length == 5`\n*   `value` consists only of lowercase letters.\n*   Each call to `insert` will have a unique `id.`\n*   Exactly `n` calls will be made to `insert`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Design",
            "Data Stream"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]"
            }
        ],
        "java": "\n    ```java\nint countGoodTriplets(int[] arr, int a, int b, int c) {\n    int count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = i + 1; j < arr.length; j++) {\n            if (Math.abs(arr[i] - arr[j]) <= a) {\n                for (int k = j + 1; k < arr.length; k++) {\n                    if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    The algorithm iterates through the array with three nested loops. The outer loop iterates through all the elements in the array with index i. The second loop starts from i+1 and goes till the last element in the array with index j. The third loop starts from j+1 and iterates till the last element in the array with index k.\n\nInside the innermost loop, we check if the absolute difference between arr[i] and arr[j] is less than or equal to a. If it is, proceed to calculate the absolute difference between arr[j] and arr[k] and check if it is less than or equal to b, as well as the absolute difference between arr[i] and arr[k] to check if it is less than or equal to c. If all three conditions are true, increment the count by 1.\n\nReturn the count after all nested loops are completed.\n    ",
        "python": "\n    ```python\ndef count_good_triplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if abs(arr[i] - arr[j]) <= a:\n                for k in range(j+1, len(arr)):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n    return count\n```\n\n    \n    The algorithm iterates through the array with three nested loops. The outer loop iterates through all the elements in the array with index i. The second loop starts from i+1 and goes till the last element in the array with index j. The third loop starts from j+1 and iterates till the last element in the array with index k.\n\nInside the innermost loop, we check if the absolute difference between arr[i] and arr[j] is less than or equal to a. If it is, proceed to calculate the absolute difference between arr[j] and arr[k] and check if it is less than or equal to b, as well as the absolute difference between arr[i] and arr[k] to check if it is less than or equal to c. If all three conditions are true, increment the count by 1.\n\nReturn the count after all nested loops are completed.\n    ",
        "c++": "\n    ```cpp\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\n    int count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (abs(arr[i] - arr[j]) <= a) {\n                for (int k = j + 1; k < arr.size(); k++) {\n                    if (abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    The algorithm iterates through the array with three nested loops. The outer loop iterates through all the elements in the array with index i. The second loop starts from i+1 and goes till the last element in the array with index j. The third loop starts from j+1 and iterates till the last element in the array with index k.\n\nInside the innermost loop, we check if the absolute difference between arr[i] and arr[j] is less than or equal to a. If it is, proceed to calculate the absolute difference between arr[j] and arr[k] and check if it is less than or equal to b, as well as the absolute difference between arr[i] and arr[k] to check if it is less than or equal to c. If all three conditions are true, increment the count by 1.\n\nReturn the count after all nested loops are completed.\n    ",
        "js": "\n    ```javascript\nfunction countGoodTriplets(arr, a, b, c) {\n    let count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = i + 1; j < arr.length; j++) {\n            if (Math.abs(arr[i] - arr[j]) <= a) {\n                for (let k = j + 1; k < arr.length; k++) {\n                    if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    The algorithm iterates through the array with three nested loops. The outer loop iterates through all the elements in the array with index i. The second loop starts from i+1 and goes till the last element in the array with index j. The third loop starts from j+1 and iterates till the last element in the array with index k.\n\nInside the innermost loop, we check if the absolute difference between arr[i] and arr[j] is less than or equal to a. If it is, proceed to calculate the absolute difference between arr[j] and arr[k] and check if it is less than or equal to b, as well as the absolute difference between arr[i] and arr[k] to check if it is less than or equal to c. If all three conditions are true, increment the count by 1.\n\nReturn the count after all nested loops are completed.\n    "
    },
    {
        "id": 300,
        "title": "Check If Two String Arrays are Equivalent",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two string arrays `word1` and `word2`, return `true` _if the two arrays **represent** the same string, and_ `false` _otherwise._\n\nA string is **represented** by an array if the array elements concatenated **in order** forms the string.",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 = \\[ \"ab \",  \"c \"\\], word2 = \\[ \"a \",  \"bc \"\\]\n**Output:** true\n**Explanation:**\nword1 represents string  \"ab \" +  \"c \" ->  \"abc \"\nword2 represents string  \"a \" +  \"bc \" ->  \"abc \"\nThe strings are the same, so return true.\n\n",
                "**Example 2:**\n\n**Input:** word1 = \\[ \"a \",  \"cb \"\\], word2 = \\[ \"ab \",  \"c \"\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** word1  = \\[ \"abc \",  \"d \",  \"defg \"\\], word2 = \\[ \"abcddefg \"\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 103`\n*   `1 <= word1[i].length, word2[i].length <= 103`\n*   `1 <= sum(word1[i].length), sum(word2[i].length) <= 103`\n*   `word1[i]` and `word2[i]` consist of lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"ab\",\"c\"],[\"a\",\"bc\"]",
                "output": "true"
            },
            {
                "input": "[\"a\",\"cb\"],[\"ab\",\"c\"]",
                "output": "false"
            },
            {
                "input": "[\"abc\",\"d\",\"defg\"],[\"abcddefg\"]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic int minNumOperations(int[] nums) {\n    int result = 0;\n    int[] highestBit = new int[32];\n    for (int num : nums) {\n        for (int j = 0; j < 32; j++) {\n            if ((num & (1 << j)) != 0) {\n                highestBit[j]++;\n            }\n        }\n    }\n    for (int count : highestBit) {\n        result = Math.max(result, count);\n    }\n    return result + 31;\n}\n```\n    \n    The algorithm starts by initializing a result variable to 0 and an array called highestBit of size 32 with all elements set to 0. Then, for each number in the input nums array, we perform bitwise operations to check if a specific bit is turned on (1). If so, we increment the corresponding element in the highestBit array by 1. After processing all the numbers in the input array, we loop through the highestBit array and update the result variable to the maximum value found plus 31. Finally, we return the result. The algorithm tries to find the highest bit set in any of the input numbers to determine the minimum number of calls needed to make nums from arr.\n    ",
        "python": "\n    ```python\ndef min_num_operations(nums):\n    result = 0\n    highest_bit = [0] * 32\n    for num in nums:\n        for j in range(32):\n            if num & (1 << j):\n                highest_bit[j] += 1\n    for count in highest_bit:\n        result = max(result, count)\n    return result + 31\n```\n    \n    The algorithm starts by initializing a result variable to 0 and an array called highestBit of size 32 with all elements set to 0. Then, for each number in the input nums array, we perform bitwise operations to check if a specific bit is turned on (1). If so, we increment the corresponding element in the highestBit array by 1. After processing all the numbers in the input array, we loop through the highestBit array and update the result variable to the maximum value found plus 31. Finally, we return the result. The algorithm tries to find the highest bit set in any of the input numbers to determine the minimum number of calls needed to make nums from arr.\n    ",
        "c++": "\n    ```cpp\nint minNumOperations(vector<int>& nums) {\n    int result = 0;\n    int highestBit[32] = {0};\n    for (int num : nums) {\n        for (int j = 0; j < 32; ++j) {\n            if (num & (1 << j)) {\n                highestBit[j]++;\n            }\n        }\n    }\n    for (int count : highestBit) {\n        result = max(result, count);\n    }\n    return result + 31;\n}\n```\n    \n    The algorithm starts by initializing a result variable to 0 and an array called highestBit of size 32 with all elements set to 0. Then, for each number in the input nums array, we perform bitwise operations to check if a specific bit is turned on (1). If so, we increment the corresponding element in the highestBit array by 1. After processing all the numbers in the input array, we loop through the highestBit array and update the result variable to the maximum value found plus 31. Finally, we return the result. The algorithm tries to find the highest bit set in any of the input numbers to determine the minimum number of calls needed to make nums from arr.\n    ",
        "js": "\n    ```javascript\nfunction minNumOperations(nums) {\n    let result = 0;\n    let highestBit = new Array(32).fill(0);\n    for (let num of nums) {\n        for (let j = 0; j < 32; ++j) {\n            if (num & (1 << j)) {\n                highestBit[j]++;\n            }\n        }\n    }\n    for (let count of highestBit) {\n        result = Math.max(result, count);\n    }\n    return result + 31;\n}\n```\n    \n    The algorithm starts by initializing a result variable to 0 and an array called highestBit of size 32 with all elements set to 0. Then, for each number in the input nums array, we perform bitwise operations to check if a specific bit is turned on (1). If so, we increment the corresponding element in the highestBit array by 1. After processing all the numbers in the input array, we loop through the highestBit array and update the result variable to the maximum value found plus 31. Finally, we return the result. The algorithm tries to find the highest bit set in any of the input numbers to determine the minimum number of calls needed to make nums from arr.\n    "
    },
    {
        "id": 301,
        "title": "Maximum Repeating Substring",
        "difficulty": "Easy",
        "content": {
            "problem": "For a string `sequence`, a string `word` is **`k`\\-repeating** if `word` concatenated `k` times is a substring of `sequence`. The `word`'s **maximum `k`\\-repeating value** is the highest value `k` where `word` is `k`\\-repeating in `sequence`. If `word` is not a substring of `sequence`, `word`'s maximum `k`\\-repeating value is `0`.\n\nGiven strings `sequence` and `word`, return _the **maximum `k`\\-repeating value** of `word` in `sequence`_.",
            "examples": [
                "**Example 1:**\n\n**Input:** sequence =  \"ababc \", word =  \"ab \"\n**Output:** 2\n**Explanation: ** \"abab \" is a substring in  \"ababc \".\n\n",
                "**Example 2:**\n\n**Input:** sequence =  \"ababc \", word =  \"ba \"\n**Output:** 1\n**Explanation: ** \"ba \" is a substring in  \"ababc \".  \"baba \" is not a substring in  \"ababc \".\n\n",
                "**Example 3:**\n\n**Input:** sequence =  \"ababc \", word =  \"ac \"\n**Output:** 0\n**Explanation: ** \"ac \" is not a substring in  \"ababc \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sequence.length <= 100`\n*   `1 <= word.length <= 100`\n*   `sequence` and `word` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"ababc\",\"ab\"",
                "output": "2\n**Explanation:**\"abab\"isasubstringin\"ababc\"."
            },
            {
                "input": "\"ababc\",\"ba\"",
                "output": "1\n**Explanation:**\"ba\"isasubstringin\"ababc\".\"baba\"isnotasubstringin\"ababc\"."
            },
            {
                "input": "\"ababc\",\"ac\"",
                "output": "0\n**Explanation:**\"ac\"isnotasubstringin\"ababc\"."
            }
        ],
        "java": "\n    ```java\nint longestAwesomeSubstring(String s) {\n    int n = s.length();\n    int maxLen = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            String substr = s.substring(i, j);\n            if (isAwesome(substr)) {\n                maxLen = Math.max(maxLen, j - i);\n            }\n        }\n    }\n    return maxLen;\n}\n\nboolean isAwesome(String s) {\n    int odd_count = 0;\n    int[] freq = new int[26];\n    for (char c : s.toCharArray()) {\n        freq[c - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 1) {\n            odd_count++;\n        }\n    }\n    return (odd_count <= 1);\n}\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    ",
        "python": "\n    ```python\ndef longestAwesomeSubstring(s):\n    n = len(s)\n    maxLen = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if isAwesome(substr):\n                maxLen = max(maxLen, j - i)\n    return maxLen\n\ndef isAwesome(s):\n    odd_count = 0\n    freq = [0] * 26\n    for c in s:\n        freq[ord(c) - ord('a')] += 1\n    for i in range(26):\n        if freq[i] % 2 == 1:\n            odd_count += 1\n    return odd_count <= 1\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    ",
        "c++": "\n    ```cpp\nint longestAwesomeSubstring(std::string s) {\n    int n = s.length();\n    int maxLen = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            std::string substr = s.substr(i, j - i);\n            if (isAwesome(substr)) {\n                maxLen = std::max(maxLen, j - i);\n            }\n        }\n    }\n    return maxLen;\n}\n\nbool isAwesome(std::string s) {\n    int odd_count = 0;\n    int freq[26] = {0};\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 1) {\n            odd_count++;\n        }\n    }\n    return (odd_count <= 1);\n}\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    ",
        "js": "\n    ```javascript\nfunction longestAwesomeSubstring(s) {\n    let n = s.length;\n    let maxLen = 0;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j <= n; ++j) {\n            let substr = s.substring(i, j);\n            if (isAwesome(substr)) {\n                maxLen = Math.max(maxLen, j - i);\n            }\n        }\n    }\n    return maxLen;\n}\n\nfunction isAwesome(s) {\n    let odd_count = 0;\n    let freq = new Array(26).fill(0);\n    for (let c of s) {\n        freq[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    for (let i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 1) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    "
    },
    {
        "id": 302,
        "title": "Richest Customer Wealth",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the amount of money the `ith` customer has in the `jth` bank. Return _the **wealth** that the richest customer has._\n\nA customer's **wealth** is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum **wealth**.",
            "examples": [
                "**Example 1:**\n\n**Input:** accounts = \\[\\[1,2,3\\],\\[3,2,1\\]\\]\n**Output:** 6\n**Explanation****:**\n`1st customer has wealth = 1 + 2 + 3 = 6`\n`2nd customer has wealth = 3 + 2 + 1 = 6`\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\n",
                "**Example 2:**\n\n**Input:** accounts = \\[\\[1,5\\],\\[7,3\\],\\[3,5\\]\\]\n**Output:** 10\n**Explanation**: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\n\n",
                "**Example 3:**\n\n**Input:** accounts = \\[\\[2,8,7\\],\\[7,1,3\\],\\[1,9,5\\]\\]\n**Output:** 17"
            ],
            "constraints": "**Constraints:**\n\n*   `m == accounts.length`\n*   `n == accounts[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= accounts[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[3,2,1]]",
                "output": "6"
            },
            {
                "input": "[[1,5],[7,3],[3,5]]",
                "output": "10"
            },
            {
                "input": "[[2,8,7],[7,1,3],[1,9,5]]",
                "output": "17"
            }
        ],
        "java": "\n    ```java\npublic int maximumWealth(int[][] accounts) {\n    int maxWealth = 0;\n    for (int[] customer : accounts) {\n        int wealth = 0;\n        for (int account : customer) {\n            wealth += account;\n        }\n        maxWealth = Math.max(maxWealth, wealth);\n    }\n    return maxWealth;\n}\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "python": "\n    ```python\ndef maximumWealth(accounts):\n    max_wealth = 0\n    for customer in accounts:\n        wealth = sum(customer)\n        max_wealth = max(max_wealth, wealth)\n    return max_wealth\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "c++": "\n    ```cpp\nint maximumWealth(vector<vector<int>>& accounts) {\n    int max_wealth = 0;\n    for (auto& customer : accounts) {\n        int wealth = 0;\n        for (int account : customer) {\n            wealth += account;\n        }\n        max_wealth = max(max_wealth, wealth);\n    }\n    return max_wealth;\n}\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "js": "\n    ```javascript\nfunction maximumWealth(accounts) {\n    let maxWealth = 0;\n    for (let customer of accounts) {\n        let wealth = 0;\n        for (let account of customer) {\n            wealth += account;\n        }\n        maxWealth = Math.max(maxWealth, wealth);\n    }\n    return maxWealth;\n}\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    "
    },
    {
        "id": 303,
        "title": "Goal Parser Interpretation",
        "difficulty": "Easy",
        "content": {
            "problem": "You own a **Goal Parser** that can interpret a string `command`. The `command` consists of an alphabet of `\"G \"`, `\"() \"` and/or `\"(al) \"` in some order. The Goal Parser will interpret `\"G \"` as the string `\"G \"`, `\"() \"` as the string `\"o \"`, and `\"(al) \"` as the string `\"al \"`. The interpreted strings are then concatenated in the original order.\n\nGiven the string `command`, return _the **Goal Parser**'s interpretation of_ `command`.",
            "examples": [
                "**Example 1:**\n\n**Input:** command =  \"G()(al) \"\n**Output:**  \"Goal \"\n**Explanation:** The Goal Parser interprets the command as follows:\nG -> G\n() -> o\n(al) -> al\nThe final concatenated result is  \"Goal \".\n\n",
                "**Example 2:**\n\n**Input:** command =  \"G()()()()(al) \"\n**Output:**  \"Gooooal \"\n\n",
                "**Example 3:**\n\n**Input:** command =  \"(al)G(al)()()G \"\n**Output:**  \"alGalooG \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= command.length <= 100`\n*   `command` consists of `\"G \"`, `\"() \"`, and/or `\"(al) \"` in some order.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"G()(al)\"",
                "output": "\"Goal\""
            },
            {
                "input": "\"G()()()()(al)\"",
                "output": "\"Gooooal\""
            },
            {
                "input": "\"(al)G(al)()()G\"",
                "output": "\"alGalooG\""
            }
        ],
        "java": "\n    ```java\npublic int numWays(String s) {\n    int numberOfOnes = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '1') numberOfOnes++;\n    }\n    if (numberOfOnes % 3 != 0) return 0;\n\n    int target = numberOfOnes / 3;\n    if (target == 0) {\n        long n = s.length();\n        return (int) ((n - 1) * (n - 2) / 2 % 1000000007);\n    }\n\n    int onesSoFar1 = 0, onesSoFar2 = 0;\n    long way1 = 0, way2 = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '1') {\n            onesSoFar1++;\n            if (onesSoFar1 == target) {\n                way1++;\n                onesSoFar1 = 0;\n            }\n\n            onesSoFar2++;\n            if (onesSoFar2 == target * 2) {\n                way2++;\n                onesSoFar2 = 0;\n            }\n        }\n    }\n\n    return (int) (way1 * way2 % 1000000007);\n}\n```\n\n    \n    First, count the number of ones in the binary string s. If the number of ones is not divisible by three, there is no valid way to split s. If the number of ones is zero, calculate the result as the number of ways to pick two positions out of (s.length() - 1) positions to insert separator. In other cases, we iterate through the string and count ones. If the count reaches target ones, we accumulate the result for s1 and clear the count. Similarly for s2, we accumulate the result based on the count reaching target * 2. Finally, we calculate the result as (way1 * way2) % 1000000007.\n    ",
        "python": "\n    ```python\ndef num_ways(s: str) -> int:\n    number_of_ones = s.count('1')\n    if number_of_ones % 3 != 0:\n        return 0\n\n    target = number_of_ones // 3\n    if target == 0:\n        n = len(s)\n        return ((n - 1) * (n - 2) // 2) % 1000000007\n\n    ones_so_far1, ones_so_far2 = 0, 0\n    way1, way2 = 0, 0\n    for c in s:\n        if c == '1':\n            ones_so_far1 += 1\n            if ones_so_far1 == target:\n                way1 += 1\n                ones_so_far1 = 0\n\n            ones_so_far2 += 1\n            if ones_so_far2 == target * 2:\n                way2 += 1\n                ones_so_far2 = 0\n\n    return (way1 * way2) % 1000000007\n```\n\n    \n    First, count the number of ones in the binary string s. If the number of ones is not divisible by three, there is no valid way to split s. If the number of ones is zero, calculate the result as the number of ways to pick two positions out of (s.length() - 1) positions to insert separator. In other cases, we iterate through the string and count ones. If the count reaches target ones, we accumulate the result for s1 and clear the count. Similarly for s2, we accumulate the result based on the count reaching target * 2. Finally, we calculate the result as (way1 * way2) % 1000000007.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nint numWays(string s) {\n    int numberOfOnes = 0;\n    for (char c : s) {\n        if (c == '1') numberOfOnes++;\n    }\n    if (numberOfOnes % 3 != 0) return 0;\n\n    int target = numberOfOnes / 3;\n    if (target == 0) {\n        long n = s.length();\n        return ((n - 1) * (n - 2) / 2) % 1000000007;\n    }\n\n    int onesSoFar1 = 0, onesSoFar2 = 0;\n    long way1 = 0, way2 = 0;\n    for (char c : s) {\n        if (c == '1') {\n            onesSoFar1++;\n            if (onesSoFar1 == target) {\n                way1++;\n                onesSoFar1 = 0;\n            }\n\n            onesSoFar2++;\n            if (onesSoFar2 == target * 2) {\n                way2++;\n                onesSoFar2 = 0;\n            }\n        }\n    }\n\n    return (way1 * way2) % 1000000007;\n}\n```\n\n    \n    First, count the number of ones in the binary string s. If the number of ones is not divisible by three, there is no valid way to split s. If the number of ones is zero, calculate the result as the number of ways to pick two positions out of (s.length() - 1) positions to insert separator. In other cases, we iterate through the string and count ones. If the count reaches target ones, we accumulate the result for s1 and clear the count. Similarly for s2, we accumulate the result based on the count reaching target * 2. Finally, we calculate the result as (way1 * way2) % 1000000007.\n    ",
        "js": "\n    ```javascript\nfunction numWays(s) {\n  let numberOfOnes = s.split('').filter(c => c === '1').length;\n  if (numberOfOnes % 3 !== 0) return 0;\n\n  let target = numberOfOnes / 3;\n  if (target === 0) {\n    let n = s.length;\n    return ((n - 1) * (n - 2) / 2) % 1000000007;\n  }\n\n  let onesSoFar1 = 0, onesSoFar2 = 0;\n  let way1 = 0, way2 = 0;\n  for (let c of s) {\n    if (c === '1') {\n      onesSoFar1++;\n      if (onesSoFar1 === target) {\n        way1++;\n        onesSoFar1 = 0;\n      }\n\n      onesSoFar2++;\n      if (onesSoFar2 === target * 2) {\n        way2++;\n        onesSoFar2 = 0;\n      }\n    }\n  }\n\n  return (way1 * way2) % 1000000007;\n}\n```\n\n    \n    First, count the number of ones in the binary string s. If the number of ones is not divisible by three, there is no valid way to split s. If the number of ones is zero, calculate the result as the number of ways to pick two positions out of (s.length() - 1) positions to insert separator. In other cases, we iterate through the string and count ones. If the count reaches target ones, we accumulate the result for s1 and clear the count. Similarly for s2, we accumulate the result based on the count reaching target * 2. Finally, we calculate the result as (way1 * way2) % 1000000007.\n    "
    },
    {
        "id": 304,
        "title": "Count the Number of Consistent Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `allowed` consisting of **distinct** characters and an array of strings `words`. A string is **consistent** if all characters in the string appear in the string `allowed`.\n\nReturn _the number of **consistent** strings in the array_ `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** allowed =  \"ab \", words = \\[ \"ad \", \"bd \", \"aaab \", \"baa \", \"badab \"\\]\n**Output:** 2\n**Explanation:** Strings  \"aaab \" and  \"baa \" are consistent since they only contain characters 'a' and 'b'.\n\n",
                "**Example 2:**\n\n**Input:** allowed =  \"abc \", words = \\[ \"a \", \"b \", \"c \", \"ab \", \"ac \", \"bc \", \"abc \"\\]\n**Output:** 7\n**Explanation:** All strings are consistent.\n\n",
                "**Example 3:**\n\n**Input:** allowed =  \"cad \", words = \\[ \"cc \", \"acd \", \"b \", \"ba \", \"bac \", \"bad \", \"ac \", \"d \"\\]\n**Output:** 4\n**Explanation:** Strings  \"cc \",  \"acd \",  \"ac \", and  \"d \" are consistent."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= allowed.length <= 26`\n*   `1 <= words[i].length <= 10`\n*   The characters in `allowed` are **distinct**.\n*   `words[i]` and `allowed` contain only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "example": [
            {
                "input": "\"ab\",[\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]",
                "output": "2"
            },
            {
                "input": "\"abc\",[\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]",
                "output": "7"
            },
            {
                "input": "\"cad\",[\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int findLatestStep(int[] arr, int m) {\n    int n = arr.length;\n    int[] lengthLeft = new int[n + 2], lengthRight = new int[n + 2];\n    int count = 0, result = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int pos = arr[i];\n        int leftLength = lengthRight[pos - 1];\n        int rightLength = lengthLeft[pos + 1];\n        int newLength = leftLength + rightLength + 1;\n\n        if (leftLength == m || rightLength == m) {\n            count--;\n        }\n        \n        if (newLength == m) {\n            count++;\n        }\n        \n        if (newLength > 0) {\n            lengthLeft[pos - leftLength] = newLength;\n            lengthRight[pos + rightLength] = newLength;\n            result = i + 1;\n        }\n    }\n\n    return count > 0 ? result : -1;\n}\n```\n\n    \n    The algorithm initializes two arrays `lengthLeft` and `lengthRight` to keep track of the left and right lengths of contiguous groups of 1's. It also initializes a `count` variable that will be incremented when finding a group of 1's with length `m` and decremented when a group of 1's is extended beyond length `m`.\n\nFor each step `i` from 1 to n, the position in the binary string is set to 1 using the value from the array `arr`. The left length, right length, and total new length of the newly created group of 1's is then calculated using `lengthLeft` and `lengthRight`.\n\nAfter calculating the new lengths, we modify the count:\n- If the left length is equal to `m` or the right length is equal to `m`, decrement the count\n- If the new length is equal to `m`, increment the count\n\nAfter that, if the new length is greater than 0, we set the values of new left and right lengths in `lengthLeft` and `lengthRight` arrays and update the `result` with the current step `i + 1`.\n\nOnce all steps are completed, if the count is greater than 0, then the `result` is returned. If the count is 0 or less, then we return -1 as no such group of 1's exists with length `m`.\n    ",
        "python": "\n    ```python\ndef find_latest_step(arr, m):\n    n = len(arr)\n    length_left, length_right = [0] * (n + 2), [0] * (n + 2)\n    count, result = 0, -1\n\n    for i, pos in enumerate(arr):\n        left_length = length_right[pos - 1]\n        right_length = length_left[pos + 1]\n        new_length = left_length + right_length + 1\n\n        if left_length == m or right_length == m:\n            count -= 1\n\n        if new_length == m:\n            count += 1\n\n        if new_length > 0:\n            length_left[pos - left_length] = new_length\n            length_right[pos + right_length] = new_length\n            result = i + 1\n\n    return result if count > 0 else -1\n```\n\n    \n    The algorithm initializes two arrays `lengthLeft` and `lengthRight` to keep track of the left and right lengths of contiguous groups of 1's. It also initializes a `count` variable that will be incremented when finding a group of 1's with length `m` and decremented when a group of 1's is extended beyond length `m`.\n\nFor each step `i` from 1 to n, the position in the binary string is set to 1 using the value from the array `arr`. The left length, right length, and total new length of the newly created group of 1's is then calculated using `lengthLeft` and `lengthRight`.\n\nAfter calculating the new lengths, we modify the count:\n- If the left length is equal to `m` or the right length is equal to `m`, decrement the count\n- If the new length is equal to `m`, increment the count\n\nAfter that, if the new length is greater than 0, we set the values of new left and right lengths in `lengthLeft` and `lengthRight` arrays and update the `result` with the current step `i + 1`.\n\nOnce all steps are completed, if the count is greater than 0, then the `result` is returned. If the count is 0 or less, then we return -1 as no such group of 1's exists with length `m`.\n    ",
        "c++": "\n    ```cpp\nint findLatestStep(vector<int>& arr, int m) {\n    int n = arr.size();\n    vector<int> lengthLeft(n + 2, 0), lengthRight(n + 2, 0);\n    int count = 0, result = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int pos = arr[i];\n        int leftLength = lengthRight[pos - 1];\n        int rightLength = lengthLeft[pos + 1];\n        int newLength = leftLength + rightLength + 1;\n\n        if (leftLength == m || rightLength == m) {\n            count--;\n        }\n        \n        if (newLength == m) {\n            count++;\n        }\n        \n        if (newLength > 0) {\n            lengthLeft[pos - leftLength] = newLength;\n            lengthRight[pos + rightLength] = newLength;\n            result = i + 1;\n        }\n    }\n\n    return count > 0 ? result : -1;\n}\n```\n\n    \n    The algorithm initializes two arrays `lengthLeft` and `lengthRight` to keep track of the left and right lengths of contiguous groups of 1's. It also initializes a `count` variable that will be incremented when finding a group of 1's with length `m` and decremented when a group of 1's is extended beyond length `m`.\n\nFor each step `i` from 1 to n, the position in the binary string is set to 1 using the value from the array `arr`. The left length, right length, and total new length of the newly created group of 1's is then calculated using `lengthLeft` and `lengthRight`.\n\nAfter calculating the new lengths, we modify the count:\n- If the left length is equal to `m` or the right length is equal to `m`, decrement the count\n- If the new length is equal to `m`, increment the count\n\nAfter that, if the new length is greater than 0, we set the values of new left and right lengths in `lengthLeft` and `lengthRight` arrays and update the `result` with the current step `i + 1`.\n\nOnce all steps are completed, if the count is greater than 0, then the `result` is returned. If the count is 0 or less, then we return -1 as no such group of 1's exists with length `m`.\n    ",
        "js": "\n    ```javascript\nfunction findLatestStep(arr, m) {\n    const n = arr.length;\n    const lengthLeft = new Array(n + 2).fill(0);\n    const lengthRight = new Array(n + 2).fill(0);\n    let count = 0;\n    let result = -1;\n    \n    for (let i = 0; i < n; ++i) {\n        const pos = arr[i];\n        const leftLength = lengthRight[pos - 1];\n        const rightLength = lengthLeft[pos + 1];\n        const newLength = leftLength + rightLength + 1;\n\n        if (leftLength === m || rightLength === m) {\n            count--;\n        }\n\n        if (newLength === m) {\n            count++;\n        }\n\n        if (newLength > 0) {\n            lengthLeft[pos - leftLength] = newLength;\n            lengthRight[pos + rightLength] = newLength;\n            result = i + 1;\n        }\n    }\n    \n    return count > 0 ? result : -1;\n}\n```\n\n    \n    The algorithm initializes two arrays `lengthLeft` and `lengthRight` to keep track of the left and right lengths of contiguous groups of 1's. It also initializes a `count` variable that will be incremented when finding a group of 1's with length `m` and decremented when a group of 1's is extended beyond length `m`.\n\nFor each step `i` from 1 to n, the position in the binary string is set to 1 using the value from the array `arr`. The left length, right length, and total new length of the newly created group of 1's is then calculated using `lengthLeft` and `lengthRight`.\n\nAfter calculating the new lengths, we modify the count:\n- If the left length is equal to `m` or the right length is equal to `m`, decrement the count\n- If the new length is equal to `m`, increment the count\n\nAfter that, if the new length is greater than 0, we set the values of new left and right lengths in `lengthLeft` and `lengthRight` arrays and update the `result` with the current step `i + 1`.\n\nOnce all steps are completed, if the count is greater than 0, then the `result` is returned. If the count is 0 or less, then we return -1 as no such group of 1's exists with length `m`.\n    "
    },
    {
        "id": 305,
        "title": "Count of Matches in Tournament",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `n`, the number of teams in a tournament that has strange rules:\n\n*   If the current number of teams is **even**, each team gets paired with another team. A total of `n / 2` matches are played, and `n / 2` teams advance to the next round.\n*   If the current number of teams is **odd**, one team randomly advances in the tournament, and the rest gets paired. A total of `(n - 1) / 2` matches are played, and `(n - 1) / 2 + 1` teams advance to the next round.\n\nReturn _the number of matches played in the tournament until a winner is decided._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7\n**Output:** 6\n**Explanation:** Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n\n",
                "**Example 2:**\n\n**Input:** n = 14\n**Output:** 13\n**Explanation:** Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 200`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "7",
                "output": "6"
            },
            {
                "input": "14",
                "output": "13"
            }
        ],
        "java": "\n    ```java\npublic int numberOfMatches(int n) {\n    int matches = 0;\n    while (n > 1) {\n        matches += n / 2;\n        n = (n + 1) / 2;\n    }\n    return matches;\n}\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "python": "\n    ```python\ndef numberOfMatches(n: int) -> int:\n    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "c++": "\n    ```cpp\nint numberOfMatches(int n) {\n    int matches = 0;\n    while (n > 1) {\n        matches += n / 2;\n        n = (n + 1) / 2;\n    }\n    return matches;\n}\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "js": "\n    ```javascript\nfunction numberOfMatches(n) {\n    let matches = 0;\n    while (n > 1) {\n        matches += Math.floor(n / 2);\n        n = Math.floor((n + 1) / 2);\n    }\n    return matches;\n}\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    "
    },
    {
        "id": 306,
        "title": "Reformat Phone Number",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a phone number as a string `number`. `number` consists of digits, spaces `' '`, and/or dashes `'-'`.\n\nYou would like to reformat the phone number in a certain manner. Firstly, **remove** all spaces and dashes. Then, **group** the digits from left to right into blocks of length 3 **until** there are 4 or fewer digits. The final digits are then grouped as follows:\n\n*   2 digits: A single block of length 2.\n*   3 digits: A single block of length 3.\n*   4 digits: Two blocks of length 2 each.\n\nThe blocks are then joined by dashes. Notice that the reformatting process should **never** produce any blocks of length 1 and produce **at most** two blocks of length 2.\n\nReturn _the phone number after formatting._",
            "examples": [
                "**Example 1:**\n\n**Input:** number =  \"1-23-45 6 \"\n**Output:**  \"123-456 \"\n**Explanation:** The digits are  \"123456 \".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is  \"123 \".\nStep 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is  \"456 \".\nJoining the blocks gives  \"123-456 \".\n\n",
                "**Example 2:**\n\n**Input:** number =  \"123 4-567 \"\n**Output:**  \"123-45-67 \"\n**Explanation:** The digits are  \"1234567 \".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is  \"123 \".\nStep 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are  \"45 \" and  \"67 \".\nJoining the blocks gives  \"123-45-67 \".\n\n",
                "**Example 3:**\n\n**Input:** number =  \"123 4-5678 \"\n**Output:**  \"123-456-78 \"\n**Explanation:** The digits are  \"12345678 \".\nStep 1: The 1st block is  \"123 \".\nStep 2: The 2nd block is  \"456 \".\nStep 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is  \"78 \".\nJoining the blocks gives  \"123-456-78 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= number.length <= 100`\n*   `number` consists of digits and the characters `'-'` and `' '`.\n*   There are at least **two** digits in `number`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"1-23-456\"",
                "output": "\"123-456\""
            },
            {
                "input": "\"1234-567\"",
                "output": "\"123-45-67\""
            },
            {
                "input": "\"1234-5678\"",
                "output": "\"123-456-78\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int minSubarray(int[] nums, int p) {\n    int n = nums.length, need = 0, cur = 0, res = n;\n    for (int num : nums) need = (need + num) % p;\n    if (need == 0) return 0;\n    HashMap<Integer, Integer> last_seen = new HashMap<>();\n    last_seen.put(cur, -1);\n    for (int i = 0; i < n; ++i) {\n        cur = (cur + nums[i]) % p;\n        last_seen.put(cur, i);\n        int want = (cur - need + p) % p;\n        if (last_seen.containsKey(want)) {\n            res = Math.min(res, i-last_seen.get(want));\n        }\n    }\n    return res == n ? -1 : res;\n}\n```\n\n    \n    The algorithm starts by calculating the sum modulo p of the entire array (called \"need\"). If the sum is already divisible by p (i.e., need is 0), it returns 0 as no elements need to be removed.\n\nNext, we define an unordered_map (in C++), a HashMap (in Java), a dictionary (in Python), or a Map (in JavaScript) called \"last_seen\" which keeps track of the last_seen index where each \"cur\" value appears. \"cur\" represents the current accumulated sum modulo p.\n\nWhile iterating through the array, we calculate the \"cur\" value and put it into the last_seen data structure with the corresponding index i as the value. We also calculate the \"want\" value, which is the value we need in last_seen to ensure the sum of the remaining elements is divisible by p. If \"want\" is in last_seen, we update the minimum result length with the difference between the current index and the index where the \"want\" value was last seen in last_seen.\n\nFinally, if the result length is still equal to the length of the array, it means it is impossible to get a subarray whose sum is divisible by p, so we return -1; otherwise, we return the result length.\n    ",
        "python": "\n    ```python\ndef min_subarray(nums, p):\n    n = len(nums)\n    need, cur, res = 0, 0, n\n    last_seen = {}\n\n    for num in nums:\n        need = (need + num) % p\n\n    if need == 0:\n        return 0\n\n    last_seen[cur] = -1\n    for i, num in enumerate(nums):\n        cur = (cur + num) % p\n        last_seen[cur] = i\n        want = (cur - need + p) % p\n        if want in last_seen:\n            res = min(res, i - last_seen[want])\n\n    return res if res != n else -1\n```\n\n    \n    The algorithm starts by calculating the sum modulo p of the entire array (called \"need\"). If the sum is already divisible by p (i.e., need is 0), it returns 0 as no elements need to be removed.\n\nNext, we define an unordered_map (in C++), a HashMap (in Java), a dictionary (in Python), or a Map (in JavaScript) called \"last_seen\" which keeps track of the last_seen index where each \"cur\" value appears. \"cur\" represents the current accumulated sum modulo p.\n\nWhile iterating through the array, we calculate the \"cur\" value and put it into the last_seen data structure with the corresponding index i as the value. We also calculate the \"want\" value, which is the value we need in last_seen to ensure the sum of the remaining elements is divisible by p. If \"want\" is in last_seen, we update the minimum result length with the difference between the current index and the index where the \"want\" value was last seen in last_seen.\n\nFinally, if the result length is still equal to the length of the array, it means it is impossible to get a subarray whose sum is divisible by p, so we return -1; otherwise, we return the result length.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minSubarray(vector<int>& nums, int p) {\n    int n = nums.size(), need = 0, cur = 0, res = n;\n    for (int num : nums) need = (need + num) % p;\n    if (need == 0) return 0;\n    unordered_map<int, int> last_seen;\n    last_seen[cur] = -1;\n    for (int i = 0; i < n; ++i) {\n        cur = (cur + nums[i]) % p;\n        last_seen[cur] = i;\n        int want = (cur - need + p) % p;\n        if (last_seen.count(want)) {\n            res = min(res, i-last_seen[want]);\n        }\n    }\n    return res == n ? -1 : res;\n}\n```\n\n    \n    The algorithm starts by calculating the sum modulo p of the entire array (called \"need\"). If the sum is already divisible by p (i.e., need is 0), it returns 0 as no elements need to be removed.\n\nNext, we define an unordered_map (in C++), a HashMap (in Java), a dictionary (in Python), or a Map (in JavaScript) called \"last_seen\" which keeps track of the last_seen index where each \"cur\" value appears. \"cur\" represents the current accumulated sum modulo p.\n\nWhile iterating through the array, we calculate the \"cur\" value and put it into the last_seen data structure with the corresponding index i as the value. We also calculate the \"want\" value, which is the value we need in last_seen to ensure the sum of the remaining elements is divisible by p. If \"want\" is in last_seen, we update the minimum result length with the difference between the current index and the index where the \"want\" value was last seen in last_seen.\n\nFinally, if the result length is still equal to the length of the array, it means it is impossible to get a subarray whose sum is divisible by p, so we return -1; otherwise, we return the result length.\n    ",
        "js": "\n    ```javascript\nfunction minSubarray(nums, p) {\n    const n = nums.length;\n    let need = 0, cur = 0, res = n;\n    const last_seen = new Map();\n\n    for (const num of nums)\n        need = (need + num) % p;\n\n    if (need === 0)\n        return 0;\n\n    last_seen.set(cur, -1);\n    for (let i = 0; i < n; ++i) {\n        cur = (cur + nums[i]) % p;\n        last_seen.set(cur, i);\n        const want = (cur - need + p) % p;\n        if (last_seen.has(want))\n            res = Math.min(res, i - last_seen.get(want));\n    }\n\n    return res === n ? -1 : res;\n}\n```\n\n    \n    The algorithm starts by calculating the sum modulo p of the entire array (called \"need\"). If the sum is already divisible by p (i.e., need is 0), it returns 0 as no elements need to be removed.\n\nNext, we define an unordered_map (in C++), a HashMap (in Java), a dictionary (in Python), or a Map (in JavaScript) called \"last_seen\" which keeps track of the last_seen index where each \"cur\" value appears. \"cur\" represents the current accumulated sum modulo p.\n\nWhile iterating through the array, we calculate the \"cur\" value and put it into the last_seen data structure with the corresponding index i as the value. We also calculate the \"want\" value, which is the value we need in last_seen to ensure the sum of the remaining elements is divisible by p. If \"want\" is in last_seen, we update the minimum result length with the difference between the current index and the index where the \"want\" value was last seen in last_seen.\n\nFinally, if the result length is still equal to the length of the array, it means it is impossible to get a subarray whose sum is divisible by p, so we return -1; otherwise, we return the result length.\n    "
    },
    {
        "id": 307,
        "title": "Number of Students Unable to Eat Lunch",
        "difficulty": "Easy",
        "content": {
            "problem": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers `0` and `1` respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.\n\nThe number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a **stack**. At each step:\n\n*   If the student at the front of the queue **prefers** the sandwich on the top of the stack, they will **take it** and leave the queue.\n*   Otherwise, they will **leave it** and go to the queue's end.\n\nThis continues until none of the queue students want to take the top sandwich and are thus unable to eat.\n\nYou are given two integer arrays `students` and `sandwiches` where `sandwiches[i]` is the type of the `ith` sandwich in the stack (`i = 0` is the top of the stack) and `students[j]` is the preference of the `jth` student in the initial queue (`j = 0` is the front of the queue). Return _the number of students that are unable to eat._",
            "examples": [
                "**Example 1:**\n\n**Input:** students = \\[1,1,0,0\\], sandwiches = \\[0,1,0,1\\]\n**Output:** 0 \n**Explanation:**\n- Front student leaves the top sandwich and returns to the end of the line making students = \\[1,0,0,1\\].\n- Front student leaves the top sandwich and returns to the end of the line making students = \\[0,0,1,1\\].\n- Front student takes the top sandwich and leaves the line making students = \\[0,1,1\\] and sandwiches = \\[1,0,1\\].\n- Front student leaves the top sandwich and returns to the end of the line making students = \\[1,1,0\\].\n- Front student takes the top sandwich and leaves the line making students = \\[1,0\\] and sandwiches = \\[0,1\\].\n- Front student leaves the top sandwich and returns to the end of the line making students = \\[0,1\\].\n- Front student takes the top sandwich and leaves the line making students = \\[1\\] and sandwiches = \\[1\\].\n- Front student takes the top sandwich and leaves the line making students = \\[\\] and sandwiches = \\[\\].\nHence all students are able to eat.\n\n",
                "**Example 2:**\n\n**Input:** students = \\[1,1,1,0,0,1\\], sandwiches = \\[1,0,0,0,1,1\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= students.length, sandwiches.length <= 100`\n*   `students.length == sandwiches.length`\n*   `sandwiches[i]` is `0` or `1`.\n*   `students[i]` is `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Queue",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,1,0,0],[0,1,0,1]",
                "output": "0"
            },
            {
                "input": "[1,1,1,0,0,1],[1,0,0,0,1,1]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int min_time_to_remove_balloons(String colors, int[] neededTime) {\n    int n = colors.length();\n    int[][] dp = new int[n][26];\n    final int INF = (int) 1e9;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 26; j++) {\n            dp[i][j] = INF;\n        }\n    }\n\n    for (int color = 0; color < 26; color++) {\n        if (colors.charAt(0) != 'A' + color) dp[0][color] = neededTime[0];\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int color1 = 0; color1 < 26; color1++) {\n            for (int color2 = 0; color2 < 26; color2++) {\n                if (color1 != color2 && colors.charAt(i) != 'A' + color1) {\n                    dp[i][color1] = Math.min(dp[i][color1], dp[i-1][color2] + neededTime[i]);\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int color = 0; color < 26; color++) {\n        ans = Math.min(ans, dp[n-1][color]);\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming. We maintain a 2D table dp[i][j] that represents the minimum time Bob needs to make the rope colorful up to (and including) the i-th balloon, with the assumption that the i-th balloon's color is changed to color j. Initially, we fill the table with a large value (here, 1e9).\n\nWe then loop through each balloon, and for each balloon, we loop through all pairs of colors (26^2 possibilities). For each pair of colors, if the colors are different and the i-th balloon is not of color1, we update dp[i][color1] by taking the minimum between its current value and dp[i - 1][color2] + the time needed to remove the i-th balloon.\n\nAfter iterating over all balloons and color pairs, we search for the minimum value in the last row of the dp table, as this represents the minimum time needed to make the whole rope colorful.\n\nThe time complexity of this algorithm is O(n * 26^2), where n is the length of the string colors, since the algorithm needs to loop through each balloon and all possible color pairs. This complexity is acceptable for the problem's constraints.\n    ",
        "python": "\n    ```python\ndef min_time_to_remove_balloons(colors, neededTime):\n    n = len(colors)\n    INF = 10**9\n    dp = [[INF] * 26 for _ in range(n)]\n\n    for color in range(26):\n        if colors[0] != chr(ord('A') + color):\n            dp[0][color] = neededTime[0]\n\n    for i in range(1, n):\n        for color1 in range(26):\n            for color2 in range(26):\n                if color1 != color2 and colors[i] != chr(ord('A') + color1):\n                    dp[i][color1] = min(dp[i][color1], dp[i-1][color2] + neededTime[i])\n\n    ans = INF\n    for color in range(26):\n        ans = min(ans, dp[n-1][color])\n\n    return ans\n```\n\n    \n    The algorithm uses dynamic programming. We maintain a 2D table dp[i][j] that represents the minimum time Bob needs to make the rope colorful up to (and including) the i-th balloon, with the assumption that the i-th balloon's color is changed to color j. Initially, we fill the table with a large value (here, 1e9).\n\nWe then loop through each balloon, and for each balloon, we loop through all pairs of colors (26^2 possibilities). For each pair of colors, if the colors are different and the i-th balloon is not of color1, we update dp[i][color1] by taking the minimum between its current value and dp[i - 1][color2] + the time needed to remove the i-th balloon.\n\nAfter iterating over all balloons and color pairs, we search for the minimum value in the last row of the dp table, as this represents the minimum time needed to make the whole rope colorful.\n\nThe time complexity of this algorithm is O(n * 26^2), where n is the length of the string colors, since the algorithm needs to loop through each balloon and all possible color pairs. This complexity is acceptable for the problem's constraints.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint min_time_to_remove_balloons(const std::string& colors, const std::vector<int>& neededTime) {\n    int n = colors.size();\n    int dp[n][26];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 26; j++) {\n            dp[i][j] = 1e9; \n        }\n    }\n\n    for (int color = 0; color < 26; color++) {\n        if (colors[0] != 'A' + color) dp[0][color] = neededTime[0];\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int color1 = 0; color1 < 26; color1++) {\n            for (int color2 = 0; color2 < 26; color2++) {\n                if (color1 != color2 && colors[i] != 'A' + color1) {\n                    dp[i][color1] = std::min(dp[i][color1], dp[i-1][color2] + neededTime[i]);\n                }\n            }\n        }\n    }\n\n    int ans = 1e9;\n    for (int color = 0; color < 26; color++) {\n        ans = std::min(ans, dp[n-1][color]);\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming. We maintain a 2D table dp[i][j] that represents the minimum time Bob needs to make the rope colorful up to (and including) the i-th balloon, with the assumption that the i-th balloon's color is changed to color j. Initially, we fill the table with a large value (here, 1e9).\n\nWe then loop through each balloon, and for each balloon, we loop through all pairs of colors (26^2 possibilities). For each pair of colors, if the colors are different and the i-th balloon is not of color1, we update dp[i][color1] by taking the minimum between its current value and dp[i - 1][color2] + the time needed to remove the i-th balloon.\n\nAfter iterating over all balloons and color pairs, we search for the minimum value in the last row of the dp table, as this represents the minimum time needed to make the whole rope colorful.\n\nThe time complexity of this algorithm is O(n * 26^2), where n is the length of the string colors, since the algorithm needs to loop through each balloon and all possible color pairs. This complexity is acceptable for the problem's constraints.\n    ",
        "js": "\n    ```javascript\nfunction min_time_to_remove_balloons(colors, neededTime) {\n    const n = colors.length;\n    const INF = 1e9;\n    let dp = Array.from({ length: n }, () => Array(26).fill(INF));\n\n    for (let color = 0; color < 26; color++) {\n        if (colors.charAt(0) !== String.fromCharCode('A'.charCodeAt(0) + color))\n            dp[0][color] = neededTime[0];\n    }\n\n    for (let i = 1; i < n; i++) {\n        for (let color1 = 0; color1 < 26; color1++) {\n            for (let color2 = 0; color2 < 26; color2++) {\n                if (color1 !== color2 && colors.charAt(i) !== String.fromCharCode('A'.charCodeAt(0) + color1)) {\n                    dp[i][color1] = Math.min(dp[i][color1], dp[i - 1][color2] + neededTime[i]);\n                }\n            }\n        }\n    }\n\n    let ans = INF;\n    for (let color = 0; color < 26; color++) {\n        ans = Math.min(ans, dp[n - 1][color]);\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming. We maintain a 2D table dp[i][j] that represents the minimum time Bob needs to make the rope colorful up to (and including) the i-th balloon, with the assumption that the i-th balloon's color is changed to color j. Initially, we fill the table with a large value (here, 1e9).\n\nWe then loop through each balloon, and for each balloon, we loop through all pairs of colors (26^2 possibilities). For each pair of colors, if the colors are different and the i-th balloon is not of color1, we update dp[i][color1] by taking the minimum between its current value and dp[i - 1][color2] + the time needed to remove the i-th balloon.\n\nAfter iterating over all balloons and color pairs, we search for the minimum value in the last row of the dp table, as this represents the minimum time needed to make the whole rope colorful.\n\nThe time complexity of this algorithm is O(n * 26^2), where n is the length of the string colors, since the algorithm needs to loop through each balloon and all possible color pairs. This complexity is acceptable for the problem's constraints.\n    "
    },
    {
        "id": 308,
        "title": "Determine if String Halves Are Alike",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` of even length. Split this string into two halves of equal lengths, and let `a` be the first half and `b` be the second half.\n\nTwo strings are **alike** if they have the same number of vowels (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`, `'A'`, `'E'`, `'I'`, `'O'`, `'U'`). Notice that `s` contains uppercase and lowercase letters.\n\nReturn `true` _if_ `a` _and_ `b` _are **alike**_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"book \"\n**Output:** true\n**Explanation:** a =  \"bo \" and b =  \"ok \". a has 1 vowel and b has 1 vowel. Therefore, they are alike.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"textbook \"\n**Output:** false\n**Explanation:** a =  \"text \" and b =  \"book \". a has 1 vowel whereas b has 2. Therefore, they are not alike.\nNotice that the vowel o is counted twice."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 1000`\n*   `s.length` is even.\n*   `s` consists of **uppercase and lowercase** letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"book\"",
                "output": "true"
            },
            {
                "input": "\"textbook\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int numSpecial(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    int[] row = new int[m], col = new int[n];\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (mat[i][j] == 1) {\n                ++row[i];\n                ++col[j];\n            }\n        }\n    }\n\n    int special_positions = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) {\n                ++special_positions;\n            }\n        }\n    }\n\n    return special_positions;\n}\n```\n    \n    1. First, initialize variables `m` and `n` to be the number of rows and columns of the given matrix `mat`. Also, create two vectors `row` and `col` of size `m` and `n` respectively, and initialize them with all zeros. These vectors will be used to store the one's count of each row and column in the matrix.\n2. For each cell of the matrix, add 1 to the corresponding row and column vectors' elements if the cell value is 1. Thus, by the end of the nested loop, we'll have the count of one's in each row and column in our `row` and `col` vectors.\n3. Now, iterate over each cell of the matrix once again. If the cell value is 1, and the corresponding row and column count in `row` and `col` vectors are both 1, increment the special_positions count.\n4. Finally, return the special_positions count, which represents the number of special positions in the matrix `mat`.\n    ",
        "python": "\n    ```python\ndef numSpecial(mat):\n    m, n = len(mat), len(mat[0])\n    row, col = [0] * m, [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                row[i] += 1\n                col[j] += 1\n\n    special_positions = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1 and row[i] == 1 and col[j] == 1:\n                special_positions += 1\n\n    return special_positions\n```\n    \n    1. First, initialize variables `m` and `n` to be the number of rows and columns of the given matrix `mat`. Also, create two vectors `row` and `col` of size `m` and `n` respectively, and initialize them with all zeros. These vectors will be used to store the one's count of each row and column in the matrix.\n2. For each cell of the matrix, add 1 to the corresponding row and column vectors' elements if the cell value is 1. Thus, by the end of the nested loop, we'll have the count of one's in each row and column in our `row` and `col` vectors.\n3. Now, iterate over each cell of the matrix once again. If the cell value is 1, and the corresponding row and column count in `row` and `col` vectors are both 1, increment the special_positions count.\n4. Finally, return the special_positions count, which represents the number of special positions in the matrix `mat`.\n    ",
        "c++": "\n    ```cpp\nint numSpecial(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    vector<int> row(m, 0), col(n, 0);\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (mat[i][j] == 1) {\n                ++row[i];\n                ++col[j];\n            }\n        }\n    }\n\n    int special_positions = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) {\n                ++special_positions;\n            }\n        }\n    }\n\n    return special_positions;\n}\n```\n    \n    1. First, initialize variables `m` and `n` to be the number of rows and columns of the given matrix `mat`. Also, create two vectors `row` and `col` of size `m` and `n` respectively, and initialize them with all zeros. These vectors will be used to store the one's count of each row and column in the matrix.\n2. For each cell of the matrix, add 1 to the corresponding row and column vectors' elements if the cell value is 1. Thus, by the end of the nested loop, we'll have the count of one's in each row and column in our `row` and `col` vectors.\n3. Now, iterate over each cell of the matrix once again. If the cell value is 1, and the corresponding row and column count in `row` and `col` vectors are both 1, increment the special_positions count.\n4. Finally, return the special_positions count, which represents the number of special positions in the matrix `mat`.\n    ",
        "js": "\n    ```javascript\nfunction numSpecial(mat) {\n    let m = mat.length, n = mat[0].length;\n    let row = new Array(m).fill(0), col = new Array(n).fill(0);\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (mat[i][j] == 1) {\n                ++row[i];\n                ++col[j];\n            }\n        }\n    }\n\n    let special_positions = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) {\n                ++special_positions;\n            }\n        }\n    }\n\n    return special_positions;\n}\n```\n    \n    1. First, initialize variables `m` and `n` to be the number of rows and columns of the given matrix `mat`. Also, create two vectors `row` and `col` of size `m` and `n` respectively, and initialize them with all zeros. These vectors will be used to store the one's count of each row and column in the matrix.\n2. For each cell of the matrix, add 1 to the corresponding row and column vectors' elements if the cell value is 1. Thus, by the end of the nested loop, we'll have the count of one's in each row and column in our `row` and `col` vectors.\n3. Now, iterate over each cell of the matrix once again. If the cell value is 1, and the corresponding row and column count in `row` and `col` vectors are both 1, increment the special_positions count.\n4. Finally, return the special_positions count, which represents the number of special positions in the matrix `mat`.\n    "
    },
    {
        "id": 309,
        "title": "Maximum Units on a Truck",
        "difficulty": "Easy",
        "content": {
            "problem": "You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:\n\n*   `numberOfBoxesi` is the number of boxes of type `i`.\n*   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the **maximum** total number of **units** that can be put on the truck._",
            "examples": [
                "**Example 1:**\n\n**Input:** boxTypes = \\[\\[1,3\\],\\[2,2\\],\\[3,1\\]\\], truckSize = 4\n**Output:** 8\n**Explanation:** There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 \\* 3) + (2 \\* 2) + (1 \\* 1) = 8.\n\n",
                "**Example 2:**\n\n**Input:** boxTypes = \\[\\[5,10\\],\\[2,5\\],\\[4,7\\],\\[3,9\\]\\], truckSize = 10\n**Output:** 91"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= boxTypes.length <= 1000`\n*   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`\n*   `1 <= truckSize <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,3],[2,2],[3,1]],4",
                "output": "8"
            },
            {
                "input": "[[5,10],[2,5],[4,7],[3,9]],10",
                "output": "91"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\n    int[] serverRequests = new int[k];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    Queue<Integer> availableServers = new LinkedList<>();\n\n    for (int i = 0; i < k; i++) {\n        availableServers.offer(i);\n    }\n\n    for (int i = 0; i < arrival.length; i++) {\n        while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {\n            availableServers.offer(pq.poll()[1]);\n        }\n\n        if (!availableServers.isEmpty()) {\n            int serverId = availableServers.poll();\n            serverRequests[serverId]++;\n            pq.offer(new int[]{arrival[i] + load[i], serverId});\n        }\n    }\n\n    int maxRequests = 0;\n    for (int requests : serverRequests) {\n        maxRequests = Math.max(maxRequests, requests);\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        if (serverRequests[i] == maxRequests) {\n            result.add(i);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef busiest_servers(k, arrival, load):\n    server_requests = [0] * k\n    pq = []\n    available_servers = list(range(k))\n\n    for i in range(len(arrival)):\n        while pq and pq[0][0] <= arrival[i]:\n            _, server_id = heapq.heappop(pq)\n            available_servers.append(server_id)\n\n        if available_servers:\n            server_id = available_servers.pop(0)\n            server_requests[server_id] += 1\n            heapq.heappush(pq, (arrival[i] + load[i], server_id))\n\n    max_requests = max(server_requests)\n    return [i for i in range(k) if server_requests[i] == max_requests]\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nstd::vector<int> busiestServers(int k, std::vector<int>& arrival, std::vector<int>& load) {\n    std::vector<int> serverRequests(k, 0);\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n    std::queue<int> availableServers;\n\n    for (int i = 0; i < k; ++i) {\n        availableServers.push(i);\n    }\n\n    for (int i = 0; i < arrival.size(); ++i) {\n        while (!pq.empty() && pq.top().first <= arrival[i]) {\n            availableServers.push(pq.top().second);\n            pq.pop();\n        }\n\n        if (!availableServers.empty()) {\n            int serverId = availableServers.front();\n            availableServers.pop();\n            serverRequests[serverId]++;\n            pq.push({arrival[i] + load[i], serverId});\n        }\n    }\n\n    int maxRequests = 0;\n    for (int requests : serverRequests) {\n        maxRequests = std::max(maxRequests, requests);\n    }\n\n    std::vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        if (serverRequests[i] == maxRequests) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    ",
        "js": "\n    ```javascript\nfunction busiestServers(k, arrival, load) {\n    const serverRequests = new Array(k).fill(0);\n    const pq = [];\n    const availableServers = Array.from({ length: k }, (_, i) => i);\n\n    for (let i = 0; i < arrival.length; i++) {\n        while (pq.length && pq[0][0] <= arrival[i]) {\n            const [, serverId] = pq.shift();\n            availableServers.push(serverId);\n        }\n\n        if (availableServers.length) {\n            const serverId = availableServers.shift();\n            serverRequests[serverId]++;\n            pq.push([arrival[i] + load[i], serverId]);\n            pq.sort((a, b) => a[0] - b[0]);\n        }\n    }\n\n    const maxRequests = Math.max(...serverRequests);\n    return serverRequests.reduce((result, requests, i) => {\n        if (requests === maxRequests) {\n            result.push(i);\n        }\n        return result;\n    }, []);\n}\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    "
    },
    {
        "id": 310,
        "title": "Calculate Money in Leetcode Bank",
        "difficulty": "Easy",
        "content": {
            "problem": "Hercy wants to save money for his first car. He puts money in the Leetcode bank **every day**.\n\nHe starts by putting in `$1` on Monday, the first day. Every day from Tuesday to Sunday, he will put in `$1` more than the day before. On every subsequent Monday, he will put in `$1` more than the **previous Monday**.\n\nGiven `n`, return _the total amount of money he will have in the Leetcode bank at the end of the_ `nth` _day._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 10\n**Explanation:** After the 4th day, the total is 1 + 2 + 3 + 4 = 10.\n\n",
                "**Example 2:**\n\n**Input:** n = 10\n**Output:** 37\n**Explanation:** After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.\n\n",
                "**Example 3:**\n\n**Input:** n = 20\n**Output:** 96\n**Explanation:** After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "4",
                "output": "10"
            },
            {
                "input": "10",
                "output": "37"
            },
            {
                "input": "20",
                "output": "96"
            }
        ],
        "java": "\n    ```java\npublic int maxProductPath(int[][] grid) {\n    int m = grid.length, n = grid[0].length, mod = 1000000007;\n    long[][][] dp = new long[m][n][2];\n    \n    dp[0][0] = new long[]{grid[0][0], grid[0][0]};\n    \n    for(int i = 1; i < m; i++) {\n        dp[i][0] = new long[]{dp[i-1][0][0] * grid[i][0], dp[i-1][0][0] * grid[i][0]};\n    }\n    for(int j = 1; j < n; j++) {\n        dp[0][j] = new long[]{dp[0][j-1][0] * grid[0][j], dp[0][j-1][0] * grid[0][j]};\n    }\n    \n    for(int i = 1; i < m; i++) {\n        for(int j = 1; j < n; j++) {\n            if(grid[i][j] < 0) {\n                dp[i][j][0] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];\n                dp[i][j][1] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];\n            } else {\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];\n                dp[i][j][1] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];\n            }\n        }\n    }\n    \n    return dp[m - 1][n - 1][0] >= 0 ? (int)(dp[m - 1][n - 1][0] % mod) : -1;\n}\n```\n\n    \n    The algorithm used is a dynamic programming approach, where we maintain a 3D DP array `dp` with dimensions m x n x 2. For each cell `dp[i][j]`, we store the maximum non-negative product and the minimum non-positive product of the path up until cell (i, j) in the grid. We initialize the first row and first column of the grid, and then iterate through the remaining cells.\n\nAt each cell, if the corresponding grid value is negative, the product of this value with the minimum non-positive value of the previous cells will give the maximum non-negative value for the current cell, and vice versa for minimum non-positive value. If the value is non-negative, multiplying by maximum non-negative values from previous cells will give the maximum non-negative value for the current cell, and similarly for minimum non-positive value.\n\nAfter filling out the DP array, the result is the modulo of the maximum non-negative product of the last cell in the DP array, unless it's negative, in which case we return -1.\n    ",
        "python": "\n    ```python\ndef maxProductPath(grid):\n    m, n, mod = len(grid), len(grid[0]), int(1e9 + 7)\n    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n    \n    dp[0][0] = [grid[0][0], grid[0][0]]\n    \n    for i in range(1, m):\n        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]]\n    for j in range(1, n):\n        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] < 0:\n                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]\n                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]\n            else:\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]\n                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]\n            \n    return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1\n```\n\n    \n    The algorithm used is a dynamic programming approach, where we maintain a 3D DP array `dp` with dimensions m x n x 2. For each cell `dp[i][j]`, we store the maximum non-negative product and the minimum non-positive product of the path up until cell (i, j) in the grid. We initialize the first row and first column of the grid, and then iterate through the remaining cells.\n\nAt each cell, if the corresponding grid value is negative, the product of this value with the minimum non-positive value of the previous cells will give the maximum non-negative value for the current cell, and vice versa for minimum non-positive value. If the value is non-negative, multiplying by maximum non-negative values from previous cells will give the maximum non-negative value for the current cell, and similarly for minimum non-positive value.\n\nAfter filling out the DP array, the result is the modulo of the maximum non-negative product of the last cell in the DP array, unless it's negative, in which case we return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint maxProductPath(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size(), mod = 1e9 + 7;\n    vector<vector<vector<long long>>> dp(m, vector<vector<long long>>(n, vector<long long>(2)));\n    \n    dp[0][0] = {grid[0][0], grid[0][0]};\n    \n    for(int i = 1; i < m; i++) {\n        dp[i][0][0] = dp[i][0][1] = dp[i-1][0][0] * grid[i][0];\n    }\n    for(int j = 1; j < n; j++) {\n        dp[0][j][0] = dp[0][j][1] = dp[0][j-1][0] * grid[0][j];\n    }\n    \n    for(int i = 1; i < m; i++) {\n        for(int j = 1; j < n; j++) {\n            if(grid[i][j] < 0) {\n                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];\n                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];\n            } else {\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];\n                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];\n            }\n        }\n    }\n    \n    return dp[m - 1][n - 1][0] >= 0 ? dp[m - 1][n - 1][0] % mod : -1;\n}\n```\n\n    \n    The algorithm used is a dynamic programming approach, where we maintain a 3D DP array `dp` with dimensions m x n x 2. For each cell `dp[i][j]`, we store the maximum non-negative product and the minimum non-positive product of the path up until cell (i, j) in the grid. We initialize the first row and first column of the grid, and then iterate through the remaining cells.\n\nAt each cell, if the corresponding grid value is negative, the product of this value with the minimum non-positive value of the previous cells will give the maximum non-negative value for the current cell, and vice versa for minimum non-positive value. If the value is non-negative, multiplying by maximum non-negative values from previous cells will give the maximum non-negative value for the current cell, and similarly for minimum non-positive value.\n\nAfter filling out the DP array, the result is the modulo of the maximum non-negative product of the last cell in the DP array, unless it's negative, in which case we return -1.\n    ",
        "js": "\n    ```javascript\nfunction maxProductPath(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const mod = 1e9 + 7;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0).map(() => [0, 0]));\n\n    dp[0][0] = [grid[0][0], grid[0][0]];\n\n    for(let i = 1; i < m; i++) {\n        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]];\n    }\n    for(let j = 1; j < n; j++) {\n        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]];\n    }\n\n    for(let i = 1; i < m; i++) {\n        for(let j = 1; j < n; j++) {\n            if(grid[i][j] < 0) {\n                dp[i][j][0] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];\n                dp[i][j][1] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];\n            } else {\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];\n                dp[i][j][1] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];\n            }\n        }\n    }\n    \n    return dp[m - 1][n - 1][0] >= 0 ? dp[m - 1][n - 1][0] % mod : -1;\n}\n```\n\n    \n    The algorithm used is a dynamic programming approach, where we maintain a 3D DP array `dp` with dimensions m x n x 2. For each cell `dp[i][j]`, we store the maximum non-negative product and the minimum non-positive product of the path up until cell (i, j) in the grid. We initialize the first row and first column of the grid, and then iterate through the remaining cells.\n\nAt each cell, if the corresponding grid value is negative, the product of this value with the minimum non-positive value of the previous cells will give the maximum non-negative value for the current cell, and vice versa for minimum non-positive value. If the value is non-negative, multiplying by maximum non-negative values from previous cells will give the maximum non-negative value for the current cell, and similarly for minimum non-positive value.\n\nAfter filling out the DP array, the result is the modulo of the maximum non-negative product of the last cell in the DP array, unless it's negative, in which case we return -1.\n    "
    },
    {
        "id": 311,
        "title": "Decode XORed Array",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a **hidden** integer array `arr` that consists of `n` non-negative integers.\n\nIt was encoded into another integer array `encoded` of length `n - 1`, such that `encoded[i] = arr[i] XOR arr[i + 1]`. For example, if `arr = [1,0,2,1]`, then `encoded = [1,2,3]`.\n\nYou are given the `encoded` array. You are also given an integer `first`, that is the first element of `arr`, i.e. `arr[0]`.\n\nReturn _the original array_ `arr`. It can be proved that the answer exists and is unique.",
            "examples": [
                "**Example 1:**\n\n**Input:** encoded = \\[1,2,3\\], first = 1\n**Output:** \\[1,0,2,1\\]\n**Explanation:** If arr = \\[1,0,2,1\\], then first = 1 and encoded = \\[1 XOR 0, 0 XOR 2, 2 XOR 1\\] = \\[1,2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** encoded = \\[6,2,7,3\\], first = 4\n**Output:** \\[4,2,0,7,4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`\n*   `encoded.length == n - 1`\n*   `0 <= encoded[i] <= 105`\n*   `0 <= first <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,2,3],1",
                "output": "[1,0,2,1]"
            },
            {
                "input": "[6,2,7,3],4",
                "output": "[4,2,0,7,4]"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(String[] logs) {\n    int depth = 0;\n    for (String log : logs) {\n        if (log.equals(\"../\")) {\n            if (depth > 0) {\n                depth--;\n            }\n        } else if (!log.equals(\"./\")) {\n            depth++;\n        }\n    }\n    return depth;\n}\n```\n\n    \n    The algorithm maintains a variable `depth` to keep track of the current folder depth from the main folder. It starts from 0 (main folder) becuase the file system initially starts in the main folder. Then, it iterates through the `logs` list:\n\n- If the log is \"../\", it means the operation is to go up one level, so we decrement the `depth` by 1. Note that we check if `depth` is greater than 0 to handle the situation where the current folder is already the main folder (we don't want to go above the main folder).\n- If the log is not \"./\" (which means it's a sub-folder), it means the operation is to go down one level, so we increment the `depth` by 1.\n\nAfter the loop, the value of `depth` represents the minimum number of operations needed to go back to the main folder, so we return it.\n    ",
        "python": "\n    ```python\ndef minOperations(logs):\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            if depth > 0:\n                depth -= 1\n        elif log != \"./\":\n            depth += 1\n    return depth\n```\n\n    \n    The algorithm maintains a variable `depth` to keep track of the current folder depth from the main folder. It starts from 0 (main folder) becuase the file system initially starts in the main folder. Then, it iterates through the `logs` list:\n\n- If the log is \"../\", it means the operation is to go up one level, so we decrement the `depth` by 1. Note that we check if `depth` is greater than 0 to handle the situation where the current folder is already the main folder (we don't want to go above the main folder).\n- If the log is not \"./\" (which means it's a sub-folder), it means the operation is to go down one level, so we increment the `depth` by 1.\n\nAfter the loop, the value of `depth` represents the minimum number of operations needed to go back to the main folder, so we return it.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<string>& logs) {\n    int depth = 0;\n    for (const string& log : logs) {\n        if (log == \"../\") {\n            if (depth > 0) {\n                depth--;\n            }\n        } else if (log != \"./\") {\n            depth++;\n        }\n    }\n    return depth;\n}\n```\n\n    \n    The algorithm maintains a variable `depth` to keep track of the current folder depth from the main folder. It starts from 0 (main folder) becuase the file system initially starts in the main folder. Then, it iterates through the `logs` list:\n\n- If the log is \"../\", it means the operation is to go up one level, so we decrement the `depth` by 1. Note that we check if `depth` is greater than 0 to handle the situation where the current folder is already the main folder (we don't want to go above the main folder).\n- If the log is not \"./\" (which means it's a sub-folder), it means the operation is to go down one level, so we increment the `depth` by 1.\n\nAfter the loop, the value of `depth` represents the minimum number of operations needed to go back to the main folder, so we return it.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(logs) {\n    let depth = 0;\n    for (const log of logs) {\n        if (log === \"../\") {\n            if (depth > 0) {\n                depth--;\n            }\n        } else if (log !== \"./\") {\n            depth++;\n        }\n    }\n    return depth;\n}\n```\n\n    \n    The algorithm maintains a variable `depth` to keep track of the current folder depth from the main folder. It starts from 0 (main folder) becuase the file system initially starts in the main folder. Then, it iterates through the `logs` list:\n\n- If the log is \"../\", it means the operation is to go up one level, so we decrement the `depth` by 1. Note that we check if `depth` is greater than 0 to handle the situation where the current folder is already the main folder (we don't want to go above the main folder).\n- If the log is not \"./\" (which means it's a sub-folder), it means the operation is to go down one level, so we increment the `depth` by 1.\n\nAfter the loop, the value of `depth` represents the minimum number of operations needed to go back to the main folder, so we return it.\n    "
    },
    {
        "id": 312,
        "title": "Number Of Rectangles That Can Form The Largest Square",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`.\n\nYou can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`.\n\nLet `maxLen` be the side length of the **largest** square you can obtain from any of the given rectangles.\n\nReturn _the **number** of rectangles that can make a square with a side length of_ `maxLen`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rectangles = \\[\\[5,8\\],\\[3,9\\],\\[5,12\\],\\[16,5\\]\\]\n**Output:** 3\n**Explanation:** The largest squares you can get from each rectangle are of lengths \\[5,3,5,5\\].\nThe largest possible square is of length 5, and you can get it out of 3 rectangles.\n\n",
                "**Example 2:**\n\n**Input:** rectangles = \\[\\[2,3\\],\\[3,7\\],\\[4,3\\],\\[3,7\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rectangles.length <= 1000`\n*   `rectangles[i].length == 2`\n*   `1 <= li, wi <= 109`\n*   `li != wi`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[[5,8],[3,9],[5,12],[16,5]]",
                "output": "3"
            },
            {
                "input": "[[2,3],[3,7],[4,3],[3,7]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int numberOfSets(int n, int k) {\n    long mod = 1000000007;\n    long[][] dp = new long[n][k + 1];\n    long[] presum = new long[n];\n    Arrays.fill(presum, 1);\n    \n    for (int j = 1; j <= k; ++j) {\n        for (int i = 0; i < n; ++i) {\n            dp[i][j] = presum[i];\n            if (i > 0) {\n                dp[i][j] += dp[i - 1][j];\n            }\n            dp[i][j] %= mod;\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod;\n        }\n    }\n    \n    return (int) dp[n - 1][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We create a 2D array `dp` of dimensions (n, k + 1), where `dp[i][j]` stores the number of ways to draw `j` non-overlapping line segments up to point `i`. We also maintain an array `presum` which is the prefix sum of the `dp` array. \n\nWe then loop through `j` from 1 to k and `i` from 0 to n-1, calculating `dp[i][j]` using the values in `presum` and `dp` arrays. To avoid recomputing values, we update the `presum` array iteratively.\n\nFinally, we return the value in `dp[n - 1][k]` which is the number of ways to draw k non-overlapping line segments up to point n-1.\n    ",
        "python": "\n    ```python\ndef numberOfSets(n, k):\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n)]\n    presum = [1] * n\n    \n    for j in range(1, k + 1):\n        for i in range(n):\n            dp[i][j] = presum[i]\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= mod\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod\n    \n    return dp[n - 1][k]\n```\n    \n    The problem can be solved using dynamic programming. We create a 2D array `dp` of dimensions (n, k + 1), where `dp[i][j]` stores the number of ways to draw `j` non-overlapping line segments up to point `i`. We also maintain an array `presum` which is the prefix sum of the `dp` array. \n\nWe then loop through `j` from 1 to k and `i` from 0 to n-1, calculating `dp[i][j]` using the values in `presum` and `dp` arrays. To avoid recomputing values, we update the `presum` array iteratively.\n\nFinally, we return the value in `dp[n - 1][k]` which is the number of ways to draw k non-overlapping line segments up to point n-1.\n    ",
        "c++": "\n    ```cpp\nint numberOfSets(int n, int k) {\n    long long mod = 1e9 + 7;\n    vector<vector<long long>> dp(n, vector<long long>(k + 1, 0));\n    vector<long long> presum(n, 1);\n    \n    for (int j = 1; j <= k; ++j) {\n        for (int i = 0; i < n; ++i) {\n            dp[i][j] = presum[i];\n            if (i) {\n                dp[i][j] += dp[i - 1][j];\n            }\n            dp[i][j] %= mod;\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod;\n        }\n    }\n    \n    return dp[n - 1][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We create a 2D array `dp` of dimensions (n, k + 1), where `dp[i][j]` stores the number of ways to draw `j` non-overlapping line segments up to point `i`. We also maintain an array `presum` which is the prefix sum of the `dp` array. \n\nWe then loop through `j` from 1 to k and `i` from 0 to n-1, calculating `dp[i][j]` using the values in `presum` and `dp` arrays. To avoid recomputing values, we update the `presum` array iteratively.\n\nFinally, we return the value in `dp[n - 1][k]` which is the number of ways to draw k non-overlapping line segments up to point n-1.\n    ",
        "js": "\n    ```javascript\nfunction numberOfSets(n, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n }, () => Array(k + 1).fill(0));\n    const presum = Array(n).fill(1);\n    \n    for (let j = 1; j <= k; ++j) {\n        for (let i = 0; i < n; ++i) {\n            dp[i][j] = presum[i];\n            if (i > 0) {\n                dp[i][j] += dp[i - 1][j];\n            }\n            dp[i][j] %= mod;\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod;\n        }\n    }\n\n    return dp[n - 1][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We create a 2D array `dp` of dimensions (n, k + 1), where `dp[i][j]` stores the number of ways to draw `j` non-overlapping line segments up to point `i`. We also maintain an array `presum` which is the prefix sum of the `dp` array. \n\nWe then loop through `j` from 1 to k and `i` from 0 to n-1, calculating `dp[i][j]` using the values in `presum` and `dp` arrays. To avoid recomputing values, we update the `presum` array iteratively.\n\nFinally, we return the value in `dp[n - 1][k]` which is the number of ways to draw k non-overlapping line segments up to point n-1.\n    "
    },
    {
        "id": 313,
        "title": "Find the Highest Altitude",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a biker going on a road trip. The road trip consists of `n + 1` points at different altitudes. The biker starts his trip on point `0` with altitude equal `0`.\n\nYou are given an integer array `gain` of length `n` where `gain[i]` is the **net gain in altitude** between points `i` and `i + 1` for all (`0 <= i < n)`. Return _the **highest altitude** of a point._",
            "examples": [
                "**Example 1:**\n\n**Input:** gain = \\[-5,1,5,0,-7\\]\n**Output:** 1\n**Explanation:** The altitudes are \\[0,-5,-4,1,1,-6\\]. The highest is 1.\n\n",
                "**Example 2:**\n\n**Input:** gain = \\[-4,-3,-2,-1,4,3,2\\]\n**Output:** 0\n**Explanation:** The altitudes are \\[0,-4,-7,-9,-10,-6,-3,-1\\]. The highest is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == gain.length`\n*   `1 <= n <= 100`\n*   `-100 <= gain[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[-5,1,5,0,-7]",
                "output": "1"
            },
            {
                "input": "[-4,-3,-2,-1,4,3,2]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint minOperations(int n) {\n    int operations = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n--;\n        }\n        operations++;\n    }\n    return operations;\n}\n```\n    \n    The algorithm initializes a variable `operations` to store the number of operations taken. It then enters a loop that iterates while `n` is greater than 0. In each iteration, it checks whether `n` is divisible by 2 (i.e., even). If it is, the algorithm divides `n` by 2; otherwise, it decrements `n` by 1. In each loop iteration, the algorithm also increments the `operations` counter. The loop ends when `n` reaches 0, and the algorithm returns the total count of operations performed.\n\nThis algorithm finds the minimum number of operations required because dividing `n` by 2 is more optimal than decrementing `n` by 1 whenever `n` is even, as it reduces the number more rapidly.\n    ",
        "python": "\n    ```python\ndef min_operations(n):\n    operations = 0\n    while n > 0:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n -= 1\n        operations += 1\n    return operations\n```\n    \n    The algorithm initializes a variable `operations` to store the number of operations taken. It then enters a loop that iterates while `n` is greater than 0. In each iteration, it checks whether `n` is divisible by 2 (i.e., even). If it is, the algorithm divides `n` by 2; otherwise, it decrements `n` by 1. In each loop iteration, the algorithm also increments the `operations` counter. The loop ends when `n` reaches 0, and the algorithm returns the total count of operations performed.\n\nThis algorithm finds the minimum number of operations required because dividing `n` by 2 is more optimal than decrementing `n` by 1 whenever `n` is even, as it reduces the number more rapidly.\n    ",
        "c++": "\n    ```cpp\nint min_operations(int n) {\n    int operations = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n--;\n        }\n        operations++;\n    }\n    return operations;\n}\n```\n    \n    The algorithm initializes a variable `operations` to store the number of operations taken. It then enters a loop that iterates while `n` is greater than 0. In each iteration, it checks whether `n` is divisible by 2 (i.e., even). If it is, the algorithm divides `n` by 2; otherwise, it decrements `n` by 1. In each loop iteration, the algorithm also increments the `operations` counter. The loop ends when `n` reaches 0, and the algorithm returns the total count of operations performed.\n\nThis algorithm finds the minimum number of operations required because dividing `n` by 2 is more optimal than decrementing `n` by 1 whenever `n` is even, as it reduces the number more rapidly.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(n) {\n    let operations = 0;\n    while (n > 0) {\n        if (n % 2 === 0) {\n            n /= 2;\n        } else {\n            n--;\n        }\n        operations++;\n    }\n    return operations;\n}\n```\n    \n    The algorithm initializes a variable `operations` to store the number of operations taken. It then enters a loop that iterates while `n` is greater than 0. In each iteration, it checks whether `n` is divisible by 2 (i.e., even). If it is, the algorithm divides `n` by 2; otherwise, it decrements `n` by 1. In each loop iteration, the algorithm also increments the `operations` counter. The loop ends when `n` reaches 0, and the algorithm returns the total count of operations performed.\n\nThis algorithm finds the minimum number of operations required because dividing `n` by 2 is more optimal than decrementing `n` by 1 whenever `n` is even, as it reduces the number more rapidly.\n    "
    },
    {
        "id": 314,
        "title": "Latest Time by Replacing Hidden Digits",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `time` in the form of `hh:mm`, where some of the digits in the string are hidden (represented by `?`).\n\nThe valid times are those inclusively between `00:00` and `23:59`.\n\nReturn _the latest valid time you can get from_ `time` _by replacing the hidden_ _digits_.",
            "examples": [
                "**Example 1:**\n\n**Input:** time =  \"2?:?0 \"\n**Output:**  \"23:50 \"\n**Explanation:** The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.\n\n",
                "**Example 2:**\n\n**Input:** time =  \"0?:3? \"\n**Output:**  \"09:39 \"\n\n",
                "**Example 3:**\n\n**Input:** time =  \"1?:22 \"\n**Output:**  \"19:22 \""
            ],
            "constraints": "**Constraints:**\n\n*   `time` is in the format `hh:mm`.\n*   It is guaranteed that you can produce a valid time from the given string.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"2?:?0\"",
                "output": "\"23:50\""
            },
            {
                "input": "\"0?:3?\"",
                "output": "\"09:39\""
            },
            {
                "input": "\"1?:22\"",
                "output": "\"19:22\""
            }
        ],
        "java": "\n    ```java\npublic String maximumTime(String time) {\n    char[] res = time.toCharArray();\n    if (res[0] == '?') {\n        res[0] = (res[1] <= '3' || res[1] == '?') ? '2' : '1';\n    }\n    if (res[1] == '?') {\n        res[1] = (res[0] == '2') ? '3' : '9';\n    }\n    if (res[3] == '?') {\n        res[3] = '5';\n    }\n    if (res[4] == '?') {\n        res[4] = '9';\n    }\n    return new String(res);\n}\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    ",
        "python": "\n    ```python\ndef maximumTime(time: str) -> str:\n    time_list = list(time)\n    if time_list[0] == '?':\n        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'\n    if time_list[1] == '?':\n        time_list[1] = '3' if time_list[0] == '2' else '9'\n    if time_list[3] == '?':\n        time_list[3] = '5'\n    if time_list[4] == '?':\n        time_list[4] = '9'\n    return \"\".join(time_list)\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string maximumTime(std::string time) {\n    if (time[0] == '?') {\n        time[0] = (time[1] <= '3' || time[1] == '?') ? '2' : '1';\n    }\n    if (time[1] == '?') {\n        time[1] = (time[0] == '2') ? '3' : '9';\n    }\n    if (time[3] == '?') {\n        time[3] = '5';\n    }\n    if (time[4] == '?') {\n        time[4] = '9';\n    }\n    return time;\n}\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    ",
        "js": "\n    ```javascript\nfunction maximumTime(time) {\n    let res = time.split('');\n    if (res[0] === \"?\") {\n        res[0] = (res[1] <= \"3\" || res[1] === \"?\") ? \"2\" : \"1\";\n    }\n    if (res[1] === \"?\") {\n        res[1] = (res[0] === \"2\") ? \"3\" : \"9\";\n    }\n    if (res[3] === \"?\") {\n        res[3] = \"5\";\n    }\n    if (res[4] === \"?\") {\n        res[4] = \"9\";\n    }\n    return res.join('');\n}\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    "
    },
    {
        "id": 315,
        "title": "Maximum Number of Balls in a Box",
        "difficulty": "Easy",
        "content": {
            "problem": "You are working in a ball factory where you have `n` balls numbered from `lowLimit` up to `highLimit` **inclusive** (i.e., `n == highLimit - lowLimit + 1`), and an infinite number of boxes numbered from `1` to `infinity`.\n\nYour job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number `321` will be put in the box number `3 + 2 + 1 = 6` and the ball number `10` will be put in the box number `1 + 0 = 1`.\n\nGiven two integers `lowLimit` and `highLimit`, return _the number of balls in the box with the most balls._",
            "examples": [
                "**Example 1:**\n\n**Input:** lowLimit = 1, highLimit = 10\n**Output:** 2\n**Explanation:**\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  2 1 1 1 1 1 1 1 1 0  0  ...\nBox 1 has the most number of balls with 2 balls.\n\n",
                "**Example 2:**\n\n**Input:** lowLimit = 5, highLimit = 15\n**Output:** 2\n**Explanation:**\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  1 1 1 1 2 2 1 1 1 0  0  ...\nBoxes 5 and 6 have the most number of balls with 2 balls in each.\n\n",
                "**Example 3:**\n\n**Input:** lowLimit = 19, highLimit = 28\n**Output:** 2\n**Explanation:**\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...\nBall Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...\nBox 10 has the most number of balls with 2 balls."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= lowLimit <= highLimit <= 105`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "Counting"
        ],
        "example": [
            {
                "input": "1,10",
                "output": "2"
            },
            {
                "input": "5,15",
                "output": "2"
            },
            {
                "input": "19,28",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxWidthOfVerticalArea(int[][] points) {\n    List<Integer> xs = new ArrayList<>();\n    for (int[] point : points) {\n        xs.add(point[0]);\n    }\n    Collections.sort(xs);\n\n    int max_width = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        max_width = Math.max(max_width, xs.get(i) - xs.get(i - 1));\n    }\n\n    return max_width;\n}\n```\n\n    \n    1. Obtain all the x-coordinates from the given points, and store them in a new list (`xs`).\n2. Sort the x-coordinates in ascending order.\n3. Initialize the maximum width (`max_width`) to be 0.\n4. Iterate through the sorted x coordinates:\n   - For each consecutive pair of x-coordinates, calculate their difference.\n   - Update the `max_width` with the maximum value between the current `max_width` and the difference.\n5. Return the `max_width`.\n    ",
        "python": "\n    ```python\ndef maxWidthOfVerticalArea(points):\n    xs = sorted([point[0] for point in points])\n    max_width = 0\n    for i in range(1, len(xs)):\n        max_width = max(max_width, xs[i] - xs[i - 1])\n    return max_width\n```\n\n    \n    1. Obtain all the x-coordinates from the given points, and store them in a new list (`xs`).\n2. Sort the x-coordinates in ascending order.\n3. Initialize the maximum width (`max_width`) to be 0.\n4. Iterate through the sorted x coordinates:\n   - For each consecutive pair of x-coordinates, calculate their difference.\n   - Update the `max_width` with the maximum value between the current `max_width` and the difference.\n5. Return the `max_width`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxWidthOfVerticalArea(std::vector<std::vector<int>>& points) {\n    std::vector<int> xs;\n    for (const auto& point : points) {\n        xs.push_back(point[0]);\n    }\n    std::sort(xs.begin(), xs.end());\n    \n    int max_width = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        max_width = std::max(max_width, xs[i] - xs[i - 1]);\n    }\n    \n    return max_width;\n}\n```\n\n    \n    1. Obtain all the x-coordinates from the given points, and store them in a new list (`xs`).\n2. Sort the x-coordinates in ascending order.\n3. Initialize the maximum width (`max_width`) to be 0.\n4. Iterate through the sorted x coordinates:\n   - For each consecutive pair of x-coordinates, calculate their difference.\n   - Update the `max_width` with the maximum value between the current `max_width` and the difference.\n5. Return the `max_width`.\n    ",
        "js": "\n    ```javascript\nfunction maxWidthOfVerticalArea(points) {\n    const xs = points.map(point => point[0]).sort((a, b) => a - b);\n    let max_width = 0;\n    for (let i = 1; i < xs.length; i++) {\n        max_width = Math.max(max_width, xs[i] - xs[i - 1]);\n    }\n    return max_width;\n}\n```\n\n    \n    1. Obtain all the x-coordinates from the given points, and store them in a new list (`xs`).\n2. Sort the x-coordinates in ascending order.\n3. Initialize the maximum width (`max_width`) to be 0.\n4. Iterate through the sorted x coordinates:\n   - For each consecutive pair of x-coordinates, calculate their difference.\n   - Update the `max_width` with the maximum value between the current `max_width` and the difference.\n5. Return the `max_width`.\n    "
    },
    {
        "id": 316,
        "title": "Sum of Unique Elements",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums`. The unique elements of an array are the elements that appear **exactly once** in the array.\n\nReturn _the **sum** of all the unique elements of_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,2\\]\n**Output:** 4\n**Explanation:** The unique elements are \\[1,3\\], and the sum is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,1\\]\n**Output:** 0\n**Explanation:** There are no unique elements, and the sum is 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** 15\n**Explanation:** The unique elements are \\[1,2,3,4,5\\], and the sum is 15."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,2,3,2]",
                "output": "4"
            },
            {
                "input": "[1,1,1,1,1]",
                "output": "0"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "15"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int bestTeamScore(int[] scores, int[] ages) {\n        int n = scores.length;\n        Integer[] indices = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n        \n        Arrays.sort(indices, (i, j) -> ages[i] == ages[j] ? scores[i] - scores[j] : ages[i] - ages[j]);\n        \n        int[] dp = new int[n];\n        int best_score = 0;\n        \n        for (int i = 0; i < n; i++) {\n            dp[i] = scores[indices[i]];\n            for (int j = 0; j < i; j++) {\n                if (scores[indices[i]] >= scores[indices[j]]) {\n                    dp[i] = Math.max(dp[i], dp[j] + scores[indices[i]]);\n                }\n            }\n            best_score = Math.max(best_score, dp[i]);\n        }\n        \n        return best_score;\n    }\n}\n```\n\n    \n    1. First, we create a new array/list (`players`) of pairs containing the players' ages and scores. \n2. Next, we sort the `players` array/list by age, followed by sorting by scores within the same age.\n3. We create a `dp` array/list of length `n` (number of players) initializing it with 0.\n4. Then, we iterate through each player in the sorted `players` array/list:\n    a. Set `dp[i]` to the current player's score.\n    b. Iterate through all previous players (0 to i-1) and check if the current player's score is greater or equal to the previous player's score. If true, set `dp[i]` to the maximum value between existing `dp[i]` and the sum of that previous player's DP value plus the current player's score.\n    c. Update the `best_score` with the maximum of its current value and `dp[i]` for each player.\n5. Lastly, return the `best_score` which represents the highest overall score of all possible basketball teams without conflicts.\n    ",
        "python": "\n    ```python\ndef bestTeamScore(scores, ages):\n    players = sorted(zip(ages, scores))\n    n = len(players)\n    dp = [0] * n\n    best_score = 0\n    \n    for i in range(n):\n        dp[i] = players[i][1]\n        for j in range(i):\n            if players[i][1] >= players[j][1]:\n                dp[i] = max(dp[i], dp[j] + players[i][1])\n        best_score = max(best_score, dp[i])\n    \n    return best_score\n```\n\n    \n    1. First, we create a new array/list (`players`) of pairs containing the players' ages and scores. \n2. Next, we sort the `players` array/list by age, followed by sorting by scores within the same age.\n3. We create a `dp` array/list of length `n` (number of players) initializing it with 0.\n4. Then, we iterate through each player in the sorted `players` array/list:\n    a. Set `dp[i]` to the current player's score.\n    b. Iterate through all previous players (0 to i-1) and check if the current player's score is greater or equal to the previous player's score. If true, set `dp[i]` to the maximum value between existing `dp[i]` and the sum of that previous player's DP value plus the current player's score.\n    c. Update the `best_score` with the maximum of its current value and `dp[i]` for each player.\n5. Lastly, return the `best_score` which represents the highest overall score of all possible basketball teams without conflicts.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint bestTeamScore(vector<int>& scores, vector<int>& ages) {\n    int n = scores.size();\n    vector<pair<int, int>> players(n);\n    \n    for (int i = 0; i < n; ++i) {\n        players[i] = {ages[i], scores[i]};\n    }\n    \n    sort(players.begin(), players.end());\n    \n    vector<int> dp(n);\n    int best_score = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i] = players[i].second;\n        for (int j = 0; j < i; ++j) {\n            if (players[i].second >= players[j].second) {\n                dp[i] = max(dp[i], dp[j] + players[i].second);\n            }\n        }\n        best_score = max(best_score, dp[i]);\n    }\n    \n    return best_score;\n}\n```\n\n    \n    1. First, we create a new array/list (`players`) of pairs containing the players' ages and scores. \n2. Next, we sort the `players` array/list by age, followed by sorting by scores within the same age.\n3. We create a `dp` array/list of length `n` (number of players) initializing it with 0.\n4. Then, we iterate through each player in the sorted `players` array/list:\n    a. Set `dp[i]` to the current player's score.\n    b. Iterate through all previous players (0 to i-1) and check if the current player's score is greater or equal to the previous player's score. If true, set `dp[i]` to the maximum value between existing `dp[i]` and the sum of that previous player's DP value plus the current player's score.\n    c. Update the `best_score` with the maximum of its current value and `dp[i]` for each player.\n5. Lastly, return the `best_score` which represents the highest overall score of all possible basketball teams without conflicts.\n    ",
        "js": "\n    ```javascript\nfunction bestTeamScore(scores, ages) {\n    const players = ages.map((age, index) => [age, scores[index]]);\n    players.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    \n    const n = players.length;\n    const dp = Array(n).fill(0);\n    let bestScore = 0;\n    \n    for (let i = 0; i < n; i++) {\n        dp[i] = players[i][1];\n        for (let j = 0; j < i; j++) {\n            if (players[i][1] >= players[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + players[i][1]);\n            }\n        }\n        bestScore = Math.max(bestScore, dp[i]);\n    }\n    \n    return bestScore;\n}\n```\n\n    \n    1. First, we create a new array/list (`players`) of pairs containing the players' ages and scores. \n2. Next, we sort the `players` array/list by age, followed by sorting by scores within the same age.\n3. We create a `dp` array/list of length `n` (number of players) initializing it with 0.\n4. Then, we iterate through each player in the sorted `players` array/list:\n    a. Set `dp[i]` to the current player's score.\n    b. Iterate through all previous players (0 to i-1) and check if the current player's score is greater or equal to the previous player's score. If true, set `dp[i]` to the maximum value between existing `dp[i]` and the sum of that previous player's DP value plus the current player's score.\n    c. Update the `best_score` with the maximum of its current value and `dp[i]` for each player.\n5. Lastly, return the `best_score` which represents the highest overall score of all possible basketball teams without conflicts.\n    "
    },
    {
        "id": 317,
        "title": "Check if Array Is Sorted and Rotated",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums`, return `true` _if the array was originally sorted in non-decreasing order, then rotated **some** number of positions (including zero)_. Otherwise, return `false`.\n\nThere may be **duplicates** in the original array.\n\n**Note:** An array `A` rotated by `x` positions results in an array `B` of the same length such that `A[i] == B[(i+x) % A.length]`, where `%` is the modulo operation.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** true\n**Explanation:** \\[1,2,3,4,5\\] is the original sorted array.\nYou can rotate the array by x = 3 positions to begin on the the element of value 3: \\[3,4,5,1,2\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,1,3,4\\]\n**Output:** false\n**Explanation:** There is no sorted array once rotated that can make nums.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** true\n**Explanation:** \\[1,2,3\\] is the original sorted array.\nYou can rotate the array by x = 0 positions (i.e. no rotation) to make nums."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[3,4,5,1,2]",
                "output": "true"
            },
            {
                "input": "[2,1,3,4]",
                "output": "false"
            },
            {
                "input": "[1,2,3]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {\n    List<Boolean> results = new ArrayList<>();\n    for(int i = 0; i < l.length; i++) {\n        int[] subarray = Arrays.copyOfRange(nums, l[i], r[i] + 1);\n        Arrays.sort(subarray);\n        boolean is_arithmetic = true;\n        int diff = subarray[1] - subarray[0];\n        for(int j = 1; j < subarray.length - 1; j++) {\n            if(subarray[j + 1] - subarray[j] != diff) {\n                is_arithmetic = false;\n                break;\n            }\n        }\n        results.add(is_arithmetic);\n    }\n    return results;\n}\n```\n\n    \n    1. For each element `i` in arrays `l` and `r`, create a subarray from `nums` using the range `[l[i], r[i]]`.\n2. Sort the subarray.\n3. Check if the subarray is an arithmetic sequence, by iterating through the subarray and making sure the difference between consecutive elements is the same.\n4. If the subarray is an arithmetic sequence, add `true` to the result array, otherwise, add `false`.\n5. Repeat this process for all the elements in arrays `l` and `r`.\n6. Return the results array containing the answers for each query.\n    ",
        "python": "\n    ```python\ndef check_arithmetic_subarrays(nums, l, r):\n    results = []\n    for i in range(len(l)):\n        subarray = sorted(nums[l[i]:r[i] + 1])\n        is_arithmetic = True\n        diff = subarray[1] - subarray[0]\n        for j in range(1, len(subarray) - 1):\n            if subarray[j + 1] - subarray[j] != diff:\n                is_arithmetic = False\n                break\n        results.append(is_arithmetic)\n    return results\n```\n\n    \n    1. For each element `i` in arrays `l` and `r`, create a subarray from `nums` using the range `[l[i], r[i]]`.\n2. Sort the subarray.\n3. Check if the subarray is an arithmetic sequence, by iterating through the subarray and making sure the difference between consecutive elements is the same.\n4. If the subarray is an arithmetic sequence, add `true` to the result array, otherwise, add `false`.\n5. Repeat this process for all the elements in arrays `l` and `r`.\n6. Return the results array containing the answers for each query.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {\n    vector<bool> results;\n    for(int i = 0; i < l.size(); i++) {\n        vector<int> subarray(nums.begin() + l[i], nums.begin() + r[i] + 1);\n        sort(subarray.begin(), subarray.end());\n        bool is_arithmetic = true;\n        int diff = subarray[1] - subarray[0];\n        for(int j = 1; j < subarray.size() - 1; j++) {\n            if(subarray[j + 1] - subarray[j] != diff) {\n                is_arithmetic = false;\n                break;\n            }\n        }\n        results.push_back(is_arithmetic);\n    }\n    return results;\n}\n```\n\n    \n    1. For each element `i` in arrays `l` and `r`, create a subarray from `nums` using the range `[l[i], r[i]]`.\n2. Sort the subarray.\n3. Check if the subarray is an arithmetic sequence, by iterating through the subarray and making sure the difference between consecutive elements is the same.\n4. If the subarray is an arithmetic sequence, add `true` to the result array, otherwise, add `false`.\n5. Repeat this process for all the elements in arrays `l` and `r`.\n6. Return the results array containing the answers for each query.\n    ",
        "js": "\n    ```javascript\nfunction checkArithmeticSubarrays(nums, l, r) {\n    const results = [];\n    for(let i = 0; i < l.length; i++) {\n        const subarray = nums.slice(l[i], r[i] + 1).sort((a, b) => a - b);\n        let is_arithmetic = true;\n        const diff = subarray[1] - subarray[0];\n        for(let j = 1; j < subarray.length - 1; j++) {\n            if(subarray[j + 1] - subarray[j] !== diff) {\n                is_arithmetic = false;\n                break;\n            }\n        }\n        results.push(is_arithmetic);\n    }\n    return results;\n}\n```\n\n    \n    1. For each element `i` in arrays `l` and `r`, create a subarray from `nums` using the range `[l[i], r[i]]`.\n2. Sort the subarray.\n3. Check if the subarray is an arithmetic sequence, by iterating through the subarray and making sure the difference between consecutive elements is the same.\n4. If the subarray is an arithmetic sequence, add `true` to the result array, otherwise, add `false`.\n5. Repeat this process for all the elements in arrays `l` and `r`.\n6. Return the results array containing the answers for each query.\n    "
    },
    {
        "id": 318,
        "title": "Minimum Changes To Make Alternating Binary String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` consisting only of the characters `'0'` and `'1'`. In one operation, you can change any `'0'` to `'1'` or vice versa.\n\nThe string is called alternating if no two adjacent characters are equal. For example, the string `\"010 \"` is alternating, while the string `\"0100 \"` is not.\n\nReturn _the **minimum** number of operations needed to make_ `s` _alternating_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"0100 \"\n**Output:** 1\n**Explanation:** If you change the last character to '1', s will be  \"0101 \", which is alternating.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10 \"\n**Output:** 0\n**Explanation:** s is already alternating.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"1111 \"\n**Output:** 2\n**Explanation:** You need two operations to reach  \"0101 \" or  \"1010 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s[i]` is either `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"0100\"",
                "output": "1"
            },
            {
                "input": "\"10\"",
                "output": "0"
            },
            {
                "input": "\"1111\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean canDistribute(int[] nums, int[] quantity) {\n    int[] counts = new int[51];\n    for (int num : nums) {\n        counts[num]++;\n    }\n\n    Arrays.sort(quantity);\n    int m = quantity.length;\n\n    return dfs(quantity, counts, m - 1);\n}\n\nprivate boolean dfs(int[] quantity, int[] counts, int idx) {\n    if (idx == -1) {\n        return true;\n    }\n    for (int i = 1; i <= 50; ++i) {\n        if (counts[i] >= quantity[idx]) {\n            counts[i] -= quantity[idx];\n            if (dfs(quantity, counts, idx - 1)) {\n                return true;\n            }\n            counts[i] += quantity[idx];\n        }\n    }\n    return false;\n}\n```\n\n    \n    1. Count the occurrences of each unique value in the `nums` list and store them in an array `counts`.\n2. Sort the `quantity` array in descending order.\n3. Define a depth-first search function `dfs` that takes the index `idx` of the current customer.\n   a. If `idx` reaches the total number of customers, all orders have been fulfilled so return true.\n   b. For each unique value, if its count in `counts` is greater than or equal to the current customer's order quantity, subtract the order quantity from its count and call `dfs` for the next customer (idx + 1).\n   c. If the quantity can be distributed successfully for the next customers, return true. Otherwise, restore the count in `counts` and continue to check the next unique value.\n4. Return the result of `dfs(0)` for the first customer's order fulfillment.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef canDistribute(nums: List[int], quantity: List[int]) -> bool:\n    counts = [0] * 51\n    for num in nums:\n        counts[num] += 1\n\n    quantity.sort(reverse=True)\n\n    def dfs(idx: int) -> bool:\n        if idx == len(quantity):\n            return True\n        for i in range(1, 51):\n            if counts[i] >= quantity[idx]:\n                counts[i] -= quantity[idx]\n                if dfs(idx + 1):\n                    return True\n                counts[i] += quantity[idx]\n        return False\n\n    return dfs(0)\n```\n\n    \n    1. Count the occurrences of each unique value in the `nums` list and store them in an array `counts`.\n2. Sort the `quantity` array in descending order.\n3. Define a depth-first search function `dfs` that takes the index `idx` of the current customer.\n   a. If `idx` reaches the total number of customers, all orders have been fulfilled so return true.\n   b. For each unique value, if its count in `counts` is greater than or equal to the current customer's order quantity, subtract the order quantity from its count and call `dfs` for the next customer (idx + 1).\n   c. If the quantity can be distributed successfully for the next customers, return true. Otherwise, restore the count in `counts` and continue to check the next unique value.\n4. Return the result of `dfs(0)` for the first customer's order fulfillment.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool canDistribute(vector<int>& nums, vector<int>& quantity) {\n    vector<int> counts(51, 0);\n    for (int num : nums) {\n        counts[num]++;\n    }\n\n    sort(quantity.rbegin(), quantity.rend());\n    \n    function<bool(int)> dfs = [&](int idx) {\n        if (idx == quantity.size()) {\n            return true;\n        }\n        for (int i = 1; i <= 50; ++i) {\n            if (counts[i] >= quantity[idx]) {\n                counts[i] -= quantity[idx];\n                if (dfs(idx + 1)) {\n                    return true;\n                }\n                counts[i] += quantity[idx];\n            }\n        }\n        return false;\n    };\n\n    return dfs(0);\n}\n```\n\n    \n    1. Count the occurrences of each unique value in the `nums` list and store them in an array `counts`.\n2. Sort the `quantity` array in descending order.\n3. Define a depth-first search function `dfs` that takes the index `idx` of the current customer.\n   a. If `idx` reaches the total number of customers, all orders have been fulfilled so return true.\n   b. For each unique value, if its count in `counts` is greater than or equal to the current customer's order quantity, subtract the order quantity from its count and call `dfs` for the next customer (idx + 1).\n   c. If the quantity can be distributed successfully for the next customers, return true. Otherwise, restore the count in `counts` and continue to check the next unique value.\n4. Return the result of `dfs(0)` for the first customer's order fulfillment.\n    ",
        "js": "\n    ```javascript\nfunction canDistribute(nums, quantity) {\n    const counts = new Array(51).fill(0);\n    for (const num of nums) {\n        counts[num]++;\n    }\n\n    quantity.sort((a, b) => b - a);\n\n    function dfs(idx) {\n        if (idx === quantity.length) {\n            return true;\n        }\n        for (let i = 1; i <= 50; ++i) {\n            if (counts[i] >= quantity[idx]) {\n                counts[i] -= quantity[idx];\n                if (dfs(idx + 1)) {\n                    return true;\n                }\n                counts[i] += quantity[idx];\n            }\n        }\n        return false;\n    }\n\n    return dfs(0);\n}\n```\n\n    \n    1. Count the occurrences of each unique value in the `nums` list and store them in an array `counts`.\n2. Sort the `quantity` array in descending order.\n3. Define a depth-first search function `dfs` that takes the index `idx` of the current customer.\n   a. If `idx` reaches the total number of customers, all orders have been fulfilled so return true.\n   b. For each unique value, if its count in `counts` is greater than or equal to the current customer's order quantity, subtract the order quantity from its count and call `dfs` for the next customer (idx + 1).\n   c. If the quantity can be distributed successfully for the next customers, return true. Otherwise, restore the count in `counts` and continue to check the next unique value.\n4. Return the result of `dfs(0)` for the first customer's order fulfillment.\n    "
    },
    {
        "id": 319,
        "title": "Longest Nice Substring",
        "difficulty": "Easy",
        "content": {
            "problem": "A string `s` is **nice** if, for every letter of the alphabet that `s` contains, it appears **both** in uppercase and lowercase. For example, `\"abABB \"` is nice because `'A'` and `'a'` appear, and `'B'` and `'b'` appear. However, `\"abA \"` is not because `'b'` appears, but `'B'` does not.\n\nGiven a string `s`, return _the longest **substring** of `s` that is **nice**. If there are multiple, return the substring of the **earliest** occurrence. If there are none, return an empty string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"YazaAay \"\n**Output:**  \"aAa \"\n**Explanation: ** \"aAa \" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.\n \"aAa \" is the longest nice substring.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"Bb \"\n**Output:**  \"Bb \"\n**Explanation:**  \"Bb \" is a nice string because both 'B' and 'b' appear. The whole string is a substring.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"c \"\n**Output:**  \" \"\n**Explanation:** There are no nice substrings."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of uppercase and lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Divide and Conquer",
            "Bit Manipulation",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"YazaAay\"",
                "output": "\"aAa\"\n**Explanation:**\"aAa\"isanicestringbecause'A/a'istheonlyletterofthealphabetins,andboth'A'and'a'appear.\n\"aAa\"isthelongestnicesubstring."
            },
            {
                "input": "\"Bb\"",
                "output": "\"Bb\""
            },
            {
                "input": "\"c\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String longestNiceSubstring(String s) {\n    int n = s.length();\n    String result = \"\";\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; ++j) {\n            boolean isNice = true;\n            loop:\n            for (char ch = 'A'; ch <= 'Z'; ++ch) {\n                boolean upper = false, lower = false;\n                for (int k = i; k <= j; ++k) {\n                    if (s.charAt(k) == ch) upper = true;\n                    if (s.charAt(k) == (ch + 32)) lower = true;\n                }\n                if ((upper && !lower) || (!upper && lower)) {\n                    isNice = false;\n                    break loop;\n                }\n            }\n            if (isNice && j - i + 1 > result.length()) {\n                result = s.substring(i, j + 1);\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through all possible substrings using two nested `for` loops. Then, for each substring, it checks if the substring is nice. If a substring is nice and its length is greater than the current longest nice substring found, it updates the result to store the new longest nice substring.\n\nSpecifically, in the innermost loop, the algorithm checks if there is any character (in uppercase form) present and missing its counterpart (lowercase form) or vice versa. If it finds such a pair, it marks the substring as not nice and breaks the loop. If the substring is nice, it updates the result if the substring is longer than the current longest nice substring found.\n    ",
        "python": "\n    ```python\ndef longestNiceSubstring(s: str) -> str:\n    n = len(s)\n    result = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            is_nice = True\n            for ch in range(ord('A'), ord('Z') + 1):\n                upper = chr(ch) in s[i:j+1]\n                lower = chr(ch + 32) in s[i:j+1]\n                if (upper and not lower) or (not upper and lower):\n                    is_nice = False\n                    break\n            if is_nice and j - i + 1 > len(result):\n                result = s[i:j+1]\n    return result\n```\n    \n    The algorithm iterates through all possible substrings using two nested `for` loops. Then, for each substring, it checks if the substring is nice. If a substring is nice and its length is greater than the current longest nice substring found, it updates the result to store the new longest nice substring.\n\nSpecifically, in the innermost loop, the algorithm checks if there is any character (in uppercase form) present and missing its counterpart (lowercase form) or vice versa. If it finds such a pair, it marks the substring as not nice and breaks the loop. If the substring is nice, it updates the result if the substring is longer than the current longest nice substring found.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring longestNiceSubstring(string s) {\n    int n = s.length();\n    string result = \"\";\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; ++j) {\n            bool isNice = true;\n            for (char ch = 'A'; ch <= 'Z'; ++ch) {\n                bool upper = false, lower = false;\n                for (int k = i; k <= j; ++k) {\n                    if (s[k] == ch) upper = true;\n                    if (s[k] == (ch + 32)) lower = true;\n                }\n                if ((upper && !lower) || (!upper && lower)) {\n                    isNice = false;\n                    break;\n                }\n            }\n            if (isNice && j - i + 1 > result.length()) {\n                result = s.substr(i, j - i + 1);\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through all possible substrings using two nested `for` loops. Then, for each substring, it checks if the substring is nice. If a substring is nice and its length is greater than the current longest nice substring found, it updates the result to store the new longest nice substring.\n\nSpecifically, in the innermost loop, the algorithm checks if there is any character (in uppercase form) present and missing its counterpart (lowercase form) or vice versa. If it finds such a pair, it marks the substring as not nice and breaks the loop. If the substring is nice, it updates the result if the substring is longer than the current longest nice substring found.\n    ",
        "js": "\n    ```javascript\nfunction longestNiceSubstring(s) {\n    let n = s.length;\n    let result = \"\";\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; ++j) {\n            let isNice = true;\n            for (let ch = 'A'.charCodeAt(0); ch <= 'Z'.charCodeAt(0); ++ch) {\n                let upper = false, lower = false;\n                for (let k = i; k <= j; ++k) {\n                    if (s.charCodeAt(k) == ch) upper = true;\n                    if (s.charCodeAt(k) == (ch + 32)) lower = true;\n                }\n                if ((upper && !lower) || (!upper && lower)) {\n                    isNice = false;\n                    break;\n                }\n            }\n            if (isNice && j - i + 1 > result.length) {\n                result = s.substring(i, j + 1);\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through all possible substrings using two nested `for` loops. Then, for each substring, it checks if the substring is nice. If a substring is nice and its length is greater than the current longest nice substring found, it updates the result to store the new longest nice substring.\n\nSpecifically, in the innermost loop, the algorithm checks if there is any character (in uppercase form) present and missing its counterpart (lowercase form) or vice versa. If it finds such a pair, it marks the substring as not nice and breaks the loop. If the substring is nice, it updates the result if the substring is longer than the current longest nice substring found.\n    "
    },
    {
        "id": 320,
        "title": "Merge Strings Alternately",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\nReturn _the merged string._",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"abc \", word2 =  \"pqr \"\n**Output:**  \"apbqcr \"\n**Explanation:** The merged string will be merged as so:\nword1:  a   b   c\nword2:    p   q   r\nmerged: a p b q c r\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"ab \", word2 =  \"pqrs \"\n**Output:**  \"apbqrs \"\n**Explanation:** Notice that as word2 is longer,  \"rs \" is appended to the end.\nword1:  a   b \nword2:    p   q   r   s\nmerged: a p b q   r   s\n\n",
                "**Example 3:**\n\n**Input:** word1 =  \"abcd \", word2 =  \"pq \"\n**Output:**  \"apbqcd \"\n**Explanation:** Notice that as word1 is longer,  \"cd \" is appended to the end.\nword1:  a   b   c   d\nword2:    p   q \nmerged: a p b q c   d"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 100`\n*   `word1` and `word2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"abc\",\"pqr\"",
                "output": "\"apbqcr\""
            },
            {
                "input": "\"ab\",\"pqrs\"",
                "output": "\"apbqrs\""
            },
            {
                "input": "\"abcd\",\"pq\"",
                "output": "\"apbqcd\""
            }
        ],
        "java": "\n    ```java\npublic String mergeAlternately(String word1, String word2) {\n    StringBuilder result = new StringBuilder();\n    int i = 0, j = 0;\n    while (i < word1.length() && j < word2.length()) {\n        result.append(word1.charAt(i++));\n        result.append(word2.charAt(j++));\n    }\n    while (i < word1.length()) result.append(word1.charAt(i++));\n    while (j < word2.length()) result.append(word2.charAt(j++));\n    return result.toString();\n}\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    ",
        "python": "\n    ```python\ndef mergeAlternately(word1: str, word2: str) -> str:\n    result = []\n    i, j = 0, 0\n    while i < len(word1) and j < len(word2):\n        result.append(word1[i])\n        result.append(word2[j])\n        i += 1\n        j += 1\n    result += word1[i:]\n    result += word2[j:]\n    return \"\".join(result)\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    ",
        "c++": "\n    ```cpp\nstd::string mergeAlternately(std::string word1, std::string word2) {\n    std::string result = \"\";\n    int i = 0, j = 0;\n    while (i < word1.length() && j < word2.length()) {\n        result += word1[i++];\n        result += word2[j++];\n    }\n    while (i < word1.length()) result += word1[i++];\n    while (j < word2.length()) result += word2[j++];\n    return result;\n}\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    ",
        "js": "\n    ```javascript\nfunction mergeAlternately(word1, word2) {\n    let result = \"\";\n    let i = 0, j = 0;\n    while (i < word1.length && j < word2.length) {\n        result += word1[i++];\n        result += word2[j++];\n    }\n    while (i < word1.length) result += word1[i++];\n    while (j < word2.length) result += word2[j++];\n    return result;\n}\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    "
    },
    {
        "id": 321,
        "title": "Count Items Matching a Rule",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `items`, where each `items[i] = [typei, colori, namei]` describes the type, color, and name of the `ith` item. You are also given a rule represented by two strings, `ruleKey` and `ruleValue`.\n\nThe `ith` item is said to match the rule if **one** of the following is true:\n\n*   `ruleKey == \"type \"` and `ruleValue == typei`.\n*   `ruleKey == \"color \"` and `ruleValue == colori`.\n*   `ruleKey == \"name \"` and `ruleValue == namei`.\n\nReturn _the number of items that match the given rule_.",
            "examples": [
                "**Example 1:**\n\n**Input:** items = \\[\\[ \"phone \", \"blue \", \"pixel \"\\],\\[ \"computer \", \"silver \", \"lenovo \"\\],\\[ \"phone \", \"gold \", \"iphone \"\\]\\], ruleKey =  \"color \", ruleValue =  \"silver \"\n**Output:** 1\n**Explanation:** There is only one item matching the given rule, which is \\[ \"computer \", \"silver \", \"lenovo \"\\].\n\n",
                "**Example 2:**\n\n**Input:** items = \\[\\[ \"phone \", \"blue \", \"pixel \"\\],\\[ \"computer \", \"silver \", \"phone \"\\],\\[ \"phone \", \"gold \", \"iphone \"\\]\\], ruleKey =  \"type \", ruleValue =  \"phone \"\n**Output:** 2\n**Explanation:** There are only two items matching the given rule, which are \\[ \"phone \", \"blue \", \"pixel \"\\] and \\[ \"phone \", \"gold \", \"iphone \"\\]. Note that the item \\[ \"computer \", \"silver \", \"phone \"\\] does not match."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= items.length <= 104`\n*   `1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10`\n*   `ruleKey` is equal to either `\"type \"`, `\"color \"`, or `\"name \"`.\n*   All strings consist only of lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]],\"color\",\"silver\"",
                "output": "1"
            },
            {
                "input": "[[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]],\"type\",\"phone\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n    int count = 0;\n    int index = ruleKey.equals(\"type\") ? 0 : (ruleKey.equals(\"color\") ? 1 : 2);\n    for (List<String> item : items) {\n        if (item.get(index).equals(ruleValue))\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "python": "\n    ```python\ndef countMatches(items, ruleKey, ruleValue):\n    count = 0\n    index = {\"type\": 0, \"color\": 1, \"name\": 2}[ruleKey]\n    for item in items:\n        if item[index] == ruleValue:\n            count += 1\n    return count\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) {\n    int count = 0;\n    int index = (ruleKey == \"type\" ? 0 : (ruleKey == \"color\" ? 1 : 2));\n    for (const auto& item : items) {\n        if (item[index] == ruleValue)\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "js": "\n    ```javascript\nfunction countMatches(items, ruleKey, ruleValue) {\n    let count = 0;\n    let index = ruleKey === \"type\" ? 0 : (ruleKey === \"color\" ? 1 : 2);\n    for (let item of items) {\n        if (item[index] === ruleValue)\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    "
    },
    {
        "id": 322,
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integers, `x` and `y`, which represent your current location on a Cartesian grid: `(x, y)`. You are also given an array `points` where each `points[i] = [ai, bi]` represents that a point exists at `(ai, bi)`. A point is **valid** if it shares the same x-coordinate or the same y-coordinate as your location.\n\nReturn _the index **(0-indexed)** of the **valid** point with the smallest **Manhattan distance** from your current location_. If there are multiple, return _the valid point with the **smallest** index_. If there are no valid points, return `-1`.\n\nThe **Manhattan distance** between two points `(x1, y1)` and `(x2, y2)` is `abs(x1 - x2) + abs(y1 - y2)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 3, y = 4, points = \\[\\[1,2\\],\\[3,1\\],\\[2,4\\],\\[2,3\\],\\[4,4\\]\\]\n**Output:** 2\n**Explanation:** Of all the points, only \\[3,1\\], \\[2,4\\] and \\[4,4\\] are valid. Of the valid points, \\[2,4\\] and \\[4,4\\] have the smallest Manhattan distance from your current location, with a distance of 1. \\[2,4\\] has the smallest index, so return 2.\n\n",
                "**Example 2:**\n\n**Input:** x = 3, y = 4, points = \\[\\[3,4\\]\\]\n**Output:** 0\n**Explanation:** The answer is allowed to be on the same location as your current location.\n\n",
                "**Example 3:**\n\n**Input:** x = 3, y = 4, points = \\[\\[2,3\\]\\]\n**Output:** -1\n**Explanation:** There are no valid points."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 104`\n*   `points[i].length == 2`\n*   `1 <= x, y, ai, bi <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "3,4,[[1,2],[3,1],[2,4],[2,3],[4,4]]",
                "output": "2"
            },
            {
                "input": "3,4,[[3,4]]",
                "output": "0"
            },
            {
                "input": "3,4,[[2,3]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int nearestValidPoint(int x, int y, int[][] points) {\n    int min_distance = Integer.MAX_VALUE, index = -1;\n    for (int i = 0; i < points.length; i++) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < min_distance) {\n                min_distance = distance;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    ",
        "python": "\n    ```python\ndef nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\n    min_distance = float(\"inf\")\n    index = -1\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                index = i\n    return index\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    ",
        "c++": "\n    ```cpp\nint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\n    int min_distance = INT_MAX, index = -1;\n    for (int i = 0; i < points.size(); i++) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = abs(x - points[i][0]) + abs(y - points[i][1]);\n            if (distance < min_distance) {\n                min_distance = distance;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    ",
        "js": "\n    ```javascript\nfunction nearestValidPoint(x, y, points) {\n    let min_distance = Number.MAX_VALUE, index = -1;\n    for (let i = 0; i < points.length; i++) {\n        if (x === points[i][0] || y === points[i][1]) {\n            const distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < min_distance) {\n                min_distance = distance;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    "
    },
    {
        "id": 323,
        "title": "Check if Binary String Has at Most One Segment of Ones",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary string `s` **without leading zeros**, return `true` _if_ `s` _contains **at most one contiguous segment of ones**_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1001 \"\n**Output:** false\n**Explanation:** The ones do not form a contiguous segment.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"110 \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s[i]` is either `'0'` or `'1'`.\n*   `s[0]` is `'1'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"1001\"",
                "output": "false"
            },
            {
                "input": "\"110\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minimumEnergy(int[][] tasks) {\n    Arrays.sort(tasks, (a, b) -> (b[1] - b[0]) - (a[1] - a[0]));\n\n    int energy = 0;\n    for (int[] task : tasks) {\n        energy = Math.max(energy + task[0], task[1]);\n    }\n    return energy;\n}\n```\n    \n    1. Sort the tasks in descending order based on the difference between the minimum energy required to start the task and the actual energy cost to complete the task `(minimum[i] - actual[i])`.\n2. Initialize the current energy to 0.\n3. Iterate through the sorted list of tasks, for each task:\n   - Calculate the maximum of the current energy plus the actual energy cost to complete the task, or the minimum energy required to start the task, and set it as the current energy.\n4. Return the current energy after processing all tasks. This will be the minimum initial amount of energy required to finish all tasks.\n    ",
        "python": "\n    ```python\ndef minimum_energy(tasks):\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n\n    energy = 0\n    for task in tasks:\n        energy = max(energy + task[0], task[1])\n    return energy\n```\n    \n    1. Sort the tasks in descending order based on the difference between the minimum energy required to start the task and the actual energy cost to complete the task `(minimum[i] - actual[i])`.\n2. Initialize the current energy to 0.\n3. Iterate through the sorted list of tasks, for each task:\n   - Calculate the maximum of the current energy plus the actual energy cost to complete the task, or the minimum energy required to start the task, and set it as the current energy.\n4. Return the current energy after processing all tasks. This will be the minimum initial amount of energy required to finish all tasks.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minimumEnergy(std::vector<std::vector<int>>& tasks) {\n    std::sort(tasks.begin(), tasks.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] - a[0] > b[1] - b[0];\n    });\n\n    int energy = 0;\n    for (const auto& task : tasks) {\n        energy = std::max(energy + task[0], task[1]);\n    }\n    return energy;\n}\n```\n    \n    1. Sort the tasks in descending order based on the difference between the minimum energy required to start the task and the actual energy cost to complete the task `(minimum[i] - actual[i])`.\n2. Initialize the current energy to 0.\n3. Iterate through the sorted list of tasks, for each task:\n   - Calculate the maximum of the current energy plus the actual energy cost to complete the task, or the minimum energy required to start the task, and set it as the current energy.\n4. Return the current energy after processing all tasks. This will be the minimum initial amount of energy required to finish all tasks.\n    ",
        "js": "\n    ```javascript\nfunction minimumEnergy(tasks) {\n    tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]));\n\n    let energy = 0;\n    for (let task of tasks) {\n        energy = Math.max(energy + task[0], task[1]);\n    }\n    return energy;\n}\n```\n    \n    1. Sort the tasks in descending order based on the difference between the minimum energy required to start the task and the actual energy cost to complete the task `(minimum[i] - actual[i])`.\n2. Initialize the current energy to 0.\n3. Iterate through the sorted list of tasks, for each task:\n   - Calculate the maximum of the current energy plus the actual energy cost to complete the task, or the minimum energy required to start the task, and set it as the current energy.\n4. Return the current energy after processing all tasks. This will be the minimum initial amount of energy required to finish all tasks.\n    "
    },
    {
        "id": 324,
        "title": "Check if One String Swap Can Make Strings Equal",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `s1` and `s2` of equal length. A **string swap** is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\n\nReturn `true` _if it is possible to make both strings equal by performing **at most one string swap** on **exactly one** of the strings._ Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"bank \", s2 =  \"kanb \"\n**Output:** true\n**Explanation:** For example, swap the first character with the last character of s2 to make  \"bank \".\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"attack \", s2 =  \"defend \"\n**Output:** false\n**Explanation:** It is impossible to make them equal with one string swap.\n\n",
                "**Example 3:**\n\n**Input:** s1 =  \"kelb \", s2 =  \"kelb \"\n**Output:** true\n**Explanation:** The two strings are already equal, so no string swap operation is required."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 100`\n*   `s1.length == s2.length`\n*   `s1` and `s2` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"bank\",\"kanb\"",
                "output": "true"
            },
            {
                "input": "\"attack\",\"defend\"",
                "output": "false"
            },
            {
                "input": "\"kelb\",\"kelb\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean areAlmostEqual(String s1, String s2) {\n    if(s1.equals(s2)) return true;\n    List<Integer> diff = new ArrayList<>();\n    for(int i = 0; i < s1.length(); i++) {\n        if(s1.charAt(i) != s2.charAt(i)) {\n            diff.add(i);\n        }\n    }\n    return diff.size() == 2 && s1.charAt(diff.get(0)) == s2.charAt(diff.get(1)) && s1.charAt(diff.get(1)) == s2.charAt(diff.get(0));\n}\n```\n    \n    1. Check if the two given strings are already equal, if so return `True`.\n2. Iterate through the characters of the strings, if the characters at the same index are different, store the index in a list called `diff`.\n3. Check if the `diff` list has exactly 2 indices, and if the character in s1 at the first index of `diff` is the same as the character in s2 at the second index of `diff`, and if the character in s1 at the second index of `diff` is the same as the character in s2 at the first index of `diff`. If these conditions are satisfied, return `True`, otherwise return `False`.\n    ",
        "python": "\n    ```python\ndef are_almost_equal(s1, s2):\n    if s1 == s2:\n        return True\n    diff = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    return len(diff) == 2 and s1[diff[0]] == s2[diff[1]] and s1[diff[1]] == s2[diff[0]]\n```\n    \n    1. Check if the two given strings are already equal, if so return `True`.\n2. Iterate through the characters of the strings, if the characters at the same index are different, store the index in a list called `diff`.\n3. Check if the `diff` list has exactly 2 indices, and if the character in s1 at the first index of `diff` is the same as the character in s2 at the second index of `diff`, and if the character in s1 at the second index of `diff` is the same as the character in s2 at the first index of `diff`. If these conditions are satisfied, return `True`, otherwise return `False`.\n    ",
        "c++": "\n    ```cpp\nbool areAlmostEqual(string s1, string s2) {\n    if(s1 == s2) return true;\n    vector<int> diff;\n    for(int i = 0; i < s1.length(); i++) {\n        if(s1[i] != s2[i]) {\n            diff.push_back(i);\n        }\n    }\n    return diff.size() == 2 && s1[diff[0]] == s2[diff[1]] && s1[diff[1]] == s2[diff[0]];\n}\n```\n    \n    1. Check if the two given strings are already equal, if so return `True`.\n2. Iterate through the characters of the strings, if the characters at the same index are different, store the index in a list called `diff`.\n3. Check if the `diff` list has exactly 2 indices, and if the character in s1 at the first index of `diff` is the same as the character in s2 at the second index of `diff`, and if the character in s1 at the second index of `diff` is the same as the character in s2 at the first index of `diff`. If these conditions are satisfied, return `True`, otherwise return `False`.\n    ",
        "js": "\n    ```javascript\nfunction areAlmostEqual(s1, s2) {\n    if(s1 === s2) return true;\n    let diff = [];\n    for(let i = 0; i < s1.length; i++) {\n        if(s1.charAt(i) !== s2.charAt(i)) {\n            diff.push(i);\n        }\n    }\n    return diff.length === 2 && s1.charAt(diff[0]) === s2.charAt(diff[1]) && s1.charAt(diff[1]) === s2.charAt(diff[0]);\n}\n```\n    \n    1. Check if the two given strings are already equal, if so return `True`.\n2. Iterate through the characters of the strings, if the characters at the same index are different, store the index in a list called `diff`.\n3. Check if the `diff` list has exactly 2 indices, and if the character in s1 at the first index of `diff` is the same as the character in s2 at the second index of `diff`, and if the character in s1 at the second index of `diff` is the same as the character in s2 at the first index of `diff`. If these conditions are satisfied, return `True`, otherwise return `False`.\n    "
    },
    {
        "id": 325,
        "title": "Find Center of Star Graph",
        "difficulty": "Easy",
        "content": {
            "problem": "There is an undirected **star** graph consisting of `n` nodes labeled from `1` to `n`. A star graph is a graph where there is one **center** node and **exactly** `n - 1` edges that connect the center node with every other node.\n\nYou are given a 2D integer array `edges` where each `edges[i] = [ui, vi]` indicates that there is an edge between the nodes `ui` and `vi`. Return the center of the given star graph.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[4,2\\]\\]\n**Output:** 2\n**Explanation:** As shown in the figure above, node 2 is connected to every other node, so 2 is the center.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[1,2\\],\\[5,1\\],\\[1,3\\],\\[1,4\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   The given `edges` represent a valid star graph.",
            "follow_up": null
        },
        "tag": [
            "Graph"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[4,2]]",
                "output": "2"
            },
            {
                "input": "[[1,2],[5,1],[1,3],[1,4]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maximumWealth(int[][] accounts) {\n    int maxWealth = 0;\n    for (int[] customer : accounts) {\n        int wealth = 0;\n        for (int account : customer) {\n            wealth += account;\n        }\n        maxWealth = Math.max(maxWealth, wealth);\n    }\n    return maxWealth;\n}\n```\n\n    \n    Iterate through each customer's accounts in the grid. For each customer, calculate the total wealth by summing the values of all their bank accounts. Compare the total wealth of each customer with the previously calculated maximum wealth, and set the maximum wealth to the current customer's wealth if it is greater. Continue this process for all customers and return the final maximum wealth value when finished. \n\nThe implementations in C++, Java, and JavaScript use loops or built-in functions to iterate through the grid and calculate the sums. Python uses a small one-liner to achieve the same result with a generator expression.\n    ",
        "python": "\n    ```python\ndef maximum_wealth(accounts):\n    return max(sum(customer) for customer in accounts)\n```\n\n    \n    Iterate through each customer's accounts in the grid. For each customer, calculate the total wealth by summing the values of all their bank accounts. Compare the total wealth of each customer with the previously calculated maximum wealth, and set the maximum wealth to the current customer's wealth if it is greater. Continue this process for all customers and return the final maximum wealth value when finished. \n\nThe implementations in C++, Java, and JavaScript use loops or built-in functions to iterate through the grid and calculate the sums. Python uses a small one-liner to achieve the same result with a generator expression.\n    ",
        "c++": "\n    ```cpp\nint maximumWealth(vector<vector<int>>& accounts) {\n    int max_wealth = 0;\n    for (const auto& customer : accounts) {\n        max_wealth = max(max_wealth, accumulate(customer.begin(), customer.end(), 0));\n    }\n    return max_wealth;\n}\n```\n\n    \n    Iterate through each customer's accounts in the grid. For each customer, calculate the total wealth by summing the values of all their bank accounts. Compare the total wealth of each customer with the previously calculated maximum wealth, and set the maximum wealth to the current customer's wealth if it is greater. Continue this process for all customers and return the final maximum wealth value when finished. \n\nThe implementations in C++, Java, and JavaScript use loops or built-in functions to iterate through the grid and calculate the sums. Python uses a small one-liner to achieve the same result with a generator expression.\n    ",
        "js": "\n    ```javascript\nfunction maximumWealth(accounts) {\n    return accounts.reduce((maxWealth, customer) =>\n        Math.max(maxWealth, customer.reduce((wealth, account) => wealth + account, 0)), 0);\n}\n```\n\n    \n    Iterate through each customer's accounts in the grid. For each customer, calculate the total wealth by summing the values of all their bank accounts. Compare the total wealth of each customer with the previously calculated maximum wealth, and set the maximum wealth to the current customer's wealth if it is greater. Continue this process for all customers and return the final maximum wealth value when finished. \n\nThe implementations in C++, Java, and JavaScript use loops or built-in functions to iterate through the grid and calculate the sums. Python uses a small one-liner to achieve the same result with a generator expression.\n    "
    },
    {
        "id": 326,
        "title": "Second Largest Digit in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an alphanumeric string `s`, return _the **second largest** numerical digit that appears in_ `s`_, or_ `-1` _if it does not exist_.\n\nAn **alphanumeric** string is a string consisting of lowercase English letters and digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"dfa12321afd \"\n**Output:** 2\n**Explanation:** The digits that appear in s are \\[1, 2, 3\\]. The second largest digit is 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abc1111 \"\n**Output:** -1\n**Explanation:** The digits that appear in s are \\[1\\]. There is no second largest digit."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of only lowercase English letters and/or digits.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"dfa12321afd\"",
                "output": "2"
            },
            {
                "input": "\"abc1111\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int secondHighest(String s) {\n    int largest = -1, second_largest = -1;\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            int d = c - '0';\n            if (d > largest) {\n                second_largest = largest;\n                largest = d;\n            } else if (d < largest && d > second_largest) {\n                second_largest = d;\n            }\n        }\n    }\n    return second_largest;\n}\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "python": "\n    ```python\ndef second_highest(s: str) -> int:\n    largest = -1\n    second_largest = -1\n    for c in s:\n        if c.isdigit():\n            d = int(c)\n            if d > largest:\n                second_largest = largest\n                largest = d\n            elif d < largest and d > second_largest:\n                second_largest = d\n    return second_largest\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "c++": "\n    ```cpp\nint secondHighest(string s) {\n    int largest = -1, second_largest = -1;\n    for (char c : s) {\n        if (isdigit(c)) {\n            int d = c - '0';\n            if (d > largest) {\n                second_largest = largest;\n                largest = d;\n            } else if (d < largest && d > second_largest) {\n                second_largest = d;\n            }\n        }\n    }\n    return second_largest;\n}\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "js": "\n    ```javascript\nfunction secondHighest(s) {\n    let largest = -1, second_largest = -1;\n    for (let c of s) {\n        if (!isNaN(c)) {\n            let d = parseInt(c);\n            if (d > largest) {\n                second_largest = largest;\n                largest = d;\n            } else if (d < largest && d > second_largest) {\n                second_largest = d;\n            }\n        }\n    }\n    return second_largest;\n}\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    "
    },
    {
        "id": 327,
        "title": "Maximum Ascending Subarray Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of positive integers `nums`, return the _maximum possible sum of an **ascending** subarray in_ `nums`.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nA subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[10,20,30,5,10,50\\]\n**Output:** 65\n**Explanation:** \\[5,10,50\\] is the ascending subarray with the maximum sum of 65.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,20,30,40,50\\]\n**Output:** 150\n**Explanation:** \\[10,20,30,40,50\\] is the ascending subarray with the maximum sum of 150.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[12,17,15,13,10,11,12\\]\n**Output:** 33\n**Explanation:** \\[10,11,12\\] is the ascending subarray with the maximum sum of 33."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[10,20,30,5,10,50]",
                "output": "65"
            },
            {
                "input": "[10,20,30,40,50]",
                "output": "150"
            },
            {
                "input": "[12,17,15,13,10,11,12]",
                "output": "33"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    public int concatenatedBinary(int n) {\n        long result = 0;\n        int mod = 1_000_000_007;\n        for (int i = 1; i <= n; ++i) {\n            int length = (int)(Math.log(i) / Math.log(2)) + 1;\n            result = ((result << length) % mod + i) % mod;\n        }\n        return (int) result;\n    }\n}\n```\n\n    \n    The algorithm iterates through all integers from 1 to `n`. For each integer, it first calculates its binary length (i.e. number of bits) using log base 2. This can be done using logarithm internally with floating point representation, followed by flooring and adding 1. In C++, you can use `log2`, in Java you can do `Math.log(i) / Math.log(2)`, and in JavaScript  `Math.log2`. \n\nThen, the result is shifted left by the calculated length (integer arithmetic is mostly used), and the current integer is added to the result. The whole operation is performed under modulo 109 + 7 to prevent overflow. In the end, the result is returned.\n    ",
        "python": "\n    ```python\ndef concatenated_binary(n: int) -> int:\n    result = 0\n    mod = 1000000007\n    for i in range(1, n + 1):\n        length = len(bin(i)) - 2\n        result = ((result << length) % mod + i) % mod\n    return result\n```\n\n    \n    The algorithm iterates through all integers from 1 to `n`. For each integer, it first calculates its binary length (i.e. number of bits) using log base 2. This can be done using logarithm internally with floating point representation, followed by flooring and adding 1. In C++, you can use `log2`, in Java you can do `Math.log(i) / Math.log(2)`, and in JavaScript  `Math.log2`. \n\nThen, the result is shifted left by the calculated length (integer arithmetic is mostly used), and the current integer is added to the result. The whole operation is performed under modulo 109 + 7 to prevent overflow. In the end, the result is returned.\n    ",
        "c++": "\n    ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint concatenatedBinary(int n) {\n    long long result = 0;\n    for (int i = 1; i <= n; ++i) {\n        int length = log2(i) + 1;\n        result = ((result << length) % 1000000007 + i) % 1000000007;\n    }\n    return result;\n}\n```\n\n    \n    The algorithm iterates through all integers from 1 to `n`. For each integer, it first calculates its binary length (i.e. number of bits) using log base 2. This can be done using logarithm internally with floating point representation, followed by flooring and adding 1. In C++, you can use `log2`, in Java you can do `Math.log(i) / Math.log(2)`, and in JavaScript  `Math.log2`. \n\nThen, the result is shifted left by the calculated length (integer arithmetic is mostly used), and the current integer is added to the result. The whole operation is performed under modulo 109 + 7 to prevent overflow. In the end, the result is returned.\n    ",
        "js": "\n    ```javascript\nfunction concatenatedBinary(n) {\n    let result = 0;\n    const mod = 1000000007;\n    for (let i = 1; i <= n; ++i) {\n        const length = Math.floor(Math.log2(i)) + 1;\n        result = ((result << length) % mod + i) % mod;\n    }\n    return result;\n}\n```\n\n    \n    The algorithm iterates through all integers from 1 to `n`. For each integer, it first calculates its binary length (i.e. number of bits) using log base 2. This can be done using logarithm internally with floating point representation, followed by flooring and adding 1. In C++, you can use `log2`, in Java you can do `Math.log(i) / Math.log(2)`, and in JavaScript  `Math.log2`. \n\nThen, the result is shifted left by the calculated length (integer arithmetic is mostly used), and the current integer is added to the result. The whole operation is performed under modulo 109 + 7 to prevent overflow. In the end, the result is returned.\n    "
    },
    {
        "id": 328,
        "title": "Number of Different Integers in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `word` that consists of digits and lowercase English letters.\n\nYou will replace every non-digit character with a space. For example, `\"a123bc34d8ef34 \"` will become `\" 123 34 8 34 \"`. Notice that you are left with some integers that are separated by at least one space: `\"123 \"`, `\"34 \"`, `\"8 \"`, and `\"34 \"`.\n\nReturn _the number of **different** integers after performing the replacement operations on_ `word`.\n\nTwo integers are considered different if their decimal representations **without any leading zeros** are different.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"a123bc34d8ef34 \"\n**Output:** 3\n**Explanation:** The three different integers are  \"123 \",  \"34 \", and  \"8 \". Notice that  \"34 \" is only counted once.\n\n",
                "**Example 2:**\n\n**Input:** word =  \"leet1234code234 \"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** word =  \"a1b01c001 \"\n**Output:** 1\n**Explanation:** The three integers  \"1 \",  \"01 \", and  \"001 \" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 1000`\n*   `word` consists of digits and lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"a123bc34d8ef34\"",
                "output": "3"
            },
            {
                "input": "\"leet1234code234\"",
                "output": "2"
            },
            {
                "input": "\"a1b01c001\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minMoves(int[] nums, int k) {\n    int n = nums.length;\n    ArrayList<Integer> ones = new ArrayList<>();\n    \n    for(int i = 0; i < n; ++i){\n        if(nums[i] == 1){\n            ones.add(i - ones.size());\n        }\n    }\n    \n    int moves = 0;\n    for(int i = 0; i < k; ++i){\n        moves += (ones.get(i) - ones.get(k / 2));\n    }\n    \n    int min_moves = moves;\n    for(int i = k; i < ones.size(); ++i){\n        moves += ones.get(i) - ones.get(i - k) - k;\n        min_moves = Math.min(min_moves, moves);\n    }\n    \n    return min_moves;\n}\n```\n\n    \n    First, we extract the positions of 1's into a new list and subtract the index of 1's to get the relative positions. Then we calculate the moves required to make the first k 1's consecutive. For each consecutive block of k 1's, we calculate the moves required to make them consecutive and update the minimum moves if it is less than the current minimum moves. To get the moves for the next block of k 1's, we just add the difference in positions and subtract k from the current moves, as one extra move is needed to move past the last 1 in the previous k 1's.\n    ",
        "python": "\n    ```python\ndef min_moves(nums, k):\n    n = len(nums)\n    ones = [i - j for i, j in enumerate(nums) if j == 1]\n    \n    moves = sum(ones[i] - ones[k // 2] for i in range(k))\n    min_moves = moves\n    \n    for i in range(k, len(ones)):\n        moves += ones[i] - ones[i - k] - k\n        min_moves = min(min_moves, moves)\n    \n    return min_moves\n```\n\n    \n    First, we extract the positions of 1's into a new list and subtract the index of 1's to get the relative positions. Then we calculate the moves required to make the first k 1's consecutive. For each consecutive block of k 1's, we calculate the moves required to make them consecutive and update the minimum moves if it is less than the current minimum moves. To get the moves for the next block of k 1's, we just add the difference in positions and subtract k from the current moves, as one extra move is needed to move past the last 1 in the previous k 1's.\n    ",
        "c++": "\n    ```cpp\nint minMoves(vector<int>& nums, int k) {\n    int n = nums.size();\n    vector<int> ones;\n    for(int i = 0; i < n; ++i){\n        if(nums[i] == 1){\n            ones.push_back(i - ones.size());\n        }\n    }\n    \n    int moves = 0;\n    for(int i = 0; i < k; ++i){\n        moves += (ones[i] - ones[k / 2]);\n    }\n    \n    int min_moves = moves;\n    for(int i = k; i < ones.size(); ++i){\n        moves += ones[i] - ones[i - k] - k;\n        min_moves = min(min_moves, moves);\n    }\n    \n    return min_moves;\n}\n```\n\n    \n    First, we extract the positions of 1's into a new list and subtract the index of 1's to get the relative positions. Then we calculate the moves required to make the first k 1's consecutive. For each consecutive block of k 1's, we calculate the moves required to make them consecutive and update the minimum moves if it is less than the current minimum moves. To get the moves for the next block of k 1's, we just add the difference in positions and subtract k from the current moves, as one extra move is needed to move past the last 1 in the previous k 1's.\n    ",
        "js": "\n    ```javascript\nfunction minMoves(nums, k) {\n    const n = nums.length;\n    const ones = [];\n    \n    for(let i = 0; i < n; ++i){\n        if(nums[i] === 1){\n            ones.push(i - ones.length);\n        }\n    }\n\n    let moves = 0;\n    for(let i = 0; i < k; ++i){\n        moves += (ones[i] - ones[k / 2]);\n    }\n\n    let min_moves = moves;\n    for(let i = k; i < ones.length; ++i){\n        moves += ones[i] - ones[i - k] - k;\n        min_moves = Math.min(min_moves, moves);\n    }\n\n    return min_moves;\n}\n```\n\n    \n    First, we extract the positions of 1's into a new list and subtract the index of 1's to get the relative positions. Then we calculate the moves required to make the first k 1's consecutive. For each consecutive block of k 1's, we calculate the moves required to make them consecutive and update the minimum moves if it is less than the current minimum moves. To get the moves for the next block of k 1's, we just add the difference in positions and subtract k from the current moves, as one extra move is needed to move past the last 1 in the previous k 1's.\n    "
    },
    {
        "id": 329,
        "title": "Determine Color of a Chessboard Square",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given `coordinates`, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\nReturn `true` _if the square is white, and_ `false` _if the square is black_.\n\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.",
            "examples": [
                "**Example 1:**\n\n**Input:** coordinates =  \"a1 \"\n**Output:** false\n**Explanation:** From the chessboard above, the square with coordinates  \"a1 \" is black, so return false.\n\n",
                "**Example 2:**\n\n**Input:** coordinates =  \"h3 \"\n**Output:** true\n**Explanation:** From the chessboard above, the square with coordinates  \"h3 \" is white, so return true.\n\n",
                "**Example 3:**\n\n**Input:** coordinates =  \"c7 \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `coordinates.length == 2`\n*   `'a' <= coordinates[0] <= 'h'`\n*   `'1' <= coordinates[1] <= '8'`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"a1\"",
                "output": "false"
            },
            {
                "input": "\"h3\"",
                "output": "true"
            },
            {
                "input": "\"c7\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic String reformatNumber(String number) {\n    String cleanedNumber = \"\";\n    for (char c : number.toCharArray()) {\n        if (Character.isDigit(c)) {\n            cleanedNumber += c;\n        }\n    }\n\n    List<String> blocks = new ArrayList<>();\n    int n = cleanedNumber.length();\n    for (int i = 0; i < n;) {\n        if (n - i == 2 || n - i == 4) {\n            blocks.add(cleanedNumber.substring(i, i + 2));\n            i += 2;\n        } else {\n            blocks.add(cleanedNumber.substring(i, i + 3));\n            i += 3;\n        }\n    }\n\n    String formattedNumber = blocks.get(0);\n    for (int i = 1; i < blocks.size(); i++) {\n        formattedNumber += '-' + blocks.get(i);\n    }\n    return formattedNumber;\n}\n```\n    \n    1. Remove all non-digit characters from the given phone number string.\n2. Create a list called `blocks` which will store the number groups.\n3. Loop through the cleaned number string:\n   - If there are exactly 2 or 4 digits remaining, add a group of 2 digits to `blocks`.\n   - Otherwise, add a group of 3 digits to `blocks`.\n4. Join the groups in `blocks` with dashes and return the resulting string.\n    ",
        "python": "\n    ```python\ndef reformat_number(number):\n    cleaned_number = ''.join(c for c in number if c.isdigit())\n\n    blocks = []\n    n = len(cleaned_number)\n    i = 0\n    while i < n:\n        if n - i == 2 or n - i == 4:\n            blocks.append(cleaned_number[i:i + 2])\n            i += 2\n        else:\n            blocks.append(cleaned_number[i:i + 3])\n            i += 3\n\n    return '-'.join(blocks)\n```\n    \n    1. Remove all non-digit characters from the given phone number string.\n2. Create a list called `blocks` which will store the number groups.\n3. Loop through the cleaned number string:\n   - If there are exactly 2 or 4 digits remaining, add a group of 2 digits to `blocks`.\n   - Otherwise, add a group of 3 digits to `blocks`.\n4. Join the groups in `blocks` with dashes and return the resulting string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string reformatNumber(std::string number) {\n    std::string cleaned_number;\n    for (char c : number) {\n        if (isdigit(c))\n            cleaned_number.push_back(c);\n    }\n\n    std::vector<std::string> blocks;\n    int n = cleaned_number.size();\n    int i = 0;\n    while (i < n) {\n        if (n - i == 2 || n - i == 4) {\n            blocks.push_back(cleaned_number.substr(i, 2));\n            i += 2;\n        } else {\n            blocks.push_back(cleaned_number.substr(i, 3));\n            i += 3;\n        }\n    }\n\n    std::string formatted_number = blocks[0];\n    for (int i = 1; i < blocks.size(); i++) {\n        formatted_number += '-' + blocks[i];\n    }\n    return formatted_number;\n}\n```\n    \n    1. Remove all non-digit characters from the given phone number string.\n2. Create a list called `blocks` which will store the number groups.\n3. Loop through the cleaned number string:\n   - If there are exactly 2 or 4 digits remaining, add a group of 2 digits to `blocks`.\n   - Otherwise, add a group of 3 digits to `blocks`.\n4. Join the groups in `blocks` with dashes and return the resulting string.\n    ",
        "js": "\n    ```javascript\nfunction reformatNumber(number) {\n    const cleanedNumber = number.replace(/\\D/g, '');\n\n    const blocks = [];\n    let n = cleanedNumber.length;\n    for (let i = 0; i < n;) {\n        if (n - i === 2 || n - i === 4) {\n            blocks.push(cleanedNumber.substr(i, 2));\n            i += 2;\n        } else {\n            blocks.push(cleanedNumber.substr(i, 3));\n            i += 3;\n        }\n    }\n\n    return blocks.join('-');\n}\n```\n    \n    1. Remove all non-digit characters from the given phone number string.\n2. Create a list called `blocks` which will store the number groups.\n3. Loop through the cleaned number string:\n   - If there are exactly 2 or 4 digits remaining, add a group of 2 digits to `blocks`.\n   - Otherwise, add a group of 3 digits to `blocks`.\n4. Join the groups in `blocks` with dashes and return the resulting string.\n    "
    },
    {
        "id": 330,
        "title": "Truncate Sentence",
        "difficulty": "Easy",
        "content": {
            "problem": "A **sentence** is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of **only** uppercase and lowercase English letters (no punctuation).\n\n*   For example, `\"Hello World \"`, `\"HELLO \"`, and `\"hello world hello world \"` are all sentences.\n\nYou are given a sentence `s` and an integer `k`. You want to **truncate** `s` such that it contains only the **first** `k` words. Return `s`_ after **truncating** it._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello how are you Contestant \", k = 4\n**Output:**  \"Hello how are you \"\n**Explanation:**\nThe words in s are \\[ \"Hello \",  \"how \"  \"are \",  \"you \",  \"Contestant \"\\].\nThe first 4 words are \\[ \"Hello \",  \"how \",  \"are \",  \"you \"\\].\nHence, you should return  \"Hello how are you \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"What is the solution to this problem \", k = 4\n**Output:**  \"What is the solution \"\n**Explanation:**\nThe words in s are \\[ \"What \",  \"is \"  \"the \",  \"solution \",  \"to \",  \"this \",  \"problem \"\\].\nThe first 4 words are \\[ \"What \",  \"is \",  \"the \",  \"solution \"\\].\nHence, you should return  \"What is the solution \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"chopper is not a tanuki \", k = 5\n**Output:**  \"chopper is not a tanuki \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `k` is in the range `[1, the number of words in s]`.\n*   `s` consist of only lowercase and uppercase English letters and spaces.\n*   The words in `s` are separated by a single space.\n*   There are no leading or trailing spaces.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "\"HellohowareyouContestant\",4",
                "output": "\"Hellohowareyou\""
            },
            {
                "input": "\"Whatisthesolutiontothisproblem\",4",
                "output": "\"Whatisthesolution\""
            },
            {
                "input": "\"chopperisnotatanuki\",5",
                "output": "\"chopperisnotatanuki\""
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public String truncateSentence(String s, int k) {\n        String[] words = s.split(\" \");\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; ++i) {\n            sb.append(words[i]).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n}\n```\n    \n    The algorithm for all languages is the same:\n1. First, we split the input string `s` by space character to get an array/list of words.\n2. Then, we slice this array/list so that only the first `k` words are included.\n3. Finally, we join the words back into a single string using space character, which is the final output string.\n\nUsing this common algorithm, we wrote functions for the respective programming languages. Note that in C++ and Java, we use a string stream and a string builder respectively for string manipulations as they are more efficient. On the other hand, in Python and JavaScript, slicing and joining strings are much easier to do with the built-in functions.\n    ",
        "python": "\n    ```python\ndef truncateSentence(s: str, k: int) -> str:\n    words = s.split()\n    return \" \".join(words[:k])\n```\n    \n    The algorithm for all languages is the same:\n1. First, we split the input string `s` by space character to get an array/list of words.\n2. Then, we slice this array/list so that only the first `k` words are included.\n3. Finally, we join the words back into a single string using space character, which is the final output string.\n\nUsing this common algorithm, we wrote functions for the respective programming languages. Note that in C++ and Java, we use a string stream and a string builder respectively for string manipulations as they are more efficient. On the other hand, in Python and JavaScript, slicing and joining strings are much easier to do with the built-in functions.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring truncateSentence(string s, int k) {\n    istringstream is(s);\n    string result, tmp;\n    while (k--) {\n        is >> tmp;\n        result += tmp + \" \";\n    }\n    result.pop_back();\n    return result;\n}\n```\n    \n    The algorithm for all languages is the same:\n1. First, we split the input string `s` by space character to get an array/list of words.\n2. Then, we slice this array/list so that only the first `k` words are included.\n3. Finally, we join the words back into a single string using space character, which is the final output string.\n\nUsing this common algorithm, we wrote functions for the respective programming languages. Note that in C++ and Java, we use a string stream and a string builder respectively for string manipulations as they are more efficient. On the other hand, in Python and JavaScript, slicing and joining strings are much easier to do with the built-in functions.\n    ",
        "js": "\n    ```javascript\nfunction truncateSentence(s, k) {\n    let words = s.split(\" \");\n    return words.slice(0, k).join(\" \");\n}\n```\n\n    \n    The algorithm for all languages is the same:\n1. First, we split the input string `s` by space character to get an array/list of words.\n2. Then, we slice this array/list so that only the first `k` words are included.\n3. Finally, we join the words back into a single string using space character, which is the final output string.\n\nUsing this common algorithm, we wrote functions for the respective programming languages. Note that in C++ and Java, we use a string stream and a string builder respectively for string manipulations as they are more efficient. On the other hand, in Python and JavaScript, slicing and joining strings are much easier to do with the built-in functions.\n    "
    },
    {
        "id": 331,
        "title": "Sign of the Product of an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a function `signFunc(x)` that returns:\n\n*   `1` if `x` is positive.\n*   `-1` if `x` is negative.\n*   `0` if `x` is equal to `0`.\n\nYou are given an integer array `nums`. Let `product` be the product of all values in the array `nums`.\n\nReturn `signFunc(product)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,-2,-3,-4,3,2,1\\]\n**Output:** 1\n**Explanation:** The product of all values in the array is 144, and signFunc(144) = 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,0,2,-3\\]\n**Output:** 0\n**Explanation:** The product of all values in the array is 0, and signFunc(0) = 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,1,-1,1,-1\\]\n**Output:** -1\n**Explanation:** The product of all values in the array is -1, and signFunc(-1) = -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-100 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[-1,-2,-3,-4,3,2,1]",
                "output": "1"
            },
            {
                "input": "[1,5,0,2,-3]",
                "output": "0"
            },
            {
                "input": "[-1,1,-1,1,-1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int signFunc(int x) {\n    if(x > 0) return 1;\n    if(x < 0) return -1;\n    return 0;\n}\n\npublic int arraySign(int[] nums) {\n    int product = 1;\n    for(int i = 0; i < nums.length; i++) {\n        product *= signFunc(nums[i]);\n    }\n    return product;\n}\n```\n    \n    For the algorithm, we first define a function `signFunc` that returns 1 if a number is positive, -1 if it's negative, and 0 if it's 0. Then, we initialize a variable `product` with the value 1. We iterate through the array `nums` and for each number, we multiply the value of `product` by the return value of `signFunc` called with that number as its argument. Finally, we return the value of `product`.\n\nThanks to this approach, we don't compute the actual product, which may cause an overflow. Instead, we directly calculate the result using the signs of the integers in the array, making the solution efficient and safe for big arrays with large integers.\n    ",
        "python": "\n    ```python\ndef signFunc(x):\n    if x > 0:\n        return 1\n    elif x < 0:\n        return -1\n    else:\n        return 0\n\ndef arraySign(nums):\n    product = 1\n    for num in nums:\n        product *= signFunc(num)\n    return product\n```\n    \n    For the algorithm, we first define a function `signFunc` that returns 1 if a number is positive, -1 if it's negative, and 0 if it's 0. Then, we initialize a variable `product` with the value 1. We iterate through the array `nums` and for each number, we multiply the value of `product` by the return value of `signFunc` called with that number as its argument. Finally, we return the value of `product`.\n\nThanks to this approach, we don't compute the actual product, which may cause an overflow. Instead, we directly calculate the result using the signs of the integers in the array, making the solution efficient and safe for big arrays with large integers.\n    ",
        "c++": "\n    ```cpp\nint signFunc(int x) {\n    if(x > 0) return 1;\n    if(x < 0) return -1;\n    return 0;\n}\n\nint arraySign(vector<int>& nums) {\n    int product = 1;\n    for(int i = 0; i < nums.size(); i++) {\n        product *= signFunc(nums[i]);\n    }\n    return product;\n}\n```\n    \n    For the algorithm, we first define a function `signFunc` that returns 1 if a number is positive, -1 if it's negative, and 0 if it's 0. Then, we initialize a variable `product` with the value 1. We iterate through the array `nums` and for each number, we multiply the value of `product` by the return value of `signFunc` called with that number as its argument. Finally, we return the value of `product`.\n\nThanks to this approach, we don't compute the actual product, which may cause an overflow. Instead, we directly calculate the result using the signs of the integers in the array, making the solution efficient and safe for big arrays with large integers.\n    ",
        "js": "\n    ```javascript\nfunction signFunc(x) {\n    if(x > 0) return 1;\n    if(x < 0) return -1;\n    return 0;\n}\n\nfunction arraySign(nums) {\n    let product = 1;\n    for(let i = 0; i < nums.length; i++) {\n        product *= signFunc(nums[i]);\n    }\n    return product;\n}\n```\n    \n    For the algorithm, we first define a function `signFunc` that returns 1 if a number is positive, -1 if it's negative, and 0 if it's 0. Then, we initialize a variable `product` with the value 1. We iterate through the array `nums` and for each number, we multiply the value of `product` by the return value of `signFunc` called with that number as its argument. Finally, we return the value of `product`.\n\nThanks to this approach, we don't compute the actual product, which may cause an overflow. Instead, we directly calculate the result using the signs of the integers in the array, making the solution efficient and safe for big arrays with large integers.\n    "
    },
    {
        "id": 332,
        "title": "Minimum Operations to Make the Array Increasing",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` (**0-indexed**). In one operation, you can choose an element of the array and increment it by `1`.\n\n*   For example, if `nums = [1,2,3]`, you can choose to increment `nums[1]` to make `nums = [1,**3**,3]`.\n\nReturn _the **minimum** number of operations needed to make_ `nums` _**strictly** **increasing**._\n\nAn array `nums` is **strictly increasing** if `nums[i] < nums[i+1]` for all `0 <= i < nums.length - 1`. An array of length `1` is trivially strictly increasing.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 3\n**Explanation:** You can do the following operations:\n1) Increment nums\\[2\\], so nums becomes \\[1,1,**2**\\].\n2) Increment nums\\[1\\], so nums becomes \\[1,**2**,2\\].\n3) Increment nums\\[2\\], so nums becomes \\[1,2,**3**\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,2,4,1\\]\n**Output:** 14\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[8\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `1 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,1,1]",
                "output": "3"
            },
            {
                "input": "[1,5,2,4,1]",
                "output": "14"
            },
            {
                "input": "[8]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += (nums[i - 1] - nums[i]) + 1\n            nums[i] = nums[i - 1] + 1\n    return operations\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ",
        "c++": "\n    ```cpp\nint min_operations(vector<int>& nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    let operations = 0;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    "
    },
    {
        "id": 333,
        "title": "Check if the Sentence Is Pangram",
        "difficulty": "Easy",
        "content": {
            "problem": "A **pangram** is a sentence where every letter of the English alphabet appears at least once.\n\nGiven a string `sentence` containing only lowercase English letters, return `true` _if_ `sentence` _is a **pangram**, or_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence =  \"thequickbrownfoxjumpsoverthelazydog \"\n**Output:** true\n**Explanation:** sentence contains at least one of every letter of the English alphabet.\n\n",
                "**Example 2:**\n\n**Input:** sentence =  \"leetcode \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 1000`\n*   `sentence` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"thequickbrownfoxjumpsoverthelazydog\"",
                "output": "true"
            },
            {
                "input": "\"leetcode\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\npublic int minOperations(int[] target, int[] arr) {\n    Map<Integer, Integer> indexMap = new HashMap<>();\n    for (int i = 0; i < target.length; ++i) {\n        indexMap.put(target[i], i);\n    }\n\n    int[] lis = new int[arr.length];\n    int lisSize = 0;\n    for (int num : arr) {\n        if (indexMap.containsKey(num)) {\n            int pos = Arrays.binarySearch(lis, 0, lisSize, indexMap.get(num));\n            if (pos < 0) {\n                pos = -(pos + 1);\n            }\n            lis[pos] = indexMap.get(num);\n            if (pos == lisSize) {\n                lisSize++;\n            }\n        }\n    }\n    \n    return target.length - lisSize;\n}\n```\n    \n    The algorithm first creates a mapping of the target integers to their index positions. This mapping will later be used to determine if a number in `arr` is in the target sequence and its relative order. It then initializes an empty list called `lis` (Longest Increasing Subsequence) and iterates through `arr`.\n\nFor each number `num` in `arr`, if it's also in the target, we check if that number can be appended to the end of `lis`. If not, it replaces the first number in `lis` that is greater than or equal to it to maintain the sorted order. This is done using `lowerBound` (C++, JavaScript) or `bisect_left` (Python) or `Arrays.binarySearch` (Java) functions - all of which perform binary search to find the position at which the new number should be inserted.\n\nFinally, the algorithm returns the difference between the lengths of the target sequence and `lis`, which represents the minimum number of operations needed to make `target` a subsequence of `arr`.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef min_operations(target, arr):\n    index_map = {num: i for i, num in enumerate(target)}\n\n    lis = []\n    for num in arr:\n        if num in index_map:\n            pos = bisect_left(lis, index_map[num])\n            if pos == len(lis):\n                lis.append(index_map[num])\n            else:\n                lis[pos] = index_map[num]\n\n    return len(target) - len(lis)\n```\n    \n    The algorithm first creates a mapping of the target integers to their index positions. This mapping will later be used to determine if a number in `arr` is in the target sequence and its relative order. It then initializes an empty list called `lis` (Longest Increasing Subsequence) and iterates through `arr`.\n\nFor each number `num` in `arr`, if it's also in the target, we check if that number can be appended to the end of `lis`. If not, it replaces the first number in `lis` that is greater than or equal to it to maintain the sorted order. This is done using `lowerBound` (C++, JavaScript) or `bisect_left` (Python) or `Arrays.binarySearch` (Java) functions - all of which perform binary search to find the position at which the new number should be inserted.\n\nFinally, the algorithm returns the difference between the lengths of the target sequence and `lis`, which represents the minimum number of operations needed to make `target` a subsequence of `arr`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint minOperations(std::vector<int>& target, std::vector<int>& arr) {\n    std::unordered_map<int, int> index_map;\n    for (int i = 0; i < target.size(); ++i) {\n        index_map[target[i]] = i;\n    }\n\n    std::vector<int> lis;\n    for (int num : arr) {\n        if (index_map.count(num)) {\n            int pos = std::lower_bound(lis.begin(), lis.end(), index_map[num]) - lis.begin();\n            if (pos == lis.size()) {\n                lis.push_back(index_map[num]);\n            } else {\n                lis[pos] = index_map[num];\n            }\n        }\n    }\n\n    return target.size() - lis.size();\n}\n```\n    \n    The algorithm first creates a mapping of the target integers to their index positions. This mapping will later be used to determine if a number in `arr` is in the target sequence and its relative order. It then initializes an empty list called `lis` (Longest Increasing Subsequence) and iterates through `arr`.\n\nFor each number `num` in `arr`, if it's also in the target, we check if that number can be appended to the end of `lis`. If not, it replaces the first number in `lis` that is greater than or equal to it to maintain the sorted order. This is done using `lowerBound` (C++, JavaScript) or `bisect_left` (Python) or `Arrays.binarySearch` (Java) functions - all of which perform binary search to find the position at which the new number should be inserted.\n\nFinally, the algorithm returns the difference between the lengths of the target sequence and `lis`, which represents the minimum number of operations needed to make `target` a subsequence of `arr`.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(target, arr) {\n    const indexMap = new Map();\n    \n    for (let i = 0; i < target.length; ++i) {\n        indexMap.set(target[i], i);\n    }\n\n    const lis = [];\n    for (const num of arr) {\n        if (indexMap.has(num)) {\n            const pos = lowerBound(lis, indexMap.get(num));\n            if (pos === lis.length) {\n                lis.push(indexMap.get(num));\n            } else {\n                lis[pos] = indexMap.get(num);\n            }\n        }\n    }\n\n    return target.length - lis.length;\n}\n\nfunction lowerBound(arr, target) {\n    let low = 0;\n    let high = arr.length;\n\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (arr[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n\n    return low;\n}\n```\n    \n    The algorithm first creates a mapping of the target integers to their index positions. This mapping will later be used to determine if a number in `arr` is in the target sequence and its relative order. It then initializes an empty list called `lis` (Longest Increasing Subsequence) and iterates through `arr`.\n\nFor each number `num` in `arr`, if it's also in the target, we check if that number can be appended to the end of `lis`. If not, it replaces the first number in `lis` that is greater than or equal to it to maintain the sorted order. This is done using `lowerBound` (C++, JavaScript) or `bisect_left` (Python) or `Arrays.binarySearch` (Java) functions - all of which perform binary search to find the position at which the new number should be inserted.\n\nFinally, the algorithm returns the difference between the lengths of the target sequence and `lis`, which represents the minimum number of operations needed to make `target` a subsequence of `arr`.\n    "
    },
    {
        "id": 334,
        "title": "Sum of Digits in Base K",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n` (in base `10`) and a base `k`, return _the **sum** of the digits of_ `n` _**after** converting_ `n` _from base_ `10` _to base_ `k`.\n\nAfter converting, each digit should be interpreted as a base `10` number, and the sum should be returned in base `10`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 34, k = 6\n**Output:** 9\n**Explanation:** 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.\n\n",
                "**Example 2:**\n\n**Input:** n = 10, k = 10\n**Output:** 1\n**Explanation:** n is already in base 10. 1 + 0 = 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`\n*   `2 <= k <= 10`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "34,6",
                "output": "9"
            },
            {
                "input": "10,10",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int sumBase(int n, int k) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % k;\n        n /= k;\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm is straightforward for converting a number from base 10 to base k and summing its digits. We use a while loop to repeatedly divide the number n by k, until n becomes 0. In each iteration, we add the remainder (n % k) to the sum, and update n by dividing it by k and taking the floor of the result. In the end, we return the sum.\n    ",
        "python": "\n    ```python\ndef sum_base(n: int, k: int) -> int:\n    s = 0\n    while n:\n        s += n % k\n        n //= k\n    return s\n```\n\n    \n    The algorithm is straightforward for converting a number from base 10 to base k and summing its digits. We use a while loop to repeatedly divide the number n by k, until n becomes 0. In each iteration, we add the remainder (n % k) to the sum, and update n by dividing it by k and taking the floor of the result. In the end, we return the sum.\n    ",
        "c++": "\n    ```cpp\nint sumBase(int n, int k) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % k;\n        n /= k;\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm is straightforward for converting a number from base 10 to base k and summing its digits. We use a while loop to repeatedly divide the number n by k, until n becomes 0. In each iteration, we add the remainder (n % k) to the sum, and update n by dividing it by k and taking the floor of the result. In the end, we return the sum.\n    ",
        "js": "\n    ```javascript\nfunction sumBase(n, k) {\n    let sum = 0;\n    while (n > 0) {\n        sum += n % k;\n        n = Math.floor(n / k);\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm is straightforward for converting a number from base 10 to base k and summing its digits. We use a while loop to repeatedly divide the number n by k, until n becomes 0. In each iteration, we add the remainder (n % k) to the sum, and update n by dividing it by k and taking the floor of the result. In the end, we return the sum.\n    "
    },
    {
        "id": 335,
        "title": "Replace All Digits with Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string `s` that has lowercase English letters in its **even** indices and digits in its **odd** indices.\n\nThere is a function `shift(c, x)`, where `c` is a character and `x` is a digit, that returns the `xth` character after `c`.\n\n*   For example, `shift('a', 5) = 'f'` and `shift('x', 0) = 'x'`.\n\nFor every **odd** index `i`, you want to replace the digit `s[i]` with `shift(s[i-1], s[i])`.\n\nReturn `s` _after replacing all digits. It is **guaranteed** that_ `shift(s[i-1], s[i])` _will never exceed_ `'z'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"a1c1e1 \"\n**Output:**  \"abcdef \"\n**Explanation:** The digits are replaced as follows:\n- s\\[1\\] -> shift('a',1) = 'b'\n- s\\[3\\] -> shift('c',1) = 'd'\n- s\\[5\\] -> shift('e',1) = 'f'\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a1b2c3d4e \"\n**Output:**  \"abbdcfdhe \"\n**Explanation:** The digits are replaced as follows:\n- s\\[1\\] -> shift('a',1) = 'b'\n- s\\[3\\] -> shift('b',2) = 'd'\n- s\\[5\\] -> shift('c',3) = 'f'\n- s\\[7\\] -> shift('d',4) = 'h'"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists only of lowercase English letters and digits.\n*   `shift(s[i-1], s[i]) <= 'z'` for all **odd** indices `i`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"a1c1e1\"",
                "output": "\"abcdef\""
            },
            {
                "input": "\"a1b2c3d4e\"",
                "output": "\"abbdcfdhe\""
            }
        ],
        "java": "\n    ```java\npublic int countBalls(int lowLimit, int highLimit) {\n    int[] boxCounts = new int[46];\n    for(int i = lowLimit; i <= highLimit; i++) {\n        int boxNumber = 0;\n        int num = i;\n        while(num != 0) {\n            boxNumber += num % 10;\n            num /= 10;\n        }\n        boxCounts[boxNumber]++;\n    }\n    return Arrays.stream(boxCounts).max().orElse(0);\n}\n```\n    \n    1. Initialize an array `boxCounts` with 46 elements, all set to 0. This array will store the counts of balls in each box. We use 46 because the maximum possible sum of digits for numbers in the range of the problem is 9 + 9 + 9 + 9 + 9 = 45.\n2. Iterate through numbers from `lowLimit` to `highLimit`, inclusive.\n3. For each number, calculate the sum of its digits (box number) using a while loop.\n4. Increment the count in `boxCounts` corresponding to the calculated box number.\n5. Once all numbers have been placed in boxes, return the maximum count in the `boxCounts` array.\n    ",
        "python": "\n    ```python\ndef count_balls(low_limit: int, high_limit: int) -> int:\n    box_counts = [0] * 46\n    for i in range(low_limit, high_limit + 1):\n        box_number = sum(map(int, str(i)))\n        box_counts[box_number] += 1\n    return max(box_counts)\n```\n    \n    1. Initialize an array `boxCounts` with 46 elements, all set to 0. This array will store the counts of balls in each box. We use 46 because the maximum possible sum of digits for numbers in the range of the problem is 9 + 9 + 9 + 9 + 9 = 45.\n2. Iterate through numbers from `lowLimit` to `highLimit`, inclusive.\n3. For each number, calculate the sum of its digits (box number) using a while loop.\n4. Increment the count in `boxCounts` corresponding to the calculated box number.\n5. Once all numbers have been placed in boxes, return the maximum count in the `boxCounts` array.\n    ",
        "c++": "\n    ```cpp\nint countBalls(int lowLimit, int highLimit) {\n    std::vector<int> boxCounts(46, 0);\n    for(int i = lowLimit; i <= highLimit; i++) {\n        int boxNumber = 0;\n        int num = i;\n        while(num) {\n            boxNumber += num % 10;\n            num /= 10;\n        }\n        boxCounts[boxNumber]++;\n    }\n    return *std::max_element(boxCounts.begin(), boxCounts.end());\n}\n```\n    \n    1. Initialize an array `boxCounts` with 46 elements, all set to 0. This array will store the counts of balls in each box. We use 46 because the maximum possible sum of digits for numbers in the range of the problem is 9 + 9 + 9 + 9 + 9 = 45.\n2. Iterate through numbers from `lowLimit` to `highLimit`, inclusive.\n3. For each number, calculate the sum of its digits (box number) using a while loop.\n4. Increment the count in `boxCounts` corresponding to the calculated box number.\n5. Once all numbers have been placed in boxes, return the maximum count in the `boxCounts` array.\n    ",
        "js": "\n    ```javascript\nfunction countBalls(lowLimit, highLimit) {\n    const boxCounts = new Array(46).fill(0);\n    for(let i = lowLimit; i <= highLimit; i++) {\n        let boxNumber = 0;\n        let num = i;\n        while(num) {\n            boxNumber += num % 10;\n            num = Math.floor(num / 10);\n        }\n        boxCounts[boxNumber]++;\n    }\n    return Math.max(...boxCounts);\n}\n```\n    \n    1. Initialize an array `boxCounts` with 46 elements, all set to 0. This array will store the counts of balls in each box. We use 46 because the maximum possible sum of digits for numbers in the range of the problem is 9 + 9 + 9 + 9 + 9 = 45.\n2. Iterate through numbers from `lowLimit` to `highLimit`, inclusive.\n3. For each number, calculate the sum of its digits (box number) using a while loop.\n4. Increment the count in `boxCounts` corresponding to the calculated box number.\n5. Once all numbers have been placed in boxes, return the maximum count in the `boxCounts` array.\n    "
    },
    {
        "id": 336,
        "title": "Maximum Population Year",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die.\n\nReturn _the **earliest** year with the **maximum population**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** logs = \\[\\[1993,1999\\],\\[2000,2010\\]\\]\n**Output:** 1993\n**Explanation:** The maximum population is 1, and 1993 is the earliest year with this population.\n\n",
                "**Example 2:**\n\n**Input:** logs = \\[\\[1950,1961\\],\\[1960,1971\\],\\[1970,1981\\]\\]\n**Output:** 1960\n**Explanation:** \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= logs.length <= 100`\n*   `1950 <= birthi < deathi <= 2050`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Counting",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1993,1999],[2000,2010]]",
                "output": "1993"
            },
            {
                "input": "[[1950,1961],[1960,1971],[1970,1981]]",
                "output": "1960"
            }
        ],
        "java": "\n    ```java\npublic int maxAliveYear(int[][] logs) {\n    int[] years = new int[101];\n    for (int[] log : logs) {\n        years[log[0] - 1950]++;\n        years[log[1] - 1950]--;\n    }\n    int max_population = years[0];\n    int max_year = 1950;\n    for (int i = 1; i < 101; i++) {\n        years[i] += years[i - 1];\n        if (years[i] > max_population) {\n            max_population = years[i];\n            max_year = i + 1950;\n        }\n    }\n    return max_year;\n}\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    ",
        "python": "\n    ```python\ndef maxAliveYear(logs):\n    years = [0] * 101\n    for log in logs:\n        years[log[0] - 1950] += 1\n        years[log[1] - 1950] -= 1\n    max_population = years[0]\n    max_year = 1950\n    for i in range(1, 101):\n        years[i] += years[i - 1]\n        if years[i] > max_population:\n            max_population = years[i]\n            max_year = i + 1950\n    return max_year\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    ",
        "c++": "\n    ```cpp\nint maxAliveYear(vector<vector<int>>& logs) {\n    vector<int> years(101, 0);\n    for (vector<int> log : logs) {\n        years[log[0] - 1950]++;\n        years[log[1] - 1950]--;\n    }\n    int max_population = years[0];\n    int max_year = 1950;\n    for (int i = 1; i < 101; i++) {\n        years[i] += years[i - 1];\n        if (years[i] > max_population) {\n            max_population = years[i];\n            max_year = i + 1950;\n        }\n    }\n    return max_year;\n}\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    ",
        "js": "\n    ```javascript\nfunction maxAliveYear(logs) {\n    let years = new Array(101).fill(0);\n    for (let log of logs) {\n        years[log[0] - 1950]++;\n        years[log[1] - 1950]--;\n    }\n    let max_population = years[0];\n    let max_year = 1950;\n    for (let i = 1; i < 101; i++) {\n        years[i] += years[i - 1];\n        if (years[i] > max_population) {\n            max_population = years[i];\n            max_year = i + 1950;\n        }\n    }\n    return max_year;\n}\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    "
    },
    {
        "id": 337,
        "title": "Sorting the Sentence",
        "difficulty": "Easy",
        "content": {
            "problem": "A **sentence** is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.\n\nA sentence can be **shuffled** by appending the **1-indexed word position** to each word then rearranging the words in the sentence.\n\n*   For example, the sentence `\"This is a sentence \"` can be shuffled as `\"sentence4 a3 is2 This1 \"` or `\"is2 sentence4 This1 a3 \"`.\n\nGiven a **shuffled sentence** `s` containing no more than `9` words, reconstruct and return _the original sentence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"is2 sentence4 This1 a3 \"\n**Output:**  \"This is a sentence \"\n**Explanation:** Sort the words in s to their original positions  \"This1 is2 a3 sentence4 \", then remove the numbers.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"Myself2 Me1 I4 and3 \"\n**Output:**  \"Me Myself and I \"\n**Explanation:** Sort the words in s to their original positions  \"Me1 Myself2 and3 I4 \", then remove the numbers."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 200`\n*   `s` consists of lowercase and uppercase English letters, spaces, and digits from `1` to `9`.\n*   The number of words in `s` is between `1` and `9`.\n*   The words in `s` are separated by a single space.\n*   `s` contains no leading or trailing spaces.\n\n1\\. All characters in a are strictly less than those in b (i.e., a\\[i\\] < b\\[i\\] for all i). 2. All characters in b are strictly less than those in a (i.e., a\\[i\\] > b\\[i\\] for all i). 3. All characters in a and b are the same (i.e., a\\[i\\] = b\\[i\\] for all i).",
            "follow_up": null
        },
        "tag": [
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"is2sentence4This1a3\"",
                "output": "\"Thisisasentence\""
            },
            {
                "input": "\"Myself2Me1I4and3\"",
                "output": "\"MeMyselfandI\""
            }
        ],
        "java": "\n    ```java\nint minOperationsToSatisfyConditions(String a, String b) {\n    int same = 0, less = 0, greater = 0;\n\n    for (int i = 0; i < a.length(); i++) {\n        if (a.charAt(i) == b.charAt(i)) same++;\n        else if (a.charAt(i) < b.charAt(i)) less++;\n        else greater++;\n    }\n\n    return Math.min(same + Math.max(less, greater), Math.min(less, greater));\n}\n```\n    \n    The algorithm keeps track of three counts: 'same', 'less', and 'greater'. These counts store the number of characters that are the same, less, and greater in string a compared to string b, respectively. Iterate through the characters in a and b simultaneously, comparing each character and updating the counts accordingly. The minimum number of operations needed to satisfy one of the three conditions is then calculated as the minimum of the sum of 'same' and the maximum of 'less' and 'greater', as well as 'less' and 'greater' individually. This is because you can either change all 'same' characters and one of 'less' or 'greater', or change only one of 'less' or 'greater' while keeping the other characters in the same order.\n\nThe time complexity of the algorithm is O(n) where n is the length of input strings a and b, as it iterates through each character pair in the strings once.\n    ",
        "python": "\n    ```python\ndef min_operations_to_satisfy_conditions(a: str, b: str) -> int:\n    same, less, greater = 0, 0, 0\n\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            same += 1\n        elif a[i] < b[i]:\n            less += 1\n        else:\n            greater += 1\n\n    return min(same + max(less, greater), less, greater)\n```\n    \n    The algorithm keeps track of three counts: 'same', 'less', and 'greater'. These counts store the number of characters that are the same, less, and greater in string a compared to string b, respectively. Iterate through the characters in a and b simultaneously, comparing each character and updating the counts accordingly. The minimum number of operations needed to satisfy one of the three conditions is then calculated as the minimum of the sum of 'same' and the maximum of 'less' and 'greater', as well as 'less' and 'greater' individually. This is because you can either change all 'same' characters and one of 'less' or 'greater', or change only one of 'less' or 'greater' while keeping the other characters in the same order.\n\nThe time complexity of the algorithm is O(n) where n is the length of input strings a and b, as it iterates through each character pair in the strings once.\n    ",
        "c++": "\n    ```cpp\nint minOperationsToSatisfyConditions(std::string a, std::string b) {\n    int same = 0, less = 0, greater = 0;\n    \n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) same++;\n        else if (a[i] < b[i]) less++;\n        else greater++;\n    }\n\n    return std::min({same + std::max(less, greater), less, greater});\n}\n```\n    \n    The algorithm keeps track of three counts: 'same', 'less', and 'greater'. These counts store the number of characters that are the same, less, and greater in string a compared to string b, respectively. Iterate through the characters in a and b simultaneously, comparing each character and updating the counts accordingly. The minimum number of operations needed to satisfy one of the three conditions is then calculated as the minimum of the sum of 'same' and the maximum of 'less' and 'greater', as well as 'less' and 'greater' individually. This is because you can either change all 'same' characters and one of 'less' or 'greater', or change only one of 'less' or 'greater' while keeping the other characters in the same order.\n\nThe time complexity of the algorithm is O(n) where n is the length of input strings a and b, as it iterates through each character pair in the strings once.\n    ",
        "js": "\n    ```javascript\nfunction minOperationsToSatisfyConditions(a, b) {\n    let same = 0, less = 0, greater = 0;\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] === b[i]) same++;\n        else if (a[i] < b[i]) less++;\n        else greater++;\n    }\n\n    return Math.min(same + Math.max(less, greater), Math.min(less, greater));\n}\n```\n    \n    The algorithm keeps track of three counts: 'same', 'less', and 'greater'. These counts store the number of characters that are the same, less, and greater in string a compared to string b, respectively. Iterate through the characters in a and b simultaneously, comparing each character and updating the counts accordingly. The minimum number of operations needed to satisfy one of the three conditions is then calculated as the minimum of the sum of 'same' and the maximum of 'less' and 'greater', as well as 'less' and 'greater' individually. This is because you can either change all 'same' characters and one of 'less' or 'greater', or change only one of 'less' or 'greater' while keeping the other characters in the same order.\n\nThe time complexity of the algorithm is O(n) where n is the length of input strings a and b, as it iterates through each character pair in the strings once.\n    "
    },
    {
        "id": 338,
        "title": "Sum of All Subset XOR Totals",
        "difficulty": "Easy",
        "content": {
            "problem": "The **XOR total** of an array is defined as the bitwise `XOR` of **all its elements**, or `0` if the array is **empty**.\n\n*   For example, the **XOR total** of the array `[2,5,6]` is `2 XOR 5 XOR 6 = 1`.\n\nGiven an array `nums`, return _the **sum** of all **XOR totals** for every **subset** of_ `nums`.\n\n**Note:** Subsets with the **same** elements should be counted **multiple** times.\n\nAn array `a` is a **subset** of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3\\]\n**Output:** 6\n**Explanation:** The 4 subsets of \\[1,3\\] are:\n- The empty subset has an XOR total of 0.\n- \\[1\\] has an XOR total of 1.\n- \\[3\\] has an XOR total of 3.\n- \\[1,3\\] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,1,6\\]\n**Output:** 28\n**Explanation:** The 8 subsets of \\[5,1,6\\] are:\n- The empty subset has an XOR total of 0.\n- \\[5\\] has an XOR total of 5.\n- \\[1\\] has an XOR total of 1.\n- \\[6\\] has an XOR total of 6.\n- \\[5,1\\] has an XOR total of 5 XOR 1 = 4.\n- \\[5,6\\] has an XOR total of 5 XOR 6 = 3.\n- \\[1,6\\] has an XOR total of 1 XOR 6 = 7.\n- \\[5,1,6\\] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,4,5,6,7,8\\]\n**Output:** 480\n**Explanation:** The sum of all XOR totals for every subset is 480."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 12`\n*   `1 <= nums[i] <= 20`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Backtracking",
            "Bit Manipulation",
            "Combinatorics",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[1,3]",
                "output": "6"
            },
            {
                "input": "[5,1,6]",
                "output": "28"
            },
            {
                "input": "[3,4,5,6,7,8]",
                "output": "480"
            }
        ],
        "java": "\n    ```java\npublic int subsetXORSum(int[] nums) {\n    int ans = 0, n = nums.length, max_val = 1 << n;\n    for (int i = 1; i < max_val; i++) {\n        int xor_total = 0;\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j)) > 0) {\n                xor_total ^= nums[j];\n            }\n        }\n        ans += xor_total;\n    }\n    return ans;\n}\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    ",
        "python": "\n    ```python\ndef subsetXORSum(nums):\n    ans = 0\n    n = len(nums)\n    max_val = 1 << n\n    for i in range(1, max_val):\n        xor_total = 0\n        for j in range(n):\n            if i & (1 << j):\n                xor_total ^= nums[j]\n        ans += xor_total\n    return ans\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    ",
        "c++": "\n    ```cpp\nint subsetXORSum(vector<int>& nums) {\n    int ans = 0, n = nums.size(), max_val = 1 << n;\n    for (int i = 1; i < max_val; i++) {\n        int xor_total = 0;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                xor_total ^= nums[j];\n            }\n        }\n        ans += xor_total;\n    }\n    return ans;\n}\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    ",
        "js": "\n    ```javascript\nfunction subsetXORSum(nums) {\n    let ans = 0, n = nums.length, max_val = 1 << n;\n    for (let i = 1; i < max_val; i++) {\n        let xor_total = 0;\n        for (let j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                xor_total ^= nums[j];\n            }\n        }\n        ans += xor_total;\n    }\n    return ans;\n}\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    "
    },
    {
        "id": 339,
        "title": "Longer Contiguous Segments of Ones than Zeros",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary string `s`, return `true` _if the **longest** contiguous segment of_ `1`'_s is **strictly longer** than the **longest** contiguous segment of_ `0`'_s in_ `s`, or return `false` _otherwise_.\n\n*   For example, in `s = \"110100010 \"` the longest continuous segment of `1`s has length `2`, and the longest continuous segment of `0`s has length `3`.\n\nNote that if there are no `0`'s, then the longest continuous segment of `0`'s is considered to have a length `0`. The same applies if there is no `1`'s.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1101 \"\n**Output:** true\n**Explanation:**\nThe longest contiguous segment of 1s has length 2:  \"1101 \"\nThe longest contiguous segment of 0s has length 1:  \"1101 \"\nThe segment of 1s is longer, so return true.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"111000 \"\n**Output:** false\n**Explanation:**\nThe longest contiguous segment of 1s has length 3:  \"111000 \"\nThe longest contiguous segment of 0s has length 3:  \"111000 \"\nThe segment of 1s is not longer, so return false.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"110100010 \"\n**Output:** false\n**Explanation:**\nThe longest contiguous segment of 1s has length 2:  \"110100010 \"\nThe longest contiguous segment of 0s has length 3:  \"110100010 \"\nThe segment of 1s is not longer, so return false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s[i]` is either `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"1101\"",
                "output": "true"
            },
            {
                "input": "\"111000\"",
                "output": "false"
            },
            {
                "input": "\"110100010\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean checkZeroOnes(String s) {\n    int max_ones = 0, max_zeros = 0, current_ones = 0, current_zeros = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '1') {\n            current_ones++;\n            current_zeros = 0;\n        } else {\n            current_zeros++;\n            current_ones = 0;\n        }\n        max_ones = Math.max(max_ones, current_ones);\n        max_zeros = Math.max(max_zeros, current_zeros);\n    }\n    return max_ones > max_zeros;\n}\n```\n    \n    We initialize 4 variables: `max_ones`, `max_zeros`, `current_ones`, and `current_zeros`. We then iterate through each character in the string. If we find `1`, we increment the `current_ones` counter and set the `current_zeros` count to 0, and if we find `0`, we increment the `current_zeros` counter and set the `current_ones` counter to 0. After each character, we update the maximum values of `max_ones` and `max_zeros` using the `max` function or `Math.max` function depending on the language. Finally, after iterating through the entire string, we compare the `max_ones` and `max_zeros` to determine if the longest continuous segment of `1`s is strictly longer than that of `0`s and return the result.\n    ",
        "python": "\n    ```python\ndef checkZeroOnes(s: str) -> bool:\n    max_ones, max_zeros, current_ones, current_zeros = 0, 0, 0, 0\n    for c in s:\n        if c == '1':\n            current_ones += 1\n            current_zeros = 0\n        else:\n            current_zeros += 1\n            current_ones = 0\n        max_ones = max(max_ones, current_ones)\n        max_zeros = max(max_zeros, current_zeros)\n    return max_ones > max_zeros\n```\n    \n    We initialize 4 variables: `max_ones`, `max_zeros`, `current_ones`, and `current_zeros`. We then iterate through each character in the string. If we find `1`, we increment the `current_ones` counter and set the `current_zeros` count to 0, and if we find `0`, we increment the `current_zeros` counter and set the `current_ones` counter to 0. After each character, we update the maximum values of `max_ones` and `max_zeros` using the `max` function or `Math.max` function depending on the language. Finally, after iterating through the entire string, we compare the `max_ones` and `max_zeros` to determine if the longest continuous segment of `1`s is strictly longer than that of `0`s and return the result.\n    ",
        "c++": "\n    ```cpp\nbool checkZeroOnes(string s) {\n    int max_ones = 0, max_zeros = 0, current_ones = 0, current_zeros = 0;\n    for (char c : s) {\n        if (c == '1') {\n            current_ones++;\n            current_zeros = 0;\n        } else {\n            current_zeros++;\n            current_ones = 0;\n        }\n        max_ones = max(max_ones, current_ones);\n        max_zeros = max(max_zeros, current_zeros);\n    }\n    return max_ones > max_zeros;\n}\n```\n    \n    We initialize 4 variables: `max_ones`, `max_zeros`, `current_ones`, and `current_zeros`. We then iterate through each character in the string. If we find `1`, we increment the `current_ones` counter and set the `current_zeros` count to 0, and if we find `0`, we increment the `current_zeros` counter and set the `current_ones` counter to 0. After each character, we update the maximum values of `max_ones` and `max_zeros` using the `max` function or `Math.max` function depending on the language. Finally, after iterating through the entire string, we compare the `max_ones` and `max_zeros` to determine if the longest continuous segment of `1`s is strictly longer than that of `0`s and return the result.\n    ",
        "js": "\n    ```javascript\nfunction checkZeroOnes(s) {\n    let max_ones = 0, max_zeros = 0, current_ones = 0, current_zeros = 0;\n    for (const c of s) {\n        if (c === '1') {\n            current_ones++;\n            current_zeros = 0;\n        } else {\n            current_zeros++;\n            current_ones = 0;\n        }\n        max_ones = Math.max(max_ones, current_ones);\n        max_zeros = Math.max(max_zeros, current_zeros);\n    }\n    return max_ones > max_zeros;\n}\n```\n    \n    We initialize 4 variables: `max_ones`, `max_zeros`, `current_ones`, and `current_zeros`. We then iterate through each character in the string. If we find `1`, we increment the `current_ones` counter and set the `current_zeros` count to 0, and if we find `0`, we increment the `current_zeros` counter and set the `current_ones` counter to 0. After each character, we update the maximum values of `max_ones` and `max_zeros` using the `max` function or `Math.max` function depending on the language. Finally, after iterating through the entire string, we compare the `max_ones` and `max_zeros` to determine if the longest continuous segment of `1`s is strictly longer than that of `0`s and return the result.\n    "
    },
    {
        "id": 340,
        "title": "Substrings of Size Three with Distinct Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "A string is **good** if there are no repeated characters.\n\nGiven a string `s`, return _the number of **good substrings** of length **three** in_ `s`.\n\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\n\nA **substring** is a contiguous sequence of characters in a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"xyzzaz \"\n**Output:** 1\n**Explanation:** There are 4 substrings of size 3:  \"xyz \",  \"yzz \",  \"zza \", and  \"zaz \". \nThe only good substring of length 3 is  \"xyz \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aababcabc \"\n**Output:** 4\n**Explanation:** There are 7 substrings of size 3:  \"aab \",  \"aba \",  \"bab \",  \"abc \",  \"bca \",  \"cab \", and  \"abc \".\nThe good substrings are  \"abc \",  \"bca \",  \"cab \", and  \"abc \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window",
            "Counting"
        ],
        "example": [
            {
                "input": "\"xyzzaz\"",
                "output": "1"
            },
            {
                "input": "\"aababcabc\"",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[][] highestIsland(int[][] isWater) {\n    int m = isWater.length;\n    int n = isWater[0].length;\n    int[][] height = new int[m][n];\n    Queue<int[]> q = new LinkedList<>();\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (isWater[i][j] == 1) {\n                height[i][j] = 0;\n                q.offer(new int[]{i, j});\n            } else {\n                height[i][j] = -1;\n            }\n        }\n    }\n\n    int[] dx = {-1, 0, 1, 0};\n    int[] dy = {0, 1, 0, -1};\n\n    while (!q.isEmpty()) {\n        int[] curr = q.poll();\n        int x = curr[0];\n        int y = curr[1];\n\n        for (int i = 0; i < 4; i++) {\n            int newX = x + dx[i];\n            int newY = y + dy[i];\n\n            if (newX >= 0 && newX < m && newY >= 0 && newY < n && height[newX][newY] == -1) {\n                height[newX][newY] = height[x][y] + 1;\n                q.offer(new int[]{newX, newY});\n            }\n        }\n    }\n\n    return height;\n}\n```\n    \n    The algorithm works by performing a breadth-first search (BFS) from each water cell (value 1). It first initializes the height matrix with -1 for all cells, except water cells are assigned height 0. It then pushes all water cells to the queue. This queue is used for BFS.\n\nInside the while loop, we dequeue the cell and explore its neighbors. If a neighbor cell's height is -1 (which means it hasn't been visited yet), we assign it a height that is one more than the height of the current cell, then push the neighbor into the queue. By doing this for all cells in the queue, we will eventually assign every cell its maximum possible height.\n\nThe time complexity of this algorithm is O(mn) since the BFS processes each cell once.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef highest_island(is_water):\n    m, n = len(is_water), len(is_water[0])\n    height = [[-1] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if is_water[i][j] == 1:\n                height[i][j] = 0\n                q.append((i, j))\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            newX = x + dx[i]\n            newY = y + dy[i]\n\n            if 0 <= newX < m and 0 <= newY < n and height[newX][newY] == -1:\n                height[newX][newY] = height[x][y] + 1\n                q.append((newX, newY))\n\n    return height\n```\n    \n    The algorithm works by performing a breadth-first search (BFS) from each water cell (value 1). It first initializes the height matrix with -1 for all cells, except water cells are assigned height 0. It then pushes all water cells to the queue. This queue is used for BFS.\n\nInside the while loop, we dequeue the cell and explore its neighbors. If a neighbor cell's height is -1 (which means it hasn't been visited yet), we assign it a height that is one more than the height of the current cell, then push the neighbor into the queue. By doing this for all cells in the queue, we will eventually assign every cell its maximum possible height.\n\nThe time complexity of this algorithm is O(mn) since the BFS processes each cell once.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> highestIsland(vector<vector<int>>& isWater) {\n    int m = isWater.size();\n    int n = isWater[0].size();\n    vector<vector<int>> height(m, vector<int>(n, -1));\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (isWater[i][j] == 1) {\n                height[i][j] = 0;\n                q.push({i, j});\n            }\n        }\n    }\n\n    vector<int> dx = {-1, 0, 1, 0};\n    vector<int> dy = {0, 1, 0, -1};\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        for (int i = 0; i < 4; i++) {\n            int newX = x + dx[i];\n            int newY = y + dy[i];\n\n            if (newX >= 0 && newX < m && newY >= 0 && newY < n && height[newX][newY] == -1) {\n                height[newX][newY] = height[x][y] + 1;\n                q.push({newX, newY});\n            }\n        }\n    }\n\n    return height;\n}\n```\n    \n    The algorithm works by performing a breadth-first search (BFS) from each water cell (value 1). It first initializes the height matrix with -1 for all cells, except water cells are assigned height 0. It then pushes all water cells to the queue. This queue is used for BFS.\n\nInside the while loop, we dequeue the cell and explore its neighbors. If a neighbor cell's height is -1 (which means it hasn't been visited yet), we assign it a height that is one more than the height of the current cell, then push the neighbor into the queue. By doing this for all cells in the queue, we will eventually assign every cell its maximum possible height.\n\nThe time complexity of this algorithm is O(mn) since the BFS processes each cell once.\n    ",
        "js": "\n    ```javascript\nfunction highestIsland(isWater) {\n    const m = isWater.length;\n    const n = isWater[0].length;\n    const height = Array.from({ length: m }, () => Array(n).fill(-1));\n    const q = [];\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (isWater[i][j] === 1) {\n                height[i][j] = 0;\n                q.push([i, j]);\n            }\n        }\n    }\n\n    const dx = [-1, 0, 1, 0];\n    const dy = [0, 1, 0, -1];\n\n    while (q.length) {\n        const [x, y] = q.shift();\n\n        for (let i = 0; i < 4; i++) {\n            const newX = x + dx[i];\n            const newY = y + dy[i];\n\n            if (newX >= 0 && newX < m && newY >= 0 && newY < n && height[newX][newY] === -1) {\n                height[newX][newY] = height[x][y] + 1;\n                q.push([newX, newY]);\n            }\n        }\n    }\n\n    return height;\n}\n```\n    \n    The algorithm works by performing a breadth-first search (BFS) from each water cell (value 1). It first initializes the height matrix with -1 for all cells, except water cells are assigned height 0. It then pushes all water cells to the queue. This queue is used for BFS.\n\nInside the while loop, we dequeue the cell and explore its neighbors. If a neighbor cell's height is -1 (which means it hasn't been visited yet), we assign it a height that is one more than the height of the current cell, then push the neighbor into the queue. By doing this for all cells in the queue, we will eventually assign every cell its maximum possible height.\n\nThe time complexity of this algorithm is O(mn) since the BFS processes each cell once.\n    "
    },
    {
        "id": 341,
        "title": "Check if Word Equals Summation of Two Words",
        "difficulty": "Easy",
        "content": {
            "problem": "The **letter value** of a letter is its position in the alphabet **starting from 0** (i.e. `'a' -> 0`, `'b' -> 1`, `'c' -> 2`, etc.).\n\nThe **numerical value** of some string of lowercase English letters `s` is the **concatenation** of the **letter values** of each letter in `s`, which is then **converted** into an integer.\n\n*   For example, if `s = \"acb \"`, we concatenate each letter's letter value, resulting in `\"021 \"`. After converting it, we get `21`.\n\nYou are given three strings `firstWord`, `secondWord`, and `targetWord`, each consisting of lowercase English letters `'a'` through `'j'` **inclusive**.\n\nReturn `true` _if the **summation** of the **numerical values** of_ `firstWord` _and_ `secondWord` _equals the **numerical value** of_ `targetWord`_, or_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** firstWord =  \"acb \", secondWord =  \"cba \", targetWord =  \"cdb \"\n**Output:** true\n**Explanation:**\nThe numerical value of firstWord is  \"acb \" ->  \"021 \" -> 21.\nThe numerical value of secondWord is  \"cba \" ->  \"210 \" -> 210.\nThe numerical value of targetWord is  \"cdb \" ->  \"231 \" -> 231.\nWe return true because 21 + 210 == 231.\n\n",
                "**Example 2:**\n\n**Input:** firstWord =  \"aaa \", secondWord =  \"a \", targetWord =  \"aab \"\n**Output:** false\n**Explanation:** \nThe numerical value of firstWord is  \"aaa \" ->  \"000 \" -> 0.\nThe numerical value of secondWord is  \"a \" ->  \"0 \" -> 0.\nThe numerical value of targetWord is  \"aab \" ->  \"001 \" -> 1.\nWe return false because 0 + 0 != 1.\n\n",
                "**Example 3:**\n\n**Input:** firstWord =  \"aaa \", secondWord =  \"a \", targetWord =  \"aaaa \"\n**Output:** true\n**Explanation:** \nThe numerical value of firstWord is  \"aaa \" ->  \"000 \" -> 0.\nThe numerical value of secondWord is  \"a \" ->  \"0 \" -> 0.\nThe numerical value of targetWord is  \"aaaa \" ->  \"0000 \" -> 0.\nWe return true because 0 + 0 == 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= firstWord.length,` `secondWord.length,` `targetWord.length <= 8`\n*   `firstWord`, `secondWord`, and `targetWord` consist of lowercase English letters from `'a'` to `'j'` **inclusive**.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"acb\",\"cba\",\"cdb\"",
                "output": "true"
            },
            {
                "input": "\"aaa\",\"a\",\"aab\"",
                "output": "false"
            },
            {
                "input": "\"aaa\",\"a\",\"aaaa\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic String largestMerge(String word1, String word2) {\n    StringBuilder merge = new StringBuilder();\n    while (!word1.isEmpty() || !word2.isEmpty()) {\n        if (word1.compareTo(word2) > 0) {\n            merge.append(word1.charAt(0));\n            word1 = word1.substring(1);\n        } else {\n            merge.append(word2.charAt(0));\n            word2 = word2.substring(1);\n        }\n    }\n    return merge.toString();\n}\n```\n    \n    The algorithm starts with two given strings, `word1` and `word2`. The goal is to create the lexicographically largest `merge` string by choosing characters from either of the input strings. The algorithm operates in a `while` loop that continues until both input strings are empty.\n\nIn each iteration of the loop, the algorithm compares the input strings lexicographically. If `word1` is lexicographically larger, it takes the first character of `word1`, appends it to the `merge` string, and removes it from the input string. If `word2` is lexicographically larger or equal, it does the same operation for `word2`.\n\nThis process continues until both input strings are empty, resulting in the lexicographically largest possible `merge` string. Then the `merge` string is returned.\n    ",
        "python": "\n    ```python\ndef largest_merge(word1: str, word2: str) -> str:\n    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)\n```\n    \n    The algorithm starts with two given strings, `word1` and `word2`. The goal is to create the lexicographically largest `merge` string by choosing characters from either of the input strings. The algorithm operates in a `while` loop that continues until both input strings are empty.\n\nIn each iteration of the loop, the algorithm compares the input strings lexicographically. If `word1` is lexicographically larger, it takes the first character of `word1`, appends it to the `merge` string, and removes it from the input string. If `word2` is lexicographically larger or equal, it does the same operation for `word2`.\n\nThis process continues until both input strings are empty, resulting in the lexicographically largest possible `merge` string. Then the `merge` string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string largestMerge(std::string word1, std::string word2) {\n    std::string merge = \"\";\n    while (!word1.empty() || !word2.empty()) {\n        if (word1 > word2) {\n            merge += word1[0];\n            word1 = word1.substr(1);\n        } else {\n            merge += word2[0];\n            word2 = word2.substr(1);\n        }\n    }\n    return merge;\n}\n```\n    \n    The algorithm starts with two given strings, `word1` and `word2`. The goal is to create the lexicographically largest `merge` string by choosing characters from either of the input strings. The algorithm operates in a `while` loop that continues until both input strings are empty.\n\nIn each iteration of the loop, the algorithm compares the input strings lexicographically. If `word1` is lexicographically larger, it takes the first character of `word1`, appends it to the `merge` string, and removes it from the input string. If `word2` is lexicographically larger or equal, it does the same operation for `word2`.\n\nThis process continues until both input strings are empty, resulting in the lexicographically largest possible `merge` string. Then the `merge` string is returned.\n    ",
        "js": "\n    ```javascript\nfunction largestMerge(word1, word2) {\n    let merge = \"\";\n    while (word1.length > 0 || word2.length > 0) {\n        if (word1.localeCompare(word2) > 0) {\n            merge += word1[0];\n            word1 = word1.slice(1);\n        } else {\n            merge += word2[0];\n            word2 = word2.slice(1);\n        }\n    }\n    return merge;\n}\n```\n    \n    The algorithm starts with two given strings, `word1` and `word2`. The goal is to create the lexicographically largest `merge` string by choosing characters from either of the input strings. The algorithm operates in a `while` loop that continues until both input strings are empty.\n\nIn each iteration of the loop, the algorithm compares the input strings lexicographically. If `word1` is lexicographically larger, it takes the first character of `word1`, appends it to the `merge` string, and removes it from the input string. If `word2` is lexicographically larger or equal, it does the same operation for `word2`.\n\nThis process continues until both input strings are empty, resulting in the lexicographically largest possible `merge` string. Then the `merge` string is returned.\n    "
    },
    {
        "id": 342,
        "title": "Determine Whether Matrix Can Be Obtained By Rotation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two `n x n` binary matrices `mat` and `target`, return `true` _if it is possible to make_ `mat` _equal to_ `target` _by **rotating**_ `mat` _in **90-degree increments**, or_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[0,1\\],\\[1,0\\]\\], target = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** true\n**Explanation:** We can rotate mat 90 degrees clockwise to make mat equal target.\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[0,1\\],\\[1,1\\]\\], target = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** false\n**Explanation:** It is impossible to make mat equal to target by rotating mat.\n\n",
                "**Example 3:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\], target = \\[\\[1,1,1\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** true\n**Explanation:** We can rotate mat 90 degrees clockwise two times to make mat equal target."
            ],
            "constraints": "**Constraints:**\n\n*   `n == mat.length == target.length`\n*   `n == mat[i].length == target[i].length`\n*   `1 <= n <= 10`\n*   `mat[i][j]` and `target[i][j]` are either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,1],[1,0]],[[1,0],[0,1]]",
                "output": "true"
            },
            {
                "input": "[[0,1],[1,1]],[[1,0],[0,1]]",
                "output": "false"
            },
            {
                "input": "[[0,0,0],[0,1,0],[1,1,1]],[[1,1,1],[0,1,0],[0,0,0]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minimumSize(int[] nums, int maxOperations) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    for (int num : nums) {\n        pq.offer(num);\n    }\n    while (maxOperations > 0) {\n        int maxBalls = pq.poll();\n        pq.offer(maxBalls / 2);\n        pq.offer(maxBalls - (maxBalls / 2));\n        maxOperations--;\n    }\n    return pq.peek();\n}\n```\n    \n    The algorithm is based on using a priority queue (max heap) to store the number of balls in each bag. In each operation, we remove the largest (or maximum) number of balls from the queue, divide this number by 2, and push both divided parts back into the queue. This operation is performed for given `maxOperations` times, and then we return the maximum number of balls in the bag (i.e., the top of the max heap). \n\nSince the priority queue maintains the order of elements, prioritizing the maximum number of balls, we can efficiently divide the balls in the largest bag in each operation, eventually minimizing the penalty after `maxOperations`.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef minimumSize(nums, maxOperations):\n    pq = [-num for num in nums] # Negative numbers to simulate max heap\n    heapq.heapify(pq)\n    while maxOperations > 0:\n        maxBalls = -heapq.heappop(pq)\n        heapq.heappush(pq, -maxBalls // 2)\n        heapq.heappush(pq, -(maxBalls - (maxBalls // 2)))\n        maxOperations -= 1\n    return -pq[0]\n```\n    \n    The algorithm is based on using a priority queue (max heap) to store the number of balls in each bag. In each operation, we remove the largest (or maximum) number of balls from the queue, divide this number by 2, and push both divided parts back into the queue. This operation is performed for given `maxOperations` times, and then we return the maximum number of balls in the bag (i.e., the top of the max heap). \n\nSince the priority queue maintains the order of elements, prioritizing the maximum number of balls, we can efficiently divide the balls in the largest bag in each operation, eventually minimizing the penalty after `maxOperations`.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint minimumSize(std::vector<int>& nums, int maxOperations) {\n    std::priority_queue<int> pq(nums.begin(), nums.end());\n    while (maxOperations > 0) {\n        int maxBalls = pq.top();\n        pq.pop();\n        pq.push(maxBalls / 2);\n        pq.push(maxBalls - (maxBalls / 2));\n        maxOperations--;\n    }\n    return pq.top();\n}\n```\n    \n    The algorithm is based on using a priority queue (max heap) to store the number of balls in each bag. In each operation, we remove the largest (or maximum) number of balls from the queue, divide this number by 2, and push both divided parts back into the queue. This operation is performed for given `maxOperations` times, and then we return the maximum number of balls in the bag (i.e., the top of the max heap). \n\nSince the priority queue maintains the order of elements, prioritizing the maximum number of balls, we can efficiently divide the balls in the largest bag in each operation, eventually minimizing the penalty after `maxOperations`.\n    ",
        "js": "\n    ```javascript\nfunction minimumSize(nums, maxOperations) {\n    const pq = new PriorityQueue((a, b) => b - a);\n    for (const num of nums) {\n        pq.offer(num);\n    }\n    while (maxOperations > 0) {\n        const maxBalls = pq.poll();\n        pq.offer(Math.floor(maxBalls / 2));\n        pq.offer(maxBalls - Math.floor(maxBalls / 2));\n        maxOperations--;\n    }\n    return pq.peek();\n}\n\nclass PriorityQueue {\n    constructor(comparator = (a, b) => a - b) {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n    size() {\n        return this._heap.length;\n    }\n    isEmpty() {\n        return this.size() == 0;\n    }\n    peek() {\n        return this._heap[0];\n    }\n    // Rest of the PriorityQueue implementation\n}\n```\n    \n    The algorithm is based on using a priority queue (max heap) to store the number of balls in each bag. In each operation, we remove the largest (or maximum) number of balls from the queue, divide this number by 2, and push both divided parts back into the queue. This operation is performed for given `maxOperations` times, and then we return the maximum number of balls in the bag (i.e., the top of the max heap). \n\nSince the priority queue maintains the order of elements, prioritizing the maximum number of balls, we can efficiently divide the balls in the largest bag in each operation, eventually minimizing the penalty after `maxOperations`.\n    "
    },
    {
        "id": 343,
        "title": "Check if All the Integers in a Range Are Covered",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a 2D integer array `ranges` and two integers `left` and `right`. Each `ranges[i] = [starti, endi]` represents an **inclusive** interval between `starti` and `endi`.\n\nReturn `true` _if each integer in the inclusive range_ `[left, right]` _is covered by **at least one** interval in_ `ranges`. Return `false` _otherwise_.\n\nAn integer `x` is covered by an interval `ranges[i] = [starti, endi]` if `starti <= x <= endi`.",
            "examples": [
                "**Example 1:**\n\n**Input:** ranges = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\]\\], left = 2, right = 5\n**Output:** true\n**Explanation:** Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.\n\n",
                "**Example 2:**\n\n**Input:** ranges = \\[\\[1,10\\],\\[10,20\\]\\], left = 21, right = 21\n**Output:** false\n**Explanation:** 21 is not covered by any range."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= ranges.length <= 50`\n*   `1 <= starti <= endi <= 50`\n*   `1 <= left <= right <= 50`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1,2],[3,4],[5,6]],2,5",
                "output": "true"
            },
            {
                "input": "[[1,10],[10,20]],21,21",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isCovered(int[][] ranges, int left, int right) {\n    for (int i = left; i <= right; i++) {\n        boolean found = false;\n        for (int[] range : ranges) {\n            if (i >= range[0] && i <= range[1]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the inclusive range `[left, right]` and checks if each integer is covered by at least one interval. To accomplish this, it iterates through each interval in `ranges` and checks if the current integer is within an interval in `ranges`. If the integer is within an interval, the loop breaks, and the next integer will be checked. If an integer is not within any of the intervals, the function returns `false`. Otherwise, the function returns `true` after all integers have been checked.\n    ",
        "python": "\n    ```python\ndef isCovered(ranges: List[List[int]], left: int, right: int) -> bool:\n    for i in range(left, right + 1):\n        found = False\n        for _range in ranges:\n            if _range[0] <= i <= _range[1]:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n```\n    \n    The algorithm iterates through the inclusive range `[left, right]` and checks if each integer is covered by at least one interval. To accomplish this, it iterates through each interval in `ranges` and checks if the current integer is within an interval in `ranges`. If the integer is within an interval, the loop breaks, and the next integer will be checked. If an integer is not within any of the intervals, the function returns `false`. Otherwise, the function returns `true` after all integers have been checked.\n    ",
        "c++": "\n    ```cpp\nbool isCovered(vector<vector<int>>& ranges, int left, int right) {\n    for (int i = left; i <= right; i++) {\n        bool found = false;\n        for (const auto& range : ranges) {\n            if (i >= range[0] && i <= range[1]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the inclusive range `[left, right]` and checks if each integer is covered by at least one interval. To accomplish this, it iterates through each interval in `ranges` and checks if the current integer is within an interval in `ranges`. If the integer is within an interval, the loop breaks, and the next integer will be checked. If an integer is not within any of the intervals, the function returns `false`. Otherwise, the function returns `true` after all integers have been checked.\n    ",
        "js": "\n    ```javascript\nfunction isCovered(ranges, left, right) {\n    for (let i = left; i <= right; i++) {\n        let found = false;\n        for (const range of ranges) {\n            if (i >= range[0] && i <= range[1]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the inclusive range `[left, right]` and checks if each integer is covered by at least one interval. To accomplish this, it iterates through each interval in `ranges` and checks if the current integer is within an interval in `ranges`. If the integer is within an interval, the loop breaks, and the next integer will be checked. If an integer is not within any of the intervals, the function returns `false`. Otherwise, the function returns `true` after all integers have been checked.\n    "
    },
    {
        "id": 344,
        "title": "Redistribute Characters to Make All Strings Equal",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of strings `words` (**0-indexed**).\n\nIn one operation, pick two **distinct** indices `i` and `j`, where `words[i]` is a non-empty string, and move **any** character from `words[i]` to **any** position in `words[j]`.\n\nReturn `true` _if you can make **every** string in_ `words` _**equal** using **any** number of operations_, _and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abc \", \"aabc \", \"bc \"\\]\n**Output:** true\n**Explanation:** Move the first 'a' in `words[1] to the front of words[2], to make` `words[1]` =  \"abc \" and words\\[2\\] =  \"abc \".\nAll the strings are now equal to  \"abc \", so return `true`.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"ab \", \"a \"\\]\n**Output:** false\n**Explanation:** It is impossible to make all the strings equal using the operation."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"abc\",\"aabc\",\"bc\"]",
                "output": "true"
            },
            {
                "input": "[\"ab\",\"a\"]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int longestPalindromeSubseq(String word1, String word2) {\n    int n = word1.length();\n    int m = word2.length();\n\n    int[][] dp = new int[1001][1001];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (word1.charAt(i) == word2.charAt(j)) {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            } else {\n                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n```\n    \n    1. Create a 2D array `dp` of size (word1.length + 1) x (word2.length + 1) to store the longest common subsequence for each prefix of word1 and word2.\n2. Initialize all elements of `dp` to 0.\n3. Iterate through each character in word1 and word2.\n4. If the characters at position `i` in word1 and `j` in word2 are equal, update `dp[i + 1][j + 1]` to `dp[i][j] + 1`.\n5. If the characters are not equal, update `dp[i + 1][j + 1]` to the maximum of `dp[i][j + 1]` and `dp[i + 1][j]`.\n6. Return the value at `dp[word1.length][word2.length]`, which is the length of the longest palindrome subsequence between word1 and word2.\n    ",
        "python": "\n    ```python\ndef longestPalindromeSubseq(word1, word2):\n    n, m = len(word1), len(word2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if word1[i] == word2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n\n    return dp[n][m]\n```\n    \n    1. Create a 2D array `dp` of size (word1.length + 1) x (word2.length + 1) to store the longest common subsequence for each prefix of word1 and word2.\n2. Initialize all elements of `dp` to 0.\n3. Iterate through each character in word1 and word2.\n4. If the characters at position `i` in word1 and `j` in word2 are equal, update `dp[i + 1][j + 1]` to `dp[i][j] + 1`.\n5. If the characters are not equal, update `dp[i + 1][j + 1]` to the maximum of `dp[i][j + 1]` and `dp[i + 1][j]`.\n6. Return the value at `dp[word1.length][word2.length]`, which is the length of the longest palindrome subsequence between word1 and word2.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nint longestPalindromeSubseq(string word1, string word2) {\n    int n = word1.length();\n    int m = word2.length();\n\n    int dp[1001][1001] = {0};\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (word1[i] == word2[j]) {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            } else {\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n```\n    \n    1. Create a 2D array `dp` of size (word1.length + 1) x (word2.length + 1) to store the longest common subsequence for each prefix of word1 and word2.\n2. Initialize all elements of `dp` to 0.\n3. Iterate through each character in word1 and word2.\n4. If the characters at position `i` in word1 and `j` in word2 are equal, update `dp[i + 1][j + 1]` to `dp[i][j] + 1`.\n5. If the characters are not equal, update `dp[i + 1][j + 1]` to the maximum of `dp[i][j + 1]` and `dp[i + 1][j]`.\n6. Return the value at `dp[word1.length][word2.length]`, which is the length of the longest palindrome subsequence between word1 and word2.\n    ",
        "js": "\n    ```javascript\nfunction longestPalindromeSubseq(word1, word2) {\n    const n = word1.length;\n    const m = word2.length;\n\n    const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(0));\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (word1[i] === word2[j]) {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            } else {\n                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n```\n    \n    1. Create a 2D array `dp` of size (word1.length + 1) x (word2.length + 1) to store the longest common subsequence for each prefix of word1 and word2.\n2. Initialize all elements of `dp` to 0.\n3. Iterate through each character in word1 and word2.\n4. If the characters at position `i` in word1 and `j` in word2 are equal, update `dp[i + 1][j + 1]` to `dp[i][j] + 1`.\n5. If the characters are not equal, update `dp[i + 1][j + 1]` to the maximum of `dp[i][j + 1]` and `dp[i + 1][j]`.\n6. Return the value at `dp[word1.length][word2.length]`, which is the length of the longest palindrome subsequence between word1 and word2.\n    "
    },
    {
        "id": 345,
        "title": "Largest Odd Number in String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `num`, representing a large integer. Return _the **largest-valued odd** integer (as a string) that is a **non-empty substring** of_ `num`_, or an empty string_ `\" \"` _if no odd integer exists_.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"52 \"\n**Output:**  \"5 \"\n**Explanation:** The only non-empty substrings are  \"5 \",  \"2 \", and  \"52 \".  \"5 \" is the only odd number.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"4206 \"\n**Output:**  \" \"\n**Explanation:** There are no odd numbers in  \"4206 \".\n\n",
                "**Example 3:**\n\n**Input:** num =  \"35427 \"\n**Output:**  \"35427 \"\n**Explanation:**  \"35427 \" is already an odd number."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 105`\n*   `num` only consists of digits and does not contain any leading zeros.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"52\"",
                "output": "\"5\""
            },
            {
                "input": "\"4206\"",
                "output": "\"\""
            },
            {
                "input": "\"35427\"",
                "output": "\"35427\""
            }
        ],
        "java": "\n    ```java\npublic String largestOddNumber(String num) {\n    for (int i = num.length() - 1; i >= 0; i--) {\n        if ((num.charAt(i) - '0') % 2 != 0) {\n            return num.substring(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ",
        "python": "\n    ```python\ndef largest_odd_number(num: str) -> str:\n    for i in range(len(num) - 1, -1, -1):\n        if int(num[i]) % 2 != 0:\n            return num[:i + 1]\n    return \"\"\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ",
        "c++": "\n    ```cpp\nstd::string largestOddNumber(std::string num) {\n    for (int i = num.length() - 1; i >= 0; i--) {\n        if ((num[i] - '0') % 2 != 0) {\n            return num.substr(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ",
        "js": "\n    ```javascript\nfunction largestOddNumber(num) {\n    for (let i = num.length - 1; i >= 0; i--) {\n        if ((num.charCodeAt(i) - '0'.charCodeAt(0)) % 2 !== 0) {\n            return num.slice(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    "
    },
    {
        "id": 346,
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, return `true` _if it can be made **strictly increasing** after removing **exactly one** element, or_ `false` _otherwise. If the array is already strictly increasing, return_ `true`.\n\nThe array `nums` is **strictly increasing** if `nums[i - 1] < nums[i]` for each index `(1 <= i < nums.length).`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,10,5,7\\]\n**Output:** true\n**Explanation:** By removing 10 at index 2 from nums, it becomes \\[1,2,5,7\\].\n\\[1,2,5,7\\] is strictly increasing, so return true.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,1,2\\]\n**Output:** false\n**Explanation:**\n\\[3,1,2\\] is the result of removing the element at index 0.\n\\[2,1,2\\] is the result of removing the element at index 1.\n\\[2,3,2\\] is the result of removing the element at index 2.\n\\[2,3,1\\] is the result of removing the element at index 3.\nNo resulting array is strictly increasing, so return false.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** false\n**Explanation:** The result of removing any element is \\[1,1\\].\n\\[1,1\\] is not strictly increasing, so return false."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,2,10,5,7]",
                "output": "true"
            },
            {
                "input": "[2,3,1,2]",
                "output": "false"
            },
            {
                "input": "[1,1,1]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean canBeIncreasing(int[] nums) {\n    int count = 0;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i - 1] >= nums[i]) {\n            count++;\n            if (count > 1) return false;\n            if (i > 1 && nums[i - 2] >= nums[i] && i < nums.length - 1 && nums[i - 1] >= nums[i + 1]) return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by initializing a counter variable `count` to keep track of the number of non-increasing sequences we find in the array `nums`. We iterate through the array starting from index 1 till the end of the array, and at each index, we check if the current element is greater than or equal to the previous element. If we find such elements, we increment the `count` by 1. We return `false` if `count` is greater than 1, as we can only remove exactly one element.\n\nWe also need to handle a special case: if removing the current element doesn't make the subarray strictly increasing, we return `false`. This happens if the element before the previous element is greater than or equal to the current element and the previous element is greater than or equal to the next element.\n\nIf we pass through the array without finding either of these conditions, we return `true`.\n    ",
        "python": "\n    ```python\ndef canBeIncreasing(nums):\n    count = 0\n    for i in range(1, len(nums)):\n        if nums[i - 1] >= nums[i]:\n            count += 1\n            if count > 1: return False\n            if i > 1 and nums[i - 2] >= nums[i] and i < len(nums) - 1 and nums[i - 1] >= nums[i + 1]: return False\n    return True\n```\n    \n    We start by initializing a counter variable `count` to keep track of the number of non-increasing sequences we find in the array `nums`. We iterate through the array starting from index 1 till the end of the array, and at each index, we check if the current element is greater than or equal to the previous element. If we find such elements, we increment the `count` by 1. We return `false` if `count` is greater than 1, as we can only remove exactly one element.\n\nWe also need to handle a special case: if removing the current element doesn't make the subarray strictly increasing, we return `false`. This happens if the element before the previous element is greater than or equal to the current element and the previous element is greater than or equal to the next element.\n\nIf we pass through the array without finding either of these conditions, we return `true`.\n    ",
        "c++": "\n    ```cpp\nbool canBeIncreasing(vector<int>& nums) {\n    int count = 0;\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i - 1] >= nums[i]) {\n            count++;\n            if (count > 1) return false;\n            if (i > 1 && nums[i - 2] >= nums[i] && i < nums.size() - 1 && nums[i - 1] >= nums[i + 1]) return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by initializing a counter variable `count` to keep track of the number of non-increasing sequences we find in the array `nums`. We iterate through the array starting from index 1 till the end of the array, and at each index, we check if the current element is greater than or equal to the previous element. If we find such elements, we increment the `count` by 1. We return `false` if `count` is greater than 1, as we can only remove exactly one element.\n\nWe also need to handle a special case: if removing the current element doesn't make the subarray strictly increasing, we return `false`. This happens if the element before the previous element is greater than or equal to the current element and the previous element is greater than or equal to the next element.\n\nIf we pass through the array without finding either of these conditions, we return `true`.\n    ",
        "js": "\n    ```javascript\nfunction canBeIncreasing(nums) {\n    let count = 0;\n    for (let i = 1; i < nums.length; ++i) {\n        if (nums[i - 1] >= nums[i]) {\n            count++;\n            if (count > 1) return false;\n            if (i > 1 && nums[i - 2] >= nums[i] && i < nums.length - 1 && nums[i - 1] >= nums[i + 1]) return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by initializing a counter variable `count` to keep track of the number of non-increasing sequences we find in the array `nums`. We iterate through the array starting from index 1 till the end of the array, and at each index, we check if the current element is greater than or equal to the previous element. If we find such elements, we increment the `count` by 1. We return `false` if `count` is greater than 1, as we can only remove exactly one element.\n\nWe also need to handle a special case: if removing the current element doesn't make the subarray strictly increasing, we return `false`. This happens if the element before the previous element is greater than or equal to the current element and the previous element is greater than or equal to the next element.\n\nIf we pass through the array without finding either of these conditions, we return `true`.\n    "
    },
    {
        "id": 347,
        "title": "Maximum Product Difference Between Two Pairs",
        "difficulty": "Easy",
        "content": {
            "problem": "The **product difference** between two pairs `(a, b)` and `(c, d)` is defined as `(a * b) - (c * d)`.\n\n*   For example, the product difference between `(5, 6)` and `(2, 7)` is `(5 * 6) - (2 * 7) = 16`.\n\nGiven an integer array `nums`, choose four **distinct** indices `w`, `x`, `y`, and `z` such that the **product difference** between pairs `(nums[w], nums[x])` and `(nums[y], nums[z])` is **maximized**.\n\nReturn _the **maximum** such product difference_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,6,2,7,4\\]\n**Output:** 34\n**Explanation:** We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\nThe product difference is (6 \\* 7) - (2 \\* 4) = 34.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,2,5,9,7,4,8\\]\n**Output:** 64\n**Explanation:** We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\nThe product difference is (9 \\* 8) - (2 \\* 4) = 64."
            ],
            "constraints": "**Constraints:**\n\n*   `4 <= nums.length <= 104`\n*   `1 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[5,6,2,7,4]",
                "output": "34"
            },
            {
                "input": "[4,2,5,9,7,4,8]",
                "output": "64"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int minChanges(int[] nums, int k) {\n    int n = nums.length;\n    int[] xor_prefix = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1];\n    }\n\n    HashMap<Integer, Integer>[] dp = new HashMap[k];\n    int[] min_dp = new int[k];\n    for (int j = 0; j < k; ++j) {\n        dp[j] = new HashMap<>();\n        min_dp[j] = n;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        int x = xor_prefix[i] ^ xor_prefix[i - k];\n\n        if (i >= k) {\n            dp[0].put(x, dp[0].getOrDefault(x, 0) + 1);\n        }\n\n        for (int j = 1; i - j * k >= 0; ++j) {\n            dp[j].put(x, dp[j].getOrDefault(x, 0) + 1);\n            min_dp[j] = Math.min(min_dp[j], dp[j - 1].getOrDefault(x, 0) - dp[j].getOrDefault(x, 0));\n        }\n    }\n\n    int answer = n;\n    for (int j = 0; j < k; ++j) {\n        answer = Math.min(answer, min_dp[j] + j);\n    }\n    return answer;\n}\n```\n    \n    We first create a prefix XOR array called `xor_prefix`, containing the XOR values from the start of the original input array `nums` to each element in `xor_prefix`. We then initialize our dynamic programming table `dp`, which is an array of maps, and an array `min_dp`, that will be used to store the minimum elements to change.\n\nWe iterate through the prefix XOR array, calculating the XOR of the prefixes considering the length of k, and we store the count of the occurrences where the XOR is equal to zero.\n\nFor each possible combination of segment size and occurrences, we update our `dp` table and the `min_dp` array accordingly. \n\nFinally, we iterate through the `min_dp` array to find the minimum number of elements to change, implying that the XOR of all segments is equal to zero. We return the minimum value found. \n    ",
        "python": "\n    ```python\ndef min_changes(nums, k):\n    n = len(nums)\n    xor_prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1]\n\n    dp = [{} for _ in range(k)]\n    min_dp = [n] * k\n\n    for i in range(1, n + 1):\n        x = xor_prefix[i] ^ xor_prefix[i - k]\n\n        if i >= k:\n            dp[0][x] = dp[0].get(x, 0) + 1\n\n        for j in range(1, 1 + (i - j * k) // k):\n            if x in dp[j - 1]:\n                dp[j][x] = dp[j].get(x, 0) + 1\n                min_dp[j] = min(min_dp[j], dp[j - 1][x] - dp[j][x])\n\n    return min(n, [min_dp[j] + j for j in range(k)])\n```\n    \n    We first create a prefix XOR array called `xor_prefix`, containing the XOR values from the start of the original input array `nums` to each element in `xor_prefix`. We then initialize our dynamic programming table `dp`, which is an array of maps, and an array `min_dp`, that will be used to store the minimum elements to change.\n\nWe iterate through the prefix XOR array, calculating the XOR of the prefixes considering the length of k, and we store the count of the occurrences where the XOR is equal to zero.\n\nFor each possible combination of segment size and occurrences, we update our `dp` table and the `min_dp` array accordingly. \n\nFinally, we iterate through the `min_dp` array to find the minimum number of elements to change, implying that the XOR of all segments is equal to zero. We return the minimum value found. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint minChanges(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    std::vector<int> xor_prefix(n+1);\n    for (int i = 1; i <= n; ++i) {\n        xor_prefix[i] = xor_prefix[i-1] ^ nums[i-1];\n    }\n    \n    std::vector<std::unordered_map<int, int>> dp(k);\n    std::vector<int> min_dp(k, n);\n    \n    for (int i = 1; i <= n; ++i) {\n        int x = xor_prefix[i] ^ xor_prefix[i - k];\n        \n        if (i >= k) {\n            dp[0][x]++;\n        }\n        \n        for (int j = 1; i - j * k >= 0; ++j) {\n            dp[j][x]++;\n            min_dp[j] = std::min(min_dp[j], dp[j-1][x] - dp[j][x]);\n        }\n    }\n    \n    int answer = n;\n    for (int j = 0; j < k; ++j) {\n        answer = std::min(answer, min_dp[j] + j);\n    }\n    return answer;\n}\n```\n    \n    We first create a prefix XOR array called `xor_prefix`, containing the XOR values from the start of the original input array `nums` to each element in `xor_prefix`. We then initialize our dynamic programming table `dp`, which is an array of maps, and an array `min_dp`, that will be used to store the minimum elements to change.\n\nWe iterate through the prefix XOR array, calculating the XOR of the prefixes considering the length of k, and we store the count of the occurrences where the XOR is equal to zero.\n\nFor each possible combination of segment size and occurrences, we update our `dp` table and the `min_dp` array accordingly. \n\nFinally, we iterate through the `min_dp` array to find the minimum number of elements to change, implying that the XOR of all segments is equal to zero. We return the minimum value found. \n    ",
        "js": "\n    ```javascript\nfunction minChanges(nums, k) {\n    let n = nums.length;\n    let xor_prefix = new Array(n + 1).fill(0);\n\n    for (let i = 1; i <= n; i++) {\n        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1];\n    }\n\n    let dp = Array.from({ length: k }, () => new Map());\n    let min_dp = Array(k).fill(n);\n\n    for (let i = 1; i <= n; i++) {\n        let x = xor_prefix[i] ^ xor_prefix[i - k];\n\n        if (i >= k) {\n            dp[0].set(x, (dp[0].get(x) || 0) + 1);\n        }\n\n        for (let j = 1; i - j * k >= 0; j++) {\n            dp[j].set(x, (dp[j].get(x) || 0) + 1);\n            min_dp[j] = Math.min(min_dp[j], (dp[j - 1].get(x) || 0) - (dp[j].get(x) || 0));\n        }\n    }\n\n    let answer = n;\n    for (let j = 0; j < k; j++) {\n        answer = Math.min(answer, min_dp[j] + j);\n    }\n    return answer;\n}\n```\n    \n    We first create a prefix XOR array called `xor_prefix`, containing the XOR values from the start of the original input array `nums` to each element in `xor_prefix`. We then initialize our dynamic programming table `dp`, which is an array of maps, and an array `min_dp`, that will be used to store the minimum elements to change.\n\nWe iterate through the prefix XOR array, calculating the XOR of the prefixes considering the length of k, and we store the count of the occurrences where the XOR is equal to zero.\n\nFor each possible combination of segment size and occurrences, we update our `dp` table and the `min_dp` array accordingly. \n\nFinally, we iterate through the `min_dp` array to find the minimum number of elements to change, implying that the XOR of all segments is equal to zero. We return the minimum value found. \n    "
    },
    {
        "id": 348,
        "title": "Build Array from Permutation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **zero-based permutation** `nums` (**0-indexed**), build an array `ans` of the **same length** where `ans[i] = nums[nums[i]]` for each `0 <= i < nums.length` and return it.\n\nA **zero-based permutation** `nums` is an array of **distinct** integers from `0` to `nums.length - 1` (**inclusive**).",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,2,1,5,3,4\\]\n**Output:** \\[0,1,2,4,5,3\\]\n**Explanation:** The array ans is built as follows: \nans = \\[nums\\[nums\\[0\\]\\], nums\\[nums\\[1\\]\\], nums\\[nums\\[2\\]\\], nums\\[nums\\[3\\]\\], nums\\[nums\\[4\\]\\], nums\\[nums\\[5\\]\\]\\]\n    = \\[nums\\[0\\], nums\\[2\\], nums\\[1\\], nums\\[5\\], nums\\[3\\], nums\\[4\\]\\]\n    = \\[0,1,2,4,5,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,0,1,2,3,4\\]\n**Output:** \\[4,5,0,1,2,3\\]\n**Explanation:** The array ans is built as follows:\nans = \\[nums\\[nums\\[0\\]\\], nums\\[nums\\[1\\]\\], nums\\[nums\\[2\\]\\], nums\\[nums\\[3\\]\\], nums\\[nums\\[4\\]\\], nums\\[nums\\[5\\]\\]\\]\n    = \\[nums\\[5\\], nums\\[0\\], nums\\[1\\], nums\\[2\\], nums\\[3\\], nums\\[4\\]\\]\n    = \\[4,5,0,1,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < nums.length`\n*   The elements in `nums` are **distinct**.\n\n**",
            "follow_up": "Follow-up:** Can you solve it without using an extra space (i.e., `O(1)` memory)?"
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[0,2,1,5,3,4]",
                "output": "[0,1,2,4,5,3]"
            },
            {
                "input": "[5,0,1,2,3,4]",
                "output": "[4,5,0,1,2,3]"
            }
        ],
        "java": "\n    ```java\npublic boolean squareIsWhite(String coordinates) {\n    return (coordinates.charAt(0) - 'a' + coordinates.charAt(1) - '1') % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the position of the square using the ASCII values of the characters given in the coordinate string, then the row and column positions are added together. If the sum is even, the square is a white square, otherwise it is a black square.\n    ",
        "python": "\n    ```python\ndef square_is_white(coordinates: str) -> bool:\n    return (ord(coordinates[0]) - ord('a') + ord(coordinates[1]) - ord('1')) % 2 == 0\n```\n    \n    The algorithm first calculates the position of the square using the ASCII values of the characters given in the coordinate string, then the row and column positions are added together. If the sum is even, the square is a white square, otherwise it is a black square.\n    ",
        "c++": "\n    ```cpp\nbool squareIsWhite(std_sequence(string coordinates) {\nreturn (coordinates[0] - 'a' + coordinates[1] - '1') % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the position of the square using the ASCII values of the characters given in the coordinate string, then the row and column positions are added together. If the sum is even, the square is a white square, otherwise it is a black square.\n    ",
        "js": "\n    ```javascript\nfunction squareIsWhite(coordinates) {\n    return (coordinates.charCodeAt(0) - 'a'.charCodeAt(0) + coordinates.charCodeAt(1) - '1'.charCodeAt(0)) % 2 === 0;\n}\n```\n    \n    The algorithm first calculates the position of the square using the ASCII values of the characters given in the coordinate string, then the row and column positions are added together. If the sum is even, the square is a white square, otherwise it is a black square.\n    "
    },
    {
        "id": 349,
        "title": "Count Square Sum Triples",
        "difficulty": "Easy",
        "content": {
            "problem": "A **square triple** `(a,b,c)` is a triple where `a`, `b`, and `c` are **integers** and `a2 + b2 = c2`.\n\nGiven an integer `n`, return _the number of **square triples** such that_ `1 <= a, b, c <= n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation**: The square triples are (3,4,5) and (4,3,5).\n\n",
                "**Example 2:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation**: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 250`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration"
        ],
        "example": [
            {
                "input": "5",
                "output": "2"
            },
            {
                "input": "10",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int reverse(int x) {\n    int rev = 0;\n    while (x != 0) {\n        rev = rev * 10 + x % 10;\n        x = x / 10;\n    }\n    return rev;\n}\n\npublic int countNicePairs(int[] nums) {\n    final int MOD = 1_000_000_007;\n    HashMap<Integer, Integer> count = new HashMap<>();\n    int result = 0;\n\n    for (int num : nums) {\n        int diff = num - reverse(num);\n        count.put(diff, count.getOrDefault(diff, 0) + 1);\n    }\n\n    for (int val : count.values()) {\n        result = (int)((result + ((val * (val - 1L)) / 2) % MOD) % MOD);\n    }\n\n    return result;\n}\n```\n    \n    1. Define a helper function 'reverse' to find the reverse of a number.\n2. Initialize a dictionary 'count' to store the difference between the number and its reverse and their count in the nums array.\n3. Initialize a result variable.\n4. Traverse the nums array, calculate the difference between num and its reverse, and update the count.\n5. Traverse the count dictionary's values, and for each value, add ((value * (value - 1)) / 2) % MOD to the current result, and take the modulus by 1e9 + 7.\n6. Return the result as the final count of nice pairs.\n    ",
        "python": "\n    ```python\ndef reverse(x):\n    rev = 0\n\n    while x != 0:\n        rev = rev * 10 + x % 10\n        x = x // 10\n\n    return rev\n\ndef count_nice_pairs(nums):\n    MOD = 1_000_000_007\n    count = {}\n    result = 0\n\n    for num in nums:\n        diff = num - reverse(num)\n        count[diff] = count.get(diff, 0) + 1\n\n    for val in count.values():\n        result = (result + ((val * (val - 1)) // 2) % MOD) % MOD\n\n    return result\n```\n    \n    1. Define a helper function 'reverse' to find the reverse of a number.\n2. Initialize a dictionary 'count' to store the difference between the number and its reverse and their count in the nums array.\n3. Initialize a result variable.\n4. Traverse the nums array, calculate the difference between num and its reverse, and update the count.\n5. Traverse the count dictionary's values, and for each value, add ((value * (value - 1)) / 2) % MOD to the current result, and take the modulus by 1e9 + 7.\n6. Return the result as the final count of nice pairs.\n    ",
        "c++": "\n    ```cpp\nint reverse(int x) {\n    int rev = 0;\n    while (x != 0) {\n        rev = rev * 10 + x % 10;\n        x = x / 10;\n    }\n    return rev;\n}\n\nint countNicePairs(vector<int>& nums) {\n    const int MOD = 1e9 + 7;\n    unordered_map<int, int> count;\n    int result = 0;\n\n    for (int num : nums) {\n        int diff = num - reverse(num);\n        count[diff]++;\n    }\n\n    for (auto &[_, val] : count) {\n        result = (result + ((val * (val - 1LL)) / 2) % MOD) % MOD;\n    }\n\n    return result;\n}\n```\n    \n    1. Define a helper function 'reverse' to find the reverse of a number.\n2. Initialize a dictionary 'count' to store the difference between the number and its reverse and their count in the nums array.\n3. Initialize a result variable.\n4. Traverse the nums array, calculate the difference between num and its reverse, and update the count.\n5. Traverse the count dictionary's values, and for each value, add ((value * (value - 1)) / 2) % MOD to the current result, and take the modulus by 1e9 + 7.\n6. Return the result as the final count of nice pairs.\n    ",
        "js": "\n    ```javascript\nfunction reverse(x) {\n    let rev = 0;\n    while (x !== 0) {\n        rev = rev * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return rev;\n}\n\nfunction countNicePairs(nums) {\n    const MOD = 1_000_000_007;\n    const count = new Map();\n    let result = 0;\n\n    for (const num of nums) {\n        const diff = num - reverse(num);\n        count.set(diff, (count.get(diff) || 0) + 1);\n    }\n\n    for (const val of count.values()) {\n        result = (result + ((val * (val - 1)) / 2) % MOD) % MOD;\n    }\n\n    return result;\n}\n```\n    \n    1. Define a helper function 'reverse' to find the reverse of a number.\n2. Initialize a dictionary 'count' to store the difference between the number and its reverse and their count in the nums array.\n3. Initialize a result variable.\n4. Traverse the nums array, calculate the difference between num and its reverse, and update the count.\n5. Traverse the count dictionary's values, and for each value, add ((value * (value - 1)) / 2) % MOD to the current result, and take the modulus by 1e9 + 7.\n6. Return the result as the final count of nice pairs.\n    "
    },
    {
        "id": 350,
        "title": "Concatenation of Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` of length `n`, you want to create an array `ans` of length `2n` where `ans[i] == nums[i]` and `ans[i + n] == nums[i]` for `0 <= i < n` (**0-indexed**).\n\nSpecifically, `ans` is the **concatenation** of two `nums` arrays.\n\nReturn _the array_ `ans`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1\\]\n**Output:** \\[1,2,1,1,2,1\\]\n**Explanation:** The array ans is formed as follows:\n- ans = \\[nums\\[0\\],nums\\[1\\],nums\\[2\\],nums\\[0\\],nums\\[1\\],nums\\[2\\]\\]\n- ans = \\[1,2,1,1,2,1\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,2,1\\]\n**Output:** \\[1,3,2,1,1,3,2,1\\]\n**Explanation:** The array ans is formed as follows:\n- ans = \\[nums\\[0\\],nums\\[1\\],nums\\[2\\],nums\\[3\\],nums\\[0\\],nums\\[1\\],nums\\[2\\],nums\\[3\\]\\]\n- ans = \\[1,3,2,1,1,3,2,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 1000`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,2,1]",
                "output": "[1,2,1,1,2,1]"
            },
            {
                "input": "[1,3,2,1]",
                "output": "[1,3,2,1,1,3,2,1]"
            }
        ],
        "java": "\n    ```java\npublic int maxValue(int n, int index, int maxSum) {\n    maxSum -= n;\n    int left = 0, right = maxSum, ans = 0;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        long sum = (long)Math.min(mid, index) * (Math.min(mid, index) + 1) / 2 + (long)Math.min(mid, n - index - 1) * (Math.min(mid, n - index) + 1) / 2;\n        if (mid > index) {\n            sum += (long)(mid - index - 1) * (mid - index) / 2;\n        }\n        if (mid > n - index) {\n            sum += (long)(mid - n + index) * (mid - n + index + 1) / 2;\n        }\n        if (sum <= maxSum) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans + 1;\n}\n```\n    \n    The problem asks to find the maximum value of nums[index] for a given array size n, position index, and maximum sum maxSum. \n\nWe have to use a binary search algorithm to maximize nums[index] in this problem. Firstly, subtract n from maxSum. This is because we want to consider the extra sum required for nums[index], as each element in nums should be at least 1. Set the initial search range as (0, maxSum). Next, we iterate until left <= right, calculating the mid-value in each iteration. For the current mid-value, we calculate its contribution to the sum on both sides of index. If the mid-value is greater than index, we add its difference to the sum. We do the same if the mid-value is greater than n-index. If the sum is within maxSum, set the answer to be the current mid-value and update the left boundary; otherwise, update the right boundary. Finally, return the answer incremented by 1 because we decreased maxSum by n earlier.\n\nThis algorithm is applied similarly in all four languages. In C++ and Java, we need to be careful with potential integer overflows and use long long (C++) or long (Java) when needed. In JavaScript, bitwise right shift (>>) is used to calculate mid-value in the binary search loop.\n    ",
        "python": "\n    ```python\ndef maxValue(n, index, maxSum):\n    maxSum -= n\n    left, right, ans = 0, maxSum, 0\n    while left <= right:\n        mid = left + (right - left) // 2\n        sum = min(mid, index) * (min(mid, index) + 1) // 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1) // 2\n        if mid > index:\n            sum += (mid - index - 1) * (mid - index) // 2\n        if mid > n - index:\n            sum += (mid - n + index) * (mid - n + index + 1) // 2\n        if sum <= maxSum:\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans + 1\n```\n    \n    The problem asks to find the maximum value of nums[index] for a given array size n, position index, and maximum sum maxSum. \n\nWe have to use a binary search algorithm to maximize nums[index] in this problem. Firstly, subtract n from maxSum. This is because we want to consider the extra sum required for nums[index], as each element in nums should be at least 1. Set the initial search range as (0, maxSum). Next, we iterate until left <= right, calculating the mid-value in each iteration. For the current mid-value, we calculate its contribution to the sum on both sides of index. If the mid-value is greater than index, we add its difference to the sum. We do the same if the mid-value is greater than n-index. If the sum is within maxSum, set the answer to be the current mid-value and update the left boundary; otherwise, update the right boundary. Finally, return the answer incremented by 1 because we decreased maxSum by n earlier.\n\nThis algorithm is applied similarly in all four languages. In C++ and Java, we need to be careful with potential integer overflows and use long long (C++) or long (Java) when needed. In JavaScript, bitwise right shift (>>) is used to calculate mid-value in the binary search loop.\n    ",
        "c++": "\n    ```cpp\nint maxValue(int n, int index, int maxSum) {\n    maxSum -= n;\n    int left = 0, right = maxSum, ans = 0;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        long long sum = min(mid, index) * (min(mid, index) + 1LL) / 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1LL) / 2;\n        if (mid > index) {\n            sum += (mid - index - 1LL) * (mid - index) / 2;\n        }\n        if (mid > n - index) {\n            sum += (mid - n + index) * (mid - n + index + 1) / 2;\n        }\n        if (sum <= maxSum) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans + 1;\n}\n```\n    \n    The problem asks to find the maximum value of nums[index] for a given array size n, position index, and maximum sum maxSum. \n\nWe have to use a binary search algorithm to maximize nums[index] in this problem. Firstly, subtract n from maxSum. This is because we want to consider the extra sum required for nums[index], as each element in nums should be at least 1. Set the initial search range as (0, maxSum). Next, we iterate until left <= right, calculating the mid-value in each iteration. For the current mid-value, we calculate its contribution to the sum on both sides of index. If the mid-value is greater than index, we add its difference to the sum. We do the same if the mid-value is greater than n-index. If the sum is within maxSum, set the answer to be the current mid-value and update the left boundary; otherwise, update the right boundary. Finally, return the answer incremented by 1 because we decreased maxSum by n earlier.\n\nThis algorithm is applied similarly in all four languages. In C++ and Java, we need to be careful with potential integer overflows and use long long (C++) or long (Java) when needed. In JavaScript, bitwise right shift (>>) is used to calculate mid-value in the binary search loop.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(n, index, maxSum) {\n    maxSum -= n;\n    let left = 0, right = maxSum, ans = 0;\n    while (left <= right) {\n        const mid = left + ((right - left) >> 1);\n        let sum = Math.min(mid, index) * (Math.min(mid, index) + 1) / 2 + Math.min(mid, n - index - 1) * (Math.min(mid, n - index) + 1) / 2;\n        if (mid > index) {\n            sum += (mid - index - 1) * (mid - index) / 2;\n        }\n        if (mid > n - index) {\n            sum += (mid - n + index) * (mid - n + index + 1) / 2;\n        }\n        if (sum <= maxSum) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans + 1;\n}\n```\n    \n    The problem asks to find the maximum value of nums[index] for a given array size n, position index, and maximum sum maxSum. \n\nWe have to use a binary search algorithm to maximize nums[index] in this problem. Firstly, subtract n from maxSum. This is because we want to consider the extra sum required for nums[index], as each element in nums should be at least 1. Set the initial search range as (0, maxSum). Next, we iterate until left <= right, calculating the mid-value in each iteration. For the current mid-value, we calculate its contribution to the sum on both sides of index. If the mid-value is greater than index, we add its difference to the sum. We do the same if the mid-value is greater than n-index. If the sum is within maxSum, set the answer to be the current mid-value and update the left boundary; otherwise, update the right boundary. Finally, return the answer incremented by 1 because we decreased maxSum by n earlier.\n\nThis algorithm is applied similarly in all four languages. In C++ and Java, we need to be careful with potential integer overflows and use long long (C++) or long (Java) when needed. In JavaScript, bitwise right shift (>>) is used to calculate mid-value in the binary search loop.\n    "
    },
    {
        "id": 351,
        "title": "Maximum Number of Words You Can Type",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.\n\nGiven a string `text` of words separated by a single space (no leading or trailing spaces) and a string `brokenLetters` of all **distinct** letter keys that are broken, return _the **number of words** in_ `text` _you can fully type using this keyboard_.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"hello world \", brokenLetters =  \"ad \"\n**Output:** 1\n**Explanation:** We cannot type  \"world \" because the 'd' key is broken.\n\n",
                "**Example 2:**\n\n**Input:** text =  \"leet code \", brokenLetters =  \"lt \"\n**Output:** 1\n**Explanation:** We cannot type  \"leet \" because the 'l' and 't' keys are broken.\n\n",
                "**Example 3:**\n\n**Input:** text =  \"leet code \", brokenLetters =  \"e \"\n**Output:** 0\n**Explanation:** We cannot type either word because the 'e' key is broken."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 104`\n*   `0 <= brokenLetters.length <= 26`\n*   `text` consists of words separated by a single space without any leading or trailing spaces.\n*   Each word only consists of lowercase English letters.\n*   `brokenLetters` consists of **distinct** lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"helloworld\",\"ad\"",
                "output": "1"
            },
            {
                "input": "\"leetcode\",\"lt\"",
                "output": "1"
            },
            {
                "input": "\"leetcode\",\"e\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int min_operations(int n) {\n    int count = 1;\n    int temp = 1;\n\n    while (temp % n != 0) {\n        temp = (temp * 2) % n;\n        count++;\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by initializing a counter count and a temporary variable temp to store the intermediate values. For each operation, the algorithm updates the value of temp by multiplying it by 2 and taking the modulo of n. This is repeated until the temporary value becomes zero modulo n (temp % n == 0), which means that the original permutation has been reached again. The counter count is updated after each iteration, and the algorithm returns the value of count as the minimum non-zero number of operations needed.\n    ",
        "python": "\n    ```python\ndef min_operations(n):\n    count = 1\n    temp = 1\n\n    while temp % n != 0:\n        temp = (temp * 2) % n\n        count += 1\n\n    return count\n```\n    \n    The algorithm starts by initializing a counter count and a temporary variable temp to store the intermediate values. For each operation, the algorithm updates the value of temp by multiplying it by 2 and taking the modulo of n. This is repeated until the temporary value becomes zero modulo n (temp % n == 0), which means that the original permutation has been reached again. The counter count is updated after each iteration, and the algorithm returns the value of count as the minimum non-zero number of operations needed.\n    ",
        "c++": "\n    ```cpp\nint min_operations(int n) {\n    int count = 1;\n    int temp = 1;\n\n    while (temp % n != 0) {\n        temp = (temp * 2) % n;\n        count++;\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by initializing a counter count and a temporary variable temp to store the intermediate values. For each operation, the algorithm updates the value of temp by multiplying it by 2 and taking the modulo of n. This is repeated until the temporary value becomes zero modulo n (temp % n == 0), which means that the original permutation has been reached again. The counter count is updated after each iteration, and the algorithm returns the value of count as the minimum non-zero number of operations needed.\n    ",
        "js": "\n    ```javascript\nfunction min_operations(n) {\n    let count = 1;\n    let temp = 1;\n\n    while (temp % n !== 0) {\n        temp = (temp * 2) % n;\n        count++;\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by initializing a counter count and a temporary variable temp to store the intermediate values. For each operation, the algorithm updates the value of temp by multiplying it by 2 and taking the modulo of n. This is repeated until the temporary value becomes zero modulo n (temp % n == 0), which means that the original permutation has been reached again. The counter count is updated after each iteration, and the algorithm returns the value of count as the minimum non-zero number of operations needed.\n    "
    },
    {
        "id": 352,
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return `true` _if_ `s` _is a **good** string, or_ `false` _otherwise_.\n\nA string `s` is **good** if **all** the characters that appear in `s` have the **same** number of occurrences (i.e., the same frequency).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abacbc \"\n**Output:** true\n**Explanation:** The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaabb \"\n**Output:** false\n**Explanation:** The characters that appear in s are 'a' and 'b'.\n'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"abacbc\"",
                "output": "true"
            },
            {
                "input": "\"aaabb\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int makeStringSorted(String s) {\n    final int mod = 1000000007;\n    int n = s.length();\n    int[] fact = new int[n + 1];\n    int[] inv = new int[n + 1];\n    fact[0] = inv[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact[i] = (int)((1L * fact[i - 1] * i) % mod);\n        inv[i] = (int)((1L * inv[i - 1] * (mod - mod / i)) % mod);\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        int less_than = 0;\n        for (int j = i + 1; j < n; ++j) {\n            if (s.charAt(j) < s.charAt(i)) ++less_than;\n        }\n        ans = (int)((ans + 1L * less_than * fact[n - i - 1]) % mod);\n    }\n    return ans;\n}\n```\n    \n    The algorithm consists of the following steps:\n\n1. Initialize the factorials and inverse factorials for numbers up to the length of the given string, using modulo arithmetic.\n2. For each character in the string, count the number of characters to the right that are less than the current character.\n3. Multiply that count by the factorial of the number of remaining characters to the right, modulo the large prime number, and add it to the result.\n\nIn this way, the algorithm takes into account all possible permutations generated through the process of sorting, accumulating the required operations to make the string sorted.\n    ",
        "python": "\n    ```python\ndef make_string_sorted(s):\n    mod = 1000000007\n    n = len(s)\n    fact = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n        inv[i] = inv[i - 1] * (mod - mod // i) % mod\n        \n    ans = 0\n    for i in range(n):\n        less_than = 0\n        for j in range(i + 1, n):\n            if s[j] < s[i]:\n                less_than += 1\n        ans = (ans + less_than * fact[n - i - 1]) % mod\n    return ans\n```\n    \n    The algorithm consists of the following steps:\n\n1. Initialize the factorials and inverse factorials for numbers up to the length of the given string, using modulo arithmetic.\n2. For each character in the string, count the number of characters to the right that are less than the current character.\n3. Multiply that count by the factorial of the number of remaining characters to the right, modulo the large prime number, and add it to the result.\n\nIn this way, the algorithm takes into account all possible permutations generated through the process of sorting, accumulating the required operations to make the string sorted.\n    ",
        "c++": "\n    ```cpp\nint makeStringSorted(string s) {\n    const int mod = 1e9 + 7;\n    int n = s.size();\n    vector<int> fact(n + 1, 1);\n    vector<int> inv(n + 1, 1);\n    for (int i = 1; i <= n; ++i) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n        inv[i] = 1LL * inv[i - 1] * (mod - mod / i) % mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        int less_than = 0;\n        for (int j = i + 1; j < n; ++j) {\n            if (s[j] < s[i]) ++less_than;\n        }\n        ans = (ans + 1LL * less_than * fact[n - i - 1] % mod) % mod;\n    }\n    return ans;\n}\n```\n    \n    The algorithm consists of the following steps:\n\n1. Initialize the factorials and inverse factorials for numbers up to the length of the given string, using modulo arithmetic.\n2. For each character in the string, count the number of characters to the right that are less than the current character.\n3. Multiply that count by the factorial of the number of remaining characters to the right, modulo the large prime number, and add it to the result.\n\nIn this way, the algorithm takes into account all possible permutations generated through the process of sorting, accumulating the required operations to make the string sorted.\n    ",
        "js": "\n    ```javascript\nfunction makeStringSorted(s) {\n    const mod = 1e9 + 7;\n    const n = s.length;\n    const fact = new Array(n + 1).fill(1);\n    const inv = new Array(n + 1).fill(1);\n\n    for (let i = 1; i <= n; ++i) {\n        fact[i] = BigInt(fact[i - 1] * i % mod);\n        inv[i] = BigInt(inv[i - 1] * (mod - Math.floor(mod / i)) % mod);\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        let less_than = 0;\n        for (let j = i + 1; j < n; ++j) {\n            if (s[j] < s[i]) ++less_than;\n        }\n        ans = Number((BigInt(ans) + BigInt(less_than) * fact[n - i - 1]) % BigInt(mod));\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm consists of the following steps:\n\n1. Initialize the factorials and inverse factorials for numbers up to the length of the given string, using modulo arithmetic.\n2. For each character in the string, count the number of characters to the right that are less than the current character.\n3. Multiply that count by the factorial of the number of remaining characters to the right, modulo the large prime number, and add it to the result.\n\nIn this way, the algorithm takes into account all possible permutations generated through the process of sorting, accumulating the required operations to make the string sorted.\n    "
    },
    {
        "id": 353,
        "title": "Sum of Digits of String After Convert",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` consisting of lowercase English letters, and an integer `k`.\n\nFirst, **convert** `s` into an integer by replacing each letter with its position in the alphabet (i.e., replace `'a'` with `1`, `'b'` with `2`, ..., `'z'` with `26`). Then, **transform** the integer by replacing it with the **sum of its digits**. Repeat the **transform** operation `k` **times** in total.\n\nFor example, if `s = \"zbax \"` and `k = 2`, then the resulting integer would be `8` by the following operations:\n\n*   **Convert**: `\"zbax \"  \"(26)(2)(1)(24) \"  \"262124 \"  262124`\n*   **Transform #1**: `262124  2 + 6 + 2 + 1 + 2 + 4  17`\n*   **Transform #2**: `17  1 + 7  8`\n\nReturn _the resulting integer after performing the operations described above_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"iiii \", k = 1\n**Output:** 36\n**Explanation:** The operations are as follows:\n- Convert:  \"iiii \"   \"(9)(9)(9)(9) \"   \"9999 \"  9999\n- Transform #1: 9999  9 + 9 + 9 + 9  36\nThus the resulting integer is 36.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"leetcode \", k = 2\n**Output:** 6\n**Explanation:** The operations are as follows:\n- Convert:  \"leetcode \"   \"(12)(5)(5)(20)(3)(15)(4)(5) \"   \"12552031545 \"  12552031545\n- Transform #1: 12552031545  1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5  33\n- Transform #2: 33  3 + 3  6\nThus the resulting integer is 6.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"zbax \", k = 2\n**Output:** 8"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `1 <= k <= 10`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"iiii\",1",
                "output": "36"
            },
            {
                "input": "\"leetcode\",2",
                "output": "6"
            },
            {
                "input": "\"zbax\",2",
                "output": "8"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] findingUsersActiveMinutes(int[][] logs, int k) {\n    Map<Integer, Set<Integer>> user_minutes = new HashMap<>();\n    for (int[] log : logs) {\n        user_minutes.computeIfAbsent(log[0], user -> new HashSet<>()).add(log[1]);\n    }\n    int[] result = new int[k];\n    for (Set<Integer> minutes : user_minutes.values()) {\n        if (minutes.size() <= k) {\n            result[minutes.size() - 1]++;\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a data structure to store the unique minutes for each user ID. In this case, we use a hash map with user IDs as keys and sets of minutes as values.\n2. Iterate through each log entry, adding the minute of the action to the user's set of minutes in the data structure.\n3. Initialize an array of size k to store the final result.\n4. Iterate through the values of the data structure, which represent sets of unique minutes for each user. If the number of unique minutes for a user is less than or equal to k, increment the corresponding value in the result array.\n5. Return the result array.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef finding_users_active_minutes(logs, k):\n    user_minutes = defaultdict(set)\n    for log in logs:\n        user_minutes[log[0]].add(log[1])\n    result = [0] * k\n    for minutes in user_minutes.values():\n        if len(minutes) <= k:\n            result[len(minutes) - 1] += 1\n    return result\n```\n\n    \n    1. Create a data structure to store the unique minutes for each user ID. In this case, we use a hash map with user IDs as keys and sets of minutes as values.\n2. Iterate through each log entry, adding the minute of the action to the user's set of minutes in the data structure.\n3. Initialize an array of size k to store the final result.\n4. Iterate through the values of the data structure, which represent sets of unique minutes for each user. If the number of unique minutes for a user is less than or equal to k, increment the corresponding value in the result array.\n5. Return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n\nstd::vector<int> finding_users_active_minutes(std::vector<std::vector<int>>& logs, int k) {\n    std::unordered_map<int, std::unordered_set<int>> user_minutes;\n    for (const auto& log : logs) {\n        user_minutes[log[0]].insert(log[1]);\n    }\n    std::vector<int> result(k, 0);\n    for (const auto& entry : user_minutes) {\n        if (entry.second.size() <= k) {\n            result[entry.second.size() - 1]++;\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a data structure to store the unique minutes for each user ID. In this case, we use a hash map with user IDs as keys and sets of minutes as values.\n2. Iterate through each log entry, adding the minute of the action to the user's set of minutes in the data structure.\n3. Initialize an array of size k to store the final result.\n4. Iterate through the values of the data structure, which represent sets of unique minutes for each user. If the number of unique minutes for a user is less than or equal to k, increment the corresponding value in the result array.\n5. Return the result array.\n    ",
        "js": "\n    ```javascript\nfunction findingUsersActiveMinutes(logs, k) {\n    const user_minutes = new Map();\n    for (const log of logs) {\n        if (!user_minutes.has(log[0])) user_minutes.set(log[0], new Set());\n        user_minutes.get(log[0]).add(log[1]);\n    }\n    const result = new Array(k).fill(0);\n    for (const minutes of user_minutes.values()) {\n        if (minutes.size <= k) {\n            result[minutes.size - 1]++;\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a data structure to store the unique minutes for each user ID. In this case, we use a hash map with user IDs as keys and sets of minutes as values.\n2. Iterate through each log entry, adding the minute of the action to the user's set of minutes in the data structure.\n3. Initialize an array of size k to store the final result.\n4. Iterate through the values of the data structure, which represent sets of unique minutes for each user. If the number of unique minutes for a user is less than or equal to k, increment the corresponding value in the result array.\n5. Return the result array.\n    "
    },
    {
        "id": 354,
        "title": "Three Divisors",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return `true` _if_ `n` _has **exactly three positive divisors**. Otherwise, return_ `false`.\n\nAn integer `m` is a **divisor** of `n` if there exists an integer `k` such that `n = k * m`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** false\n**Explantion:** 2 has only two divisors: 1 and 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 4\n**Output:** true\n**Explantion:** 4 has three divisors: 1, 2, and 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "example": [
            {
                "input": "2",
                "output": "false\n**Explantion:**2hasonlytwodivisors:1and2."
            },
            {
                "input": "4",
                "output": "true\n**Explantion:**4hasthreedivisors:1,2,and4."
            }
        ],
        "java": "\n    ```java\npublic int minSideJumps(int[] obstacles) {\n    int n = obstacles.length;\n    int[][] dp = new int[n][3];\n    dp[0][1] = 0;\n    dp[0][0] = 1;\n    dp[0][2] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (obstacles[i] != 1) dp[i][0] = Math.min(dp[i - 1][0], Math.min(dp[i - 1][1] + 1, dp[i - 1][2] + 1));\n        if (obstacles[i] != 2) dp[i][1] = Math.min(dp[i - 1][1], Math.min(dp[i - 1][0] + 1, dp[i - 1][2] + 1));\n        if (obstacles[i] != 3) dp[i][2] = Math.min(dp[i - 1][2], Math.min(dp[i - 1][0] + 1, dp[i - 1][1] + 1));\n    }\n    return Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2]));\n}\n```\n\n    \n    We maintain a dynamic programming table (dp) with dimensions n x 3 where each row i represents the current point and each column j with [0, 2] represents the lanes. The value stored in dp[i][j] is the minimum number of side jumps needed to reach the lane j at point i. We initially set all values in the table to n (the maximum possible number of side jumps), and set the values for the initial point (dp[0]) accordingly.\n\nWe then iterate through each point from 1 to n-1, checking if there is no obstacle for each lane. If there is no obstacle for lane j, we update the values in the table dp[i][j] by taking the minimum value between the previous value in the same lane or one plus the previous value in the other two lanes.\n\nAfter filling the table, we return the minimum value in the last row, which represents the minimum number of side jumps needed to reach any lane at point n.\n    ",
        "python": "\n    ```python\ndef minSideJumps(obstacles):\n    n = len(obstacles)\n    dp = [[n] * 3 for _ in range(n)]\n    dp[0][1] = 0\n    dp[0][0] = dp[0][2] = 1\n\n    for i in range(1, n):\n        if obstacles[i] != 1:\n            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 2:\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 3:\n            dp[i][2] = min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1)\n\n    return min(dp[-1])\n```\n\n    \n    We maintain a dynamic programming table (dp) with dimensions n x 3 where each row i represents the current point and each column j with [0, 2] represents the lanes. The value stored in dp[i][j] is the minimum number of side jumps needed to reach the lane j at point i. We initially set all values in the table to n (the maximum possible number of side jumps), and set the values for the initial point (dp[0]) accordingly.\n\nWe then iterate through each point from 1 to n-1, checking if there is no obstacle for each lane. If there is no obstacle for lane j, we update the values in the table dp[i][j] by taking the minimum value between the previous value in the same lane or one plus the previous value in the other two lanes.\n\nAfter filling the table, we return the minimum value in the last row, which represents the minimum number of side jumps needed to reach any lane at point n.\n    ",
        "c++": "\n    ```cpp\nint minSideJumps(vector<int>& obstacles) {\n    vector<vector<int>> dp(obstacles.size(), vector<int>(3, obstacles.size()));\n    dp[0][1] = 0;\n    dp[0][0] = 1;\n    dp[0][2] = 1;\n\n    for (size_t i = 1; i < obstacles.size(); ++i) {\n        if (obstacles[i] != 1) dp[i][0] = min(dp[i-1][0], min(dp[i-1][1] + 1, dp[i-1][2] + 1));\n        if (obstacles[i] != 2) dp[i][1] = min(dp[i-1][1], min(dp[i-1][0] + 1, dp[i-1][2] + 1));\n        if (obstacles[i] != 3) dp[i][2] = min(dp[i-1][2], min(dp[i-1][0] + 1, dp[i-1][1] + 1));\n    }\n    return min(dp.back()[0], min(dp.back()[1], dp.back()[2]));\n}\n```\n\n    \n    We maintain a dynamic programming table (dp) with dimensions n x 3 where each row i represents the current point and each column j with [0, 2] represents the lanes. The value stored in dp[i][j] is the minimum number of side jumps needed to reach the lane j at point i. We initially set all values in the table to n (the maximum possible number of side jumps), and set the values for the initial point (dp[0]) accordingly.\n\nWe then iterate through each point from 1 to n-1, checking if there is no obstacle for each lane. If there is no obstacle for lane j, we update the values in the table dp[i][j] by taking the minimum value between the previous value in the same lane or one plus the previous value in the other two lanes.\n\nAfter filling the table, we return the minimum value in the last row, which represents the minimum number of side jumps needed to reach any lane at point n.\n    ",
        "js": "\n    ```javascript\nfunction minSideJumps(obstacles) {\n    const n = obstacles.length;\n    const dp = Array.from({ length: n }, () => Array(3).fill(n));\n    dp[0][1] = 0;\n    dp[0][0] = 1;\n    dp[0][2] = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (obstacles[i] !== 1) dp[i][0] = Math.min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1);\n        if (obstacles[i] !== 2) dp[i][1] = Math.min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1);\n        if (obstacles[i] !== 3) dp[i][2] = Math.min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1);\n    }\n    return Math.min(dp[n - 1][0], dp[n - 1][1], dp[n - 1][2]);\n}\n```\n\n    \n    We maintain a dynamic programming table (dp) with dimensions n x 3 where each row i represents the current point and each column j with [0, 2] represents the lanes. The value stored in dp[i][j] is the minimum number of side jumps needed to reach the lane j at point i. We initially set all values in the table to n (the maximum possible number of side jumps), and set the values for the initial point (dp[0]) accordingly.\n\nWe then iterate through each point from 1 to n-1, checking if there is no obstacle for each lane. If there is no obstacle for lane j, we update the values in the table dp[i][j] by taking the minimum value between the previous value in the same lane or one plus the previous value in the other two lanes.\n\nAfter filling the table, we return the minimum value in the last row, which represents the minimum number of side jumps needed to reach any lane at point n.\n    "
    },
    {
        "id": 355,
        "title": "Delete Characters to Make Fancy String",
        "difficulty": "Easy",
        "content": {
            "problem": "A **fancy string** is a string where no **three** **consecutive** characters are equal.\n\nGiven a string `s`, delete the **minimum** possible number of characters from `s` to make it **fancy**.\n\nReturn _the final string after the deletion_. It can be shown that the answer will always be **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leeetcode \"\n**Output:**  \"leetcode \"\n**Explanation:**\nRemove an 'e' from the first group of 'e's to create  \"leetcode \".\nNo three consecutive characters are equal, so return  \"leetcode \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaabaaaa \"\n**Output:**  \"aabaa \"\n**Explanation:**\nRemove an 'a' from the first group of 'a's to create  \"aabaaaa \".\nRemove two 'a's from the second group of 'a's to create  \"aabaa \".\nNo three consecutive characters are equal, so return  \"aabaa \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aab \"\n**Output:**  \"aab \"\n**Explanation:** No three consecutive characters are equal, so return  \"aab \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"leeetcode\"",
                "output": "\"leetcode\""
            },
            {
                "input": "\"aaabaaaa\"",
                "output": "\"aabaa\""
            },
            {
                "input": "\"aab\"",
                "output": "\"aab\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Solution {\n    public int[] smallest_difference_room(int[][] rooms, int[][] queries) {\n        int n = rooms.length;\n        int k = queries.length;\n        int[] results = new int[k];\n        Arrays.sort(rooms, Comparator.comparingInt(a -> a[0]));\n\n        for (int i = 0; i < k; i++) {\n            int preferred = queries[i][0];\n            int minSize = queries[i][1];\n            int diff = Integer.MAX_VALUE;\n            int room_idx = -1;\n\n            for (int j = 0; j < n; j++) {\n                if (rooms[j][1] >= minSize) {\n                    int tmp_diff = Math.abs(preferred - rooms[j][0]);\n                    if (tmp_diff < diff) {\n                        diff = tmp_diff;\n                        room_idx = rooms[j][0];\n                    }\n                }\n            }\n            results[i] = room_idx;\n        }\n        return results;\n    }\n}\n```\n    \n    1. Sort the input `rooms` based on the `roomId`.\n2. Iterate through the `queries` array.\n3. For each query, initialize `diff` as the maximum possible value and `room_idx` as -1.\n4. Iterate through the `rooms` array, and for each room, check if its size is greater or equal to the minSize of the current query.\n5. If it is, calculate the absolute difference between the preferred room number and the current room number.\n6. If this absolute difference is less than the current minimum `diff`, update `diff` and `room_idx` accordingly.\n7. Once all rooms have been processed for a given query, append `room_idx` to the `results` array.\n8. Repeat this process for all queries and return the `results` array. The result array will have the same length as the number of queries and contains the answers for all queries as required.\n    ",
        "python": "\n    ```python\ndef smallest_difference_room(rooms, queries):\n    n = len(rooms)\n    k = len(queries)\n    rooms.sort(key=lambda x: x[0])\n    results = []\n\n    for i in range(k):\n        preferred, minSize = queries[i]\n        diff = float(\"inf\")\n        room_idx = -1\n\n        for j in range(n):\n            if rooms[j][1] >= minSize:\n                tmp_diff = abs(preferred - rooms[j][0])\n                if tmp_diff < diff:\n                    diff = tmp_diff\n                    room_idx = rooms[j][0]\n\n        results.append(room_idx)\n\n    return results\n```\n    \n    1. Sort the input `rooms` based on the `roomId`.\n2. Iterate through the `queries` array.\n3. For each query, initialize `diff` as the maximum possible value and `room_idx` as -1.\n4. Iterate through the `rooms` array, and for each room, check if its size is greater or equal to the minSize of the current query.\n5. If it is, calculate the absolute difference between the preferred room number and the current room number.\n6. If this absolute difference is less than the current minimum `diff`, update `diff` and `room_idx` accordingly.\n7. Once all rooms have been processed for a given query, append `room_idx` to the `results` array.\n8. Repeat this process for all queries and return the `results` array. The result array will have the same length as the number of queries and contains the answers for all queries as required.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    return a[0] < b[0];\n}\n\nvector<int> smallest_difference_room(vector<vector<int>>& rooms, vector<vector<int>>& queries) {\n    int n = rooms.size();\n    int k = queries.size();\n    sort(rooms.begin(), rooms.end(), compare);\n    vector<int> results;\n\n    for (int i = 0; i < k; i++) {\n        int preferred = queries[i][0];\n        int minSize = queries[i][1];\n        int diff = INT_MAX;\n        int room_idx = -1;\n\n        for (int j = 0; j < n; j++) {\n            if (rooms[j][1] >= minSize) {\n                int tmp_diff = abs(preferred - rooms[j][0]);\n                if (tmp_diff < diff) {\n                    diff = tmp_diff;\n                    room_idx = rooms[j][0];\n                }\n            }\n        }\n        results.push_back(room_idx);\n    }\n    \n    return results;\n}\n```\n    \n    1. Sort the input `rooms` based on the `roomId`.\n2. Iterate through the `queries` array.\n3. For each query, initialize `diff` as the maximum possible value and `room_idx` as -1.\n4. Iterate through the `rooms` array, and for each room, check if its size is greater or equal to the minSize of the current query.\n5. If it is, calculate the absolute difference between the preferred room number and the current room number.\n6. If this absolute difference is less than the current minimum `diff`, update `diff` and `room_idx` accordingly.\n7. Once all rooms have been processed for a given query, append `room_idx` to the `results` array.\n8. Repeat this process for all queries and return the `results` array. The result array will have the same length as the number of queries and contains the answers for all queries as required.\n    ",
        "js": "\n    ```javascript\nfunction smallest_difference_room(rooms, queries) {\n    const n = rooms.length;\n    const k = queries.length;\n    rooms.sort((a, b) => a[0] - b[0]);\n    const results = [];\n\n    for (let i = 0; i < k; i++) {\n        const [preferred, minSize] = queries[i];\n        let diff = Infinity;\n        let room_idx = -1;\n\n        for (let j = 0; j < n; j++) {\n            if (rooms[j][1] >= minSize) {\n                const tmp_diff = Math.abs(preferred - rooms[j][0]);\n                if (tmp_diff < diff) {\n                    diff = tmp_diff;\n                    room_idx = rooms[j][0];\n                }\n            }\n        }\n        results.push(room_idx);\n    }\n    return results;\n}\n```\n    \n    1. Sort the input `rooms` based on the `roomId`.\n2. Iterate through the `queries` array.\n3. For each query, initialize `diff` as the maximum possible value and `room_idx` as -1.\n4. Iterate through the `rooms` array, and for each room, check if its size is greater or equal to the minSize of the current query.\n5. If it is, calculate the absolute difference between the preferred room number and the current room number.\n6. If this absolute difference is less than the current minimum `diff`, update `diff` and `room_idx` accordingly.\n7. Once all rooms have been processed for a given query, append `room_idx` to the `results` array.\n8. Repeat this process for all queries and return the `results` array. The result array will have the same length as the number of queries and contains the answers for all queries as required.\n    "
    },
    {
        "id": 356,
        "title": "Check If String Is a Prefix of Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` and an array of strings `words`, determine whether `s` is a **prefix string** of `words`.\n\nA string `s` is a **prefix string** of `words` if `s` can be made by concatenating the first `k` strings in `words` for some **positive** `k` no larger than `words.length`.\n\nReturn `true` _if_ `s` _is a **prefix string** of_ `words`_, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"iloveleetcode \", words = \\[ \"i \", \"love \", \"leetcode \", \"apples \"\\]\n**Output:** true\n**Explanation:**\ns can be made by concatenating  \"i \",  \"love \", and  \"leetcode \" together.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"iloveleetcode \", words = \\[ \"apples \", \"i \", \"love \", \"leetcode \"\\]\n**Output:** false\n**Explanation:**\nIt is impossible to make s using a prefix of arr."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 20`\n*   `1 <= s.length <= 1000`\n*   `words[i]` and `s` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"iloveleetcode\",[\"i\",\"love\",\"leetcode\",\"apples\"]",
                "output": "true"
            },
            {
                "input": "\"iloveleetcode\",[\"apples\",\"i\",\"love\",\"leetcode\"]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxIceCream(int[] costs, int coins) {\n    Arrays.sort(costs);\n    int count = 0;\n    for (int cost : costs) {\n        if (coins >= cost) {\n            coins -= cost;\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm first sorts the `costs` array in ascending order. Then, it traverses the sorted array and checks if the current cost can be covered by the remaining `coins`. If it can, the function decreases the `coins` by the cost and increments the count of bought ice cream bars. If it can't, the loop breaks, as the remaining ice creams are all more expensive. Finally, the function returns the count of bought ice cream bars.\n    ",
        "python": "\n    ```python\ndef max_ice_cream(costs, coins):\n    costs.sort()\n    count = 0\n    for cost in costs:\n        if coins >= cost:\n            coins -= cost\n            count += 1\n        else:\n            break\n    return count\n```\n    \n    The algorithm first sorts the `costs` array in ascending order. Then, it traverses the sorted array and checks if the current cost can be covered by the remaining `coins`. If it can, the function decreases the `coins` by the cost and increments the count of bought ice cream bars. If it can't, the loop breaks, as the remaining ice creams are all more expensive. Finally, the function returns the count of bought ice cream bars.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxIceCream(std::vector<int>& costs, int coins) {\n    std::sort(costs.begin(), costs.end());\n    int count = 0;\n    for (int cost : costs) {\n        if (coins >= cost) {\n            coins -= cost;\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm first sorts the `costs` array in ascending order. Then, it traverses the sorted array and checks if the current cost can be covered by the remaining `coins`. If it can, the function decreases the `coins` by the cost and increments the count of bought ice cream bars. If it can't, the loop breaks, as the remaining ice creams are all more expensive. Finally, the function returns the count of bought ice cream bars.\n    ",
        "js": "\n    ```javascript\nfunction maxIceCream(costs, coins) {\n    costs.sort((a, b) => a - b);\n    let count = 0;\n    for (const cost of costs) {\n        if (coins >= cost) {\n            coins -= cost;\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm first sorts the `costs` array in ascending order. Then, it traverses the sorted array and checks if the current cost can be covered by the remaining `coins`. If it can, the function decreases the `coins` by the cost and increments the count of bought ice cream bars. If it can't, the loop breaks, as the remaining ice creams are all more expensive. Finally, the function returns the count of bought ice cream bars.\n    "
    },
    {
        "id": 357,
        "title": "Number of Strings That Appear as Substrings in Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `patterns` and a string `word`, return _the **number** of strings in_ `patterns` _that exist as a **substring** in_ `word`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** patterns = \\[ \"a \", \"abc \", \"bc \", \"d \"\\], word =  \"abc \"\n**Output:** 3\n**Explanation:**\n-  \"a \" appears as a substring in  \"abc \".\n-  \"abc \" appears as a substring in  \"abc \".\n-  \"bc \" appears as a substring in  \"abc \".\n-  \"d \" does not appear as a substring in  \"abc \".\n3 of the strings in patterns appear as a substring in word.\n\n",
                "**Example 2:**\n\n**Input:** patterns = \\[ \"a \", \"b \", \"c \"\\], word =  \"aaaaabbbbb \"\n**Output:** 2\n**Explanation:**\n-  \"a \" appears as a substring in  \"aaaaabbbbb \".\n-  \"b \" appears as a substring in  \"aaaaabbbbb \".\n-  \"c \" does not appear as a substring in  \"aaaaabbbbb \".\n2 of the strings in patterns appear as a substring in word.\n\n",
                "**Example 3:**\n\n**Input:** patterns = \\[ \"a \", \"a \", \"a \"\\], word =  \"ab \"\n**Output:** 3\n**Explanation:** Each of the patterns appears as a substring in word  \"ab \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= patterns.length <= 100`\n*   `1 <= patterns[i].length <= 100`\n*   `1 <= word.length <= 100`\n*   `patterns[i]` and `word` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"a\",\"abc\",\"bc\",\"d\"],\"abc\"",
                "output": "3"
            },
            {
                "input": "[\"a\",\"b\",\"c\"],\"aaaaabbbbb\"",
                "output": "2"
            },
            {
                "input": "[\"a\",\"a\",\"a\"],\"ab\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int longestBeautifulSubstring(String word) {\n    if (word.length() < 5) return 0;\n    \n    int maxLength = 0, currentLength = 1;\n    StringBuilder currentVowels = new StringBuilder(String.valueOf(word.charAt(0)));\n    \n    for (int i = 1; i < word.length(); ++i) {\n        char currentChar = word.charAt(i);\n        if (currentChar >= currentVowels.charAt(currentVowels.length() - 1) && currentVowels.indexOf(String.valueOf(currentChar)) == -1) {\n            currentVowels.append(currentChar);\n        } else if (currentChar == currentVowels.charAt(currentVowels.length() - 1)) {\n            // Do nothing\n        } else {\n            currentVowels = new StringBuilder(String.valueOf(currentChar));\n            currentLength = 0;\n        }\n        \n        currentLength++;\n\n        if (currentVowels.toString().equals(\"aeiou\")) {\n            maxLength = Math.max(maxLength, currentLength);\n        }\n    }\n    \n    return maxLength;\n}\n```\n\n    \n    The algorithm starts by checking if the input word is long enough to have a beautiful substring; otherwise, it returns 0 as no such substring can exist. Then, it initializes variables to track the maximum length of the beautiful substring, the current length of a candidate substring, and a string of vowels seen so far in the order they've appeared (`currentVowels`).\n\nIn the loop that goes through the input word, the algorithm checks if the current character is greater than or equal to the previous vowel and if it is not already in the `currentVowels`. If true, it adds the current character to `currentVowels`. If the current character is equal to the previous vowel, it does nothing. If the current character doesn't satisfy either of the previous conditions, it resets `currentVowels` to the current character and sets the `currentLength` to 0.\n\nFinally, for each iteration, it increments `currentLength` and checks if the `currentVowels` matches the beautiful substring condition (\"aeiou\"). If true, it updates the maxLength if the `currentLength` is greater than the current maxLength.\n\nOnce the loop is done, the algorithm returns the maxLength found.\n    ",
        "python": "\n    ```python\ndef longest_beautiful_substring(word: str) -> int:\n    if len(word) < 5:\n        return 0\n\n    max_length = current_length = 1\n    current_vowels = word[0]\n\n    for i in range(1, len(word)):\n        if word[i] >= current_vowels[-1] and word[i] not in current_vowels:\n            current_vowels += word[i]\n        elif word[i] == current_vowels[-1]:\n            pass\n        else:\n            current_vowels = word[i]\n            current_length = 0\n\n        current_length += 1\n\n        if current_vowels == \"aeiou\":\n            max_length = max(max_length, current_length)\n\n    return max_length\n```\n\n    \n    The algorithm starts by checking if the input word is long enough to have a beautiful substring; otherwise, it returns 0 as no such substring can exist. Then, it initializes variables to track the maximum length of the beautiful substring, the current length of a candidate substring, and a string of vowels seen so far in the order they've appeared (`currentVowels`).\n\nIn the loop that goes through the input word, the algorithm checks if the current character is greater than or equal to the previous vowel and if it is not already in the `currentVowels`. If true, it adds the current character to `currentVowels`. If the current character is equal to the previous vowel, it does nothing. If the current character doesn't satisfy either of the previous conditions, it resets `currentVowels` to the current character and sets the `currentLength` to 0.\n\nFinally, for each iteration, it increments `currentLength` and checks if the `currentVowels` matches the beautiful substring condition (\"aeiou\"). If true, it updates the maxLength if the `currentLength` is greater than the current maxLength.\n\nOnce the loop is done, the algorithm returns the maxLength found.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nint longestBeautifulSubstring(const std::string& word) {\n    if (word.size() < 5) return 0;\n    \n    int maxLength = 0, currentLength = 1;\n    std::string currentVowels = {word[0]};\n    \n    for (int i = 1; i < word.size(); ++i) {\n        if (word[i] >= currentVowels.back() && currentVowels.find(word[i]) == std::string::npos) {\n            currentVowels.push_back(word[i]);\n        } else if (word[i] == currentVowels.back()) {\n            // Do nothing\n        } else {\n            currentVowels = word[i];\n            currentLength = 0;\n        }\n        \n        currentLength++;\n\n        if (currentVowels == \"aeiou\") {\n            maxLength = std::max(maxLength, currentLength);\n        }\n    }\n    \n    return maxLength;\n}\n```\n\n    \n    The algorithm starts by checking if the input word is long enough to have a beautiful substring; otherwise, it returns 0 as no such substring can exist. Then, it initializes variables to track the maximum length of the beautiful substring, the current length of a candidate substring, and a string of vowels seen so far in the order they've appeared (`currentVowels`).\n\nIn the loop that goes through the input word, the algorithm checks if the current character is greater than or equal to the previous vowel and if it is not already in the `currentVowels`. If true, it adds the current character to `currentVowels`. If the current character is equal to the previous vowel, it does nothing. If the current character doesn't satisfy either of the previous conditions, it resets `currentVowels` to the current character and sets the `currentLength` to 0.\n\nFinally, for each iteration, it increments `currentLength` and checks if the `currentVowels` matches the beautiful substring condition (\"aeiou\"). If true, it updates the maxLength if the `currentLength` is greater than the current maxLength.\n\nOnce the loop is done, the algorithm returns the maxLength found.\n    ",
        "js": "\n    ```javascript\nfunction longestBeautifulSubstring(word) {\n    if (word.length < 5) return 0;\n    \n    let maxLength = 0, currentLength = 1;\n    let currentVowels = word[0];\n    \n    for (let i = 1; i < word.length; ++i) {\n        if (word[i] >= currentVowels[currentVowels.length - 1] && !currentVowels.includes(word[i])) {\n            currentVowels += word[i];\n        } else if (word[i] === currentVowels[currentVowels.length - 1]) {\n            // Do nothing\n        } else {\n            currentVowels = word[i];\n            currentLength = 0;\n        }\n        \n        currentLength++;\n\n        if (currentVowels === \"aeiou\") {\n            maxLength = Math.max(maxLength, currentLength);\n        }\n    }\n    \n    return maxLength;\n}\n```\n\n    \n    The algorithm starts by checking if the input word is long enough to have a beautiful substring; otherwise, it returns 0 as no such substring can exist. Then, it initializes variables to track the maximum length of the beautiful substring, the current length of a candidate substring, and a string of vowels seen so far in the order they've appeared (`currentVowels`).\n\nIn the loop that goes through the input word, the algorithm checks if the current character is greater than or equal to the previous vowel and if it is not already in the `currentVowels`. If true, it adds the current character to `currentVowels`. If the current character is equal to the previous vowel, it does nothing. If the current character doesn't satisfy either of the previous conditions, it resets `currentVowels` to the current character and sets the `currentLength` to 0.\n\nFinally, for each iteration, it increments `currentLength` and checks if the `currentVowels` matches the beautiful substring condition (\"aeiou\"). If true, it updates the maxLength if the `currentLength` is greater than the current maxLength.\n\nOnce the loop is done, the algorithm returns the maxLength found.\n    "
    },
    {
        "id": 358,
        "title": "Find if Path Exists in Graph",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a **bi-directional** graph with `n` vertices, where each vertex is labeled from `0` to `n - 1` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself.\n\nYou want to determine if there is a **valid path** that exists from vertex `source` to vertex `destination`.\n\nGiven `edges` and the integers `n`, `source`, and `destination`, return `true` _if there is a **valid path** from_ `source` _to_ `destination`_, or_ `false` _otherwise__._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,0\\]\\], source = 0, destination = 2\n**Output:** true\n**Explanation:** There are two paths from vertex 0 to vertex 2:\n- 0 -> 1 -> 2\n- 0 -> 2\n\n",
                "**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[3,5\\],\\[5,4\\],\\[4,3\\]\\], source = 0, destination = 5\n**Output:** false\n**Explanation:** There is no path from vertex 0 to vertex 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2 * 105`\n*   `0 <= edges.length <= 2 * 105`\n*   `edges[i].length == 2`\n*   `0 <= ui, vi <= n - 1`\n*   `ui != vi`\n*   `0 <= source, destination <= n - 1`\n*   There are no duplicate edges.\n*   There are no self edges.",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "3,[[0,1],[1,2],[2,0]],0,2",
                "output": "true"
            },
            {
                "input": "6,[[0,1],[0,2],[3,5],[5,4],[4,3]],0,5",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int[] memSticksCrash(int memory1, int memory2) {\n    int crashTime = 1;\n    while (true) {\n        if (memory1 >= memory2) {\n            if (memory1 >= crashTime) {\n                memory1 -= crashTime;\n            } else {\n                break;\n            }\n        } else {\n            if (memory2 >= crashTime) {\n                memory2 -= crashTime;\n            } else {\n                break;\n            }\n        }\n        crashTime++;\n    }\n    return new int[]{crashTime, memory1, memory2};\n}\n```\n    \n    The algorithm starts with a crashTime counter initialized to 1. Then we enter an infinite loop where we compare the available memory on both sticks. If the memory of stick 1 is greater or equal to stick 2, we try to allocate crashTime bits to it, but only if it has enough bits. If it doesn't have enough bits, we break the loop; otherwise, we subtract the bits used from it. We do the same for the memory stick with the lesser memory. Finally, we increment the crashTime counter by 1 at each iteration. When the loop breaks, the function returns an array containing crashTime, and the memory states of both memory sticks at the time of the crash. The algorithm is the same for all languages, with only minimal syntax adjustments.\n    ",
        "python": "\n    ```python\ndef mem_sticks_crash(memory1, memory2):\n    crash_time = 1\n    while True:\n        if memory1 >= memory2:\n            if memory1 >= crash_time:\n                memory1 -= crash_time\n            else:\n                break\n        else:\n            if memory2 >= crash_time:\n                memory2 -= crash_time\n            else:\n                break\n        crash_time += 1\n    return [crash_time, memory1, memory2]\n```\n    \n    The algorithm starts with a crashTime counter initialized to 1. Then we enter an infinite loop where we compare the available memory on both sticks. If the memory of stick 1 is greater or equal to stick 2, we try to allocate crashTime bits to it, but only if it has enough bits. If it doesn't have enough bits, we break the loop; otherwise, we subtract the bits used from it. We do the same for the memory stick with the lesser memory. Finally, we increment the crashTime counter by 1 at each iteration. When the loop breaks, the function returns an array containing crashTime, and the memory states of both memory sticks at the time of the crash. The algorithm is the same for all languages, with only minimal syntax adjustments.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> memSticksCrash(int memory1, int memory2) {\n    int crashTime = 1;\n    while (true) {\n        if (memory1 >= memory2) {\n            if (memory1 >= crashTime) {\n                memory1 -= crashTime;\n            } else {\n                break;\n            }\n        } else {\n            if (memory2 >= crashTime) {\n                memory2 -= crashTime;\n            } else {\n                break;\n            }\n        }\n        crashTime++;\n    }\n    return {crashTime, memory1, memory2};\n}\n```\n    \n    The algorithm starts with a crashTime counter initialized to 1. Then we enter an infinite loop where we compare the available memory on both sticks. If the memory of stick 1 is greater or equal to stick 2, we try to allocate crashTime bits to it, but only if it has enough bits. If it doesn't have enough bits, we break the loop; otherwise, we subtract the bits used from it. We do the same for the memory stick with the lesser memory. Finally, we increment the crashTime counter by 1 at each iteration. When the loop breaks, the function returns an array containing crashTime, and the memory states of both memory sticks at the time of the crash. The algorithm is the same for all languages, with only minimal syntax adjustments.\n    ",
        "js": "\n    ```javascript\nfunction memSticksCrash(memory1, memory2) {\n    let crashTime = 1;\n    while (true) {\n        if (memory1 >= memory2) {\n            if (memory1 >= crashTime) {\n                memory1 -= crashTime;\n            } else {\n                break;\n            }\n        } else {\n            if (memory2 >= crashTime) {\n                memory2 -= crashTime;\n            } else {\n                break;\n            }\n        }\n        crashTime++;\n    }\n    return [crashTime, memory1, memory2];\n}\n```\n    \n    The algorithm starts with a crashTime counter initialized to 1. Then we enter an infinite loop where we compare the available memory on both sticks. If the memory of stick 1 is greater or equal to stick 2, we try to allocate crashTime bits to it, but only if it has enough bits. If it doesn't have enough bits, we break the loop; otherwise, we subtract the bits used from it. We do the same for the memory stick with the lesser memory. Finally, we increment the crashTime counter by 1 at each iteration. When the loop breaks, the function returns an array containing crashTime, and the memory states of both memory sticks at the time of the crash. The algorithm is the same for all languages, with only minimal syntax adjustments.\n    "
    },
    {
        "id": 359,
        "title": "Minimum Time to Type Word Using Special Typewriter",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a special typewriter with lowercase English letters `'a'` to `'z'` arranged in a **circle** with a **pointer**. A character can **only** be typed if the pointer is pointing to that character. The pointer is **initially** pointing to the character `'a'`.\n\nEach second, you may perform one of the following operations:\n\n*   Move the pointer one character **counterclockwise** or **clockwise**.\n*   Type the character the pointer is **currently** on.\n\nGiven a string `word`, return the **minimum** number of seconds to type out the characters in `word`.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"abc \"\n**Output:** 5\n**Explanation:** \nThe characters are printed as follows:\n- Type the character 'a' in 1 second since the pointer is initially on 'a'.\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer clockwise to 'c' in 1 second.\n- Type the character 'c' in 1 second.\n\n",
                "**Example 2:**\n\n**Input:** word =  \"bza \"\n**Output:** 7\n**Explanation:**\nThe characters are printed as follows:\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer counterclockwise to 'z' in 2 seconds.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'a' in 1 second.\n- Type the character 'a' in 1 second.\n\n",
                "**Example 3:**\n\n**Input:** word =  \"zjpc \"\n**Output:** 34\n**Explanation:**\nThe characters are printed as follows:\n- Move the pointer counterclockwise to 'z' in 1 second.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'j' in 10 seconds.\n- Type the character 'j' in 1 second.\n- Move the pointer clockwise to 'p' in 6 seconds.\n- Type the character 'p' in 1 second.\n- Move the pointer counterclockwise to 'c' in 13 seconds.\n- Type the character 'c' in 1 second."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 100`\n*   `word` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abc\"",
                "output": "5"
            },
            {
                "input": "\"bza\"",
                "output": "7"
            },
            {
                "input": "\"zjpc\"",
                "output": "34"
            }
        ],
        "java": "\n    ```java\npublic int minTimeToType(String word) {\n    int time = 0, position = 0;\n    for (char c : word.toCharArray()) {\n        int next_position = c - 'a';\n        int diff = Math.abs(next_position - position);\n        time += Math.min(diff, 26 - diff) + 1;\n        position = next_position;\n    }\n    return time;\n}\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    ",
        "python": "\n    ```python\ndef minTimeToType(word: str) -> int:\n    time = 0\n    position = 0\n    for c in word:\n        next_position = ord(c) - ord('a')\n        diff = abs(next_position - position)\n        time += min(diff, 26 - diff) + 1\n        position = next_position\n    return time\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    ",
        "c++": "\n    ```cpp\nint minTimeToType(string word) {\n    int time = 0, position = 0;\n    for (char c : word) {\n        int next_position = c - 'a';\n        int diff = abs(next_position - position);\n        time += min(diff, 26 - diff) + 1;\n        position = next_position;\n    }\n    return time;\n}\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    ",
        "js": "\n    ```javascript\nfunction minTimeToType(word) {\n    let time = 0, position = 0;\n    for (const c of word) {\n        let next_position = c.charCodeAt(0) - 'a'.charCodeAt(0);\n        let diff = Math.abs(next_position - position);\n        time += Math.min(diff, 26 - diff) + 1;\n        position = next_position;\n    }\n    return time;\n}\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    "
    },
    {
        "id": 360,
        "title": "Find Greatest Common Divisor of Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the **greatest common divisor** of the smallest number and largest number in_ `nums`.\n\nThe **greatest common divisor** of two numbers is the largest positive integer that evenly divides both numbers.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,5,6,9,10\\]\n**Output:** 2\n**Explanation:**\nThe smallest number in nums is 2.\nThe largest number in nums is 10.\nThe greatest common divisor of 2 and 10 is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,5,6,8,3\\]\n**Output:** 1\n**Explanation:**\nThe smallest number in nums is 3.\nThe largest number in nums is 8.\nThe greatest common divisor of 3 and 8 is 1.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,3\\]\n**Output:** 3\n**Explanation:**\nThe smallest number in nums is 3.\nThe largest number in nums is 3.\nThe greatest common divisor of 3 and 3 is 3."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[2,5,6,9,10]",
                "output": "2"
            },
            {
                "input": "[7,5,6,8,3]",
                "output": "1"
            },
            {
                "input": "[3,3]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findGCD(int[] nums) {\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    while(max_val % min_val != 0) {\n        int temp = min_val;\n        min_val = max_val % min_val;\n        max_val = temp;\n    }\n    return min_val;\n}\n```\n    \n    1. First, find the minimum and maximum elements in the `nums` array.\n2. Initialize two variables `min_val` and `max_val` with the values of the minimum and maximum elements, respectively.\n3. Calculate the greatest common divisor (GCD) of `min_val` and `max_val` using the Euclidean algorithm. Keep performing the modulo operation and swapping them until `max_val % min_val` is equal to zero.\n4. Return the `min_val` as the GCD of the two numbers.\n    ",
        "python": "\n    ```python\ndef findGCD(nums):\n    min_val, max_val = min(nums), max(nums)\n    while max_val % min_val != 0:\n        min_val, max_val = max_val % min_val, min_val\n    return min_val\n```\n    \n    1. First, find the minimum and maximum elements in the `nums` array.\n2. Initialize two variables `min_val` and `max_val` with the values of the minimum and maximum elements, respectively.\n3. Calculate the greatest common divisor (GCD) of `min_val` and `max_val` using the Euclidean algorithm. Keep performing the modulo operation and swapping them until `max_val % min_val` is equal to zero.\n4. Return the `min_val` as the GCD of the two numbers.\n    ",
        "c++": "\n    ```cpp\nint findGCD(vector<int>& nums) {\n    auto min_max = minmax_element(nums.begin(), nums.end());\n    int min_val = *min_max.first;\n    int max_val = *min_max.second;\n    while(max_val % min_val != 0) {\n        int temp = min_val;\n        min_val = max_val % min_val;\n        max_val = temp;\n    }\n    return min_val;\n}\n```\n    \n    1. First, find the minimum and maximum elements in the `nums` array.\n2. Initialize two variables `min_val` and `max_val` with the values of the minimum and maximum elements, respectively.\n3. Calculate the greatest common divisor (GCD) of `min_val` and `max_val` using the Euclidean algorithm. Keep performing the modulo operation and swapping them until `max_val % min_val` is equal to zero.\n4. Return the `min_val` as the GCD of the two numbers.\n    ",
        "js": "\n    ```javascript\nfunction findGCD(nums) {\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    while(max_val % min_val !== 0) {\n        [min_val, max_val] = [max_val % min_val, min_val];\n    }\n    return min_val;\n}\n```\n    \n    1. First, find the minimum and maximum elements in the `nums` array.\n2. Initialize two variables `min_val` and `max_val` with the values of the minimum and maximum elements, respectively.\n3. Calculate the greatest common divisor (GCD) of `min_val` and `max_val` using the Euclidean algorithm. Keep performing the modulo operation and swapping them until `max_val % min_val` is equal to zero.\n4. Return the `min_val` as the GCD of the two numbers.\n    "
    },
    {
        "id": 361,
        "title": "Minimum Difference Between Highest and Lowest of K Scores",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.\n\nPick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**.\n\nReturn _the **minimum** possible difference_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[90\\], k = 1\n**Output:** 0\n**Explanation:** There is one way to pick score(s) of one student:\n- \\[**90**\\]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9,4,1,7\\], k = 2\n**Output:** 2\n**Explanation:** There are six ways to pick score(s) of two students:\n- \\[**9**,**4**,1,7\\]. The difference between the highest and lowest score is 9 - 4 = 5.\n- \\[**9**,4,**1**,7\\]. The difference between the highest and lowest score is 9 - 1 = 8.\n- \\[**9**,4,1,**7**\\]. The difference between the highest and lowest score is 9 - 7 = 2.\n- \\[9,**4**,**1**,7\\]. The difference between the highest and lowest score is 4 - 1 = 3.\n- \\[9,**4**,1,**7**\\]. The difference between the highest and lowest score is 7 - 4 = 3.\n- \\[9,4,**1**,**7**\\]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 1000`\n*   `0 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sliding Window",
            "Sorting"
        ],
        "example": [
            {
                "input": "[90],1",
                "output": "0"
            },
            {
                "input": "[9,4,1,7],2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int maxDistance(int[] nums1, int[] nums2) {\n    int i = 0, j = 0, maxDist = 0;\n    while (i < nums1.length && j < nums2.length) {\n        if (i <= j && nums1[i] <= nums2[j]) {\n            maxDist = Math.max(maxDist, j - i);\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return maxDist;\n}\n```\n    \n    1. Initialize variables `i` and `j` to 0 and `maxDist` to 0.\n2. Loop with a `while` condition until we reach the end of either of the arrays.\n3. Check the valid pair condition: `i <= j` and `nums1[i] <= nums2[j]`.\n   - If the pair is valid, calculate the distance as `j - i` and update `maxDist` if this distance is greater than its current value.\n   - Increment `j` to check the next element in array `nums2`.\n4. If the pair condition is not valid, increment `i` to check the next element in array `nums1`.\n5. Repeat steps 3-4 until the end of either array is reached.\n6. Return the `maxDist` as the maximum distance of a valid pair.\n    ",
        "python": "\n    ```python\ndef max_distance(nums1, nums2):\n    i, j, max_dist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if i <= j and nums1[i] <= nums2[j]:\n            max_dist = max(max_dist, j - i)\n            j += 1\n        else:\n            i += 1\n    return max_dist\n```\n    \n    1. Initialize variables `i` and `j` to 0 and `maxDist` to 0.\n2. Loop with a `while` condition until we reach the end of either of the arrays.\n3. Check the valid pair condition: `i <= j` and `nums1[i] <= nums2[j]`.\n   - If the pair is valid, calculate the distance as `j - i` and update `maxDist` if this distance is greater than its current value.\n   - Increment `j` to check the next element in array `nums2`.\n4. If the pair condition is not valid, increment `i` to check the next element in array `nums1`.\n5. Repeat steps 3-4 until the end of either array is reached.\n6. Return the `maxDist` as the maximum distance of a valid pair.\n    ",
        "c++": "\n    ```cpp\nint maxDistance(vector<int>& nums1, vector<int>& nums2) {\n    int i = 0, j = 0, maxDist = 0;\n    while (i < nums1.size() && j < nums2.size()) {\n        if (i <= j && nums1[i] <= nums2[j]) {\n            maxDist = max(maxDist, j - i);\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return maxDist;\n}\n```\n    \n    1. Initialize variables `i` and `j` to 0 and `maxDist` to 0.\n2. Loop with a `while` condition until we reach the end of either of the arrays.\n3. Check the valid pair condition: `i <= j` and `nums1[i] <= nums2[j]`.\n   - If the pair is valid, calculate the distance as `j - i` and update `maxDist` if this distance is greater than its current value.\n   - Increment `j` to check the next element in array `nums2`.\n4. If the pair condition is not valid, increment `i` to check the next element in array `nums1`.\n5. Repeat steps 3-4 until the end of either array is reached.\n6. Return the `maxDist` as the maximum distance of a valid pair.\n    ",
        "js": "\n    ```javascript\nfunction maxDistance(nums1, nums2) {\n    let i = 0, j = 0, maxDist = 0;\n    while (i < nums1.length && j < nums2.length) {\n        if (i <= j && nums1[i] <= nums2[j]) {\n            maxDist = Math.max(maxDist, j - i);\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return maxDist;\n}\n```\n    \n    1. Initialize variables `i` and `j` to 0 and `maxDist` to 0.\n2. Loop with a `while` condition until we reach the end of either of the arrays.\n3. Check the valid pair condition: `i <= j` and `nums1[i] <= nums2[j]`.\n   - If the pair is valid, calculate the distance as `j - i` and update `maxDist` if this distance is greater than its current value.\n   - Increment `j` to check the next element in array `nums2`.\n4. If the pair condition is not valid, increment `i` to check the next element in array `nums1`.\n5. Repeat steps 3-4 until the end of either array is reached.\n6. Return the `maxDist` as the maximum distance of a valid pair.\n    "
    },
    {
        "id": 362,
        "title": "Find the Middle Index in Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, find the **leftmost** `middleIndex` (i.e., the smallest amongst all the possible ones).\n\nA `middleIndex` is an index where `nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]`.\n\nIf `middleIndex == 0`, the left side sum is considered to be `0`. Similarly, if `middleIndex == nums.length - 1`, the right side sum is considered to be `0`.\n\nReturn _the **leftmost**_ `middleIndex` _that satisfies the condition, or_ `-1` _if there is no such index_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,-1,8,4\\]\n**Output:** 3\n**Explanation:** The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,-1,4\\]\n**Output:** 2\n**Explanation:** The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,5\\]\n**Output:** -1\n**Explanation:** There is no valid middleIndex."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `-1000 <= nums[i] <= 1000`\n\n**Note:** This question is the same as 724: [https://leetcode.com/problems/find-pivot-index/](https://leetcode.com/problems/find-pivot-index/)",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,3,-1,8,4]",
                "output": "3"
            },
            {
                "input": "[1,-1,4]",
                "output": "2"
            },
            {
                "input": "[2,5]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findMiddleIndex(int[] nums) {\n    int totalSum = 0, leftSum = 0;\n\n    for (int num : nums) {\n        totalSum += num;\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (leftSum == totalSum - leftSum - nums[i]) {\n            return i;\n        }\n        leftSum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    ",
        "python": "\n    ```python\ndef findMiddleIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n\n    return -1\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint findMiddleIndex(vector<int>& nums) {\n    int total_sum = 0, left_sum = 0;\n\n    for (int num : nums) {\n        total_sum += num;\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        if (left_sum == total_sum - left_sum - nums[i]) {\n            return i;\n        }\n        left_sum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findMiddleIndex(nums) {\n    let totalSum = 0, leftSum = 0;\n\n    nums.forEach(num => {\n        totalSum += num;\n    });\n\n    for (let i = 0; i < nums.length; i++) {\n        if (leftSum === totalSum - leftSum - nums[i]) {\n            return i;\n        }\n        leftSum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    "
    },
    {
        "id": 363,
        "title": "Reverse Prefix of Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** string `word` and a character `ch`, **reverse** the segment of `word` that starts at index `0` and ends at the index of the **first occurrence** of `ch` (**inclusive**). If the character `ch` does not exist in `word`, do nothing.\n\n*   For example, if `word = \"abcdefd \"` and `ch = \"d \"`, then you should **reverse** the segment that starts at `0` and ends at `3` (**inclusive**). The resulting string will be `\"dcbaefd \"`.\n\nReturn _the resulting string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"abcdefd \", ch =  \"d \"\n**Output:**  \"dcbaefd \"\n**Explanation:** The first occurrence of  \"d \" is at index 3. \nReverse the part of word from 0 to 3 (inclusive), the resulting string is  \"dcbaefd \".\n\n",
                "**Example 2:**\n\n**Input:** word =  \"xyxzxe \", ch =  \"z \"\n**Output:**  \"zxyxxe \"\n**Explanation:** The first and only occurrence of  \"z \" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is  \"zxyxxe \".\n\n",
                "**Example 3:**\n\n**Input:** word =  \"abcd \", ch =  \"z \"\n**Output:**  \"abcd \"\n**Explanation:**  \"z \" does not exist in word.\nYou should not do any reverse operation, the resulting string is  \"abcd \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 250`\n*   `word` consists of lowercase English letters.\n*   `ch` is a lowercase English letter.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"abcdefd\",\"d\"",
                "output": "\"dcbaefd\""
            },
            {
                "input": "\"xyxzxe\",\"z\"",
                "output": "\"zxyxxe\""
            },
            {
                "input": "\"abcd\",\"z\"",
                "output": "\"abcd\""
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public int minimumSpeed(int n, float hour, int[] dist) {\n        if (n > Math.ceil(hour)) return -1;\n        int low = 1, high = 10000000, mid, speed;\n        \n        while (low <= high) {\n            mid = low + (high - low) / 2;\n            float time = 0;\n            for (int i = 0; i < n; ++i) {\n                time += Math.ceil(dist[i] * 1.0 / mid);\n            }\n            if (time <= hour) {\n                speed = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return speed;\n    }\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum positive integer speed required for all trains to be on time. At first, we check if it's impossible to reach on time by counting if the number of distinct integer hours is less than the number of trains, if so we return `-1`. Then, we initialize the search space to be from 1 to (10^7). Within this search space, we calculate the sum of the time for each set of speeds from the middle of the search space. If this total time is less than or equal to the given hour, we choose the middle speed and reduce the search space to the left (since we are looking for the minimum speed). If the time is greater than the given hour, we increase the search space to the right. The process continues in this manner until we find the minimum speed required for the trains.\n    ",
        "python": "\n    ```python\nimport math\ndef minimum_speed(n, hour, dist):\n    if n > math.ceil(hour): return -1\n    low, high = 1, int(1e7)\n    \n    while low <= high:\n        mid = low + (high - low) // 2\n        time = sum(math.ceil(d / mid) for d in dist)\n        if time <= hour:\n            speed = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n            \n    return speed\n```\n    \n    The algorithm uses a binary search approach to find the minimum positive integer speed required for all trains to be on time. At first, we check if it's impossible to reach on time by counting if the number of distinct integer hours is less than the number of trains, if so we return `-1`. Then, we initialize the search space to be from 1 to (10^7). Within this search space, we calculate the sum of the time for each set of speeds from the middle of the search space. If this total time is less than or equal to the given hour, we choose the middle speed and reduce the search space to the left (since we are looking for the minimum speed). If the time is greater than the given hour, we increase the search space to the right. The process continues in this manner until we find the minimum speed required for the trains.\n    ",
        "c++": "\n    ```cpp\n#include <cmath>\n#include <vector>\nint minimumSpeed(int n, float hour, std::vector<int>& dist) {\n    if (n > ceil(hour)) return -1;\n    int low = 1, high = 1e7, mid, speed;\n    \n    while (low <= high) {\n        mid = low + (high - low) / 2;\n        float time = 0;\n        for (int i = 0; i < n; ++i) {\n            time += ceil(dist[i] * 1.0 / mid);\n        }\n        if (time <= hour) {\n            speed = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return speed;\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum positive integer speed required for all trains to be on time. At first, we check if it's impossible to reach on time by counting if the number of distinct integer hours is less than the number of trains, if so we return `-1`. Then, we initialize the search space to be from 1 to (10^7). Within this search space, we calculate the sum of the time for each set of speeds from the middle of the search space. If this total time is less than or equal to the given hour, we choose the middle speed and reduce the search space to the left (since we are looking for the minimum speed). If the time is greater than the given hour, we increase the search space to the right. The process continues in this manner until we find the minimum speed required for the trains.\n    ",
        "js": "\n    ```javascript\nfunction minimumSpeed(n, hour, dist) {\n    if (n > Math.ceil(hour)) return -1;\n    let low = 1, high = 1e7, mid, speed;\n    \n    while (low <= high) {\n        mid = low + Math.floor((high - low) / 2);\n        let time = 0;\n        for (let i = 0; i < n; ++i) {\n            time += Math.ceil(dist[i] * 1.0 / mid);\n        }\n        if (time <= hour) {\n            speed = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return speed;\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum positive integer speed required for all trains to be on time. At first, we check if it's impossible to reach on time by counting if the number of distinct integer hours is less than the number of trains, if so we return `-1`. Then, we initialize the search space to be from 1 to (10^7). Within this search space, we calculate the sum of the time for each set of speeds from the middle of the search space. If this total time is less than or equal to the given hour, we choose the middle speed and reduce the search space to the left (since we are looking for the minimum speed). If the time is greater than the given hour, we increase the search space to the right. The process continues in this manner until we find the minimum speed required for the trains.\n    "
    },
    {
        "id": 364,
        "title": "Count Number of Pairs With Absolute Difference K",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the number of pairs_ `(i, j)` _where_ `i < j` _such that_ `|nums[i] - nums[j]| == k`.\n\nThe value of `|x|` is defined as:\n\n*   `x` if `x >= 0`.\n*   `-x` if `x < 0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,1\\], k = 1\n**Output:** 4\n**Explanation:** The pairs with an absolute difference of 1 are:\n- \\[**1**,**2**,2,1\\]\n- \\[**1**,2,**2**,1\\]\n- \\[1,**2**,2,**1**\\]\n- \\[1,2,**2**,**1**\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3\\], k = 3\n**Output:** 0\n**Explanation:** There are no pairs with an absolute difference of 3.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,2,1,5,4\\], k = 2\n**Output:** 3\n**Explanation:** The pairs with an absolute difference of 2 are:\n- \\[**3**,2,**1**,5,4\\]\n- \\[**3**,2,1,**5**,4\\]\n- \\[3,**2**,1,5,**4**\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 100`\n*   `1 <= k <= 99`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,2,2,1],1",
                "output": "4"
            },
            {
                "input": "[1,3],3",
                "output": "0"
            },
            {
                "input": "[3,2,1,5,4],2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int chalkReplacer(int[] chalk, int k) {\n    long sum = 0;\n    for (int i = 0; i < chalk.length; i++) {\n        sum += chalk[i];\n    }\n    k %= sum;\n    for (int i = 0; i < chalk.length; i++) {\n        if (k < chalk[i]) {\n            return i;\n        }\n        k -= chalk[i];\n    }\n    return 0;\n}\n```\n    \n    1. Calculate the sum of all elements in the `chalk` array, representing the total chalk needed for one full cycle.\n2. Calculate the remainder of `k` divided by the total chalk needed using modulo operation (`k %= sum`). This will determine the remaining chalk when the teacher starts the last cycle.\n3. Iterate through the `chalk` array:\n   - If the remaining chalk (`k`) is less than the chalk needed by the current student (`chalk[i]` for C++ and Java, or `val` for Python and JavaScript), return the index of this student.\n   - Otherwise, update the remaining chalk by subtracting the chalk needed by the current student from `k`.\n\nRepeat this process until a student is found who will replace the chalk.\n    ",
        "python": "\n    ```python\ndef chalk_replacer(chalk, k):\n    total_chalk = sum(chalk)\n    k %= total_chalk\n    for i, val in enumerate(chalk):\n        if k < val:\n            return i\n        k -= val\n    return 0\n```\n    \n    1. Calculate the sum of all elements in the `chalk` array, representing the total chalk needed for one full cycle.\n2. Calculate the remainder of `k` divided by the total chalk needed using modulo operation (`k %= sum`). This will determine the remaining chalk when the teacher starts the last cycle.\n3. Iterate through the `chalk` array:\n   - If the remaining chalk (`k`) is less than the chalk needed by the current student (`chalk[i]` for C++ and Java, or `val` for Python and JavaScript), return the index of this student.\n   - Otherwise, update the remaining chalk by subtracting the chalk needed by the current student from `k`.\n\nRepeat this process until a student is found who will replace the chalk.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint chalkReplacer(std::vector<int>& chalk, int k) {\n    long long sum = 0;\n    for (int i = 0; i < chalk.size(); i++) {\n        sum += chalk[i];\n    }\n    k %= sum;\n    for (int i = 0; i < chalk.size(); i++) {\n        if (k < chalk[i]) {\n            return i;\n        }\n        k -= chalk[i];\n    }\n    return 0;\n}\n```\n    \n    1. Calculate the sum of all elements in the `chalk` array, representing the total chalk needed for one full cycle.\n2. Calculate the remainder of `k` divided by the total chalk needed using modulo operation (`k %= sum`). This will determine the remaining chalk when the teacher starts the last cycle.\n3. Iterate through the `chalk` array:\n   - If the remaining chalk (`k`) is less than the chalk needed by the current student (`chalk[i]` for C++ and Java, or `val` for Python and JavaScript), return the index of this student.\n   - Otherwise, update the remaining chalk by subtracting the chalk needed by the current student from `k`.\n\nRepeat this process until a student is found who will replace the chalk.\n    ",
        "js": "\n    ```javascript\nfunction chalkReplacer(chalk, k) {\n    let sum = chalk.reduce((a, b) => a + b, 0);\n    k %= sum;\n    for (let i = 0; i < chalk.length; i++) {\n        if (k < chalk[i]) {\n            return i;\n        }\n        k -= chalk[i];\n    }\n    return 0;\n}\n```\n    \n    1. Calculate the sum of all elements in the `chalk` array, representing the total chalk needed for one full cycle.\n2. Calculate the remainder of `k` divided by the total chalk needed using modulo operation (`k %= sum`). This will determine the remaining chalk when the teacher starts the last cycle.\n3. Iterate through the `chalk` array:\n   - If the remaining chalk (`k`) is less than the chalk needed by the current student (`chalk[i]` for C++ and Java, or `val` for Python and JavaScript), return the index of this student.\n   - Otherwise, update the remaining chalk by subtracting the chalk needed by the current student from `k`.\n\nRepeat this process until a student is found who will replace the chalk.\n    "
    },
    {
        "id": 365,
        "title": "Final Value of Variable After Performing Operations",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a programming language with only **four** operations and **one** variable `X`:\n\n*   `++X` and `X++` **increments** the value of the variable `X` by `1`.\n*   `--X` and `X--` **decrements** the value of the variable `X` by `1`.\n\nInitially, the value of `X` is `0`.\n\nGiven an array of strings `operations` containing a list of operations, return _the **final** value of_ `X` _after performing all the operations_.",
            "examples": [
                "**Example 1:**\n\n**Input:** operations = \\[ \"--X \", \"X++ \", \"X++ \"\\]\n**Output:** 1\n**Explanation:** The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.\n\n",
                "**Example 2:**\n\n**Input:** operations = \\[ \"++X \", \"++X \", \"X++ \"\\]\n**Output:** 3\n**Explanation:** The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.\n\n",
                "**Example 3:**\n\n**Input:** operations = \\[ \"X++ \", \"++X \", \"--X \", \"X-- \"\\]\n**Output:** 0\n**Explanation:** The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= operations.length <= 100`\n*   `operations[i]` will be either `\"++X \"`, `\"X++ \"`, `\"--X \"`, or `\"X-- \"`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "[\"--X\",\"X++\",\"X++\"]",
                "output": "1"
            },
            {
                "input": "[\"++X\",\"++X\",\"X++\"]",
                "output": "3"
            },
            {
                "input": "[\"X++\",\"++X\",\"--X\",\"X--\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic String maxValue(String n, int x) {\n    boolean is_negative = n.charAt(0) == '-';\n    int pos = is_negative ? 1 : 0;\n\n    while (pos < n.length()) {\n        if (is_negative && n.charAt(pos) - '0' > x || !is_negative && n.charAt(pos) - '0' < x) {\n            break;\n        }\n        pos++;\n    }\n\n    return n.substring(0, pos) + Integer.toString(x) + n.substring(pos);\n}\n```\n    \n    The algorithm starts by checking if the given integer `n` is negative or not, and initializes the position `pos` where we want to insert the integer `x`. It then iterates through the digits of `n`. For negative numbers, it checks to find the first digit that is greater than `x`. For positive numbers, it looks for the first digit that is smaller than `x`. If found, we break out of the loop.\n\nFinally, we return the new string by concatenating the substring before the position `pos`, the digit `x`, and the substring after the position.\n\nThe algorithm has a complexity of O(n) where n is the length of the input string.\n    ",
        "python": "\n    ```python\ndef max_value(n: str, x: int) -> str:\n    is_negative = n[0] == '-'\n    pos = 1 if is_negative else 0\n\n    while pos < len(n):\n        if (is_negative and int(n[pos]) > x) or (not is_negative and int(n[pos]) < x):\n            break\n        pos += 1\n\n    return n[:pos] + str(x) + n[pos:]\n```\n    \n    The algorithm starts by checking if the given integer `n` is negative or not, and initializes the position `pos` where we want to insert the integer `x`. It then iterates through the digits of `n`. For negative numbers, it checks to find the first digit that is greater than `x`. For positive numbers, it looks for the first digit that is smaller than `x`. If found, we break out of the loop.\n\nFinally, we return the new string by concatenating the substring before the position `pos`, the digit `x`, and the substring after the position.\n\nThe algorithm has a complexity of O(n) where n is the length of the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string maxValue(std::string n, int x) {\n    bool is_negative = n[0] == '-';\n    int pos = is_negative ? 1 : 0;\n\n    while (pos < n.size()) {\n        if (is_negative && n[pos] - '0' > x || !is_negative && n[pos] - '0' < x) {\n            break;\n        }\n        pos++;\n    }\n\n    return n.substr(0, pos) + std::to_string(x) + n.substr(pos);\n}\n```\n    \n    The algorithm starts by checking if the given integer `n` is negative or not, and initializes the position `pos` where we want to insert the integer `x`. It then iterates through the digits of `n`. For negative numbers, it checks to find the first digit that is greater than `x`. For positive numbers, it looks for the first digit that is smaller than `x`. If found, we break out of the loop.\n\nFinally, we return the new string by concatenating the substring before the position `pos`, the digit `x`, and the substring after the position.\n\nThe algorithm has a complexity of O(n) where n is the length of the input string.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(n, x) {\n    const isNegative = n[0] === '-';\n    let pos = isNegative ? 1 : 0;\n\n    while (pos < n.length) {\n        if ((isNegative && parseInt(n[pos], 10) > x) || (!isNegative && parseInt(n[pos], 10) < x)) {\n            break;\n        }\n        pos++;\n    }\n\n    return n.slice(0, pos) + x.toString() + n.slice(pos);\n}\n```\n    \n    The algorithm starts by checking if the given integer `n` is negative or not, and initializes the position `pos` where we want to insert the integer `x`. It then iterates through the digits of `n`. For negative numbers, it checks to find the first digit that is greater than `x`. For positive numbers, it looks for the first digit that is smaller than `x`. If found, we break out of the loop.\n\nFinally, we return the new string by concatenating the substring before the position `pos`, the digit `x`, and the substring after the position.\n\nThe algorithm has a complexity of O(n) where n is the length of the input string.\n    "
    },
    {
        "id": 366,
        "title": "Maximum Difference Between Increasing Elements",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums` of size `n`, find the **maximum difference** between `nums[i]` and `nums[j]` (i.e., `nums[j] - nums[i]`), such that `0 <= i < j < n` and `nums[i] < nums[j]`.\n\nReturn _the **maximum difference**._ If no such `i` and `j` exists, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,**1**,**5**,4\\]\n**Output:** 4\n**Explanation:**\nThe maximum difference occurs with i = 1 and j = 2, nums\\[j\\] - nums\\[i\\] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums\\[j\\] - nums\\[i\\] = 7 - 1 = 6, but i > j, so it is not valid.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9,4,3,2\\]\n**Output:** -1\n**Explanation:**\nThere is no i and j such that i < j and nums\\[i\\] < nums\\[j\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[**1**,5,2,**10**\\]\n**Output:** 9\n**Explanation:**\nThe maximum difference occurs with i = 0 and j = 3, nums\\[j\\] - nums\\[i\\] = 10 - 1 = 9."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 1000`\n*   `1 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[7,**1**,**5**,4]",
                "output": "4"
            },
            {
                "input": "[9,4,3,2]",
                "output": "-1"
            },
            {
                "input": "[**1**,5,2,**10**]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int min_steps_to_equal_elements(int[] nums) {\n    int min_elem = Arrays.stream(nums).min().getAsInt();\n    int steps = 0;\n    for(int num : nums) {\n        steps += (num - min_elem);\n    }\n    return steps;\n}\n```\n    \n    The algorithm you use to minimize the number of operations is as follows:\n\n1. Find the minimum element in the array. This can be done using a built-in function (e.g., in C++, std::min_element; in Python, min(); or in JavaScript, Math.min()) or by iterating through the array and keeping track of the minimum element encountered.\n2. Initialize a variable named `steps` to store the total number of operations needed.\n3. Iterate through the array again, and for each element, subtract the minimum element from the current element, and add the result to `steps`.\n4. Return `steps`. The variable `steps` will store the minimum number of operations required to make all elements equal in the input array.\n\nThe idea behind this approach is that we can perform multiple subtractions on each element until they all reach the same value as the minimum element in the array. This guarantees the minimum number of operations possible because making all values equal necessarily means having them all equal to the minimum element in the array. Otherwise, additional operations would be needed to decrease the value of at least one element further.\n    ",
        "python": "\n    ```python\ndef min_steps_to_equal_elements(nums):\n    min_elem = min(nums)\n    steps = 0\n    for num in nums:\n        steps += (num - min_elem)\n    return steps\n```\n    \n    The algorithm you use to minimize the number of operations is as follows:\n\n1. Find the minimum element in the array. This can be done using a built-in function (e.g., in C++, std::min_element; in Python, min(); or in JavaScript, Math.min()) or by iterating through the array and keeping track of the minimum element encountered.\n2. Initialize a variable named `steps` to store the total number of operations needed.\n3. Iterate through the array again, and for each element, subtract the minimum element from the current element, and add the result to `steps`.\n4. Return `steps`. The variable `steps` will store the minimum number of operations required to make all elements equal in the input array.\n\nThe idea behind this approach is that we can perform multiple subtractions on each element until they all reach the same value as the minimum element in the array. This guarantees the minimum number of operations possible because making all values equal necessarily means having them all equal to the minimum element in the array. Otherwise, additional operations would be needed to decrease the value of at least one element further.\n    ",
        "c++": "\n    ```cpp\nint min_steps_to_equal_elements(vector<int>& nums) {\n    int min_elem = *min_element(nums.begin(), nums.end());\n    int steps = 0;\n    for(int num : nums) {\n        steps += (num - min_elem);\n    }\n    return steps;\n}\n```\n    \n    The algorithm you use to minimize the number of operations is as follows:\n\n1. Find the minimum element in the array. This can be done using a built-in function (e.g., in C++, std::min_element; in Python, min(); or in JavaScript, Math.min()) or by iterating through the array and keeping track of the minimum element encountered.\n2. Initialize a variable named `steps` to store the total number of operations needed.\n3. Iterate through the array again, and for each element, subtract the minimum element from the current element, and add the result to `steps`.\n4. Return `steps`. The variable `steps` will store the minimum number of operations required to make all elements equal in the input array.\n\nThe idea behind this approach is that we can perform multiple subtractions on each element until they all reach the same value as the minimum element in the array. This guarantees the minimum number of operations possible because making all values equal necessarily means having them all equal to the minimum element in the array. Otherwise, additional operations would be needed to decrease the value of at least one element further.\n    ",
        "js": "\n    ```javascript\nfunction min_steps_to_equal_elements(nums) {\n    let min_elem = Math.min(...nums);\n    let steps = 0;\n    for(let num of nums) {\n        steps += (num - min_elem);\n    }\n    return steps;\n}\n```\n    \n    The algorithm you use to minimize the number of operations is as follows:\n\n1. Find the minimum element in the array. This can be done using a built-in function (e.g., in C++, std::min_element; in Python, min(); or in JavaScript, Math.min()) or by iterating through the array and keeping track of the minimum element encountered.\n2. Initialize a variable named `steps` to store the total number of operations needed.\n3. Iterate through the array again, and for each element, subtract the minimum element from the current element, and add the result to `steps`.\n4. Return `steps`. The variable `steps` will store the minimum number of operations required to make all elements equal in the input array.\n\nThe idea behind this approach is that we can perform multiple subtractions on each element until they all reach the same value as the minimum element in the array. This guarantees the minimum number of operations possible because making all values equal necessarily means having them all equal to the minimum element in the array. Otherwise, additional operations would be needed to decrease the value of at least one element further.\n    "
    },
    {
        "id": 367,
        "title": "Convert 1D Array Into 2D Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** 1-dimensional (1D) integer array `original`, and two integers, `m` and `n`. You are tasked with creating a 2-dimensional (2D) array with `m` rows and `n` columns using **all** the elements from `original`.\n\nThe elements from indices `0` to `n - 1` (**inclusive**) of `original` should form the first row of the constructed 2D array, the elements from indices `n` to `2 * n - 1` (**inclusive**) should form the second row of the constructed 2D array, and so on.\n\nReturn _an_ `m x n` _2D array constructed according to the above procedure, or an empty 2D array if it is impossible_.",
            "examples": [
                "**Example 1:**\n\n**Input:** original = \\[1,2,3,4\\], m = 2, n = 2\n**Output:** \\[\\[1,2\\],\\[3,4\\]\\]\n**Explanation:** The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, \\[1,2\\], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, \\[3,4\\], becomes the second row in the constructed 2D array.\n\n",
                "**Example 2:**\n\n**Input:** original = \\[1,2,3\\], m = 1, n = 3\n**Output:** \\[\\[1,2,3\\]\\]\n**Explanation:** The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\n",
                "**Example 3:**\n\n**Input:** original = \\[1,2\\], m = 1, n = 1\n**Output:** \\[\\]\n**Explanation:** There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= original.length <= 5 * 104`\n*   `1 <= original[i] <= 105`\n*   `1 <= m, n <= 4 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,2,3,4],2,2",
                "output": "[[1,2],[3,4]]"
            },
            {
                "input": "[1,2,3],1,3",
                "output": "[[1,2,3]]"
            },
            {
                "input": "[1,2],1,1",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic long maxAlternatingSum(int[] nums) {\n    long evenSum = 0, oddSum = 0;\n    for (int num : nums) {\n        evenSum = Math.max(evenSum + num, oddSum);\n        oddSum = evenSum - num;\n    }\n    return evenSum;\n}\n```\n    \n    The algorithm loops through each element of the input array `nums`. For each number:\n1. Calculate the new possible even index sum by adding the current number to the previous even sum.\n2. Compare it with the previous odd index sum and take the maximum of the two;\n3. Update the odd index sum by subtracting the current number from the updated even sum.\n\nThe algorithm maintains the maximum alternating sum in both even and odd indices during the loop. After iterating through all the numbers, the final result (maximum alternating sum) will be stored in the even sum variable. This approach has a time complexity of O(n) where n is the number of elements in the input array.\n    ",
        "python": "\n    ```python\ndef max_alternating_sum(nums):\n    even_sum = odd_sum = 0\n    for num in nums:\n        even_sum, odd_sum = max(even_sum + num, odd_sum), even_sum - num\n    return even_sum\n```\n    \n    The algorithm loops through each element of the input array `nums`. For each number:\n1. Calculate the new possible even index sum by adding the current number to the previous even sum.\n2. Compare it with the previous odd index sum and take the maximum of the two;\n3. Update the odd index sum by subtracting the current number from the updated even sum.\n\nThe algorithm maintains the maximum alternating sum in both even and odd indices during the loop. After iterating through all the numbers, the final result (maximum alternating sum) will be stored in the even sum variable. This approach has a time complexity of O(n) where n is the number of elements in the input array.\n    ",
        "c++": "\n    ```cpp\nlong long maxAlternatingSum(vector<int>& nums) {\n    long long evenSum = 0, oddSum = 0;\n    for (int num : nums) {\n        evenSum = max(evenSum + num, oddSum);\n        oddSum = evenSum - num;\n    }\n    return evenSum;\n}\n```\n    \n    The algorithm loops through each element of the input array `nums`. For each number:\n1. Calculate the new possible even index sum by adding the current number to the previous even sum.\n2. Compare it with the previous odd index sum and take the maximum of the two;\n3. Update the odd index sum by subtracting the current number from the updated even sum.\n\nThe algorithm maintains the maximum alternating sum in both even and odd indices during the loop. After iterating through all the numbers, the final result (maximum alternating sum) will be stored in the even sum variable. This approach has a time complexity of O(n) where n is the number of elements in the input array.\n    ",
        "js": "\n    ```javascript\nfunction maxAlternatingSum(nums) {\n    let evenSum = 0, oddSum = 0;\n    for (let num of nums) {\n        [evenSum, oddSum] = [Math.max(evenSum + num, oddSum), evenSum - num];\n    }\n    return evenSum;\n}\n```\n    \n    The algorithm loops through each element of the input array `nums`. For each number:\n1. Calculate the new possible even index sum by adding the current number to the previous even sum.\n2. Compare it with the previous odd index sum and take the maximum of the two;\n3. Update the odd index sum by subtracting the current number from the updated even sum.\n\nThe algorithm maintains the maximum alternating sum in both even and odd indices during the loop. After iterating through all the numbers, the final result (maximum alternating sum) will be stored in the even sum variable. This approach has a time complexity of O(n) where n is the number of elements in the input array.\n    "
    },
    {
        "id": 368,
        "title": "Minimum Moves to Convert String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` consisting of `n` characters which are either `'X'` or `'O'`.\n\nA **move** is defined as selecting **three** **consecutive characters** of `s` and converting them to `'O'`. Note that if a move is applied to the character `'O'`, it will stay the **same**.\n\nReturn _the **minimum** number of moves required so that all the characters of_ `s` _are converted to_ `'O'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"XXX \"\n**Output:** 1\n**Explanation:** XXX -> OOO\nWe select all the 3 characters and convert them in one move.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"XXOX \"\n**Output:** 2\n**Explanation:** XXOX -> OOOX -> OOOO\nWe select the first 3 characters in the first move, and convert them to `'O'`.\nThen we select the last 3 characters and convert them so that the final string contains all `'O'`s.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"OOOO \"\n**Output:** 0\n**Explanation:** There are no `'X's` in `s` to convert."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= s.length <= 1000`\n*   `s[i]` is either `'X'` or `'O'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"XXX\"",
                "output": "1"
            },
            {
                "input": "\"XXOX\"",
                "output": "2"
            },
            {
                "input": "\"OOOO\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maximumRemovals(String s, String p, int[] removable) {\n    int low = 0, high = removable.length;\n    while (low < high) {\n        int mid = low + (high - low + 1) / 2;\n        char[] ss = s.toCharArray();\n        for (int i = 0; i < mid; ++i) {\n            ss[removable[i]] = '-';\n        }\n        int j = 0, i = 0;\n        while (i < ss.length && j < p.length()) {\n            if (ss[i] == p.charAt(j)) {\n                ++j;\n            }\n            ++i;\n        }\n        if (j == p.length()) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low;\n}\n```\n\n    \n    The algorithm is basically binary search. We iterate through the removable array and start by removing `mid` (the middle element) number of characters from `s`. Then, we check if `p` is still a subsequence of the modified string. If it's a subsequence, it means we can try removing more characters, hence updating the lower bound `low` to `mid`. If it's not a subsequence, we update the upper bound `high` to `mid - 1`, meaning we have to try removing fewer characters. We do this until `low < high`, and then return the maximum value of `k = low` which will give us the maximum removable characters where `p` is still a subsequence of `s`.\n    ",
        "python": "\n    ```python\ndef maximumRemovals(s: str, p: str, removable: List[int]) -> int:\n    low, high = 0, len(removable)\n    while low < high:\n        mid = low + (high - low + 1) // 2\n        ss = list(s)\n        for i in range(mid):\n            ss[removable[i]] = '-'\n        j, i = 0, 0\n        while i < len(ss) and j < len(p):\n            if ss[i] == p[j]:\n                j += 1\n            i += 1\n        if j == len(p):\n            low = mid\n        else:\n            high = mid - 1\n    return low\n```\n\n    \n    The algorithm is basically binary search. We iterate through the removable array and start by removing `mid` (the middle element) number of characters from `s`. Then, we check if `p` is still a subsequence of the modified string. If it's a subsequence, it means we can try removing more characters, hence updating the lower bound `low` to `mid`. If it's not a subsequence, we update the upper bound `high` to `mid - 1`, meaning we have to try removing fewer characters. We do this until `low < high`, and then return the maximum value of `k = low` which will give us the maximum removable characters where `p` is still a subsequence of `s`.\n    ",
        "c++": "\n    ```cpp\nint maximumRemovals(string s, string p, vector<int>& removable) {\n    int low = 0, high = removable.size();\n    while (low < high) {\n        int mid = low + (high - low + 1) / 2;\n        string ss = s;\n        for (int i = 0; i < mid; ++i) {\n            ss[removable[i]] = '-';\n        }\n        int j = 0, i = 0;\n        while (i < ss.size() && j < p.size()) {\n            if (ss[i] == p[j]) {\n                ++j;\n            }\n            ++i;\n        }\n        if (j == p.size()) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low;\n}\n```\n\n    \n    The algorithm is basically binary search. We iterate through the removable array and start by removing `mid` (the middle element) number of characters from `s`. Then, we check if `p` is still a subsequence of the modified string. If it's a subsequence, it means we can try removing more characters, hence updating the lower bound `low` to `mid`. If it's not a subsequence, we update the upper bound `high` to `mid - 1`, meaning we have to try removing fewer characters. We do this until `low < high`, and then return the maximum value of `k = low` which will give us the maximum removable characters where `p` is still a subsequence of `s`.\n    ",
        "js": "\n    ```javascript\nfunction maximumRemovals(s, p, removable) {\n    let low = 0, high = removable.length;\n    while (low < high) {\n        let mid = low + Math.floor((high - low + 1) / 2);\n        let ss = [...s];\n        for (let i = 0; i < mid; ++i) {\n            ss[removable[i]] = '-';\n        }\n        let j = 0, i = 0;\n        while (i < ss.length && j < p.length) {\n            if (ss[i] === p[j]) {\n                ++j;\n            }\n            ++i;\n        }\n        if (j === p.length) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low;\n}\n```\n\n    \n    The algorithm is basically binary search. We iterate through the removable array and start by removing `mid` (the middle element) number of characters from `s`. Then, we check if `p` is still a subsequence of the modified string. If it's a subsequence, it means we can try removing more characters, hence updating the lower bound `low` to `mid`. If it's not a subsequence, we update the upper bound `high` to `mid - 1`, meaning we have to try removing fewer characters. We do this until `low < high`, and then return the maximum value of `k = low` which will give us the maximum removable characters where `p` is still a subsequence of `s`.\n    "
    },
    {
        "id": 369,
        "title": "Two Out of Three",
        "difficulty": "Easy",
        "content": {
            "problem": "Given three integer arrays `nums1`, `nums2`, and `nums3`, return _a **distinct** array containing all the values that are present in **at least two** out of the three arrays. You may return the values in **any** order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,1,3,2\\], nums2 = \\[2,3\\], nums3 = \\[3\\]\n**Output:** \\[3,2\\]\n**Explanation:** The values that are present in at least two arrays are:\n- 3, in all three arrays.\n- 2, in nums1 and nums2.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[3,1\\], nums2 = \\[2,3\\], nums3 = \\[1,2\\]\n**Output:** \\[2,3,1\\]\n**Explanation:** The values that are present in at least two arrays are:\n- 2, in nums2 and nums3.\n- 3, in nums1 and nums2.\n- 1, in nums1 and nums3.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[1,2,2\\], nums2 = \\[4,3,3\\], nums3 = \\[5\\]\n**Output:** \\[\\]\n**Explanation:** No value is present in at least two arrays."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length, nums3.length <= 100`\n*   `1 <= nums1[i], nums2[j], nums3[k] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,1,3,2],[2,3],[3]",
                "output": "[3,2]"
            },
            {
                "input": "[3,1],[2,3],[1,2]",
                "output": "[2,3,1]"
            },
            {
                "input": "[1,2,2],[4,3,3],[5]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic String largestOdd(String num) {\n    for (int i = 0; i < num.length(); ++i) {\n        if ((num.charAt(i) - '0') % 2 == 1) {\n            return num.substring(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm used iterates through the input string `num`. For each character, it checks if it's an odd digit (by subtracting '0' and mod-ing 2 to check if it's equal to 1).\n\nIf an odd digit is found, it returns the substring from the beginning of the string to the odd digit (inclusive) as the largest odd integer substring.\n\nIf no odd digit is found, it returns an empty string.\n    ",
        "python": "\n    ```python\ndef largest_odd(num: str) -> str:\n    for i in range(len(num)):\n        if (int(num[i]) % 2) == 1:\n            return num[:i + 1]\n    return \"\"\n```\n    \n    The algorithm used iterates through the input string `num`. For each character, it checks if it's an odd digit (by subtracting '0' and mod-ing 2 to check if it's equal to 1).\n\nIf an odd digit is found, it returns the substring from the beginning of the string to the odd digit (inclusive) as the largest odd integer substring.\n\nIf no odd digit is found, it returns an empty string.\n    ",
        "c++": "\n    ```cpp\nstd::string largestOdd(std::string num) {\n    for (int i = 0; i < num.length(); ++i) {\n        if ((num[i] - '0') % 2 == 1) {\n            return num.substr(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm used iterates through the input string `num`. For each character, it checks if it's an odd digit (by subtracting '0' and mod-ing 2 to check if it's equal to 1).\n\nIf an odd digit is found, it returns the substring from the beginning of the string to the odd digit (inclusive) as the largest odd integer substring.\n\nIf no odd digit is found, it returns an empty string.\n    ",
        "js": "\n    ```javascript\nfunction largestOdd(num) {\n    for (let i = 0; i < num.length; ++i) {\n        if ((num[i] - '0') % 2 === 1) {\n            return num.substr(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm used iterates through the input string `num`. For each character, it checks if it's an odd digit (by subtracting '0' and mod-ing 2 to check if it's equal to 1).\n\nIf an odd digit is found, it returns the substring from the beginning of the string to the odd digit (inclusive) as the largest odd integer substring.\n\nIf no odd digit is found, it returns an empty string.\n    "
    },
    {
        "id": 370,
        "title": "Minimum Number of Moves to Seat Everyone",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` seats and `n` students in a room. You are given an array `seats` of length `n`, where `seats[i]` is the position of the `ith` seat. You are also given the array `students` of length `n`, where `students[j]` is the position of the `jth` student.\n\nYou may perform the following move any number of times:\n\n*   Increase or decrease the position of the `ith` student by `1` (i.e., moving the `ith` student from position `x` to `x + 1` or `x - 1`)\n\nReturn _the **minimum number of moves** required to move each student to a seat_ _such that no two students are in the same seat._\n\nNote that there may be **multiple** seats or students in the **same** position at the beginning.",
            "examples": [
                "**Example 1:**\n\n**Input:** seats = \\[3,1,5\\], students = \\[2,7,4\\]\n**Output:** 4\n**Explanation:** The students are moved as follows:\n- The first student is moved from from position 2 to position 1 using 1 move.\n- The second student is moved from from position 7 to position 5 using 2 moves.\n- The third student is moved from from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\n",
                "**Example 2:**\n\n**Input:** seats = \\[4,1,5,9\\], students = \\[1,3,2,6\\]\n**Output:** 7\n**Explanation:** The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from from position 3 to position 4 using 1 move.\n- The third student is moved from from position 2 to position 5 using 3 moves.\n- The fourth student is moved from from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\n",
                "**Example 3:**\n\n**Input:** seats = \\[2,2,6,6\\], students = \\[1,3,2,6\\]\n**Output:** 4\n**Explanation:** Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from from position 1 to position 2 using 1 move.\n- The second student is moved from from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used."
            ],
            "constraints": "**Constraints:**\n\n*   `n == seats.length == students.length`\n*   `1 <= n <= 100`\n*   `1 <= seats[i], students[j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Counting Sort"
        ],
        "example": [
            {
                "input": "[3,1,5],[2,7,4]",
                "output": "4"
            },
            {
                "input": "[4,1,5,9],[1,3,2,6]",
                "output": "7"
            },
            {
                "input": "[2,2,6,6],[1,3,2,6]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int countSquareTriples(int n) {\n    int count = 0;\n    for (int a = 1; a <= n; a++) {\n        for (int b = a; b <= n; b++) {\n            int c = (int) Math.sqrt(a * a + b * b);\n            if (c * c == a * a + b * b && c <= n) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    1. Initialize the count of square triples to 0.\n2. Start two nested loops with variables a and b ranging from 1 to n, inclusive.\n3. Inside the inner loop, calculate c as the square root of a^2 + b^2, rounded down to the nearest integer, and check if c^2 equals a^2 + b^2 and c is less than or equal to n.\n4. If the condition is true, increment the count of square triples.\n5. Repeat steps 2-4 for all values of a and b.\n6. Return the count of square triples.\n    ",
        "python": "\n    ```python\ndef count_square_triples(n):\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = int((a * a + b * b)**0.5)\n            if c * c == a * a + b * b and c <= n:\n                count += 1\n    return count\n```\n\n    \n    1. Initialize the count of square triples to 0.\n2. Start two nested loops with variables a and b ranging from 1 to n, inclusive.\n3. Inside the inner loop, calculate c as the square root of a^2 + b^2, rounded down to the nearest integer, and check if c^2 equals a^2 + b^2 and c is less than or equal to n.\n4. If the condition is true, increment the count of square triples.\n5. Repeat steps 2-4 for all values of a and b.\n6. Return the count of square triples.\n    ",
        "c++": "\n    ```cpp\n#include <cmath>\n\nint countSquareTriples(int n) {\n    int count = 0;\n    for (int a = 1; a <= n; a++) {\n        for (int b = a; b <= n; b++) {\n            int c = std::sqrt(a * a + b * b);\n            if (c * c == a * a + b * b && c <= n) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    1. Initialize the count of square triples to 0.\n2. Start two nested loops with variables a and b ranging from 1 to n, inclusive.\n3. Inside the inner loop, calculate c as the square root of a^2 + b^2, rounded down to the nearest integer, and check if c^2 equals a^2 + b^2 and c is less than or equal to n.\n4. If the condition is true, increment the count of square triples.\n5. Repeat steps 2-4 for all values of a and b.\n6. Return the count of square triples.\n    ",
        "js": "\n    ```javascript\nfunction countSquareTriples(n) {\n    let count = 0;\n    for (let a = 1; a <= n; a++) {\n        for (let b = a; b <= n; b++) {\n            let c = Math.sqrt(a * a + b * b);\n            if (c * c === a * a + b * b && c <= n) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    1. Initialize the count of square triples to 0.\n2. Start two nested loops with variables a and b ranging from 1 to n, inclusive.\n3. Inside the inner loop, calculate c as the square root of a^2 + b^2, rounded down to the nearest integer, and check if c^2 equals a^2 + b^2 and c is less than or equal to n.\n4. If the condition is true, increment the count of square triples.\n5. Repeat steps 2-4 for all values of a and b.\n6. Return the count of square triples.\n    "
    },
    {
        "id": 371,
        "title": "Check if Numbers Are Ascending in a Sentence",
        "difficulty": "Easy",
        "content": {
            "problem": "A sentence is a list of **tokens** separated by a **single** space with no leading or trailing spaces. Every token is either a **positive number** consisting of digits `0-9` with no leading zeros, or a **word** consisting of lowercase English letters.\n\n*   For example, `\"a puppy has 2 eyes 4 legs \"` is a sentence with seven tokens: `\"2 \"` and `\"4 \"` are numbers and the other tokens such as `\"puppy \"` are words.\n\nGiven a string `s` representing a sentence, you need to check if **all** the numbers in `s` are **strictly increasing** from left to right (i.e., other than the last number, **each** number is **strictly smaller** than the number on its **right** in `s`).\n\nReturn `true` _if so, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1 box has 3 blue 4 red 6 green and 12 yellow marbles \"\n**Output:** true\n**Explanation:** The numbers in s are: 1, 3, 4, 6, 12.\nThey are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"hello world 5 x 5 \"\n**Output:** false\n**Explanation:** The numbers in s are: **5**, **5**. They are not strictly increasing.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s \"\n**Output:** false\n**Explanation:** The numbers in s are: 7, **51**, **50**, 60. They are not strictly increasing."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= s.length <= 200`\n*   `s` consists of lowercase English letters, spaces, and digits from `0` to `9`, inclusive.\n*   The number of tokens in `s` is between `2` and `100`, inclusive.\n*   The tokens in `s` are separated by a single space.\n*   There are at least **two** numbers in `s`.\n*   Each number in `s` is a **positive** number **less** than `100`, with no leading zeros.\n*   `s` contains no leading or trailing spaces.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"1boxhas3blue4red6greenand12yellowmarbles\"",
                "output": "true"
            },
            {
                "input": "\"helloworld5x5\"",
                "output": "false"
            },
            {
                "input": "\"sunsetisat751pmovernightlowswillbeinthelow50and60s\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int maxProductDifference(int[] nums) {\n    int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE, max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE;\n    for (int num : nums) {\n        if (num < min1) {\n            min2 = min1;\n            min1 = num;\n        } else if (num < min2) {\n            min2 = num;\n        }\n        if (num > max1) {\n            max2 = max1;\n            max1 = num;\n        } else if (num > max2) {\n            max2 = num;\n        }\n    }\n    return max1 * max2 - min1 * min2;\n}\n```\n    \n    We need to find two smallest numbers (min1, min2) and two largest numbers (max1, max2) in the given array. Initialize all four variables with appropriate extreme values, then loop through the array and update them on each iteration. The maximum product difference is (max1 * max2) - (min1 * min2).\n    ",
        "python": "\n    ```python\ndef maxProductDifference(nums):\n    min1, min2, max1, max2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num < min1:\n            min2, min1 = min1, num\n        elif num < min2:\n            min2 = num\n        if num > max1:\n            max2, max1 = max1, num\n        elif num > max2:\n            max2 = num\n    return max1 * max2 - min1 * min2\n```\n    \n    We need to find two smallest numbers (min1, min2) and two largest numbers (max1, max2) in the given array. Initialize all four variables with appropriate extreme values, then loop through the array and update them on each iteration. The maximum product difference is (max1 * max2) - (min1 * min2).\n    ",
        "c++": "\n    ```cpp\nint maxProductDifference(vector<int>& nums) {\n    int min1 = INT_MAX, min2 = INT_MAX, max1 = INT_MIN, max2 = INT_MIN;\n    for (int num : nums) {\n        if (num < min1) {\n            min2 = min1;\n            min1 = num;\n        } else if (num < min2) {\n            min2 = num;\n        }\n        if (num > max1) {\n            max2 = max1;\n            max1 = num;\n        } else if (num > max2) {\n            max2 = num;\n        }\n    }\n    return max1 * max2 - min1 * min2;\n}\n```\n    \n    We need to find two smallest numbers (min1, min2) and two largest numbers (max1, max2) in the given array. Initialize all four variables with appropriate extreme values, then loop through the array and update them on each iteration. The maximum product difference is (max1 * max2) - (min1 * min2).\n    ",
        "js": "\n    ```javascript\nfunction maxProductDifference(nums) {\n    let min1 = Number.MAX_SAFE_INTEGER, min2 = Number.MAX_SAFE_INTEGER, max1 = Number.MIN_SAFE_INTEGER, max2 = Number.MIN_SAFE_INTEGER;\n    for (let num of nums) {\n        if (num < min1) {\n            min2 = min1;\n            min1 = num;\n        } else if (num < min2) {\n            min2 = num;\n        }\n        if (num > max1) {\n            max2 = max1;\n            max1 = num;\n        } else if (num > max2) {\n            max2 = num;\n        }\n    }\n    return max1 * max2 - min1 * min2;\n}\n```\n    \n    We need to find two smallest numbers (min1, min2) and two largest numbers (max1, max2) in the given array. Initialize all four variables with appropriate extreme values, then loop through the array and update them on each iteration. The maximum product difference is (max1 * max2) - (min1 * min2).\n    "
    },
    {
        "id": 372,
        "title": "Number of Valid Words in a Sentence",
        "difficulty": "Easy",
        "content": {
            "problem": "A sentence consists of lowercase letters (`'a'` to `'z'`), digits (`'0'` to `'9'`), hyphens (`'-'`), punctuation marks (`'!'`, `'.'`, and `','`), and spaces (`' '`) only. Each sentence can be broken down into **one or more tokens** separated by one or more spaces `' '`.\n\nA token is a valid word if **all three** of the following are true:\n\n*   It only contains lowercase letters, hyphens, and/or punctuation (**no** digits).\n*   There is **at most one** hyphen `'-'`. If present, it **must** be surrounded by lowercase characters ( `\"a-b \"` is valid, but `\"-ab \"` and `\"ab- \"` are not valid).\n*   There is **at most one** punctuation mark. If present, it **must** be at the **end** of the token ( `\"ab, \"`, `\"cd! \"`, and `\". \"` are valid, but `\"a!b \"` and `\"c., \"` are not valid).\n\nExamples of valid words include `\"a-b. \"`, `\"afad \"`, `\"ba-c \"`, `\"a! \"`, and `\"! \"`.\n\nGiven a string `sentence`, return _the **number** of valid words in_ `sentence`.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence =  \"cat and  dog \"\n**Output:** 3\n**Explanation:** The valid words in the sentence are  \"cat \",  \"and \", and  \"dog \".\n\n",
                "**Example 2:**\n\n**Input:** sentence =  \"!this  1-s b8d! \"\n**Output:** 0\n**Explanation:** There are no valid words in the sentence.\n \"!this \" is invalid because it starts with a punctuation mark.\n \"1-s \" and  \"b8d \" are invalid because they contain digits.\n\n",
                "**Example 3:**\n\n**Input:** sentence =  \"alice and  bob are playing stone-game10 \"\n**Output:** 5\n**Explanation:** The valid words in the sentence are  \"alice \",  \"and \",  \"bob \",  \"are \", and  \"playing \".\n \"stone-game10 \" is invalid because it contains digits."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 1000`\n*   `sentence` only contains lowercase English letters, digits, `' '`, `'-'`, `'!'`, `'.'`, and `','`.\n*   There will be at least `1` token.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"catanddog\"",
                "output": "3"
            },
            {
                "input": "\"!this1-sb8d!\"",
                "output": "0"
            },
            {
                "input": "\"aliceandbobareplayingstone-game10\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int[] findPeakGrid(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    int l = 0, r = n - 1;\n\n    while (l < r) {\n        int mid = (l + r) / 2;\n        int max_row = 0;\n\n        for (int i = 1; i < m; i++) {\n            if (mat[i][mid] > mat[max_row][mid]) {\n                max_row = i;\n            }\n        }\n\n        if (mat[max_row][mid] < mat[max_row][mid + 1]) {\n            l = mid + 1;\n        } else {\n            r = mid;\n        }\n    }\n\n    int max_row = 0;\n    for (int i = 1; i < m; i++) {\n        if (mat[i][l] > mat[max_row][l]) {\n            max_row = i;\n        }\n    }\n\n    return new int[]{max_row, l};\n}\n```\n    \n    The algorithm is a modification of the binary search algorithm. We start by finding the middle column `mid`. For this column, we find the row `max_row` with the maximum element. Then, we compare the maximum element with its right neighbor.\n\nIf the right neighbor is greater, we know that there must be a peak element in the columns to the right, so we update `l = mid + 1`. Otherwise, we know that there must be a peak element in the columns to the left or at the current column, so we update `r = mid`.\n\nRepeat this process until `l == r`. At this point, the maximum element in the column `l` is a peak element. We find the row `max_row` with the maximum element in the column `l` and return its position `[max_row, l]`. \n\nSince we are using binary search, the time complexity of the algorithm is O(m log(n)) or O(n log(m)).\n    ",
        "python": "\n    ```python\ndef findPeakGrid(mat: List[List[int]]) -> List[int]:\n    m, n = len(mat), len(mat[0])\n    l, r = 0, n - 1\n\n    while l < r:\n        mid = (l + r) // 2\n        max_row = 0\n\n        for i in range(1, m):\n            if mat[i][mid] > mat[max_row][mid]:\n                max_row = i\n\n        if mat[max_row][mid] < mat[max_row][mid + 1]:\n            l = mid + 1\n        else:\n            r = mid\n\n    max_row = 0\n    for i in range(1, m):\n        if mat[i][l] > mat[max_row][l]:\n            max_row = i\n\n    return [max_row, l]\n```\n    \n    The algorithm is a modification of the binary search algorithm. We start by finding the middle column `mid`. For this column, we find the row `max_row` with the maximum element. Then, we compare the maximum element with its right neighbor.\n\nIf the right neighbor is greater, we know that there must be a peak element in the columns to the right, so we update `l = mid + 1`. Otherwise, we know that there must be a peak element in the columns to the left or at the current column, so we update `r = mid`.\n\nRepeat this process until `l == r`. At this point, the maximum element in the column `l` is a peak element. We find the row `max_row` with the maximum element in the column `l` and return its position `[max_row, l]`. \n\nSince we are using binary search, the time complexity of the algorithm is O(m log(n)) or O(n log(m)).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findPeakGrid(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    int l = 0, r = n - 1;\n\n    while (l < r) {\n        int mid = (l + r) / 2;\n        int max_row = 0;\n\n        for (int i = 1; i < m; i++) {\n            if (mat[i][mid] > mat[max_row][mid]) {\n                max_row = i;\n            }\n        }\n\n        if (mat[max_row][mid] < mat[max_row][mid + 1]) {\n            l = mid + 1;\n        } else {\n            r = mid;\n        }\n    }\n\n    int max_row = 0;\n    for (int i = 1; i < m; i++) {\n        if (mat[i][l] > mat[max_row][l]) {\n            max_row = i;\n        }\n    }\n\n    return {max_row, l};\n}\n```\n    \n    The algorithm is a modification of the binary search algorithm. We start by finding the middle column `mid`. For this column, we find the row `max_row` with the maximum element. Then, we compare the maximum element with its right neighbor.\n\nIf the right neighbor is greater, we know that there must be a peak element in the columns to the right, so we update `l = mid + 1`. Otherwise, we know that there must be a peak element in the columns to the left or at the current column, so we update `r = mid`.\n\nRepeat this process until `l == r`. At this point, the maximum element in the column `l` is a peak element. We find the row `max_row` with the maximum element in the column `l` and return its position `[max_row, l]`. \n\nSince we are using binary search, the time complexity of the algorithm is O(m log(n)) or O(n log(m)).\n    ",
        "js": "\n    ```javascript\nfunction findPeakGrid(mat) {\n    let m = mat.length, n = mat[0].length;\n    let l = 0, r = n - 1;\n\n    while (l < r) {\n        let mid = Math.floor((l + r) / 2);\n        let max_row = 0;\n\n        for (let i = 1; i < m; i++) {\n            if (mat[i][mid] > mat[max_row][mid]) {\n                max_row = i;\n            }\n        }\n\n        if (mat[max_row][mid] < mat[max_row][mid + 1]) {\n            l = mid + 1;\n        } else {\n            r = mid;\n        }\n    }\n\n    let max_row = 0;\n    for (let i = 1; i < m; i++) {\n        if (mat[i][l] > mat[max_row][l]) {\n            max_row = i;\n        }\n    }\n\n    return [max_row, l];\n}\n```\n    \n    The algorithm is a modification of the binary search algorithm. We start by finding the middle column `mid`. For this column, we find the row `max_row` with the maximum element. Then, we compare the maximum element with its right neighbor.\n\nIf the right neighbor is greater, we know that there must be a peak element in the columns to the right, so we update `l = mid + 1`. Otherwise, we know that there must be a peak element in the columns to the left or at the current column, so we update `r = mid`.\n\nRepeat this process until `l == r`. At this point, the maximum element in the column `l` is a peak element. We find the row `max_row` with the maximum element in the column `l` and return its position `[max_row, l]`. \n\nSince we are using binary search, the time complexity of the algorithm is O(m log(n)) or O(n log(m)).\n    "
    },
    {
        "id": 373,
        "title": "Kth Distinct String in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "A **distinct string** is a string that is present only **once** in an array.\n\nGiven an array of strings `arr`, and an integer `k`, return _the_ `kth` _**distinct string** present in_ `arr`. If there are **fewer** than `k` distinct strings, return _an **empty string**_ `\" \"`.\n\nNote that the strings are considered in the **order in which they appear** in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[ \"d \", \"b \", \"c \", \"b \", \"c \", \"a \"\\], k = 2\n**Output:**  \"a \"\n**Explanation:**\nThe only distinct strings in arr are  \"d \" and  \"a \".\n \"d \" appears 1st, so it is the 1st distinct string.\n \"a \" appears 2nd, so it is the 2nd distinct string.\nSince k == 2,  \"a \" is returned. \n\n",
                "**Example 2:**\n\n**Input:** arr = \\[ \"aaa \", \"aa \", \"a \"\\], k = 1\n**Output:**  \"aaa \"\n**Explanation:**\nAll strings in arr are distinct, so the 1st string  \"aaa \" is returned.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[ \"a \", \"b \", \"a \"\\], k = 3\n**Output:**  \" \"\n**Explanation:**\nThe only distinct string is  \"b \". Since there are fewer than 3 distinct strings, we return an empty string  \" \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= arr.length <= 1000`\n*   `1 <= arr[i].length <= 5`\n*   `arr[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"],2",
                "output": "\"a\""
            },
            {
                "input": "[\"aaa\",\"aa\",\"a\"],1",
                "output": "\"aaa\""
            },
            {
                "input": "[\"a\",\"b\",\"a\"],3",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean isGoodString(String s) {\n    HashMap<Character, Integer> freq_map = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        freq_map.put(c, freq_map.getOrDefault(c, 0) + 1);\n    }\n\n    int count = freq_map.values().iterator().next();\n    for (int value : freq_map.values()) {\n        if (value != count) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm for each implementation is as follows:\n\n1. Create a dictionary/hash map to store the frequencies of each character in the string.\n2. Iterate through the input string and update the dictionary with the character frequencies.\n3. Get the count of the first character in the dictionary.\n4. Iterate through the dictionary, compare the count of each character to the initial count obtained in step 3. If the counts are not equal, return false. In the end, if all counts are equal, return true.\n\nThis algorithm works in O(n) time complexity, where n is the length of the input string, since it traverses the input string and dictionary in linear time.\n    ",
        "python": "\n    ```python\ndef is_good_string(s: str) -> bool:\n    freq_map = {}\n    for c in s:\n        if c in freq_map:\n            freq_map[c] += 1\n        else:\n            freq_map[c] = 1\n\n    count = next(iter(freq_map.values()))\n    for value in freq_map.values():\n        if value != count:\n            return False\n    return True\n```\n    \n    The algorithm for each implementation is as follows:\n\n1. Create a dictionary/hash map to store the frequencies of each character in the string.\n2. Iterate through the input string and update the dictionary with the character frequencies.\n3. Get the count of the first character in the dictionary.\n4. Iterate through the dictionary, compare the count of each character to the initial count obtained in step 3. If the counts are not equal, return false. In the end, if all counts are equal, return true.\n\nThis algorithm works in O(n) time complexity, where n is the length of the input string, since it traverses the input string and dictionary in linear time.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n\nbool isGoodString(const std::string& s) {\n    std::unordered_map<char, int> freq_map;\n    for (char c : s) {\n        freq_map[c]++;\n    }\n\n    int count = freq_map.begin()->second;\n    for (const auto& entry : freq_map) {\n        if (entry.second != count) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm for each implementation is as follows:\n\n1. Create a dictionary/hash map to store the frequencies of each character in the string.\n2. Iterate through the input string and update the dictionary with the character frequencies.\n3. Get the count of the first character in the dictionary.\n4. Iterate through the dictionary, compare the count of each character to the initial count obtained in step 3. If the counts are not equal, return false. In the end, if all counts are equal, return true.\n\nThis algorithm works in O(n) time complexity, where n is the length of the input string, since it traverses the input string and dictionary in linear time.\n    ",
        "js": "\n    ```javascript\nfunction isGoodString(s) {\n    let freqMap = new Map();\n    for (let c of s) {\n        if (freqMap.has(c)) {\n            freqMap.set(c, freqMap.get(c) + 1);\n        } else {\n            freqMap.set(c, 1);\n        }\n    }\n\n    let count = freqMap.values().next().value;\n    for (let value of freqMap.values()) {\n        if (value !== count) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm for each implementation is as follows:\n\n1. Create a dictionary/hash map to store the frequencies of each character in the string.\n2. Iterate through the input string and update the dictionary with the character frequencies.\n3. Get the count of the first character in the dictionary.\n4. Iterate through the dictionary, compare the count of each character to the initial count obtained in step 3. If the counts are not equal, return false. In the end, if all counts are equal, return true.\n\nThis algorithm works in O(n) time complexity, where n is the length of the input string, since it traverses the input string and dictionary in linear time.\n    "
    },
    {
        "id": 374,
        "title": "Smallest Index With Equal Value",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, return _the **smallest** index_ `i` _of_ `nums` _such that_ `i mod 10 == nums[i]`_, or_ `-1` _if such index does not exist_.\n\n`x mod y` denotes the **remainder** when `x` is divided by `y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2\\]\n**Output:** 0\n**Explanation:** \ni=0: 0 mod 10 = 0 == nums\\[0\\].\ni=1: 1 mod 10 = 1 == nums\\[1\\].\ni=2: 2 mod 10 = 2 == nums\\[2\\].\nAll indices have i mod 10 == nums\\[i\\], so we return the smallest index 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,3,2,1\\]\n**Output:** 2\n**Explanation:** \ni=0: 0 mod 10 = 0 != nums\\[0\\].\ni=1: 1 mod 10 = 1 != nums\\[1\\].\ni=2: 2 mod 10 = 2 == nums\\[2\\].\ni=3: 3 mod 10 = 3 != nums\\[3\\].\n2 is the only index which has i mod 10 == nums\\[i\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9,0\\]\n**Output:** -1\n**Explanation:** No index satisfies i mod 10 == nums\\[i\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[0,1,2]",
                "output": "0"
            },
            {
                "input": "[4,3,2,1]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4,5,6,7,8,9,0]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int smallestIndex(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        if (i % 10 == nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    ",
        "python": "\n    ```python\ndef smallest_index(nums):\n    for i, num in enumerate(nums):\n        if i % 10 == num:\n            return i\n    return -1\n```\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    ",
        "c++": "\n    ```cpp\nint smallestIndex(std::vector<int>& nums) {\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (i % 10 == nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    ",
        "js": "\n    ```javascript\nfunction smallestIndex(nums) {\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 10 === nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    "
    },
    {
        "id": 375,
        "title": "Count Vowel Substrings of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "A **substring** is a contiguous (non-empty) sequence of characters within a string.\n\nA **vowel substring** is a substring that **only** consists of vowels (`'a'`, `'e'`, `'i'`, `'o'`, and `'u'`) and has **all five** vowels present in it.\n\nGiven a string `word`, return _the number of **vowel substrings** in_ `word`.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"aeiouu \"\n**Output:** 2\n**Explanation:** The vowel substrings of word are as follows (underlined):\n-  \"**aeiou**u \"\n-  \"**aeiouu** \"\n\n",
                "**Example 2:**\n\n**Input:** word =  \"unicornarihan \"\n**Output:** 0\n**Explanation:** Not all 5 vowels are present, so there are no vowel substrings.\n\n",
                "**Example 3:**\n\n**Input:** word =  \"cuaieuouac \"\n**Output:** 7\n**Explanation:** The vowel substrings of word are as follows (underlined):\n-  \"c**uaieuo**uac \"\n-  \"c**uaieuou**ac \"\n-  \"c**uaieuoua**c \"\n-  \"cu**aieuo**uac \"\n-  \"cu**aieuou**ac \"\n-  \"cu**aieuoua**c \"\n-  \"cua**ieuoua**c \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 100`\n*   `word` consists of lowercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"aeiouu\"",
                "output": "2"
            },
            {
                "input": "\"unicornarihan\"",
                "output": "0"
            },
            {
                "input": "\"cuaieuouac\"",
                "output": "7"
            }
        ],
        "java": "\n    ```java\nint countVowelSubstrings(String word) {\n    int count = 0, a = 0, e = 0, i = 0, o = 0, u = 0;\n    for (char c : word.toCharArray()) {\n        if (c == 'a') a++;\n        else if (c == 'e') e = a + e;\n        else if (c == 'i') i = e + i;\n        else if (c == 'o') o = i + o;\n        else if (c == 'u') u = o + u;\n    }\n    return u;\n}\n```\n    \n    The algorithm counts the number of vowel substrings in the given input `word`. The basic idea is to maintain separate counter variables for each vowel `a`, `e`, `i`, `o`, and `u`. When iterating through the characters of the input string, the algorithm increases or updates the respective counter variables based on whether a character is a given type of vowel. The updated counter variables keep track of the number of vowel substrings. Once the iteration is completed, the result can be obtained from the counter variable of last vowel `u`. This solution has a time complexity of O(N), where N is the length of the input string `word`.\n    ",
        "python": "\n    ```python\ndef count_vowel_substrings(word: str) -> int:\n    count, a, e, i, o, u = 0, 0, 0, 0, 0, 0\n    for c in word:\n        if c == 'a': a += 1\n        elif c == 'e': e = a + e\n        elif c == 'i': i = e + i\n        elif c == 'o': o = i + o\n        elif c == 'u': u = o + u\n    return u\n```\n    \n    The algorithm counts the number of vowel substrings in the given input `word`. The basic idea is to maintain separate counter variables for each vowel `a`, `e`, `i`, `o`, and `u`. When iterating through the characters of the input string, the algorithm increases or updates the respective counter variables based on whether a character is a given type of vowel. The updated counter variables keep track of the number of vowel substrings. Once the iteration is completed, the result can be obtained from the counter variable of last vowel `u`. This solution has a time complexity of O(N), where N is the length of the input string `word`.\n    ",
        "c++": "\n    ```cpp\nint countVowelSubstrings(string word) {\n    int count = 0, a = 0, e = 0, i = 0, o = 0, u = 0;\n    for (char c : word) {\n        if (c == 'a') a++;\n        else if (c == 'e') e = a + e;\n        else if (c == 'i') i = e + i;\n        else if (c == 'o') o = i + o;\n        else if (c == 'u') u = o + u;\n    }\n    return u;\n}\n```\n    \n    The algorithm counts the number of vowel substrings in the given input `word`. The basic idea is to maintain separate counter variables for each vowel `a`, `e`, `i`, `o`, and `u`. When iterating through the characters of the input string, the algorithm increases or updates the respective counter variables based on whether a character is a given type of vowel. The updated counter variables keep track of the number of vowel substrings. Once the iteration is completed, the result can be obtained from the counter variable of last vowel `u`. This solution has a time complexity of O(N), where N is the length of the input string `word`.\n    ",
        "js": "\n    ```javascript\nfunction countVowelSubstrings(word) {\n    let count = 0, a = 0, e = 0, i = 0, o = 0, u = 0;\n    for (let c of word) {\n        if (c === 'a') a++;\n        else if (c === 'e') e = a + e;\n        else if (c === 'i') i = e + i;\n        else if (c === 'o') o = i + o;\n        else if (c === 'u') u = o + u;\n    }\n    return u;\n}\n```\n    \n    The algorithm counts the number of vowel substrings in the given input `word`. The basic idea is to maintain separate counter variables for each vowel `a`, `e`, `i`, `o`, and `u`. When iterating through the characters of the input string, the algorithm increases or updates the respective counter variables based on whether a character is a given type of vowel. The updated counter variables keep track of the number of vowel substrings. Once the iteration is completed, the result can be obtained from the counter variable of last vowel `u`. This solution has a time complexity of O(N), where N is the length of the input string `word`.\n    "
    },
    {
        "id": 376,
        "title": "Check Whether Two Strings are Almost Equivalent",
        "difficulty": "Easy",
        "content": {
            "problem": "Two strings `word1` and `word2` are considered **almost equivalent** if the differences between the frequencies of each letter from `'a'` to `'z'` between `word1` and `word2` is **at most** `3`.\n\nGiven two strings `word1` and `word2`, each of length `n`, return `true` _if_ `word1` _and_ `word2` _are **almost equivalent**, or_ `false` _otherwise_.\n\nThe **frequency** of a letter `x` is the number of times it occurs in the string.",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"aaaa \", word2 =  \"bccb \"\n**Output:** false\n**Explanation:** There are 4 'a's in  \"aaaa \" but 0 'a's in  \"bccb \".\nThe difference is 4, which is more than the allowed 3.\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"abcdeef \", word2 =  \"abaaacc \"\n**Output:** true\n**Explanation:** The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n\n",
                "**Example 3:**\n\n**Input:** word1 =  \"cccddabba \", word2 =  \"babababab \"\n**Output:** true\n**Explanation:** The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `n == word1.length == word2.length`\n*   `1 <= n <= 100`\n*   `word1` and `word2` consist only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"aaaa\",\"bccb\"",
                "output": "false"
            },
            {
                "input": "\"abcdeef\",\"abaaacc\"",
                "output": "true"
            },
            {
                "input": "\"cccddabba\",\"babababab\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private static final int M = 17;\n    private final List<List<Integer>> tr = new ArrayList<>();\n\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\n        int n = parents.length;\n        List<List<Integer>> edges = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            edges.add(new ArrayList<>());\n        }\n        int root = -1;\n        for (int i = 0; i < n; ++i) {\n            if (parents[i] == -1) {\n                root = i;\n            } else {\n                edges.get(parents[i]).add(i);\n            }\n        }\n\n        tr.add(new ArrayList<>(2));\n        tr.get(0).add(0);\n        tr.get(0).add(0);\n        int[] ans = new int[n];\n        dfs(root, 0, edges, ans);\n\n        int[] result = new int[queries.length];\n        for (int i = 0; i < queries.length; ++i) {\n            result[i] = ans[queries[i][0]] ^ queries[i][1];\n        }\n        return result;\n    }\n\n    private void insert(int x) {\n        int u = 0;\n        for (int i = M - 1; i >= 0; --i) {\n            int v = (x >> i) & 1;\n            if (tr.get(u).get(v) == 0) {\n                tr.get(u).set(v, tr.size());\n                List<Integer> newRow = new ArrayList<>(2);\n                newRow.add(0);\n                newRow.add(0);\n                tr.add(newRow);\n            }\n            u = tr.get(u).get(v);\n        }\n    }\n\n    private int query(int x, int y) {\n        int u = 0, ans = 0;\n        for (int i = M - 1; i >= 0; --i) {\n            int v = ((x >> i) & 1) ^ 1;\n            if (tr.get(u).get(v) == 0) v ^= 1;\n            ans |= (y = (y << 1) | v);\n            u = tr.get(u).get(v);\n        }\n        return ans;\n    }\n\n    private void dfs(int u, int tree, List<List<Integer>> g, int[] ans) {\n        insert(tree ^= u);\n        ans[u] = query(tree);\n        for (int v : g.get(u)) {\n            dfs(v, tree, g, ans);\n        }\n    }\n}\n```\n\n    \n    1. Initialize a trie as the data structure for holding our bitwise XOR results.\n2. Define helper functions `insert`, `query`, and `dfs`.\n3. In `insert`, add numbers to the trie. Each bit of the number represents the node connected to the root node.\n4. In `query`, find the maximum genetic difference in the trie given a genetic value.\n5. In `dfs`, traverse the tree and perform the `query` function for every node while inserting its genetic value.\n6. First, find the root and initialize the graph of nodes using the given `parents` array.\n7. Call the `dfs` function for the root node to populate the trie.\n8. Lastly, iterate through `queries` and XOR the gene value with the result from the trie to find the maximum genetic difference.\n    ",
        "python": "\n    ```python\nimport collections\n\ndef maxGeneticDifference(parents, queries):\n    M = 17\n    tr = [0, 0]\n\n    def insert(x):\n        nonlocal tr\n        u = 0\n        for i in range(M - 1, -1, -1):\n            v = (x >> i) & 1\n            if not tr[u][v]:\n                tr[u][v] = len(tr)\n                tr.append([0, 0])\n            u = tr[u][v]\n\n    def query(x, y=0):\n        u = 0\n        ans = 0\n        for i in range(M - 1, -1, -1):\n            v = ((x >> i) & 1) ^ 1\n            if not tr[u][v]:\n                v ^= 1\n            ans |= (y := (y << 1) | v)\n            u = tr[u][v]\n        return ans\n\n    def dfs(u, tree=0, g=collections.defaultdict(list), ans=None):\n        nonlocal tr\n        insert(tree := tree ^ u)\n        ans[u] = query(tree)\n        for v in g[u]:\n            dfs(v, tree, g, ans)\n\n    n = len(parents)\n    root = -1\n    graph = collections.defaultdict(list)\n    for i, parent in enumerate(parents):\n        if parent != -1:\n            graph[parent].append(i)\n        else:\n            root = i\n\n    ans = [0] * n\n    dfs(root, 0, graph, ans)\n    result = [ans[node] ^ val for node, val in queries]\n    return result\n```\n\n    \n    1. Initialize a trie as the data structure for holding our bitwise XOR results.\n2. Define helper functions `insert`, `query`, and `dfs`.\n3. In `insert`, add numbers to the trie. Each bit of the number represents the node connected to the root node.\n4. In `query`, find the maximum genetic difference in the trie given a genetic value.\n5. In `dfs`, traverse the tree and perform the `query` function for every node while inserting its genetic value.\n6. First, find the root and initialize the graph of nodes using the given `parents` array.\n7. Call the `dfs` function for the root node to populate the trie.\n8. Lastly, iterate through `queries` and XOR the gene value with the result from the trie to find the maximum genetic difference.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nconst int M = 17;\nvector<int> tr[1 << M];\n\nvoid insert(int x) {\n    int u = 0;\n    for (int i = M - 1; i >= 0; --i) {\n        int v = (x >> i) & 1;\n        if (!tr[u][v]) tr[u][v] = tr.size(), tr.emplace_back(2);\n        u = tr[u][v];\n    }\n}\n\nint query(int x, int y = 0) {\n    int u = 0, ans = 0;\n    for (int i = M - 1; i >= 0; --i) {\n        int v = ((x >> i) & 1) ^ 1;\n        if (!tr[u][v]) v ^= 1;\n        ans |= (y = (y << 1) | v);\n        u = tr[u][v];\n    }\n    return ans;\n}\n\nvoid dfs(int u, int tree = 0, vector<vector<int>>& g = {}, vector<int>& ans = {}) {\n    insert(tree ^= u);\n    ans[u] = query(tree);\n    for (int v : g[u]) dfs(v, tree, g, ans);\n}\n\nvector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\n    int n = parents.size();\n    vector<vector<int>> edges(n);\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (parents[i] == -1) {\n            root = i;\n        } else {\n            edges[parents[i]].push_back(i);\n        }\n    }\n    vector<int> ans(n);\n    dfs(root, 0, edges, ans);\n    vector<int> result(queries.size());\n    for (int i = 0; i < queries.size(); ++i) {\n        result[i] = ans[queries[i][0]] ^ queries[i][1];\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a trie as the data structure for holding our bitwise XOR results.\n2. Define helper functions `insert`, `query`, and `dfs`.\n3. In `insert`, add numbers to the trie. Each bit of the number represents the node connected to the root node.\n4. In `query`, find the maximum genetic difference in the trie given a genetic value.\n5. In `dfs`, traverse the tree and perform the `query` function for every node while inserting its genetic value.\n6. First, find the root and initialize the graph of nodes using the given `parents` array.\n7. Call the `dfs` function for the root node to populate the trie.\n8. Lastly, iterate through `queries` and XOR the gene value with the result from the trie to find the maximum genetic difference.\n    ",
        "js": "\n    ```javascript\nconst M = 17;\nconst tr = [[0, 0]];\n\nfunction insert(x) {\n    let u = 0;\n    for (let i = M - 1; i >= 0; --i) {\n        const v = (x >> i) & 1;\n        if (!tr[u][v]) {\n            const idx = tr.length;\n            tr[u][v] = idx;\n            tr.push([0, 0]);\n        }\n        u = tr[u][v];\n    }\n}\n\nfunction query(x, y = 0) {\n    let u = 0;\n    let ans = 0;\n    for (let i = M - 1; i >= 0; --i) {\n        let v = ((x >> i) & 1) ^ 1;\n        if (!tr[u][v]) v ^= 1;\n        ans |= (y = (y << 1) | v);\n        u = tr[u][v];\n    }\n    return ans;\n}\n\nfunction dfs(u, tree = 0, g = [], ans = []) {\n    insert(tree ^= u);\n    ans[u] = query(tree);\n    for (const v of g[u]) {\n        dfs(v, tree, g, ans);\n    }\n}\n\nfunction maxGeneticDifference(parents, queries) {\n    const n = parents.length;\n    const edges = Array.from({length: n}, () => []);\n    let root = -1;\n    for (let i = 0; i < n; ++i) {\n        if (parents[i] === -1) {\n            root = i;\n        } else {\n            edges[parents[i]].push(i);\n        }\n    }\n\n    const ans = Array(n).fill(0);\n    dfs(root, 0, edges, ans);\n\n    const result = queries.map(([node, val]) => ans[node] ^ val);\n    return result;\n}\n```\n\n    \n    1. Initialize a trie as the data structure for holding our bitwise XOR results.\n2. Define helper functions `insert`, `query`, and `dfs`.\n3. In `insert`, add numbers to the trie. Each bit of the number represents the node connected to the root node.\n4. In `query`, find the maximum genetic difference in the trie given a genetic value.\n5. In `dfs`, traverse the tree and perform the `query` function for every node while inserting its genetic value.\n6. First, find the root and initialize the graph of nodes using the given `parents` array.\n7. Call the `dfs` function for the root node to populate the trie.\n8. Lastly, iterate through `queries` and XOR the gene value with the result from the trie to find the maximum genetic difference.\n    "
    },
    {
        "id": 377,
        "title": "Time Needed to Buy Tickets",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` people in a line queuing to buy tickets, where the `0th` person is at the **front** of the line and the `(n - 1)th` person is at the **back** of the line.\n\nYou are given a **0-indexed** integer array `tickets` of length `n` where the number of tickets that the `ith` person would like to buy is `tickets[i]`.\n\nEach person takes **exactly 1 second** to buy a ticket. A person can only buy **1 ticket at a time** and has to go back to **the end** of the line (which happens **instantaneously**) in order to buy more tickets. If a person does not have any tickets left to buy, the person will **leave** the line.\n\nReturn _the **time taken** for the person at position_ `k` **_(0-indexed)_** _to finish buying tickets_.",
            "examples": [
                "**Example 1:**\n\n**Input:** tickets = \\[2,3,2\\], k = 2\n**Output:** 6\n**Explanation:** \n- In the first pass, everyone in the line buys a ticket and the line becomes \\[1, 2, 1\\].\n- In the second pass, everyone in the line buys a ticket and the line becomes \\[0, 1, 0\\].\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n\n",
                "**Example 2:**\n\n**Input:** tickets = \\[5,1,1,1\\], k = 0\n**Output:** 8\n**Explanation:**\n- In the first pass, everyone in the line buys a ticket and the line becomes \\[4, 0, 0, 0\\].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds."
            ],
            "constraints": "**Constraints:**\n\n*   `n == tickets.length`\n*   `1 <= n <= 100`\n*   `1 <= tickets[i] <= 100`\n*   `0 <= k < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Queue",
            "Simulation"
        ],
        "example": [
            {
                "input": "[2,3,2],2",
                "output": "6"
            },
            {
                "input": "[5,1,1,1],0",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int timeToBuyTickets(int[] tickets, int k) {\n    int time = 0;\n    while (tickets[k] > 0) {\n        for (int i = 0; i < tickets.length; ++i) {\n            if (tickets[i] > 0) {\n                --tickets[i];\n                ++time;\n                if (i == k && tickets[k] == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    return time;\n}\n```\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    ",
        "python": "\n    ```python\ndef time_to_buy_tickets(tickets, k):\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n                if i == k and tickets[k] == 0:\n                    break\n    return time\n```\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    ",
        "c++": "\n    ```cpp\nint time_to_buy_tickets(vector<int>& tickets, int k) {\n    int time = 0;\n    while (tickets[k] > 0) {\n        for (int i = 0; i < tickets.size(); ++i) {\n            if (tickets[i] > 0) {\n                --tickets[i];\n                ++time;\n                if (i == k && tickets[k] == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    return time;\n}\n```\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    ",
        "js": "\n    ```javascript\nfunction timeToBuyTickets(tickets, k) {\n    let time = 0;\n    while (tickets[k] > 0) {\n        for (let i = 0; i < tickets.length; ++i) {\n            if (tickets[i] > 0) {\n                --tickets[i];\n                ++time;\n                if (i === k && tickets[k] === 0) {\n                    break;\n                }\n            }\n        }\n    }\n    return time;\n}\n```\n\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    "
    },
    {
        "id": 378,
        "title": "Two Furthest Houses With Different Colors",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` houses evenly lined up on the street, and each house is beautifully painted. You are given a **0-indexed** integer array `colors` of length `n`, where `colors[i]` represents the color of the `ith` house.\n\nReturn _the **maximum** distance between **two** houses with **different** colors_.\n\nThe distance between the `ith` and `jth` houses is `abs(i - j)`, where `abs(x)` is the **absolute value** of `x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** colors = \\[**1**,1,1,**6**,1,1,1\\]\n**Output:** 3\n**Explanation:** In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.\n\n",
                "**Example 2:**\n\n**Input:** colors = \\[**1**,8,3,8,**3**\\]\n**Output:** 4\n**Explanation:** In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n\n",
                "**Example 3:**\n\n**Input:** colors = \\[**0**,**1**\\]\n**Output:** 1\n**Explanation:** The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
            ],
            "constraints": "**Constraints:**\n\n*   `n == colors.length`\n*   `2 <= n <= 100`\n*   `0 <= colors[i] <= 100`\n*   Test data are generated such that **at least** two houses have different colors.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[**1**,1,1,**6**,1,1,1]",
                "output": "3"
            },
            {
                "input": "[**1**,8,3,8,**3**]",
                "output": "4"
            },
            {
                "input": "[**0**,**1**]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxCompatibilitySum(int[][] students, int[][] mentors) {\n    Arrays.sort(students, (a, b) -> Arrays.toString(a).compareTo(Arrays.toString(b)));\n    Arrays.sort(mentors, (a, b) -> Arrays.toString(a).compareTo(Arrays.toString(b)));\n    return helper(students, mentors, 0);\n}\n\nprivate int helper(int[][] students, int[][] mentors, int idx) {\n    if (idx == students.length)\n        return 0;\n    int ans = 0;\n    for (int i = 0; i < mentors.length; i++) {\n        if (mentors[i] != null) {\n            int[] temp = mentors[i];\n            int count = 0;\n            for (int j = 0; j < students[idx].length; j++) {\n                if (students[idx][j] == temp[j])\n                    count++;\n            }\n            mentors[i] = null;\n            ans = Math.max(ans, count + helper(students, mentors, idx + 1));\n            mentors[i] = temp;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm first sorts both the students and the mentors arrays. Then, it finds all possible pairings between students and mentors. For each pairing, it calculates the compatibility score by counting the number of matching answers. The sum of the compatibility scores for each pairing is then calculated, and the maximum sum is returned as the final result.\n\nIn Python, the itertools.permutations function is used to generate all possible orderings of mentors. In Java, the arrays are sorted using compareTo on the string representation of the array. In JavaScript, the arrays are sorted using the join function to concatenate the array elements for comparison. For all languages, the helper function calculates the compatibility score sum and keeps track of the maximum sum found so far.\n    ",
        "python": "\n    ```python\nfrom itertools import permutations\n\ndef maxCompatibilitySum(students, mentors):\n    ans = 0\n    for mentors_perm in permutations(mentors):\n        cur_sum = sum(sum(a == b for a, b in zip(student, mentor)) for student, mentor in zip(students, mentors_perm))\n        ans = max(ans, cur_sum)\n    return ans\n```\n    \n    The algorithm first sorts both the students and the mentors arrays. Then, it finds all possible pairings between students and mentors. For each pairing, it calculates the compatibility score by counting the number of matching answers. The sum of the compatibility scores for each pairing is then calculated, and the maximum sum is returned as the final result.\n\nIn Python, the itertools.permutations function is used to generate all possible orderings of mentors. In Java, the arrays are sorted using compareTo on the string representation of the array. In JavaScript, the arrays are sorted using the join function to concatenate the array elements for comparison. For all languages, the helper function calculates the compatibility score sum and keeps track of the maximum sum found so far.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxCompatibilitySum(std::vector<std::vector<int>>& students, std::vector<std::vector<int>>& mentors) {\n    std::sort(students.begin(), students.end());\n    std::sort(mentors.begin(), mentors.end());\n    int ans = 0;\n    do {\n        int cur_sum = 0;\n        for (int i = 0; i < students.size(); i++) {\n            int match = 0;\n            for (int j = 0; j < students[i].size(); j++) {\n                if (students[i][j] == mentors[i][j]) match++;\n            }\n            cur_sum += match;\n        }\n        ans = std::max(ans, cur_sum);\n    } while (std::next_permutation(mentors.begin(), mentors.end()));\n    return ans;\n}\n```\n    \n    The algorithm first sorts both the students and the mentors arrays. Then, it finds all possible pairings between students and mentors. For each pairing, it calculates the compatibility score by counting the number of matching answers. The sum of the compatibility scores for each pairing is then calculated, and the maximum sum is returned as the final result.\n\nIn Python, the itertools.permutations function is used to generate all possible orderings of mentors. In Java, the arrays are sorted using compareTo on the string representation of the array. In JavaScript, the arrays are sorted using the join function to concatenate the array elements for comparison. For all languages, the helper function calculates the compatibility score sum and keeps track of the maximum sum found so far.\n    ",
        "js": "\n    ```javascript\nfunction maxCompatibilitySum(students, mentors) {\n    students.sort((a, b) => a.join(\"\") - b.join(\"\"));\n    mentors.sort((a, b) => a.join(\"\") - b.join(\"\"));\n    return helper(students, mentors, 0);\n}\n\nfunction helper(students, mentors, idx) {\n    if (idx == students.length) {\n        return 0;\n    }\n    let ans = 0;\n    for (let i = 0; i < mentors.length; i++) {\n        if (mentors[i] !== null) {\n            let count = 0;\n            let temp = mentors[i];\n            for (let j = 0; j < students[idx].length; j++) {\n                if (students[idx][j] === temp[j]) {\n                    count++;\n                }\n            }\n            mentors[i] = null;\n            ans = Math.max(ans, count + helper(students, mentors, idx + 1));\n            mentors[i] = temp;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm first sorts both the students and the mentors arrays. Then, it finds all possible pairings between students and mentors. For each pairing, it calculates the compatibility score by counting the number of matching answers. The sum of the compatibility scores for each pairing is then calculated, and the maximum sum is returned as the final result.\n\nIn Python, the itertools.permutations function is used to generate all possible orderings of mentors. In Java, the arrays are sorted using compareTo on the string representation of the array. In JavaScript, the arrays are sorted using the join function to concatenate the array elements for comparison. For all languages, the helper function calculates the compatibility score sum and keeps track of the maximum sum found so far.\n    "
    },
    {
        "id": 379,
        "title": "Count Common Words With One Occurrence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two string arrays `words1` and `words2`, return _the number of strings that appear **exactly once** in **each** of the two arrays._",
            "examples": [
                "**Example 1:**\n\n**Input:** words1 = \\[ \"leetcode \", \"is \", \"amazing \", \"as \", \"is \"\\], words2 = \\[ \"amazing \", \"leetcode \", \"is \"\\]\n**Output:** 2\n**Explanation:**\n-  \"leetcode \" appears exactly once in each of the two arrays. We count this string.\n-  \"amazing \" appears exactly once in each of the two arrays. We count this string.\n-  \"is \" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n-  \"as \" appears once in words1, but does not appear in words2. We do not count this string.\nThus, there are 2 strings that appear exactly once in each of the two arrays.\n\n",
                "**Example 2:**\n\n**Input:** words1 = \\[ \"b \", \"bb \", \"bbb \"\\], words2 = \\[ \"a \", \"aa \", \"aaa \"\\]\n**Output:** 0\n**Explanation:** There are no strings that appear in each of the two arrays.\n\n",
                "**Example 3:**\n\n**Input:** words1 = \\[ \"a \", \"ab \"\\], words2 = \\[ \"a \", \"a \", \"a \", \"ab \"\\]\n**Output:** 1\n**Explanation:** The only string that appears exactly once in each of the two arrays is  \"ab \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words1.length, words2.length <= 1000`\n*   `1 <= words1[i].length, words2[j].length <= 30`\n*   `words1[i]` and `words2[j]` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"],[\"amazing\",\"leetcode\",\"is\"]",
                "output": "2"
            },
            {
                "input": "[\"b\",\"bb\",\"bbb\"],[\"a\",\"aa\",\"aaa\"]",
                "output": "0"
            },
            {
                "input": "[\"a\",\"ab\"],[\"a\",\"a\",\"a\",\"ab\"]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] rearrangeArray(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 1; i < nums.length - 1; i += 2) {\n        int temp = nums[i];\n        nums[i] = nums[i + 1];\n        nums[i + 1] = temp;\n    }\n    return nums;\n}\n```\n    \n    The algorithm first sorts the array. Then, we swap every two adjacent elements starting from the first index until the end of the array. By doing this, we can ensure that no element will be equal to the average of its neighbors, as the elements are distinct integers and the property described in the problem cannot hold after swapping.\n\nFor example, let's take the following array:\n\n```\n3 1 5 9 7\n```\n\nSort the array:\n\n```\n1 3 5 7 9\n```\n\nSwap every two adjacent elements starting from the first index:\n\n```\n1 5 3 9 7\n```\n\nNow we can observe that no element in the array is equal to the average of its neighbors.\n    ",
        "python": "\n    ```python\ndef rearrangeArray(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n```\n    \n    The algorithm first sorts the array. Then, we swap every two adjacent elements starting from the first index until the end of the array. By doing this, we can ensure that no element will be equal to the average of its neighbors, as the elements are distinct integers and the property described in the problem cannot hold after swapping.\n\nFor example, let's take the following array:\n\n```\n3 1 5 9 7\n```\n\nSort the array:\n\n```\n1 3 5 7 9\n```\n\nSwap every two adjacent elements starting from the first index:\n\n```\n1 5 3 9 7\n```\n\nNow we can observe that no element in the array is equal to the average of its neighbors.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rearrangeArray(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    for (int i = 1; i < nums.size() - 1; i += 2) {\n        std::swap(nums[i], nums[i + 1]);\n    }\n    return nums;\n}\n```\n    \n    The algorithm first sorts the array. Then, we swap every two adjacent elements starting from the first index until the end of the array. By doing this, we can ensure that no element will be equal to the average of its neighbors, as the elements are distinct integers and the property described in the problem cannot hold after swapping.\n\nFor example, let's take the following array:\n\n```\n3 1 5 9 7\n```\n\nSort the array:\n\n```\n1 3 5 7 9\n```\n\nSwap every two adjacent elements starting from the first index:\n\n```\n1 5 3 9 7\n```\n\nNow we can observe that no element in the array is equal to the average of its neighbors.\n    ",
        "js": "\n    ```javascript\nfunction rearrangeArray(nums) {\n    nums.sort((a, b) => a - b);\n    for (let i = 1; i < nums.length - 1; i += 2) {\n        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    }\n    return nums;\n}\n```\n    \n    The algorithm first sorts the array. Then, we swap every two adjacent elements starting from the first index until the end of the array. By doing this, we can ensure that no element will be equal to the average of its neighbors, as the elements are distinct integers and the property described in the problem cannot hold after swapping.\n\nFor example, let's take the following array:\n\n```\n3 1 5 9 7\n```\n\nSort the array:\n\n```\n1 3 5 7 9\n```\n\nSwap every two adjacent elements starting from the first index:\n\n```\n1 5 3 9 7\n```\n\nNow we can observe that no element in the array is equal to the average of its neighbors.\n    "
    },
    {
        "id": 380,
        "title": "Find Target Indices After Sorting Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` and a target element `target`.\n\nA **target index** is an index `i` such that `nums[i] == target`.\n\nReturn _a list of the target indices of_ `nums` after _sorting_ `nums` _in **non-decreasing** order_. If there are no target indices, return _an **empty** list_. The returned list must be sorted in **increasing** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,5,2,3\\], target = 2\n**Output:** \\[1,2\\]\n**Explanation:** After sorting, nums is \\[1,**2**,**2**,3,5\\].\nThe indices where nums\\[i\\] == 2 are 1 and 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,5,2,3\\], target = 3\n**Output:** \\[3\\]\n**Explanation:** After sorting, nums is \\[1,2,2,**3**,5\\].\nThe index where nums\\[i\\] == 3 is 3.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,5,2,3\\], target = 5\n**Output:** \\[4\\]\n**Explanation:** After sorting, nums is \\[1,2,2,3,**5**\\].\nThe index where nums\\[i\\] == 5 is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i], target <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,5,2,3],2",
                "output": "[1,2]"
            },
            {
                "input": "[1,2,5,2,3],3",
                "output": "[3]"
            },
            {
                "input": "[1,2,5,2,3],5",
                "output": "[4]"
            }
        ],
        "java": "\n    ```java\npublic int maxMatrixSum(int[][] matrix) {\n    int n = matrix.length;\n    int minValue = Integer.MAX_VALUE, negativeCount = 0, sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sum += Math.abs(matrix[i][j]);\n            minValue = Math.min(minValue, Math.abs(matrix[i][j]));\n            if (matrix[i][j] < 0) {\n                negativeCount++;\n            }\n        }\n    }\n\n    if (negativeCount % 2 == 0) {\n        return sum;\n    } else {\n        return sum - 2 * minValue;\n    }\n}\n```\n    \n    To maximize the summation of the matrix's elements, we can follow these steps: \n1. Calculate the sum of the absolute values of all elements.\n2. Count the number of negative elements in the matrix.\n3. Determine the minimum absolute value of all elements in the matrix.\n4. If the number of negative values is even, the sum remains the same.\n5. If the number of negative values is odd, subtract twice the minimum absolute value from the sum, which accounts for turning an adjacent element from positive to negative, thereby increasing the overall sum.\n\nIn each language implementation, we create a function called `maxMatrixSum` that takes an n x n integer matrix as input and loops through the matrix to calculate the values described in the steps above. The function then returns either the sum of elements or the sum minus twice the minimum absolute value depending on the number of negative values. This way, we maximize the summation of the matrix's elements.\n    ",
        "python": "\n    ```python\ndef maxMatrixSum(matrix):\n    n = len(matrix)\n    minValue, negativeCount, total = float('inf'), 0, 0\n\n    for i in range(n):\n        for j in range(n):\n            total += abs(matrix[i][j])\n            minValue = min(minValue, abs(matrix[i][j]))\n            if matrix[i][j] < 0:\n                negativeCount += 1\n\n    if negativeCount % 2 == 0:\n        return total\n    else:\n        return total - 2 * minValue\n```\n    \n    To maximize the summation of the matrix's elements, we can follow these steps: \n1. Calculate the sum of the absolute values of all elements.\n2. Count the number of negative elements in the matrix.\n3. Determine the minimum absolute value of all elements in the matrix.\n4. If the number of negative values is even, the sum remains the same.\n5. If the number of negative values is odd, subtract twice the minimum absolute value from the sum, which accounts for turning an adjacent element from positive to negative, thereby increasing the overall sum.\n\nIn each language implementation, we create a function called `maxMatrixSum` that takes an n x n integer matrix as input and loops through the matrix to calculate the values described in the steps above. The function then returns either the sum of elements or the sum minus twice the minimum absolute value depending on the number of negative values. This way, we maximize the summation of the matrix's elements.\n    ",
        "c++": "\n    ```cpp\nint maxMatrixSum(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    int minValue = INT_MAX, negativeCount = 0, sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            sum += abs(matrix[i][j]);\n            minValue = min(minValue, abs(matrix[i][j]));\n            if (matrix[i][j] < 0) {\n                negativeCount++;\n            }\n        }\n    }\n\n    if (negativeCount % 2 == 0) {\n        return sum;\n    } else {\n        return sum - 2 * minValue;\n    }\n}\n```\n    \n    To maximize the summation of the matrix's elements, we can follow these steps: \n1. Calculate the sum of the absolute values of all elements.\n2. Count the number of negative elements in the matrix.\n3. Determine the minimum absolute value of all elements in the matrix.\n4. If the number of negative values is even, the sum remains the same.\n5. If the number of negative values is odd, subtract twice the minimum absolute value from the sum, which accounts for turning an adjacent element from positive to negative, thereby increasing the overall sum.\n\nIn each language implementation, we create a function called `maxMatrixSum` that takes an n x n integer matrix as input and loops through the matrix to calculate the values described in the steps above. The function then returns either the sum of elements or the sum minus twice the minimum absolute value depending on the number of negative values. This way, we maximize the summation of the matrix's elements.\n    ",
        "js": "\n    ```javascript\nfunction maxMatrixSum(matrix) {\n    const n = matrix.length;\n    let minValue = Infinity, negativeCount = 0, sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            sum += Math.abs(matrix[i][j]);\n            minValue = Math.min(minValue, Math.abs(matrix[i][j]));\n            if (matrix[i][j] < 0) {\n                negativeCount++;\n            }\n        }\n    }\n\n    if (negativeCount % 2 === 0) {\n        return sum;\n    } else {\n        return sum - 2 * minValue;\n    }\n}\n```\n    \n    To maximize the summation of the matrix's elements, we can follow these steps: \n1. Calculate the sum of the absolute values of all elements.\n2. Count the number of negative elements in the matrix.\n3. Determine the minimum absolute value of all elements in the matrix.\n4. If the number of negative values is even, the sum remains the same.\n5. If the number of negative values is odd, subtract twice the minimum absolute value from the sum, which accounts for turning an adjacent element from positive to negative, thereby increasing the overall sum.\n\nIn each language implementation, we create a function called `maxMatrixSum` that takes an n x n integer matrix as input and loops through the matrix to calculate the values described in the steps above. The function then returns either the sum of elements or the sum minus twice the minimum absolute value depending on the number of negative values. This way, we maximize the summation of the matrix's elements.\n    "
    },
    {
        "id": 381,
        "title": "Finding 3-Digit Even Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `digits`, where each element is a digit. The array may contain duplicates.\n\nYou need to find **all** the **unique** integers that follow the given requirements:\n\n*   The integer consists of the **concatenation** of **three** elements from `digits` in **any** arbitrary order.\n*   The integer does not have **leading zeros**.\n*   The integer is **even**.\n\nFor example, if the given `digits` were `[1, 2, 3]`, integers `132` and `312` follow the requirements.\n\nReturn _a **sorted** array of the unique integers._",
            "examples": [
                "**Example 1:**\n\n**Input:** digits = \\[2,1,3,0\\]\n**Output:** \\[102,120,130,132,210,230,302,310,312,320\\]\n**Explanation:** All the possible integers that follow the requirements are in the output array. \nNotice that there are no **odd** integers or integers with **leading zeros**.\n\n",
                "**Example 2:**\n\n**Input:** digits = \\[2,2,8,8,2\\]\n**Output:** \\[222,228,282,288,822,828,882\\]\n**Explanation:** The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882. \n\n",
                "**Example 3:**\n\n**Input:** digits = \\[3,7,5\\]\n**Output:** \\[\\]\n**Explanation:** No **even** integers can be formed using the given digits."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= digits.length <= 100`\n*   `0 <= digits[i] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[2,1,3,0]",
                "output": "[102,120,130,132,210,230,302,310,312,320]"
            },
            {
                "input": "[2,2,8,8,2]",
                "output": "[222,228,282,288,822,828,882]"
            },
            {
                "input": "[3,7,5]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minStonesRemaining(int[] piles, int k) {\n    for (int i = 0; i < k; i++) {\n        int max_pile_index = 0;\n        for (int j = 1; j < piles.length; j++) {\n            if (piles[j] > piles[max_pile_index]) {\n                max_pile_index = j;\n            }\n        }\n        piles[max_pile_index] -= piles[max_pile_index] / 2;\n    }\n\n    int total_stones = 0;\n    for (int pile : piles) {\n        total_stones += pile;\n    }\n    return total_stones;\n}\n```\n\n    \n    The algorithm follows these steps:\n1. Iterate `k` times.\n2. For each iteration, find the index of the largest pile.\n3. Reduce the largest pile by half, rounding down, and update the value in the piles array.\n4. After all iterations, compute the sum of the remaining piles and return it.\n    ",
        "python": "\n    ```python\ndef min_stones_remaining(piles, k):\n    for _ in range(k):\n        max_pile_index = piles.index(max(piles))\n        piles[max_pile_index] -= piles[max_pile_index] // 2\n\n    return sum(piles)\n```\n\n    \n    The algorithm follows these steps:\n1. Iterate `k` times.\n2. For each iteration, find the index of the largest pile.\n3. Reduce the largest pile by half, rounding down, and update the value in the piles array.\n4. After all iterations, compute the sum of the remaining piles and return it.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nint minStonesRemaining(int piles[], int n, int k) {\n    for (int i = 0; i < k; i++) {\n        int max_pile_index = std::distance(piles, std::max_element(piles, piles + n));\n        piles[max_pile_index] = piles[max_pile_index] - (piles[max_pile_index] / 2);\n    }\n    \n    int total_stones = 0;\n    for (int i = 0; i < n; i++) {\n        total_stones += piles[i];\n    }\n    return total_stones;\n}\n```\n\n    \n    The algorithm follows these steps:\n1. Iterate `k` times.\n2. For each iteration, find the index of the largest pile.\n3. Reduce the largest pile by half, rounding down, and update the value in the piles array.\n4. After all iterations, compute the sum of the remaining piles and return it.\n    ",
        "js": "\n    ```javascript\nfunction minStonesRemaining(piles, k) {\n    for (let i = 0; i < k; i++) {\n        let max_pile_index = 0;\n        for (let j = 1; j < piles.length; j++) {\n            if (piles[j] > piles[max_pile_index]) {\n                max_pile_index = j;\n            }\n        }\n        piles[max_pile_index] -= Math.floor(piles[max_pile_index] / 2);\n    }\n\n    return piles.reduce((total, pile) => total + pile, 0);\n}\n```\n\n    \n    The algorithm follows these steps:\n1. Iterate `k` times.\n2. For each iteration, find the index of the largest pile.\n3. Reduce the largest pile by half, rounding down, and update the value in the piles array.\n4. After all iterations, compute the sum of the remaining piles and return it.\n    "
    },
    {
        "id": 382,
        "title": "Find Subsequence of Length K With the Largest Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `k`. You want to find a **subsequence** of `nums` of length `k` that has the **largest** sum.\n\nReturn _**any** such subsequence as an integer array of length_ `k`.\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,3,3\\], k = 2\n**Output:** \\[3,3\\]\n**Explanation:**\nThe subsequence has the largest sum of 3 + 3 = 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,-2,3,4\\], k = 3\n**Output:** \\[-1,3,4\\]\n**Explanation:** \nThe subsequence has the largest sum of -1 + 3 + 4 = 6.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,4,3,3\\], k = 2\n**Output:** \\[3,4\\]\n**Explanation:**\nThe subsequence has the largest sum of 3 + 4 = 7. \nAnother possible subsequence is \\[4, 3\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-105 <= nums[i] <= 105`\n*   `1 <= k <= nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[2,1,3,3],2",
                "output": "[3,3]"
            },
            {
                "input": "[-1,-2,3,4],3",
                "output": "[-1,3,4]"
            },
            {
                "input": "[3,4,3,3],2",
                "output": "[3,4]"
            }
        ],
        "java": "\n    ```java\npublic int countPatternsInWord(String[] patterns, String word) {\n    int count = 0;\n    for (String pattern : patterns) {\n        if (word.contains(pattern)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each string in the given `patterns` array. In each iteration, it checks if the current pattern is a substring of the given `word`. If it is, it increases the count.\n\nFor C++, we use the `find` method of the `std::string` class and compare the result to `std::string::npos` to check if the pattern is present.\n\nFor Java, we use the `contains` method of the `String` class to check if the pattern is present.\n\nFor Python, we use the `in` operator to check if the pattern is present in the word.\n\nFor JavaScript, we use the `includes` method of the `String` class to check if the pattern is present.\n\nAt the end of the loop, the function returns the count of the patterns that are substrings of the given word.\n    ",
        "python": "\n    ```python\ndef count_patterns_in_word(patterns, word):\n    count = 0\n    for pattern in patterns:\n        if pattern in word:\n            count += 1\n    return count\n```\n    \n    The algorithm iterates through each string in the given `patterns` array. In each iteration, it checks if the current pattern is a substring of the given `word`. If it is, it increases the count.\n\nFor C++, we use the `find` method of the `std::string` class and compare the result to `std::string::npos` to check if the pattern is present.\n\nFor Java, we use the `contains` method of the `String` class to check if the pattern is present.\n\nFor Python, we use the `in` operator to check if the pattern is present in the word.\n\nFor JavaScript, we use the `includes` method of the `String` class to check if the pattern is present.\n\nAt the end of the loop, the function returns the count of the patterns that are substrings of the given word.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint countPatternsInWord(const std::vector<std::string> &patterns, const std::string &word) {\n    int count = 0;\n    for (const std::string &pattern : patterns) {\n        if (word.find(pattern) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each string in the given `patterns` array. In each iteration, it checks if the current pattern is a substring of the given `word`. If it is, it increases the count.\n\nFor C++, we use the `find` method of the `std::string` class and compare the result to `std::string::npos` to check if the pattern is present.\n\nFor Java, we use the `contains` method of the `String` class to check if the pattern is present.\n\nFor Python, we use the `in` operator to check if the pattern is present in the word.\n\nFor JavaScript, we use the `includes` method of the `String` class to check if the pattern is present.\n\nAt the end of the loop, the function returns the count of the patterns that are substrings of the given word.\n    ",
        "js": "\n    ```javascript\nfunction countPatternsInWord(patterns, word) {\n    let count = 0;\n    for (const pattern of patterns) {\n        if (word.includes(pattern)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each string in the given `patterns` array. In each iteration, it checks if the current pattern is a substring of the given `word`. If it is, it increases the count.\n\nFor C++, we use the `find` method of the `std::string` class and compare the result to `std::string::npos` to check if the pattern is present.\n\nFor Java, we use the `contains` method of the `String` class to check if the pattern is present.\n\nFor Python, we use the `in` operator to check if the pattern is present in the word.\n\nFor JavaScript, we use the `includes` method of the `String` class to check if the pattern is present.\n\nAt the end of the loop, the function returns the count of the patterns that are substrings of the given word.\n    "
    },
    {
        "id": 383,
        "title": "Rings and Rods",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` rings and each ring is either red, green, or blue. The rings are distributed **across ten rods** labeled from `0` to `9`.\n\nYou are given a string `rings` of length `2n` that describes the `n` rings that are placed onto the rods. Every two characters in `rings` forms a **color-position pair** that is used to describe each ring where:\n\n*   The **first** character of the `ith` pair denotes the `ith` ring's **color** (`'R'`, `'G'`, `'B'`).\n*   The **second** character of the `ith` pair denotes the **rod** that the `ith` ring is placed on (`'0'` to `'9'`).\n\nFor example, `\"R3G2B1 \"` describes `n == 3` rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\nReturn _the number of rods that have **all three colors** of rings on them._",
            "examples": [
                "**Example 1:**\n\n**Input:** rings =  \"B0B6G0R6R0R6G9 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.\n\n",
                "**Example 2:**\n\n**Input:** rings =  \"B0R0G0R9R0B0G0 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.\n\n",
                "**Example 3:**\n\n**Input:** rings =  \"G4 \"\n**Output:** 0\n**Explanation:** \nOnly one ring is given. Thus, no rods have all three colors."
            ],
            "constraints": "**Constraints:**\n\n*   `rings.length == 2 * n`\n*   `1 <= n <= 100`\n*   `rings[i]` where `i` is **even** is either `'R'`, `'G'`, or `'B'` (**0-indexed**).\n*   `rings[i]` where `i` is **odd** is a digit from `'0'` to `'9'` (**0-indexed**).",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"B0B6G0R6R0R6G9\"",
                "output": "1"
            },
            {
                "input": "\"B0R0G0R9R0B0G0\"",
                "output": "1"
            },
            {
                "input": "\"G4\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> findFarmland(int[][] land) {\n    int m = land.length, n = land[0].length;\n    List<List<Integer>> res = new ArrayList<>();\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (land[i][j] == 1) {\n                int r = i, c = j;\n                while (r < m && land[r][j] == 1) ++r;\n                while (c < n && land[i][c] == 1) ++c;\n                for (int x = i; x < r; ++x) {\n                    for (int y = j; y < c; ++y) {\n                        land[x][y] = 0;\n                    }\n                }\n                res.add(List.of(i, j, r - 1, c - 1));\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    1. Iterate over each cell (i, j) in the given land matrix.\n2. If the cell value is 1 (farmland), initiate two pointers (r and c) at the current cell.\n3. Move r downwards while the cells in the same column have value 1.\n4. Move c rightwards while the cells in the same row have value 1.\n5. Set all cells within the rectangle (i, j, r-1, c-1) to 0, and add [i, j, r-1, c-1] to the result list.\n6. Repeat steps 1-5 for each cell in the land matrix.\n7. Return the result list with coordinates for each group of farmland.\n    ",
        "python": "\n    ```python\ndef findFarmland(land):\n    m, n = len(land), len(land[0])\n    res = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r, c = i, j\n                while r < m and land[r][j] == 1: r += 1\n                while c < n and land[i][c] == 1: c += 1\n                for x in range(i, r):\n                    for y in range(j,c):\n                        land[x][y] = 0\n                res.append([i, j, r - 1, c - 1])\n\n    return res\n```\n\n    \n    1. Iterate over each cell (i, j) in the given land matrix.\n2. If the cell value is 1 (farmland), initiate two pointers (r and c) at the current cell.\n3. Move r downwards while the cells in the same column have value 1.\n4. Move c rightwards while the cells in the same row have value 1.\n5. Set all cells within the rectangle (i, j, r-1, c-1) to 0, and add [i, j, r-1, c-1] to the result list.\n6. Repeat steps 1-5 for each cell in the land matrix.\n7. Return the result list with coordinates for each group of farmland.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> findFarmland(vector<vector<int>>& land) {\n    int m = land.size(), n = land[0].size();\n    vector<vector<int>> res;\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (land[i][j] == 1) {\n                int r = i, c = j;\n                while (r < m && land[r][j] == 1) ++r;\n                while (c < n && land[i][c] == 1) ++c;\n                for (int x = i; x < r; ++x) {\n                    for (int y = j; y < c; ++y) {\n                        land[x][y] = 0;\n                    }\n                }\n                res.push_back({i, j, r - 1, c - 1});\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    1. Iterate over each cell (i, j) in the given land matrix.\n2. If the cell value is 1 (farmland), initiate two pointers (r and c) at the current cell.\n3. Move r downwards while the cells in the same column have value 1.\n4. Move c rightwards while the cells in the same row have value 1.\n5. Set all cells within the rectangle (i, j, r-1, c-1) to 0, and add [i, j, r-1, c-1] to the result list.\n6. Repeat steps 1-5 for each cell in the land matrix.\n7. Return the result list with coordinates for each group of farmland.\n    ",
        "js": "\n    ```javascript\nfunction findFarmland(land) {\n    const m = land.length, n = land[0].length;\n    const res = [];\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (land[i][j] === 1) {\n                let r = i, c = j;\n                while (r < m && land[r][j] === 1) ++r;\n                while (c < n && land[i][c] === 1) ++c;\n                for (let x = i; x < r; ++x) {\n                    for (let y = j; y < c; ++y) {\n                        land[x][y] = 0;\n                    }\n                }\n                res.push([i, j, r - 1, c - 1]);\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    1. Iterate over each cell (i, j) in the given land matrix.\n2. If the cell value is 1 (farmland), initiate two pointers (r and c) at the current cell.\n3. Move r downwards while the cells in the same column have value 1.\n4. Move c rightwards while the cells in the same row have value 1.\n5. Set all cells within the rectangle (i, j, r-1, c-1) to 0, and add [i, j, r-1, c-1] to the result list.\n6. Repeat steps 1-5 for each cell in the land matrix.\n7. Return the result list with coordinates for each group of farmland.\n    "
    },
    {
        "id": 384,
        "title": "Find First Palindromic String in the Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `words`, return _the first **palindromic** string in the array_. If there is no such string, return _an **empty string**_ `\" \"`.\n\nA string is **palindromic** if it reads the same forward and backward.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abc \", \"car \", \"ada \", \"racecar \", \"cool \"\\]\n**Output:**  \"ada \"\n**Explanation:** The first string that is palindromic is  \"ada \".\nNote that  \"racecar \" is also palindromic, but it is not the first.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"notapalindrome \", \"racecar \"\\]\n**Output:**  \"racecar \"\n**Explanation:** The first and only string that is palindromic is  \"racecar \".\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"def \", \"ghi \"\\]\n**Output:**  \" \"\n**Explanation:** There are no palindromic strings, so the empty string is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "[\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]",
                "output": "\"ada\""
            },
            {
                "input": "[\"notapalindrome\",\"racecar\"]",
                "output": "\"racecar\""
            },
            {
                "input": "[\"def\",\"ghi\"]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public int minimizeTheDifference(int[][] mat, int target) {\n        int m = mat.length, n = mat[0].length;\n        int[] dp = new int[4901], new_dp = new int[4901];\n        dp[0] = 1;\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(new_dp, 0);\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k + mat[i][j] < 4901; ++k) {\n                    new_dp[k + mat[i][j]] |= dp[k];\n                }\n            }\n            int[] temp = dp;\n            dp = new_dp;\n            new_dp = temp;\n        }\n        for (int i = 0; i < 4901; ++i) {\n            if (dp[i] > 0) return Math.abs(target - i);\n        }\n        return Integer.MAX_VALUE;\n    }\n}\n```\n    \n    The given problem is a variation of the subset sum problem. Instead of checking all combinations using backtracking, we can use dynamic programming to optimize it. We use an array `dp` of size 4901 to store whether a sum value is possible or not. \n\n1. Initialize the `dp` array with 0, except `dp[0] = 1`, which means sum 0 is possible.\n2. For each row in the matrix, we create a temporary `new_dp` array and loop through all columns.\n3. For each column, iterate through the `dp` array, and if `dp[k] = 1`, set `new_dp[k + mat[i][j]] = 1`. It means the sum `k + mat[i][j]` is possible based on the current `dp`.\n4. Swap `dp` and `new_dp` arrays for the next iteration.\n5. After iterating through all rows, go through `dp`, if `dp[i] = 1`, return the absolute difference between i and the target.\n6. If we didn't find a possible sum, return the maximum possible absolute difference.\n\nThe algorithm's time complexity is O(m * n * 4900) and space complexity is O(4901).\n    ",
        "python": "\n    ```python\ndef minimizeTheDifference(mat, target):\n    m, n = len(mat), len(mat[0])\n    dp, new_dp = [1] + [0] * 4900, [0] * 4901\n    for i in range(m):\n        for j in range(n):\n            for k in range(4900 - mat[i][j] + 1):\n                new_dp[k + mat[i][j]] |= dp[k]\n        dp, new_dp = new_dp, [0] * 4901\n    for i in range(4901):\n        if dp[i]:\n            return abs(target - i)\n    return float('inf')\n```\n    \n    The given problem is a variation of the subset sum problem. Instead of checking all combinations using backtracking, we can use dynamic programming to optimize it. We use an array `dp` of size 4901 to store whether a sum value is possible or not. \n\n1. Initialize the `dp` array with 0, except `dp[0] = 1`, which means sum 0 is possible.\n2. For each row in the matrix, we create a temporary `new_dp` array and loop through all columns.\n3. For each column, iterate through the `dp` array, and if `dp[k] = 1`, set `new_dp[k + mat[i][j]] = 1`. It means the sum `k + mat[i][j]` is possible based on the current `dp`.\n4. Swap `dp` and `new_dp` arrays for the next iteration.\n5. After iterating through all rows, go through `dp`, if `dp[i] = 1`, return the absolute difference between i and the target.\n6. If we didn't find a possible sum, return the maximum possible absolute difference.\n\nThe algorithm's time complexity is O(m * n * 4900) and space complexity is O(4901).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint minimizeTheDifference(vector<vector<int>>& mat, int target) {\n    int m = mat.size(), n = mat[0].size();\n    vector<int> dp(4901, 0), new_dp(4901, 0);\n    dp[0] = 1;\n    for (int i = 0; i < m; ++i) {\n        fill(new_dp.begin(), new_dp.end(), 0);\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k + mat[i][j] < 4901; ++k) {\n                new_dp[k + mat[i][j]] |= dp[k];\n            }\n        }\n        dp.swap(new_dp);\n    }\n    for (int i = 0; i < 4901; ++i) {\n        if (dp[i]) return abs(target - i);\n    }\n    return INT_MAX;\n}\n```\n    \n    The given problem is a variation of the subset sum problem. Instead of checking all combinations using backtracking, we can use dynamic programming to optimize it. We use an array `dp` of size 4901 to store whether a sum value is possible or not. \n\n1. Initialize the `dp` array with 0, except `dp[0] = 1`, which means sum 0 is possible.\n2. For each row in the matrix, we create a temporary `new_dp` array and loop through all columns.\n3. For each column, iterate through the `dp` array, and if `dp[k] = 1`, set `new_dp[k + mat[i][j]] = 1`. It means the sum `k + mat[i][j]` is possible based on the current `dp`.\n4. Swap `dp` and `new_dp` arrays for the next iteration.\n5. After iterating through all rows, go through `dp`, if `dp[i] = 1`, return the absolute difference between i and the target.\n6. If we didn't find a possible sum, return the maximum possible absolute difference.\n\nThe algorithm's time complexity is O(m * n * 4900) and space complexity is O(4901).\n    ",
        "js": "\n    ```javascript\nfunction minimizeTheDifference(mat, target) {\n    const m = mat.length, n = mat[0].length;\n    let dp = new Uint8Array(4901), new_dp = new Uint8Array(4901);\n    dp[0] = 1;\n    for (let i = 0; i < m; ++i) {\n        new_dp.fill(0);\n        for (let j = 0; j < n; ++j) {\n            for (let k = 0; k + mat[i][j] < 4901; ++k) {\n                new_dp[k + mat[i][j]] |= dp[k];\n            }\n        }\n        [dp, new_dp] = [new_dp, dp];\n    }\n    for (let i = 0; i < 4901; ++i) {\n        if (dp[i]) return Math.abs(target - i);\n    }\n    return Infinity;\n}\n```\n    \n    The given problem is a variation of the subset sum problem. Instead of checking all combinations using backtracking, we can use dynamic programming to optimize it. We use an array `dp` of size 4901 to store whether a sum value is possible or not. \n\n1. Initialize the `dp` array with 0, except `dp[0] = 1`, which means sum 0 is possible.\n2. For each row in the matrix, we create a temporary `new_dp` array and loop through all columns.\n3. For each column, iterate through the `dp` array, and if `dp[k] = 1`, set `new_dp[k + mat[i][j]] = 1`. It means the sum `k + mat[i][j]` is possible based on the current `dp`.\n4. Swap `dp` and `new_dp` arrays for the next iteration.\n5. After iterating through all rows, go through `dp`, if `dp[i] = 1`, return the absolute difference between i and the target.\n6. If we didn't find a possible sum, return the maximum possible absolute difference.\n\nThe algorithm's time complexity is O(m * n * 4900) and space complexity is O(4901).\n    "
    },
    {
        "id": 385,
        "title": "Maximum Number of Words Found in Sentences",
        "difficulty": "Easy",
        "content": {
            "problem": "A **sentence** is a list of **words** that are separated by a single space with no leading or trailing spaces.\n\nYou are given an array of strings `sentences`, where each `sentences[i]` represents a single **sentence**.\n\nReturn _the **maximum number of words** that appear in a single sentence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentences = \\[ \"alice and bob love leetcode \",  \"i think so too \",  \"this is great thanks very much \"\\]\n**Output:** 6\n**Explanation:** \n- The first sentence,  \"alice and bob love leetcode \", has 5 words in total.\n- The second sentence,  \"i think so too \", has 4 words in total.\n- The third sentence,  \"this is great thanks very much \", has 6 words in total.\nThus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.\n\n",
                "**Example 2:**\n\n**Input:** sentences = \\[ \"please wait \",  \"continue to fight \",  \"continue to win \"\\]\n**Output:** 3\n**Explanation:** It is possible that multiple sentences contain the same number of words. \nIn this example, the second and third sentences (underlined) have the same number of words."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentences.length <= 100`\n*   `1 <= sentences[i].length <= 100`\n*   `sentences[i]` consists only of lowercase English letters and `' '` only.\n*   `sentences[i]` does not have leading or trailing spaces.\n*   All the words in `sentences[i]` are separated by a single space.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"aliceandbobloveleetcode\",\"ithinksotoo\",\"thisisgreatthanksverymuch\"]",
                "output": "6"
            },
            {
                "input": "[\"pleasewait\",\"continuetofight\",\"continuetowin\"]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic int minSessions(int[] tasks, int sessionTime) {\n    List<Integer> sessions = new ArrayList<>();\n    List<Integer> taskList = new ArrayList<>();\n    for (int task : tasks) taskList.add(task);\n    Collections.sort(taskList, Collections.reverseOrder());\n    \n    for (int task : taskList) {\n        boolean added = false;\n        for (int i = 0; i < sessions.size(); i++) {\n            if (sessions.get(i) + task <= sessionTime) {\n                sessions.set(i, sessions.get(i) + task);\n                added = true;\n                break;\n            }\n        }\n        \n        if (!added) {\n            sessions.add(task);\n        }\n    }\n\n    return sessions.size();\n}\n```\n    \n    The algorithm starts by sorting the tasks array in descending order. Then, for each task in tasks, it iterates over the sessions array and tries to insert the task into the first session that has sufficient remaining time. If no session can accommodate the task, a new session is created.\n\nIn the end, the size of the sessions array is the answer, which represents the minimum number of work sessions required to finish all tasks. \n    ",
        "python": "\n    ```python\ndef min_sessions(tasks, session_time):\n    sessions = []\n    tasks.sort(reverse=True)\n\n    for task in tasks:\n        added = False\n        for session_idx, session in enumerate(sessions):\n            if session + task <= session_time:\n                sessions[session_idx] += task\n                added = True\n                break\n\n        if not added:\n            sessions.append(task)\n\n    return len(sessions)\n```\n    \n    The algorithm starts by sorting the tasks array in descending order. Then, for each task in tasks, it iterates over the sessions array and tries to insert the task into the first session that has sufficient remaining time. If no session can accommodate the task, a new session is created.\n\nIn the end, the size of the sessions array is the answer, which represents the minimum number of work sessions required to finish all tasks. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minSessions(std::vector<int>& tasks, int sessionTime) {\n    std::sort(tasks.begin(), tasks.end(), std::greater<int>());\n    std::vector<int> sessions;\n    \n    for (int task : tasks) {\n        bool added = false;\n        for (int& session : sessions) {\n            if (session + task <= sessionTime) {\n                session += task;\n                added = true;\n                break;\n            }\n        }\n        \n        if (!added) {\n            sessions.push_back(task);\n        }\n    }\n\n    return sessions.size();\n}\n```\n    \n    The algorithm starts by sorting the tasks array in descending order. Then, for each task in tasks, it iterates over the sessions array and tries to insert the task into the first session that has sufficient remaining time. If no session can accommodate the task, a new session is created.\n\nIn the end, the size of the sessions array is the answer, which represents the minimum number of work sessions required to finish all tasks. \n    ",
        "js": "\n    ```javascript\nfunction minSessions(tasks, sessionTime) {\n    const sessions = [];\n    tasks.sort((a, b) => b - a);\n\n    for (let task of tasks) {\n        let added = false;\n        \n        for (let i = 0; i < sessions.length; i++) {\n            if (sessions[i] + task <= sessionTime) {\n                sessions[i] += task;\n                added = true;\n                break;\n            }\n        }\n\n        if (!added) {\n            sessions.push(task);\n        }\n    }\n\n    return sessions.length;\n}\n```\n    \n    The algorithm starts by sorting the tasks array in descending order. Then, for each task in tasks, it iterates over the sessions array and tries to insert the task into the first session that has sufficient remaining time. If no session can accommodate the task, a new session is created.\n\nIn the end, the size of the sessions array is the answer, which represents the minimum number of work sessions required to finish all tasks. \n    "
    },
    {
        "id": 386,
        "title": "A Number After a Double Reversal",
        "difficulty": "Easy",
        "content": {
            "problem": "**Reversing** an integer means to reverse all its digits.\n\n*   For example, reversing `2021` gives `1202`. Reversing `12300` gives `321` as the **leading zeros are not retained**.\n\nGiven an integer `num`, **reverse** `num` to get `reversed1`, **then reverse** `reversed1` to get `reversed2`. Return `true` _if_ `reversed2` _equals_ `num`. Otherwise return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 526\n**Output:** true\n**Explanation:** Reverse num to get 625, then reverse 625 to get 526, which equals num.\n\n",
                "**Example 2:**\n\n**Input:** num = 1800\n**Output:** false\n**Explanation:** Reverse num to get 81, then reverse 81 to get 18, which does not equal num.\n\n",
                "**Example 3:**\n\n**Input:** num = 0\n**Output:** true\n**Explanation:** Reverse num to get 0, then reverse 0 to get 0, which equals num."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 106`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "526",
                "output": "true"
            },
            {
                "input": "1800",
                "output": "false"
            },
            {
                "input": "0",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic int minOperations(int[] nums) {\n    int[] sortedNums = Arrays.stream(nums).distinct().sorted().toArray();\n    int n = sortedNums.length;\n    int ans = n;\n    for (int i = 0; i < n; ++i) {\n        int j = 0;\n        while (j < n && sortedNums[j] <= sortedNums[i] + n - 1) {\n            ++j;\n        }\n        ans = Math.min(ans, n - (j - i));\n    }\n    return ans;\n}\n```\n    \n    The algorithm first sorts the input array `nums` and removes duplicates. Then, for each element in the sorted array, it calculates the upper bound position (`j`) of the elements that can be included in a continuous range with the given element. The difference between the positions `j` and `i` is the number of elements in the continuous range. Subtracting this difference from the total number of unique elements in `nums` gives the number of operations required for this particular range. The final answer is the minimum number of operations required for all possible ranges.\n    ",
        "python": "\n    ```python\ndef minOperations(nums):\n    nums = sorted(set(nums))\n    n = len(nums)\n    ans = n\n    for i in range(n):\n        j = 0\n        while j < n and nums[j] <= nums[i] + n - 1:\n            j += 1\n        ans = min(ans, n - (j - i))\n    return ans\n```\n    \n    The algorithm first sorts the input array `nums` and removes duplicates. Then, for each element in the sorted array, it calculates the upper bound position (`j`) of the elements that can be included in a continuous range with the given element. The difference between the positions `j` and `i` is the number of elements in the continuous range. Subtracting this difference from the total number of unique elements in `nums` gives the number of operations required for this particular range. The final answer is the minimum number of operations required for all possible ranges.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint minOperations(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    nums.erase(unique(nums.begin(), nums.end()), nums.end());\n    int n = nums.size();\n    int ans = n;\n    for (int i = 0; i < n; ++i) {\n        int j = upper_bound(nums.begin() + i, nums.end(), nums[i] + n - 1) - nums.begin();\n        ans = min(ans, n - (j - i));\n    }\n    return ans;\n}\n```\n    \n    The algorithm first sorts the input array `nums` and removes duplicates. Then, for each element in the sorted array, it calculates the upper bound position (`j`) of the elements that can be included in a continuous range with the given element. The difference between the positions `j` and `i` is the number of elements in the continuous range. Subtracting this difference from the total number of unique elements in `nums` gives the number of operations required for this particular range. The final answer is the minimum number of operations required for all possible ranges.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    const sortedNums = [...new Set(nums)].sort((a, b) => a - b);\n    const n = sortedNums.length;\n    let ans = n;\n    for (let i = 0; i < n; ++i) {\n        let j = 0;\n        while (j < n && sortedNums[j] <= sortedNums[i] + n - 1) {\n            ++j;\n        }\n        ans = Math.min(ans, n - (j - i));\n    }\n    return ans;\n}\n```\n    \n    The algorithm first sorts the input array `nums` and removes duplicates. Then, for each element in the sorted array, it calculates the upper bound position (`j`) of the elements that can be included in a continuous range with the given element. The difference between the positions `j` and `i` is the number of elements in the continuous range. Subtracting this difference from the total number of unique elements in `nums` gives the number of operations required for this particular range. The final answer is the minimum number of operations required for all possible ranges.\n    "
    },
    {
        "id": 387,
        "title": "Capitalize the Title",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `title` consisting of one or more words separated by a single space, where each word consists of English letters. **Capitalize** the string by changing the capitalization of each word such that:\n\n*   If the length of the word is `1` or `2` letters, change all letters to lowercase.\n*   Otherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn _the **capitalized**_ `title`.",
            "examples": [
                "**Example 1:**\n\n**Input:** title =  \"capiTalIze tHe titLe \"\n**Output:**  \"Capitalize The Title \"\n**Explanation:**\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.\n\n",
                "**Example 2:**\n\n**Input:** title =  \"First leTTeR of EACH Word \"\n**Output:**  \"First Letter of Each Word \"\n**Explanation:**\nThe word  \"of \" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n\n",
                "**Example 3:**\n\n**Input:** title =  \"i lOve leetcode \"\n**Output:**  \"i Love Leetcode \"\n**Explanation:**\nThe word  \"i \" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= title.length <= 100`\n*   `title` consists of words separated by a single space without any leading or trailing spaces.\n*   Each word consists of uppercase and lowercase English letters and is **non-empty**.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"capiTalIzetHetitLe\"",
                "output": "\"CapitalizeTheTitle\""
            },
            {
                "input": "\"FirstleTTeRofEACHWord\"",
                "output": "\"FirstLetterofEachWord\""
            },
            {
                "input": "\"ilOveleetcode\"",
                "output": "\"iLoveLeetcode\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int interchangeableRectangles(int[][] rectangles) {\n    Map<Double, Integer> ratioCount = new HashMap<>();\n    int count = 0;\n\n    for (int[] r : rectangles) {\n        double ratio = (double) r[0] / r[1];\n        count += ratioCount.getOrDefault(ratio, 0);\n        ratioCount.put(ratio, ratioCount.getOrDefault(ratio, 0) + 1);\n    }\n\n    return count;\n}\n```\n\n    \n    For each rectangle, we calculate the width-to-height ratio by dividing the width by the height as a floating-point number. We use a hash map called `ratioCount` to maintain the counts of each unique ratio found so far. If the current ratio is already in the hash map, we increment the count of the current ratio by 1 and add the current count of the ratio to our result. In this way, we count the pairs of interchangeable rectangles that can be created with the current rectangle for each ratio.\n\nFor example, if the input array is `rectangles = [[4, 8], [3, 6], [10, 20], [12, 24], [12, 16]]`, then we calculate the following width-to-height ratios: `[1/2, 1/2, 1/2, 1/2, 3/4]`. The count of the ratio `1/2` is 4, so the result will be `1 + 2 + 3 = 6`, as these are the number of pairs that can be formed with the 4 rectangles with this ratio.\n    ",
        "python": "\n    ```python\ndef interchangeable_rectangles(rectangles):\n    ratio_count = {}\n    count = 0\n\n    for r in rectangles:\n        ratio = r[0] / r[1]\n        count += ratio_count.get(ratio, 0)\n        ratio_count[ratio] = ratio_count.get(ratio, 0) + 1\n\n    return count\n```\n\n    \n    For each rectangle, we calculate the width-to-height ratio by dividing the width by the height as a floating-point number. We use a hash map called `ratioCount` to maintain the counts of each unique ratio found so far. If the current ratio is already in the hash map, we increment the count of the current ratio by 1 and add the current count of the ratio to our result. In this way, we count the pairs of interchangeable rectangles that can be created with the current rectangle for each ratio.\n\nFor example, if the input array is `rectangles = [[4, 8], [3, 6], [10, 20], [12, 24], [12, 16]]`, then we calculate the following width-to-height ratios: `[1/2, 1/2, 1/2, 1/2, 3/4]`. The count of the ratio `1/2` is 4, so the result will be `1 + 2 + 3 = 6`, as these are the number of pairs that can be formed with the 4 rectangles with this ratio.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint interchangeableRectangles(std::vector<std::vector<int>>& rectangles) {\n    std::unordered_map<double, int> ratioCount;\n    int count = 0;\n\n    for (const auto& r : rectangles) {\n        double ratio = static_cast<double>(r[0]) / r[1];\n        count += ratioCount[ratio];\n        ratioCount[ratio]++;\n    }\n\n    return count;\n}\n```\n\n    \n    For each rectangle, we calculate the width-to-height ratio by dividing the width by the height as a floating-point number. We use a hash map called `ratioCount` to maintain the counts of each unique ratio found so far. If the current ratio is already in the hash map, we increment the count of the current ratio by 1 and add the current count of the ratio to our result. In this way, we count the pairs of interchangeable rectangles that can be created with the current rectangle for each ratio.\n\nFor example, if the input array is `rectangles = [[4, 8], [3, 6], [10, 20], [12, 24], [12, 16]]`, then we calculate the following width-to-height ratios: `[1/2, 1/2, 1/2, 1/2, 3/4]`. The count of the ratio `1/2` is 4, so the result will be `1 + 2 + 3 = 6`, as these are the number of pairs that can be formed with the 4 rectangles with this ratio.\n    ",
        "js": "\n    ```javascript\nfunction interchangeableRectangles(rectangles) {\n    const ratioCount = {};\n    let count = 0;\n\n    for (const r of rectangles) {\n        const ratio = r[0] / r[1];\n        count += ratioCount[ratio] ? ratioCount[ratio] : 0;\n        ratioCount[ratio] = (ratioCount[ratio] || 0) + 1;\n    }\n\n    return count;\n}\n```\n\n    \n    For each rectangle, we calculate the width-to-height ratio by dividing the width by the height as a floating-point number. We use a hash map called `ratioCount` to maintain the counts of each unique ratio found so far. If the current ratio is already in the hash map, we increment the count of the current ratio by 1 and add the current count of the ratio to our result. In this way, we count the pairs of interchangeable rectangles that can be created with the current rectangle for each ratio.\n\nFor example, if the input array is `rectangles = [[4, 8], [3, 6], [10, 20], [12, 24], [12, 16]]`, then we calculate the following width-to-height ratios: `[1/2, 1/2, 1/2, 1/2, 3/4]`. The count of the ratio `1/2` is 4, so the result will be `1 + 2 + 3 = 6`, as these are the number of pairs that can be formed with the 4 rectangles with this ratio.\n    "
    },
    {
        "id": 388,
        "title": "Check if Every Row and Column Contains All Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "An `n x n` matrix is **valid** if every row and every column contains **all** the integers from `1` to `n` (**inclusive**).\n\nGiven an `n x n` integer matrix `matrix`, return `true` _if the matrix is **valid**._ Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[3,1,2\\],\\[2,3,1\\]\\]\n**Output:** true\n**Explanation:** In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,1,1\\],\\[1,2,3\\],\\[1,2,3\\]\\]\n**Output:** false\n**Explanation:** In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
            ],
            "constraints": "**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 100`\n*   `1 <= matrix[i][j] <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[3,1,2],[2,3,1]]",
                "output": "true"
            },
            {
                "input": "[[1,1,1],[1,2,3],[1,2,3]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int countPairs(List<String> nums, String target) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums.get(i).concat(nums.get(j)).equals(target) || nums.get(j).concat(nums.get(i)).equals(target)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through all possible pairs of indices i and j where `i != j` by using nested loops. For each pair, we check if the concatenation of `nums[i] + nums[j]` or `nums[j] + nums[i]` equals the `target`. If either condition is true, we increment the count. Finally, we return the count of such pairs. This solution has a complexity of O(n^2).\n    ",
        "python": "\n    ```python\ndef count_pairs(nums, target):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target or nums[j] + nums[i] == target:\n                count += 1\n    return count\n```\n    \n    The algorithm iterates through all possible pairs of indices i and j where `i != j` by using nested loops. For each pair, we check if the concatenation of `nums[i] + nums[j]` or `nums[j] + nums[i]` equals the `target`. If either condition is true, we increment the count. Finally, we return the count of such pairs. This solution has a complexity of O(n^2).\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint countPairs(const std::vector<std::string>& nums, const std::string& target) {\n    int count = 0;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        for (size_t j = i + 1; j < nums.size(); ++j) {\n            if (nums[i] + nums[j] == target || nums[j] + nums[i] == target) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through all possible pairs of indices i and j where `i != j` by using nested loops. For each pair, we check if the concatenation of `nums[i] + nums[j]` or `nums[j] + nums[i]` equals the `target`. If either condition is true, we increment the count. Finally, we return the count of such pairs. This solution has a complexity of O(n^2).\n    ",
        "js": "\n    ```javascript\nfunction countPairs(nums, target) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target || nums[j] + nums[i] === target) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through all possible pairs of indices i and j where `i != j` by using nested loops. For each pair, we check if the concatenation of `nums[i] + nums[j]` or `nums[j] + nums[i]` equals the `target`. If either condition is true, we increment the count. Finally, we return the count of such pairs. This solution has a complexity of O(n^2).\n    "
    },
    {
        "id": 389,
        "title": "Divide a String Into Groups of Size k",
        "difficulty": "Easy",
        "content": {
            "problem": "A string `s` can be partitioned into groups of size `k` using the following procedure:\n\n*   The first group consists of the first `k` characters of the string, the second group consists of the next `k` characters of the string, and so on. Each character can be a part of **exactly one** group.\n*   For the last group, if the string **does not** have `k` characters remaining, a character `fill` is used to complete the group.\n\nNote that the partition is done so that after removing the `fill` character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be `s`.\n\nGiven the string `s`, the size of each group `k` and the character `fill`, return _a string array denoting the **composition of every group**_ `s` _has been divided into, using the above procedure_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcdefghi \", k = 3, fill =  \"x \"\n**Output:** \\[ \"abc \", \"def \", \"ghi \"\\]\n**Explanation:**\nThe first 3 characters  \"abc \" form the first group.\nThe next 3 characters  \"def \" form the second group.\nThe last 3 characters  \"ghi \" form the third group.\nSince all groups can be completely filled by characters from the string, we do not need to use fill.\nThus, the groups formed are  \"abc \",  \"def \", and  \"ghi \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdefghij \", k = 3, fill =  \"x \"\n**Output:** \\[ \"abc \", \"def \", \"ghi \", \"jxx \"\\]\n**Explanation:**\nSimilar to the previous example, we are forming the first three groups  \"abc \",  \"def \", and  \"ghi \".\nFor the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.\nThus, the 4 groups formed are  \"abc \",  \"def \",  \"ghi \", and  \"jxx \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters only.\n*   `1 <= k <= 100`\n*   `fill` is a lowercase English letter.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"abcdefghi\",3,\"x\"",
                "output": "[\"abc\",\"def\",\"ghi\"]"
            },
            {
                "input": "\"abcdefghij\",3,\"x\"",
                "output": "[\"abc\",\"def\",\"ghi\",\"jxx\"]"
            }
        ],
        "java": "\n    ```java\npublic int sumOfBeauties(int[] nums) {\n    int n = nums.length;\n    int result = 0;\n\n    int[] leftMax = new int[n];\n    leftMax[0] = nums[0];\n    int[] rightMin = new int[n];\n    rightMin[n - 1] = nums[n - 1];\n\n    for (int i = 1; i < n; i++) {\n        leftMax[i] = Math.max(leftMax[i - 1], nums[i]);\n    }\n\n    for (int i = n - 2; i >= 0; i--) {\n        rightMin[i] = Math.min(rightMin[i + 1], nums[i]);\n    }\n\n    for (int i = 1; i <= n - 2; i++) {\n        if (nums[i] > leftMax[i - 1] && nums[i] < rightMin[i + 1]) {\n            result += 1;\n        }\n    }\n\n    return result;\n}\n```\n    \n    To solve this problem, we first create two arrays, `leftMax` and `rightMin`. `leftMax` stores the maximum value to the left of each index i, and `rightMin` stores the minimum value to the right of each index i. We then iterate through the input array `nums` from index 1 to index n - 2 (inclusive) and check if the current value is greater than the maximum to its left and less than the minimum to its right. If both conditions are fulfilled, we increase the result by 1. Finally, we return the result as the sum of the beauty of all `nums[i]` where 1 <= i <= nums.length - 2.\n    ",
        "python": "\n    ```python\ndef sum_of_beauties(nums: List[int]) -> int:\n    n = len(nums)\n    result = 0\n\n    left_max = [0] * n\n    left_max[0] = nums[0]\n    right_min = [0] * n\n    right_min[n - 1] = nums[n - 1]\n\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], nums[i])\n\n    for i in range(n - 2, -1, -1):\n        right_min[i] = min(right_min[i + 1], nums[i])\n\n    for i in range(1, n - 1):\n        if nums[i] > left_max[i - 1] and nums[i] < right_min[i + 1]:\n            result += 1\n\n    return result\n```\n    \n    To solve this problem, we first create two arrays, `leftMax` and `rightMin`. `leftMax` stores the maximum value to the left of each index i, and `rightMin` stores the minimum value to the right of each index i. We then iterate through the input array `nums` from index 1 to index n - 2 (inclusive) and check if the current value is greater than the maximum to its left and less than the minimum to its right. If both conditions are fulfilled, we increase the result by 1. Finally, we return the result as the sum of the beauty of all `nums[i]` where 1 <= i <= nums.length - 2.\n    ",
        "c++": "\n    ```cpp\nint sumOfBeauties(std::vector<int>& nums) {\n    int n = nums.size();\n    int result = 0;\n\n    std::vector<int> leftMax(n);\n    leftMax[0] = nums[0];\n    std::vector<int> rightMin(n);\n    rightMin[n - 1] = nums[n - 1];\n\n    for (int i = 1; i < n; i++) {\n        leftMax[i] = std::max(leftMax[i - 1], nums[i]);\n    }\n\n    for (int i = n - 2; i >= 0; i--) {\n        rightMin[i] = std::min(rightMin[i + 1], nums[i]);\n    }\n\n    for (int i = 1; i <= n - 2; i++) {\n        if (nums[i] > leftMax[i - 1] && nums[i] < rightMin[i + 1]) {\n            result += 1;\n        }\n    }\n\n    return result;\n}\n```\n    \n    To solve this problem, we first create two arrays, `leftMax` and `rightMin`. `leftMax` stores the maximum value to the left of each index i, and `rightMin` stores the minimum value to the right of each index i. We then iterate through the input array `nums` from index 1 to index n - 2 (inclusive) and check if the current value is greater than the maximum to its left and less than the minimum to its right. If both conditions are fulfilled, we increase the result by 1. Finally, we return the result as the sum of the beauty of all `nums[i]` where 1 <= i <= nums.length - 2.\n    ",
        "js": "\n    ```javascript\nfunction sumOfBeauties(nums) {\n    const n = nums.length;\n    let result = 0;\n\n    const leftMax = new Array(n);\n    leftMax[0] = nums[0];\n    const rightMin = new Array(n);\n    rightMin[n - 1] = nums[n - 1];\n\n    for (let i = 1; i < n; i++) {\n        leftMax[i] = Math.max(leftMax[i - 1], nums[i]);\n    }\n\n    for (let i = n - 2; i >= 0; i--) {\n        rightMin[i] = Math.min(rightMin[i + 1], nums[i]);\n    }\n\n    for (let i = 1; i <= n - 2; i++) {\n        if (nums[i] > leftMax[i - 1] && nums[i] < rightMin[i + 1]) {\n            result += 1;\n        }\n    }\n\n    return result;\n}\n```\n    \n    To solve this problem, we first create two arrays, `leftMax` and `rightMin`. `leftMax` stores the maximum value to the left of each index i, and `rightMin` stores the minimum value to the right of each index i. We then iterate through the input array `nums` from index 1 to index n - 2 (inclusive) and check if the current value is greater than the maximum to its left and less than the minimum to its right. If both conditions are fulfilled, we increase the result by 1. Finally, we return the result as the sum of the beauty of all `nums[i]` where 1 <= i <= nums.length - 2.\n    "
    },
    {
        "id": 390,
        "title": "Minimum Cost of Buying Candies With Discount",
        "difficulty": "Easy",
        "content": {
            "problem": "A shop is selling candies at a discount. For **every two** candies sold, the shop gives a **third** candy for **free**.\n\nThe customer can choose **any** candy to take away for free as long as the cost of the chosen candy is less than or equal to the **minimum** cost of the two candies bought.\n\n*   For example, if there are `4` candies with costs `1`, `2`, `3`, and `4`, and the customer buys candies with costs `2` and `3`, they can take the candy with cost `1` for free, but not the candy with cost `4`.\n\nGiven a **0-indexed** integer array `cost`, where `cost[i]` denotes the cost of the `ith` candy, return _the **minimum cost** of buying **all** the candies_.",
            "examples": [
                "**Example 1:**\n\n**Input:** cost = \\[1,2,3\\]\n**Output:** 5\n**Explanation:** We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the **only** way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n\n",
                "**Example 2:**\n\n**Input:** cost = \\[6,5,7,9,2,2\\]\n**Output:** 23\n**Explanation:** The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n\n",
                "**Example 3:**\n\n**Input:** cost = \\[5,5\\]\n**Output:** 10\n**Explanation:** Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= cost.length <= 100`\n*   `1 <= cost[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "5"
            },
            {
                "input": "[6,5,7,9,2,2]",
                "output": "23"
            },
            {
                "input": "[5,5]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int maxDifference(int[] nums) {\n    int min_val = nums[0];\n    int max_diff = -1;\n\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] > min_val) {\n            max_diff = Math.max(max_diff, nums[i] - min_val);\n        } else {\n            min_val = nums[i];\n        }\n    }\n    return max_diff;\n}\n```\n    \n    The algorithm iterates through the array while keeping track of the smallest value found so far (`min_val`). For each element in the array, it checks if the current value is greater than the `min_val`. If it is, it calculates the difference and updates the `max_diff` if the difference is greater than the current `max_diff`. If the current value is not greater than the `min_val`, the `min_val` is updated to the current value. The algorithm returns the `max_diff` found during the iteration. If no such i and j exist, the `max_diff` remains -1.\n    ",
        "python": "\n    ```python\ndef max_difference(nums):\n    min_val = nums[0]\n    max_diff = -1\n\n    for i in range(1, len(nums)):\n        if nums[i] > min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n\n    return max_diff\n```\n    \n    The algorithm iterates through the array while keeping track of the smallest value found so far (`min_val`). For each element in the array, it checks if the current value is greater than the `min_val`. If it is, it calculates the difference and updates the `max_diff` if the difference is greater than the current `max_diff`. If the current value is not greater than the `min_val`, the `min_val` is updated to the current value. The algorithm returns the `max_diff` found during the iteration. If no such i and j exist, the `max_diff` remains -1.\n    ",
        "c++": "\n    ```cpp\nint maxDifference(vector<int>& nums) {\n    int min_val = nums[0];\n    int max_diff = -1;\n\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] > min_val) {\n            max_diff = max(max_diff, nums[i] - min_val);\n        } else {\n            min_val = nums[i];\n        }\n    }\n    return max_diff;\n}\n```\n    \n    The algorithm iterates through the array while keeping track of the smallest value found so far (`min_val`). For each element in the array, it checks if the current value is greater than the `min_val`. If it is, it calculates the difference and updates the `max_diff` if the difference is greater than the current `max_diff`. If the current value is not greater than the `min_val`, the `min_val` is updated to the current value. The algorithm returns the `max_diff` found during the iteration. If no such i and j exist, the `max_diff` remains -1.\n    ",
        "js": "\n    ```javascript\nfunction maxDifference(nums) {\n    let min_val = nums[0];\n    let max_diff = -1;\n\n    for (let i = 1; i < nums.length; ++i) {\n        if (nums[i] > min_val) {\n            max_diff = Math.max(max_diff, nums[i] - min_val);\n        } else {\n            min_val = nums[i];\n        }\n    }\n    return max_diff;\n}\n```\n    \n    The algorithm iterates through the array while keeping track of the smallest value found so far (`min_val`). For each element in the array, it checks if the current value is greater than the `min_val`. If it is, it calculates the difference and updates the `max_diff` if the difference is greater than the current `max_diff`. If the current value is not greater than the `min_val`, the `min_val` is updated to the current value. The algorithm returns the `max_diff` found during the iteration. If no such i and j exist, the `max_diff` remains -1.\n    "
    },
    {
        "id": 391,
        "title": "Keep Multiplying Found Values by Two",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of integers `nums`. You are also given an integer `original` which is the first number that needs to be searched for in `nums`.\n\nYou then do the following steps:\n\n1.  If `original` is found in `nums`, **multiply** it by two (i.e., set `original = 2 * original`).\n2.  Otherwise, **stop** the process.\n3.  **Repeat** this process with the new number as long as you keep finding the number.\n\nReturn _the **final** value of_ `original`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,3,6,1,12\\], original = 3\n**Output:** 24\n**Explanation:** \n- 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n- 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n- 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n- 24 is not found in nums. Thus, 24 is returned.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,7,9\\], original = 4\n**Output:** 4\n**Explanation:**\n- 4 is not found in nums. Thus, 4 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i], original <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Simulation"
        ],
        "example": [
            {
                "input": "[5,3,6,1,12],3",
                "output": "24"
            },
            {
                "input": "[2,7,9],4",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int minMovesToConvert(String s) {\n    int count = 0;\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s.charAt(i) == 'X' && s.charAt(i + 1) == 'X' && s.charAt(i + 2) == 'X') {\n            count++;\n            i += 2; // move by 3\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the given string s. For each character, if it finds a sequence of 3 consecutive 'X', it increases the 'count' and moves the iterator 3 positions forward. If it doesn't find the sequence, it moves the iterator 1 position forward. The algorithm ultimately returns the 'count', which is the minimum number of moves required to convert all characters in the string to 'O'.\n    ",
        "python": "\n    ```python\ndef min_moves_to_convert(s):\n    count = 0\n    i = 0\n    while i < len(s) - 2:\n        if s[i] == \"X\" and s[i + 1] == \"X\" and s[i + 2] == \"X\":\n            count += 1\n            i += 3\n        else:\n            i += 1\n    return count\n```\n    \n    The algorithm iterates over the given string s. For each character, if it finds a sequence of 3 consecutive 'X', it increases the 'count' and moves the iterator 3 positions forward. If it doesn't find the sequence, it moves the iterator 1 position forward. The algorithm ultimately returns the 'count', which is the minimum number of moves required to convert all characters in the string to 'O'.\n    ",
        "c++": "\n    ```cpp\nint min_moves_to_convert(const std::string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length() - 2; i++) {\n        if (s[i] == 'X' && s[i + 1] == 'X' && s[i + 2] == 'X') {\n            count++;\n            i += 2; // move by 3\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the given string s. For each character, if it finds a sequence of 3 consecutive 'X', it increases the 'count' and moves the iterator 3 positions forward. If it doesn't find the sequence, it moves the iterator 1 position forward. The algorithm ultimately returns the 'count', which is the minimum number of moves required to convert all characters in the string to 'O'.\n    ",
        "js": "\n    ```javascript\nfunction minimumMovesToConvert(s) {\n    let count = 0;\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s[i] === 'X' && s[i + 1] === 'X' && s[i + 2] === 'X') {\n            count++;\n            i += 2; // move by 3\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the given string s. For each character, if it finds a sequence of 3 consecutive 'X', it increases the 'count' and moves the iterator 3 positions forward. If it doesn't find the sequence, it moves the iterator 1 position forward. The algorithm ultimately returns the 'count', which is the minimum number of moves required to convert all characters in the string to 'O'.\n    "
    },
    {
        "id": 392,
        "title": "Minimum Sum of Four Digit Number After Splitting Digits",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **positive** integer `num` consisting of exactly four digits. Split `num` into two new integers `new1` and `new2` by using the **digits** found in `num`. **Leading zeros** are allowed in `new1` and `new2`, and **all** the digits found in `num` must be used.\n\n*   For example, given `num = 2932`, you have the following digits: two `2`'s, one `9` and one `3`. Some of the possible pairs `[new1, new2]` are `[22, 93]`, `[23, 92]`, `[223, 9]` and `[2, 329]`.\n\nReturn _the **minimum** possible sum of_ `new1` _and_ `new2`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 2932\n**Output:** 52\n**Explanation:** Some possible pairs \\[new1, new2\\] are \\[29, 23\\], \\[223, 9\\], etc.\nThe minimum sum can be obtained by the pair \\[29, 23\\]: 29 + 23 = 52.\n\n",
                "**Example 2:**\n\n**Input:** num = 4009\n**Output:** 13\n**Explanation:** Some possible pairs \\[new1, new2\\] are \\[0, 49\\], \\[490, 0\\], etc. \nThe minimum sum can be obtained by the pair \\[4, 9\\]: 4 + 9 = 13."
            ],
            "constraints": "**Constraints:**\n\n*   `1000 <= num <= 9999`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "2932",
                "output": "52"
            },
            {
                "input": "4009",
                "output": "13"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[][] grid, int x) {\n    int minElement = Integer.MAX_VALUE;\n    for (int[] row : grid) {\n        for (int cell : row) {\n            minElement = Math.min(minElement, cell);\n        }\n    }\n\n    int minOperations = Integer.MAX_VALUE;\n    for (int base = minElement; ; --base) {\n        int operations = 0;\n        boolean impossible = false;\n        for (int[] row : grid) {\n            if (impossible) break;\n            for (int cell : row) {\n                int diff = Math.abs(cell - base);\n                if (diff % x != 0) {\n                    impossible = true;\n                    break;\n                }\n                operations += diff / x;\n            }\n        }\n        if (impossible) break;\n        minOperations = Math.min(minOperations, operations);\n    }\n\n    return minOperations == Integer.MAX_VALUE ? -1 : minOperations;\n}\n```\n    \n    - Find the minimum element in the grid\n- Initialize the minimum operations to `inf`\n- Start with `base` equal to the minimum element, and decrement by 1 for each iteration\n- For each possible `base`, iterate over every element in the grid and calculate the absolute difference between the current element and `base`\n- If the difference can't be evenly divided by `x`, mark it as impossible and break the loop\n- Otherwise, add the number of operations required (difference / x) to obtain a uni-value grid\n- Update the minimum operations with the minimum of the current minimum and the calculated operations\n- Return -1 if the minimum operations remain `inf`, otherwise return the minimum operations found\n    ",
        "python": "\n    ```python\ndef min_operations(grid, x):\n    min_element = min(min(row) for row in grid)\n    min_ops = float('inf')\n\n    base = min_element\n    while True:\n        operations = 0\n        impossible = False\n        for row in grid:\n            if impossible:\n                break\n            for cell in row:\n                diff = abs(cell - base)\n                if diff % x != 0:\n                    impossible = True\n                    break\n                operations += diff // x\n        if impossible:\n            break\n        min_ops = min(min_ops, operations)\n        base -= 1\n\n    return -1 if min_ops == float('inf') else min_ops\n```\n    \n    - Find the minimum element in the grid\n- Initialize the minimum operations to `inf`\n- Start with `base` equal to the minimum element, and decrement by 1 for each iteration\n- For each possible `base`, iterate over every element in the grid and calculate the absolute difference between the current element and `base`\n- If the difference can't be evenly divided by `x`, mark it as impossible and break the loop\n- Otherwise, add the number of operations required (difference / x) to obtain a uni-value grid\n- Update the minimum operations with the minimum of the current minimum and the calculated operations\n- Return -1 if the minimum operations remain `inf`, otherwise return the minimum operations found\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <climits>\n#include <cmath>\n\nint min_operations(std::vector<std::vector<int>>& grid, int x) {\n    int min_elem = INT_MAX;\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            min_elem = std::min(min_elem, cell);\n        }\n    }\n\n    int min_operations = INT_MAX;\n    for (int base = min_elem;; --base) {\n        int operations = 0;\n        bool impossible = false;\n        for (const auto& row : grid) {\n            if (impossible) break;\n            for (int cell : row) {\n                int diff = std::abs(cell - base);\n                if (diff % x != 0) {\n                    impossible = true;\n                    break;\n                }\n                operations += diff / x;\n            }\n        }\n        if (impossible) break;\n        min_operations = std::min(min_operations, operations);\n    }\n\n    return min_operations == INT_MAX ? -1 : min_operations;\n}\n```\n    \n    - Find the minimum element in the grid\n- Initialize the minimum operations to `inf`\n- Start with `base` equal to the minimum element, and decrement by 1 for each iteration\n- For each possible `base`, iterate over every element in the grid and calculate the absolute difference between the current element and `base`\n- If the difference can't be evenly divided by `x`, mark it as impossible and break the loop\n- Otherwise, add the number of operations required (difference / x) to obtain a uni-value grid\n- Update the minimum operations with the minimum of the current minimum and the calculated operations\n- Return -1 if the minimum operations remain `inf`, otherwise return the minimum operations found\n    ",
        "js": "\n    ```javascript\nfunction minOperations(grid, x) {\n  const minElement = Math.min(...grid.map(row => Math.min(...row)));\n  let minOps = Infinity;\n\n  let base = minElement;\n  while (true) {\n      let operations = 0;\n      let impossible = false;\n      for (let row of grid) {\n          if (impossible) break;\n          for (let cell of row) {\n              const diff = Math.abs(cell - base);\n              if (diff % x !== 0) {\n                  impossible = true;\n                  break;\n              }\n              operations += diff / x;\n          }\n      }\n      if (impossible) break;\n      minOps = Math.min(minOps, operations);\n      base -= 1;\n  }\n\n  return minOps === Infinity ? -1 : minOps;\n}\n```\n    \n    - Find the minimum element in the grid\n- Initialize the minimum operations to `inf`\n- Start with `base` equal to the minimum element, and decrement by 1 for each iteration\n- For each possible `base`, iterate over every element in the grid and calculate the absolute difference between the current element and `base`\n- If the difference can't be evenly divided by `x`, mark it as impossible and break the loop\n- Otherwise, add the number of operations required (difference / x) to obtain a uni-value grid\n- Update the minimum operations with the minimum of the current minimum and the calculated operations\n- Return -1 if the minimum operations remain `inf`, otherwise return the minimum operations found\n    "
    },
    {
        "id": 393,
        "title": "Sort Even and Odd Indices Independently",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. Rearrange the values of `nums` according to the following rules:\n\n1.  Sort the values at **odd indices** of `nums` in **non-increasing** order.\n    *   For example, if `nums = [4,**1**,2,**3**]` before this step, it becomes `[4,**3**,2,**1**]` after. The values at odd indices `1` and `3` are sorted in non-increasing order.\n2.  Sort the values at **even indices** of `nums` in **non-decreasing** order.\n    *   For example, if `nums = [**4**,1,**2**,3]` before this step, it becomes `[**2**,1,**4**,3]` after. The values at even indices `0` and `2` are sorted in non-decreasing order.\n\nReturn _the array formed after rearranging the values of_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,1,2,3\\]\n**Output:** \\[2,3,4,1\\]\n**Explanation:** \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from \\[4,**1**,2,**3**\\] to \\[4,**3**,2,**1**\\].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from \\[**4**,1,**2**,3\\] to \\[**2**,3,**4**,1\\].\nThus, the array formed after rearranging the values is \\[2,3,4,1\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,1\\]\n**Output:** \\[2,1\\]\n**Explanation:** \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is \\[2,1\\], which is the same as the initial array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,1,2,3]",
                "output": "[2,3,4,1]"
            },
            {
                "input": "[2,1]",
                "output": "[2,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxValue(int[][] events) {\n    Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\n\n    int[] dp = new int[events.length];\n    dp[0] = events[0][2];\n\n    for (int i = 1; i < events.length; i++) {\n        int lastNonConflict = -1;\n        for (int j = i - 1; j >= 0; j--) {\n            if (events[j][1] < events[i][0]) {\n                lastNonConflict = j;\n                break;\n            }\n        }\n\n        int includedValue = events[i][2];\n        if (lastNonConflict != -1) {\n            includedValue += dp[lastNonConflict];\n        }\n\n        dp[i] = Math.max(includedValue, dp[i - 1]);\n    }\n\n    return dp[dp.length - 1];\n}\n```\n    \n    The problem can be solved using a dynamic programming approach. We first sort the events array by the end times in ascending order. Initialize an array `dp` of the same length as the number of events, and set the first value to the value of the first sorted event. Then, for each event in the sorted array starting from the second event, perform the following:\n\n1. Find the last non-conflicting event index (i.e., the event index with the end time less than the current event's start time) and store that as `lastNonConflict`. Start the search from the previous event and go backward.\n\n2. Calculate the value if we include the current event, which is the current event's value and the value of lastNonConflict (if it exists) from the dp array.\n\n3. Get the maximum value between the included value (calculated in step 2) and the value of the previous event. Update the dp array at the current index with the maximum value.\n\nFinally, return the last value from the `dp` array as it represents the maximum sum after considering all events.\n    ",
        "python": "\n    ```python\ndef maxValue(events):\n    events.sort(key=lambda a: a[1])\n\n    dp = [0] * len(events)\n    dp[0] = events[0][2]\n\n    for i in range(1, len(events)):\n        lastNonConflict = -1\n        for j in range(i - 1, -1, -1):\n            if events[j][1] < events[i][0]:\n                lastNonConflict = j\n                break\n                \n        includedValue = events[i][2]\n        if lastNonConflict != -1:\n            includedValue += dp[lastNonConflict]\n\n        dp[i] = max(includedValue, dp[i - 1])\n\n    return dp[-1]\n```\n    \n    The problem can be solved using a dynamic programming approach. We first sort the events array by the end times in ascending order. Initialize an array `dp` of the same length as the number of events, and set the first value to the value of the first sorted event. Then, for each event in the sorted array starting from the second event, perform the following:\n\n1. Find the last non-conflicting event index (i.e., the event index with the end time less than the current event's start time) and store that as `lastNonConflict`. Start the search from the previous event and go backward.\n\n2. Calculate the value if we include the current event, which is the current event's value and the value of lastNonConflict (if it exists) from the dp array.\n\n3. Get the maximum value between the included value (calculated in step 2) and the value of the previous event. Update the dp array at the current index with the maximum value.\n\nFinally, return the last value from the `dp` array as it represents the maximum sum after considering all events.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint maxValue(vector<vector<int>>& events) {\n    sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    vector<int> dp(events.size());\n    dp[0] = events[0][2];\n\n    for (int i = 1; i < events.size(); i++) {\n        int lastNonConflict = -1;\n        for (int j = i - 1; j >= 0; j--) {\n            if (events[j][1] < events[i][0]) {\n                lastNonConflict = j;\n                break;\n            }\n        }\n\n        int includedValue = events[i][2];\n        if (lastNonConflict != -1) {\n            includedValue += dp[lastNonConflict];\n        }\n\n        dp[i] = max(includedValue, dp[i - 1]);\n    }\n\n    return dp.back();\n}\n```\n    \n    The problem can be solved using a dynamic programming approach. We first sort the events array by the end times in ascending order. Initialize an array `dp` of the same length as the number of events, and set the first value to the value of the first sorted event. Then, for each event in the sorted array starting from the second event, perform the following:\n\n1. Find the last non-conflicting event index (i.e., the event index with the end time less than the current event's start time) and store that as `lastNonConflict`. Start the search from the previous event and go backward.\n\n2. Calculate the value if we include the current event, which is the current event's value and the value of lastNonConflict (if it exists) from the dp array.\n\n3. Get the maximum value between the included value (calculated in step 2) and the value of the previous event. Update the dp array at the current index with the maximum value.\n\nFinally, return the last value from the `dp` array as it represents the maximum sum after considering all events.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(events) {\n    events.sort((a, b) => a[1] - b[1]);\n\n    let dp = new Array(events.length);\n    dp[0] = events[0][2];\n\n    for (let i = 1; i < events.length; i++) {\n        let lastNonConflict = -1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (events[j][1] < events[i][0]) {\n                lastNonConflict = j;\n                break;\n            }\n        }\n\n        let includedValue = events[i][2];\n        if (lastNonConflict !== -1) {\n            includedValue += dp[lastNonConflict];\n        }\n\n        dp[i] = Math.max(includedValue, dp[i - 1]);\n    }\n\n    return dp[dp.length - 1];\n}\n```\n    \n    The problem can be solved using a dynamic programming approach. We first sort the events array by the end times in ascending order. Initialize an array `dp` of the same length as the number of events, and set the first value to the value of the first sorted event. Then, for each event in the sorted array starting from the second event, perform the following:\n\n1. Find the last non-conflicting event index (i.e., the event index with the end time less than the current event's start time) and store that as `lastNonConflict`. Start the search from the previous event and go backward.\n\n2. Calculate the value if we include the current event, which is the current event's value and the value of lastNonConflict (if it exists) from the dp array.\n\n3. Get the maximum value between the included value (calculated in step 2) and the value of the previous event. Update the dp array at the current index with the maximum value.\n\nFinally, return the last value from the `dp` array as it represents the maximum sum after considering all events.\n    "
    },
    {
        "id": 394,
        "title": "Count Equal and Divisible Pairs in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums` of length `n` and an integer `k`, return _the **number of pairs**_ `(i, j)` _where_ `0 <= i < j < n`, _such that_ `nums[i] == nums[j]` _and_ `(i * j)` _is divisible by_ `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,2,2,2,1,3\\], k = 2\n**Output:** 4\n**Explanation:**\nThere are 4 pairs that meet all the requirements:\n- nums\\[0\\] == nums\\[6\\], and 0 \\* 6 == 0, which is divisible by 2.\n- nums\\[2\\] == nums\\[3\\], and 2 \\* 3 == 6, which is divisible by 2.\n- nums\\[2\\] == nums\\[4\\], and 2 \\* 4 == 8, which is divisible by 2.\n- nums\\[3\\] == nums\\[4\\], and 3 \\* 4 == 12, which is divisible by 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\], k = 1\n**Output:** 0\n**Explanation:** Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i], k <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[3,1,2,2,2,1,3],2",
                "output": "4"
            },
            {
                "input": "[1,2,3,4],1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minMonths(int n, int[][] relations, int[] time) {\n    int[] order = new int[n];\n    for (int[] r : relations)\n        order[r[1] - 1] = Math.max(order[r[1] - 1], r[0]);\n    int totalTime = 0;\n    for (int i = 0; i < n; i++)\n        totalTime = Math.max(totalTime, time[i] + order[i]);\n    return totalTime;\n}\n```\n    \n    The algorithm starts by creating an array `order` to keep track of the maximum prerequisite course number for each course. For each relation, it updates the maximum prerequisite course number for the `nextCourse` with the `prevCourse`.\n\nNext, go through each course, and calculate the total time needed to finish that course by adding the course's time plus the time of its maximum prerequisite course. Track the maximum time across all courses as `totalTime`.\n\nFinally, return the maximum time `totalTime` as the minimum number of months needed to complete all courses.\n    ",
        "python": "\n    ```python\ndef min_months(n, relations, time):\n    order = [0] * n\n    for r in relations:\n        order[r[1] - 1] = max(order[r[1] - 1], r[0])\n    totalTime = 0\n    for i in range(n):\n        totalTime = max(totalTime, time[i] + order[i])\n    return totalTime\n```\n    \n    The algorithm starts by creating an array `order` to keep track of the maximum prerequisite course number for each course. For each relation, it updates the maximum prerequisite course number for the `nextCourse` with the `prevCourse`.\n\nNext, go through each course, and calculate the total time needed to finish that course by adding the course's time plus the time of its maximum prerequisite course. Track the maximum time across all courses as `totalTime`.\n\nFinally, return the maximum time `totalTime` as the minimum number of months needed to complete all courses.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint min_months(int n, std::vector<std::vector<int>>& relations, std::vector<int>& time) {\n    std::vector<int> order(n, 0);\n    for (auto& r : relations)\n        order[r[1] - 1] = std::max(order[r[1] - 1], r[0]);\n    int totalTime = 0;\n    for (int i = 0; i < n; ++i)\n        totalTime = std::max(totalTime, time[i] + order[i]);\n    return totalTime;\n}\n```\n    \n    The algorithm starts by creating an array `order` to keep track of the maximum prerequisite course number for each course. For each relation, it updates the maximum prerequisite course number for the `nextCourse` with the `prevCourse`.\n\nNext, go through each course, and calculate the total time needed to finish that course by adding the course's time plus the time of its maximum prerequisite course. Track the maximum time across all courses as `totalTime`.\n\nFinally, return the maximum time `totalTime` as the minimum number of months needed to complete all courses.\n    ",
        "js": "\n    ```javascript\nfunction minMonths(n, relations, time) {\n    const order = new Array(n).fill(0);\n    for (const r of relations)\n        order[r[1] - 1] = Math.max(order[r[1] - 1], r[0]);\n    let totalTime = 0;\n    for (let i = 0; i < n; i++)\n        totalTime = Math.max(totalTime, time[i] + order[i]);\n    return totalTime;\n}\n```\n    \n    The algorithm starts by creating an array `order` to keep track of the maximum prerequisite course number for each course. For each relation, it updates the maximum prerequisite course number for the `nextCourse` with the `prevCourse`.\n\nNext, go through each course, and calculate the total time needed to finish that course by adding the course's time plus the time of its maximum prerequisite course. Track the maximum time across all courses as `totalTime`.\n\nFinally, return the maximum time `totalTime` as the minimum number of months needed to complete all courses.\n    "
    },
    {
        "id": 395,
        "title": "Count Integers With Even Digit Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer `num`, return _the number of positive integers **less than or equal to**_ `num` _whose digit sums are **even**_.\n\nThe **digit sum** of a positive integer is the sum of all its digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 4\n**Output:** 2\n**Explanation:**\nThe only integers less than or equal to 4 whose digit sums are even are 2 and 4.    \n\n",
                "**Example 2:**\n\n**Input:** num = 30\n**Output:** 14\n**Explanation:**\nThe 14 integers less than or equal to 30 whose digit sums are even are\n2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "30",
                "output": "14"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxTasks(int[] tasks, int[] workers, int pills, int strength) {\n    Arrays.sort(tasks);\n    Arrays.sort(workers);\n    int taskIndex = 0;\n    int pillIndex = pills;\n    int completedTasks = 0;\n\n    for (int workerStrength : workers) {\n        while (pillIndex > 0 && workerStrength + strength >= tasks[taskIndex]) {\n            workerStrength += strength;\n            --pillIndex;\n        }\n        \n        if (workerStrength >= tasks[taskIndex]) {\n            ++taskIndex;\n            ++completedTasks;\n        }\n\n        if (taskIndex >= tasks.length) {\n            break;\n        }\n    }\n\n    return completedTasks;\n}\n```\n\n    \n    1. First, we sort both the tasks and the workers arrays in increasing order.\n2. We initialize variables: taskIndex for iterating through the tasks array, pillIndex to keep track of the available pills, and completedTasks to count the number of tasks completed.\n3. Next, we iterate through the workers array, each time checking if the current worker's strength is sufficient to complete the current task by comparing it with the task's strength requirement.\n4. If the worker's strength is not sufficient and we still have pills available, we increment the worker's strength by \"strength\" (the strength added by one pill) and decrement the number of available pills.\n5. If the worker's strength is now sufficient to complete the task, we increment the task index and the completed tasks counter.\n6. We stop the loop if all tasks have been completed.\n7. Finally, we return the completedTasks counter.\n    ",
        "python": "\n    ```python\ndef max_tasks(tasks, workers, pills, strength):\n    tasks.sort()\n    workers.sort()\n    task_index = 0\n    pill_index = pills\n    completed_tasks = 0\n\n    for worker_strength in workers:\n        while pill_index > 0 and worker_strength + strength >= tasks[task_index]:\n            worker_strength += strength\n            pill_index -= 1\n        \n        if worker_strength >= tasks[task_index]:\n            task_index += 1\n            completed_tasks += 1\n\n        if task_index >= len(tasks):\n            break\n\n    return completed_tasks\n```\n\n    \n    1. First, we sort both the tasks and the workers arrays in increasing order.\n2. We initialize variables: taskIndex for iterating through the tasks array, pillIndex to keep track of the available pills, and completedTasks to count the number of tasks completed.\n3. Next, we iterate through the workers array, each time checking if the current worker's strength is sufficient to complete the current task by comparing it with the task's strength requirement.\n4. If the worker's strength is not sufficient and we still have pills available, we increment the worker's strength by \"strength\" (the strength added by one pill) and decrement the number of available pills.\n5. If the worker's strength is now sufficient to complete the task, we increment the task index and the completed tasks counter.\n6. We stop the loop if all tasks have been completed.\n7. Finally, we return the completedTasks counter.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxTasks(std::vector<int>& tasks, std::vector<int>& workers, int pills, int strength) {\n    std::sort(tasks.begin(), tasks.end());\n    std::sort(workers.begin(), workers.end());\n    int taskIndex = 0;\n    int pillIndex = pills;\n    int completedTasks = 0;\n\n    for (int workerStrength : workers) {\n        while (pillIndex > 0 && workerStrength + strength >= tasks[taskIndex]) {\n            workerStrength += strength;\n            --pillIndex;\n        }\n        \n        if (workerStrength >= tasks[taskIndex]) {\n            ++taskIndex;\n            ++completedTasks;\n        }\n\n        if (taskIndex >= tasks.size()) {\n            break;\n        }\n    }\n\n    return completedTasks;\n}\n```\n\n    \n    1. First, we sort both the tasks and the workers arrays in increasing order.\n2. We initialize variables: taskIndex for iterating through the tasks array, pillIndex to keep track of the available pills, and completedTasks to count the number of tasks completed.\n3. Next, we iterate through the workers array, each time checking if the current worker's strength is sufficient to complete the current task by comparing it with the task's strength requirement.\n4. If the worker's strength is not sufficient and we still have pills available, we increment the worker's strength by \"strength\" (the strength added by one pill) and decrement the number of available pills.\n5. If the worker's strength is now sufficient to complete the task, we increment the task index and the completed tasks counter.\n6. We stop the loop if all tasks have been completed.\n7. Finally, we return the completedTasks counter.\n    ",
        "js": "\n    ```javascript\nfunction maxTasks(tasks, workers, pills, strength) {\n    tasks.sort((a, b) => a - b);\n    workers.sort((a, b) => a - b);\n    let taskIndex = 0;\n    let pillIndex = pills;\n    let completedTasks = 0;\n\n    for (const workerStrength of workers) {\n        while (pillIndex > 0 && workerStrength + strength >= tasks[taskIndex]) {\n            workerStrength += strength;\n            --pillIndex;\n        }\n        \n        if (workerStrength >= tasks[taskIndex]) {\n            ++taskIndex;\n            ++completedTasks;\n        }\n\n        if (taskIndex >= tasks.length) {\n            break;\n        }\n    }\n\n    return completedTasks;\n}\n```\n\n    \n    1. First, we sort both the tasks and the workers arrays in increasing order.\n2. We initialize variables: taskIndex for iterating through the tasks array, pillIndex to keep track of the available pills, and completedTasks to count the number of tasks completed.\n3. Next, we iterate through the workers array, each time checking if the current worker's strength is sufficient to complete the current task by comparing it with the task's strength requirement.\n4. If the worker's strength is not sufficient and we still have pills available, we increment the worker's strength by \"strength\" (the strength added by one pill) and decrement the number of available pills.\n5. If the worker's strength is now sufficient to complete the task, we increment the task index and the completed tasks counter.\n6. We stop the loop if all tasks have been completed.\n7. Finally, we return the completedTasks counter.\n    "
    },
    {
        "id": 396,
        "title": "Counting Words With a Given Prefix",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of strings `words` and a string `pref`.\n\nReturn _the number of strings in_ `words` _that contain_ `pref` _as a **prefix**_.\n\nA **prefix** of a string `s` is any leading contiguous substring of `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"pay \", \"**at**tention \", \"practice \", \"**at**tend \"\\], `pref` \\=  \"at \"\n**Output:** 2\n**Explanation:** The 2 strings that contain  \"at \" as a prefix are:  \"**at**tention \" and  \"**at**tend \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"leetcode \", \"win \", \"loops \", \"success \"\\], `pref` \\=  \"code \"\n**Output:** 0\n**Explanation:** There are no strings that contain  \"code \" as a prefix."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length, pref.length <= 100`\n*   `words[i]` and `pref` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "[\"pay\",\"**at**tention\",\"practice\",\"**at**tend\"],\"at\"",
                "output": "2"
            },
            {
                "input": "[\"leetcode\",\"win\",\"loops\",\"success\"],\"code\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int count_prefixes(String[] words, String pref) {\n    int count = 0;\n    for(String word : words) {\n        if(word.startsWith(pref)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the list of words and checks if the word starts with the given prefix. If it does, increment the count. Finally, return the count.\n    ",
        "python": "\n    ```python\ndef count_prefixes(words, pref):\n    return sum(1 for word in words if word.startswith(pref))\n```\n    \n    The algorithm iterates through the list of words and checks if the word starts with the given prefix. If it does, increment the count. Finally, return the count.\n    ",
        "c++": "\n    ```cpp\nint count_prefixes(vector<string>& words, string pref) {\n    int count = 0;\n    for(const auto& word : words) {\n        if(word.find(pref) == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the list of words and checks if the word starts with the given prefix. If it does, increment the count. Finally, return the count.\n    ",
        "js": "\n    ```javascript\nfunction count_prefixes(words, pref) {\n    let count = 0;\n    for(const word of words) {\n        if(word.startsWith(pref)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the list of words and checks if the word starts with the given prefix. If it does, increment the count. Finally, return the count.\n    "
    },
    {
        "id": 397,
        "title": "Most Frequent Number Following Key In an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. You are also given an integer `key`, which is present in `nums`.\n\nFor every unique integer `target` in `nums`, **count** the number of times `target` immediately follows an occurrence of `key` in `nums`. In other words, count the number of indices `i` such that:\n\n*   `0 <= i <= nums.length - 2`,\n*   `nums[i] == key` and,\n*   `nums[i + 1] == target`.\n\nReturn _the_ `target` _with the **maximum** count_. The test cases will be generated such that the `target` with maximum count is unique.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,100,200,1,100\\], key = 1\n**Output:** 100\n**Explanation:** For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.\nNo other integers follow an occurrence of key, so we return 100.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,3\\], key = 2\n**Output:** 2\n**Explanation:** For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.\nFor target = 3, there is only one occurrence at index 4 which follows an occurrence of key.\ntarget = 2 has the maximum number of occurrences following an occurrence of key, so we return 2."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`\n*   The test cases will be generated such that the answer is unique.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,100,200,1,100],1",
                "output": "100"
            },
            {
                "input": "[2,2,2,2,3],2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int countOnceInBoth(String[] words1, String[] words2) {\n    Map<String, Integer> counter1 = new HashMap<>();\n    Map<String, Integer> counter2 = new HashMap<>();\n\n    for (String word : words1)\n        counter1.put(word, counter1.getOrDefault(word, 0) + 1);\n    for (String word : words2)\n        counter2.put(word, counter2.getOrDefault(word, 0) + 1);\n\n    int count = 0;\n    for (Map.Entry<String, Integer> item : counter1.entrySet())\n        if (item.getValue() == 1 && counter2.getOrDefault(item.getKey(), 0) == 1)\n            count++;\n\n    return count;\n}\n```\n    \n    1. Create two hashmaps (counter1 and counter2) to store the frequency of each word in words1 and words2, respectively.\n2. Iterate over the two arrays and increase the word count within their respective hashmap.\n3. Initialize a count variable to 0.\n4. Iterate over the entries in counter1, checking both its value and the value in counter2 for that key (word) against 1. If both are equal to 1, increment the count.\n5. Return the final count.\n    ",
        "python": "\n    ```python\ndef count_once_in_both(words1, words2):\n    counter1 = {}\n    counter2 = {}\n\n    for word in words1:\n        counter1[word] = counter1.get(word, 0) + 1\n    for word in words2:\n        counter2[word] = counter2.get(word, 0) + 1\n\n    count = 0\n    for item in counter1.items():\n        if item[1] == 1 and counter2.get(item[0], 0) == 1:\n            count += 1\n\n    return count\n```\n    \n    1. Create two hashmaps (counter1 and counter2) to store the frequency of each word in words1 and words2, respectively.\n2. Iterate over the two arrays and increase the word count within their respective hashmap.\n3. Initialize a count variable to 0.\n4. Iterate over the entries in counter1, checking both its value and the value in counter2 for that key (word) against 1. If both are equal to 1, increment the count.\n5. Return the final count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nint countOnceInBoth(const std::vector<std::string>& words1, const std::vector<std::string>& words2) {\n    std::unordered_map<std::string, int> counter1, counter2;\n\n    for (const auto& word : words1)\n        counter1[word]++;\n    for (const auto& word : words2)\n        counter2[word]++;\n\n    int count = 0;\n    for (const auto& item : counter1)\n        if (item.second == 1 && counter2[item.first] == 1)\n            count++;\n\n    return count;\n}\n```\n    \n    1. Create two hashmaps (counter1 and counter2) to store the frequency of each word in words1 and words2, respectively.\n2. Iterate over the two arrays and increase the word count within their respective hashmap.\n3. Initialize a count variable to 0.\n4. Iterate over the entries in counter1, checking both its value and the value in counter2 for that key (word) against 1. If both are equal to 1, increment the count.\n5. Return the final count.\n    ",
        "js": "\n    ```javascript\nfunction countOnceInBoth(words1, words2) {\n    const counter1 = {};\n    const counter2 = {};\n\n    for (const word of words1)\n        counter1[word] = (counter1[word] || 0) + 1;\n    for (const word of words2)\n        counter2[word] = (counter2[word] || 0) + 1;\n\n    let count = 0;\n    for (const item in counter1)\n        if (counter1[item] === 1 && counter2[item] === 1)\n            count++;\n\n    return count;\n}\n```\n    \n    1. Create two hashmaps (counter1 and counter2) to store the frequency of each word in words1 and words2, respectively.\n2. Iterate over the two arrays and increase the word count within their respective hashmap.\n3. Initialize a count variable to 0.\n4. Iterate over the entries in counter1, checking both its value and the value in counter2 for that key (word) against 1. If both are equal to 1, increment the count.\n5. Return the final count.\n    "
    },
    {
        "id": 398,
        "title": "Cells in a Range on an Excel Sheet",
        "difficulty": "Easy",
        "content": {
            "problem": "A cell `(r, c)` of an excel sheet is represented as a string `\" \"` where:\n\n*   denotes the column number `c` of the cell. It is represented by **alphabetical letters**.\n    *   For example, the `1st` column is denoted by `'A'`, the `2nd` by `'B'`, the `3rd` by `'C'`, and so on.\n*   is the row number `r` of the cell. The `rth` row is represented by the **integer** `r`.\n\nYou are given a string `s` in the format `\": \"`, where represents the column `c1`, represents the row `r1`, represents the column `c2`, and represents the row `r2`, such that `r1 <= r2` and `c1 <= c2`.\n\nReturn _the **list of cells**_ `(x, y)` _such that_ `r1 <= x <= r2` _and_ `c1 <= y <= c2`. The cells should be represented as **strings** in the format mentioned above and be sorted in **non-decreasing** order first by columns and then by rows.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"K1:L2 \"\n**Output:** \\[ \"K1 \", \"K2 \", \"L1 \", \"L2 \"\\]\n**Explanation:**\nThe above diagram shows the cells which should be present in the list.\nThe red arrows denote the order in which the cells should be presented.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"A1:F1 \"\n**Output:** \\[ \"A1 \", \"B1 \", \"C1 \", \"D1 \", \"E1 \", \"F1 \"\\]\n**Explanation:**\nThe above diagram shows the cells which should be present in the list.\nThe red arrow denotes the order in which the cells should be presented."
            ],
            "constraints": "**Constraints:**\n\n*   `s.length == 5`\n*   `'A' <= s[0] <= s[3] <= 'Z'`\n*   `'1' <= s[1] <= s[4] <= '9'`\n*   `s` consists of uppercase English letters, digits and `':'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"K1:L2\"",
                "output": "[\"K1\",\"K2\",\"L1\",\"L2\"]"
            },
            {
                "input": "\"A1:F1\"",
                "output": "[\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> cellRange(String s) {\n    int r1 = s.charAt(1) - '0';\n    int r2 = s.charAt(4) - '0';\n    int c1 = s.charAt(0) - 'A' + 1;\n    int c2 = s.charAt(3) - 'A' + 1;\n\n    List<String> res = new ArrayList<>();\n    for (int c = c1; c <= c2; ++c) {\n        for (int r = r1; r <= r2; ++r) {\n            res.add((char)('A' + c - 1) + Integer.toString(r));\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm is relatively straightforward: First, extract each cell's row and column from the input string `s` using indexed access on the input string, which works identically in all languages. The row values are parsed from a character to the integer it represents. The column values need to be zero-indexed and then shifted by 1, so subtract the ASCII value of 'A' (or 'A'.charCodeAt(0) in JavaScript) and then add 1.\n\nNext, create a nested loop to iterate over all columns (`c`) and rows (`r`). In the inner loop, push the column and row as a formatted string to the results array, reusing the method from the column extraction to create the column character for output.\n\nFinally, return the array of sorted cell strings.\n    ",
        "python": "\n    ```python\ndef cell_range(s):\n    r1 = int(s[1])\n    r2 = int(s[4])\n    c1 = ord(s[0]) - ord('A') + 1\n    c2 = ord(s[3]) - ord('A') + 1\n\n    res = []\n    for c in range(c1, c2 + 1):\n        for r in range(r1, r2 + 1):\n            res.append(chr(ord('A') + c - 1) + str(r))\n    return res\n```\n    \n    The algorithm is relatively straightforward: First, extract each cell's row and column from the input string `s` using indexed access on the input string, which works identically in all languages. The row values are parsed from a character to the integer it represents. The column values need to be zero-indexed and then shifted by 1, so subtract the ASCII value of 'A' (or 'A'.charCodeAt(0) in JavaScript) and then add 1.\n\nNext, create a nested loop to iterate over all columns (`c`) and rows (`r`). In the inner loop, push the column and row as a formatted string to the results array, reusing the method from the column extraction to create the column character for output.\n\nFinally, return the array of sorted cell strings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> cellRange(const std::string& s) {\n    int r1 = s[1] - '0';\n    int r2 = s[4] - '0';\n    int c1 = s[0] - 'A' + 1;\n    int c2 = s[3] - 'A' + 1;\n\n    std::vector<std::string> res;\n    for (int c = c1; c <= c2; ++c) {\n        for (int r = r1; r <= r2; ++r) {\n            res.push_back(std::string(1, 'A' + c - 1) + std::to_string(r));\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm is relatively straightforward: First, extract each cell's row and column from the input string `s` using indexed access on the input string, which works identically in all languages. The row values are parsed from a character to the integer it represents. The column values need to be zero-indexed and then shifted by 1, so subtract the ASCII value of 'A' (or 'A'.charCodeAt(0) in JavaScript) and then add 1.\n\nNext, create a nested loop to iterate over all columns (`c`) and rows (`r`). In the inner loop, push the column and row as a formatted string to the results array, reusing the method from the column extraction to create the column character for output.\n\nFinally, return the array of sorted cell strings.\n    ",
        "js": "\n    ```javascript\nfunction cellRange(s) {\n    const r1 = parseInt(s[1]);\n    const r2 = parseInt(s[4]);\n    const c1 = s.charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n    const c2 = s.charCodeAt(3) - 'A'.charCodeAt(0) + 1;\n\n    const res = [];\n    for (let c = c1; c <= c2; ++c) {\n        for (let r = r1; r <= r2; ++r) {\n            res.push(String.fromCharCode('A'.charCodeAt(0) + c - 1) + r.toString());\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm is relatively straightforward: First, extract each cell's row and column from the input string `s` using indexed access on the input string, which works identically in all languages. The row values are parsed from a character to the integer it represents. The column values need to be zero-indexed and then shifted by 1, so subtract the ASCII value of 'A' (or 'A'.charCodeAt(0) in JavaScript) and then add 1.\n\nNext, create a nested loop to iterate over all columns (`c`) and rows (`r`). In the inner loop, push the column and row as a formatted string to the results array, reusing the method from the column extraction to create the column character for output.\n\nFinally, return the array of sorted cell strings.\n    "
    },
    {
        "id": 399,
        "title": "Find All K-Distant Indices in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` and two integers `key` and `k`. A **k-distant index** is an index `i` of `nums` for which there exists at least one index `j` such that `|i - j| <= k` and `nums[j] == key`.\n\nReturn _a list of all k-distant indices sorted in **increasing order**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,4,9,1,3,9,5\\], key = 9, k = 1\n**Output:** \\[1,2,3,4,5,6\\]\n**Explanation:** Here, `nums[2] == key` and `nums[5] == key. - For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j` where `|0 - j| <= k` and `nums[j] == key. Thus, 0 is not a k-distant index. - For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index. - For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index. - For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index. - For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index. - For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index. - For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.`\nThus, we return \\[1,2,3,4,5,6\\] which is sorted in increasing order. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\], key = 2, k = 2\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:** For all indices i in nums, there exists some index j such that |i - j| <= k and nums\\[j\\] == key, so every index is a k-distant index. \nHence, we return \\[0,1,2,3,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`\n*   `key` is an integer from the array `nums`.\n*   `1 <= k <= nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[3,4,9,1,3,9,5],9,1",
                "output": "[1,2,3,4,5,6]"
            },
            {
                "input": "[2,2,2,2,2],2,2",
                "output": "[0,1,2,3,4]"
            }
        ],
        "java": "\n    ```java\npublic boolean canFitStamps(int[][] grid, int stampHeight, int stampWidth) {\n    int m = grid.length, n = grid[0].length;\n    for (int i = 0; i + stampHeight - 1 < m; ++i) {\n        for (int j = 0; j + stampWidth - 1 < n; ++j) {\n            boolean canFit = true;\n            for (int x = 0; x < stampHeight && canFit; ++x) {\n                for (int y = 0; y < stampWidth && canFit; ++y) {\n                    if (grid[i + x][j + y] == 1) {\n                        canFit = false;\n                    }\n                }\n            }\n            if (canFit) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm loops through the cells of the grid, and for each cell, it checks if a stamp can fit the area starting from that cell. If the stamp fits without any occupied cells (value of 1) in the area, the function returns true. If the loop finishes without finding any fitting area, the function returns false.\n    ",
        "python": "\n    ```python\ndef can_fit_stamps(grid, stampHeight, stampWidth):\n    m, n = len(grid), len(grid[0])\n    for i in range(m - stampHeight + 1):\n        for j in range(n - stampWidth + 1):\n            canFit = True\n            for x in range(stampHeight):\n                for y in range(stampWidth):\n                    if grid[i + x][j + y] == 1:\n                        canFit = False\n                        break\n                if not canFit:\n                    break\n            if canFit:\n                return True\n    return False\n```\n    \n    The algorithm loops through the cells of the grid, and for each cell, it checks if a stamp can fit the area starting from that cell. If the stamp fits without any occupied cells (value of 1) in the area, the function returns true. If the loop finishes without finding any fitting area, the function returns false.\n    ",
        "c++": "\n    ```cpp\nbool canFitStamps(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n    int m = grid.size(), n = grid[0].size();\n    for (int i = 0; i + stampHeight - 1 < m; ++i) {\n        for (int j = 0; j + stampWidth - 1 < n; ++j) {\n            bool canFit = true;\n            for (int x = 0; x < stampHeight && canFit; ++x) {\n                for (int y = 0; y < stampWidth && canFit; ++y) {\n                    if (grid[i + x][j + y] == 1) {\n                        canFit = false;\n                    }\n                }\n            }\n            if (canFit) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm loops through the cells of the grid, and for each cell, it checks if a stamp can fit the area starting from that cell. If the stamp fits without any occupied cells (value of 1) in the area, the function returns true. If the loop finishes without finding any fitting area, the function returns false.\n    ",
        "js": "\n    ```javascript\nfunction canFitStamps(grid, stampHeight, stampWidth) {\n    let m = grid.length, n = grid[0].length;\n    for (let i = 0; i + stampHeight - 1 < m; ++i) {\n        for (let j = 0; j + stampWidth - 1 < n; ++j) {\n            let canFit = true;\n            for (let x = 0; x < stampHeight && canFit; ++x) {\n                for (let y = 0; y < stampWidth && canFit; ++y) {\n                    if (grid[i + x][j + y] === 1) {\n                        canFit = false;\n                    }\n                }\n            }\n            if (canFit) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm loops through the cells of the grid, and for each cell, it checks if a stamp can fit the area starting from that cell. If the stamp fits without any occupied cells (value of 1) in the area, the function returns true. If the loop finishes without finding any fitting area, the function returns false.\n    "
    },
    {
        "id": 400,
        "title": "Divide Array Into Equal Pairs",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` consisting of `2 * n` integers.\n\nYou need to divide `nums` into `n` pairs such that:\n\n*   Each element belongs to **exactly one** pair.\n*   The elements present in a pair are **equal**.\n\nReturn `true` _if nums can be divided into_ `n` _pairs, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,3,2,2,2\\]\n**Output:** true\n**Explanation:** \nThere are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\nIf nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** \nThere is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition."
            ],
            "constraints": "**Constraints:**\n\n*   `nums.length == 2 * n`\n*   `1 <= n <= 500`\n*   `1 <= nums[i] <= 500`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Counting"
        ],
        "example": [
            {
                "input": "[3,2,3,2,2,2]",
                "output": "true"
            },
            {
                "input": "[1,2,3,4]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int maxBombsDetonated(List<List<Integer>> bombs) {\n    int n = bombs.size();\n    int maxBombs = 0;\n\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = 0; j < n; j++) {\n            int dx = bombs.get(i).get(0) - bombs.get(j).get(0);\n            int dy = bombs.get(i).get(1) - bombs.get(j).get(1);\n            int distance = dx * dx + dy * dy;\n            int range = bombs.get(i).get(2) * bombs.get(i).get(2) + bombs.get(j).get(2) * bombs.get(j).get(2);\n            if (distance <= range) {\n                count++;\n            }\n        }\n        maxBombs = Math.max(maxBombs, count);\n    }\n\n    return maxBombs;\n}\n```\n\n    \n    To solve this problem, we want to find the maximum number of bombs that can be detonated by detonating a single bomb. The algorithm:\n1. Determine the number of bombs `n` and initialize a variable `max_bombs` to store the maximum number of bombs that can be detonated.\n2. Iterate through each bomb `i` in the given list of bombs.\n3. For each bomb, initialize a counter `count` to store the number of bombs it can detonate in its range.\n4. Iterate through all other bombs `j`.\n    - Calculate the distance between the bombs `i` and `j` (using squared Euclidean distance to avoid floating point calculations).\n    - Calculate the sum of the squares of the radii of bombs `i` and `j`.\n    - If the distance between the bombs is less than or equal to the sum of the squares of their radii, it means bomb `i` can detonate bomb `j`. Increment the counter `count`.\n5. Update the maximum number of bombs that can be detonated by checking if `count` is greater than the current value of `max_bombs`.\n6. Repeat steps 3-5 for all bombs `i`.\n7. Return the value of `max_bombs`. This represents the maximum number of bombs that can be detonated by detonating a single bomb in the given list of bombs.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef max_bombs_detonated(bombs: List[List[int]]) -> int:\n    n = len(bombs)\n    max_bombs = 0\n\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            dx = bombs[i][0] - bombs[j][0]\n            dy = bombs[i][1] - bombs[j][1]\n            distance = dx * dx + dy * dy\n            range_ = bombs[i][2] * bombs[i][2] + bombs[j][2] * bombs[j][2]\n            if distance <= range_:\n                count += 1\n        max_bombs = max(max_bombs, count)\n\n    return max_bombs\n```\n\n    \n    To solve this problem, we want to find the maximum number of bombs that can be detonated by detonating a single bomb. The algorithm:\n1. Determine the number of bombs `n` and initialize a variable `max_bombs` to store the maximum number of bombs that can be detonated.\n2. Iterate through each bomb `i` in the given list of bombs.\n3. For each bomb, initialize a counter `count` to store the number of bombs it can detonate in its range.\n4. Iterate through all other bombs `j`.\n    - Calculate the distance between the bombs `i` and `j` (using squared Euclidean distance to avoid floating point calculations).\n    - Calculate the sum of the squares of the radii of bombs `i` and `j`.\n    - If the distance between the bombs is less than or equal to the sum of the squares of their radii, it means bomb `i` can detonate bomb `j`. Increment the counter `count`.\n5. Update the maximum number of bombs that can be detonated by checking if `count` is greater than the current value of `max_bombs`.\n6. Repeat steps 3-5 for all bombs `i`.\n7. Return the value of `max_bombs`. This represents the maximum number of bombs that can be detonated by detonating a single bomb in the given list of bombs.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nint maxBombsDetonated(std::vector<std::vector<int>>& bombs) {\n    int n = bombs.size();\n    int max_bombs = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int count = 0;\n        for (int j = 0; j < n; ++j) {\n            int dx = bombs[i][0] - bombs[j][0];\n            int dy = bombs[i][1] - bombs[j][1];\n            int distance = dx * dx + dy * dy;\n            int range = bombs[i][2] * bombs[i][2] + bombs[j][2] * bombs[j][2];\n            if (distance <= range) {\n                count++;\n            }\n        }\n        max_bombs = std::max(max_bombs, count);\n    }\n\n    return max_bombs;\n}\n```\n\n    \n    To solve this problem, we want to find the maximum number of bombs that can be detonated by detonating a single bomb. The algorithm:\n1. Determine the number of bombs `n` and initialize a variable `max_bombs` to store the maximum number of bombs that can be detonated.\n2. Iterate through each bomb `i` in the given list of bombs.\n3. For each bomb, initialize a counter `count` to store the number of bombs it can detonate in its range.\n4. Iterate through all other bombs `j`.\n    - Calculate the distance between the bombs `i` and `j` (using squared Euclidean distance to avoid floating point calculations).\n    - Calculate the sum of the squares of the radii of bombs `i` and `j`.\n    - If the distance between the bombs is less than or equal to the sum of the squares of their radii, it means bomb `i` can detonate bomb `j`. Increment the counter `count`.\n5. Update the maximum number of bombs that can be detonated by checking if `count` is greater than the current value of `max_bombs`.\n6. Repeat steps 3-5 for all bombs `i`.\n7. Return the value of `max_bombs`. This represents the maximum number of bombs that can be detonated by detonating a single bomb in the given list of bombs.\n    ",
        "js": "\n    ```javascript\nfunction maxBombsDetonated(bombs) {\n    let n = bombs.length;\n    let maxBombs = 0;\n\n    for (let i = 0; i < n; i++) {\n        let count = 0;\n        for (let j = 0; j < n; j++) {\n            let dx = bombs[i][0] - bombs[j][0];\n            let dy = bombs[i][1] - bombs[j][1];\n            let distance = dx * dx + dy * dy;\n            let range = bombs[i][2] * bombs[i][2] + bombs[j][2] * bombs[j][2];\n            if (distance <= range) {\n                count++;\n            }\n        }\n        maxBombs = Math.max(maxBombs, count);\n    }\n\n    return maxBombs;\n}\n```\n\n    \n    To solve this problem, we want to find the maximum number of bombs that can be detonated by detonating a single bomb. The algorithm:\n1. Determine the number of bombs `n` and initialize a variable `max_bombs` to store the maximum number of bombs that can be detonated.\n2. Iterate through each bomb `i` in the given list of bombs.\n3. For each bomb, initialize a counter `count` to store the number of bombs it can detonate in its range.\n4. Iterate through all other bombs `j`.\n    - Calculate the distance between the bombs `i` and `j` (using squared Euclidean distance to avoid floating point calculations).\n    - Calculate the sum of the squares of the radii of bombs `i` and `j`.\n    - If the distance between the bombs is less than or equal to the sum of the squares of their radii, it means bomb `i` can detonate bomb `j`. Increment the counter `count`.\n5. Update the maximum number of bombs that can be detonated by checking if `count` is greater than the current value of `max_bombs`.\n6. Repeat steps 3-5 for all bombs `i`.\n7. Return the value of `max_bombs`. This represents the maximum number of bombs that can be detonated by detonating a single bomb in the given list of bombs.\n    "
    },
    {
        "id": 401,
        "title": "Count Hills and Valleys in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. An index `i` is part of a **hill** in `nums` if the closest non-equal neighbors of `i` are smaller than `nums[i]`. Similarly, an index `i` is part of a **valley** in `nums` if the closest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices `i` and `j` are part of the **same** hill or valley if `nums[i] == nums[j]`.\n\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on **both** the left and right of the index.\n\nReturn _the number of hills and valleys in_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,1,1,6,5\\]\n**Output:** 3\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,6,5,5,4,1\\]\n**Output:** 0\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[2,4,1,1,6,5]",
                "output": "3"
            },
            {
                "input": "[6,6,5,5,4,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic List<Integer> sortedTargetIndices(int[] nums, int target) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == target) {\n            result.add(i);\n        }\n    }\n    Collections.sort(result);\n    return result;\n}\n```\n    \n    We iterate over the input array `nums` and check if the element at the current index is equal to the `target`. If it is, we add the current index to the `result` list. After iterating through the whole array, we sort the `result` list to ensure that the indices are in increasing order. Finally, we return the `result` list, which contains the target indices of the given element in the sorted array. If there are no target indices, the `result` list will be empty, and an empty list will be returned as specified.\n    ",
        "python": "\n    ```python\ndef sorted_target_indices(nums, target):\n    result = [i for i, num in enumerate(nums) if num == target]\n    return sorted(result)\n```\n    \n    We iterate over the input array `nums` and check if the element at the current index is equal to the `target`. If it is, we add the current index to the `result` list. After iterating through the whole array, we sort the `result` list to ensure that the indices are in increasing order. Finally, we return the `result` list, which contains the target indices of the given element in the sorted array. If there are no target indices, the `result` list will be empty, and an empty list will be returned as specified.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sortedTargetIndices(std::vector<int>& nums, int target) {\n    std::vector<int> result;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == target) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```\n    \n    We iterate over the input array `nums` and check if the element at the current index is equal to the `target`. If it is, we add the current index to the `result` list. After iterating through the whole array, we sort the `result` list to ensure that the indices are in increasing order. Finally, we return the `result` list, which contains the target indices of the given element in the sorted array. If there are no target indices, the `result` list will be empty, and an empty list will be returned as specified.\n    ",
        "js": "\n    ```javascript\nfunction sortedTargetIndices(nums, target) {\n    const result = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) {\n            result.push(i);\n        }\n    }\n    return result.sort((a, b) => a - b);\n}\n```\n    \n    We iterate over the input array `nums` and check if the element at the current index is equal to the `target`. If it is, we add the current index to the `result` list. After iterating through the whole array, we sort the `result` list to ensure that the indices are in increasing order. Finally, we return the `result` list, which contains the target indices of the given element in the sorted array. If there are no target indices, the `result` list will be empty, and an empty list will be returned as specified.\n    "
    },
    {
        "id": 402,
        "title": "Find the Difference of Two Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two **0-indexed** integer arrays `nums1` and `nums2`, return _a list_ `answer` _of size_ `2` _where:_\n\n*   `answer[0]` _is a list of all **distinct** integers in_ `nums1` _which are **not** present in_ `nums2`_._\n*   `answer[1]` _is a list of all **distinct** integers in_ `nums2` _which are **not** present in_ `nums1`.\n\n**Note** that the integers in the lists may be returned in **any** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3\\], nums2 = \\[2,4,6\\]\n**Output:** \\[\\[1,3\\],\\[4,6\\]\\]\n**Explanation:**\nFor nums1, nums1\\[1\\] = 2 is present at index 0 of nums2, whereas nums1\\[0\\] = 1 and nums1\\[2\\] = 3 are not present in nums2. Therefore, answer\\[0\\] = \\[1,3\\].\nFor nums2, nums2\\[0\\] = 2 is present at index 1 of nums1, whereas nums2\\[1\\] = 4 and nums2\\[2\\] = 6 are not present in nums2. Therefore, answer\\[1\\] = \\[4,6\\].\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,2,3,3\\], nums2 = \\[1,1,2,2\\]\n**Output:** \\[\\[3\\],\\[\\]\\]\n**Explanation:**\nFor nums1, nums1\\[2\\] and nums1\\[3\\] are not present in nums2. Since nums1\\[2\\] == nums1\\[3\\], their value is only included once and answer\\[0\\] = \\[3\\].\nEvery integer in nums2 is present in nums1. Therefore, answer\\[1\\] = \\[\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `-1000 <= nums1[i], nums2[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2,3],[2,4,6]",
                "output": "[[1,3],[4,6]]"
            },
            {
                "input": "[1,2,3,3],[1,1,2,2]",
                "output": "[[3],[]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n    void helper(int[] digits, ArrayList<Integer> current, Set<Integer> result, boolean[] used) {\n        if (current.size() == digits.length) {\n            int num = 0;\n            for (int d : current) {\n                num = num * 10 + d;\n            }\n            result.add(num);\n            return;\n        }\n        for (int i = 0; i < digits.length; ++i) {\n            if (!used[i]) {\n                used[i] = true;\n                current.add(digits[i]);\n                helper(digits, current, result, used);\n                current.remove(current.size() - 1);\n                used[i] = false;\n            }\n        }\n    }\n\n    public List<Integer> uniquePermutations(int[] digits) {\n        ArrayList<Integer> current = new ArrayList<>();\n        Set<Integer> result = new HashSet<>();\n        boolean[] used = new boolean[digits.length];\n        java.util.Arrays.sort(digits);\n\n        helper(digits, current, result, used);\n\n        return result.stream().sorted().collect(Collectors.toList());\n    }\n}\n```\n    \n    1. For each language, the function accepts the input array `digits`.\n2. We sort the input array in non-decreasing order.\n3. We use a helper function to perform recursion and create permutations. The helper function takes parameters for the digits, the current permutation being formed, the set of unique permutations, and a tracking array called `used` to keep track of digits that have been used in the current permutation.\n4. In the helper function, if the length of the current permutation matches the length of the input array, we have a complete permutation, so we convert the current permutation into an integer and insert it into the result set.\n5. If the current permutation is not complete, we iterate through the input array, and for each digit that is not already used in the current permutation, we mark it as used, add it to the current permutation, and call the helper function recursively.\n6. After a recursive call, we remove the last added digit from the current permutation and mark that digit as unused.\n7. Once the helper function is done, we convert the result set into a sorted array and return it.\n    ",
        "python": "\n    ```python\nfrom itertools import permutations\n\ndef unique_permutations(digits):\n    unique_perms = set(permutations(digits))\n    unique_ints = sorted({int(''.join(map(str, perm))) for perm in unique_perms})\n    \n    return unique_ints\n```\n    \n    1. For each language, the function accepts the input array `digits`.\n2. We sort the input array in non-decreasing order.\n3. We use a helper function to perform recursion and create permutations. The helper function takes parameters for the digits, the current permutation being formed, the set of unique permutations, and a tracking array called `used` to keep track of digits that have been used in the current permutation.\n4. In the helper function, if the length of the current permutation matches the length of the input array, we have a complete permutation, so we convert the current permutation into an integer and insert it into the result set.\n5. If the current permutation is not complete, we iterate through the input array, and for each digit that is not already used in the current permutation, we mark it as used, add it to the current permutation, and call the helper function recursively.\n6. After a recursive call, we remove the last added digit from the current permutation and mark that digit as unused.\n7. Once the helper function is done, we convert the result set into a sorted array and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nvoid helper(vector<int>& digits, vector<int>& current, set<int>& result, vector<bool>& used) {\n    if (current.size() == digits.size()) {\n        int num = 0;\n        for (int d : current) {\n            num = num * 10 + d;\n        }\n        result.insert(num);\n        return;\n    }\n    for (int i = 0; i < digits.size(); ++i) {\n        if (!used[i]) {\n            used[i] = true;\n            current.push_back(digits[i]);\n            helper(digits, current, result, used);\n            current.pop_back();\n            used[i] = false;\n        }\n    }\n}\n\nvector<int> uniquePermutations(vector<int>& digits) {\n    vector<int> current;\n    set<int> result;\n    vector<bool> used(digits.size(), false);\n    sort(digits.begin(), digits.end());\n\n    helper(digits, current, result, used);\n\n    return vector<int>(result.begin(), result.end());\n}\n```\n    \n    1. For each language, the function accepts the input array `digits`.\n2. We sort the input array in non-decreasing order.\n3. We use a helper function to perform recursion and create permutations. The helper function takes parameters for the digits, the current permutation being formed, the set of unique permutations, and a tracking array called `used` to keep track of digits that have been used in the current permutation.\n4. In the helper function, if the length of the current permutation matches the length of the input array, we have a complete permutation, so we convert the current permutation into an integer and insert it into the result set.\n5. If the current permutation is not complete, we iterate through the input array, and for each digit that is not already used in the current permutation, we mark it as used, add it to the current permutation, and call the helper function recursively.\n6. After a recursive call, we remove the last added digit from the current permutation and mark that digit as unused.\n7. Once the helper function is done, we convert the result set into a sorted array and return it.\n    ",
        "js": "\n    ```javascript\nfunction helper(digits, current, result, used) {\n    if (current.length === digits.length) {\n        let num = parseInt(current.join(''), 10);\n        result.add(num);\n        return;\n    }\n    for (let i = 0; i < digits.length; ++i) {\n        if (!used[i]) {\n            used[i] = true;\n            current.push(digits[i]);\n            helper(digits, current, result, used);\n            current.pop();\n            used[i] = false;\n        }\n    }\n}\n\nfunction uniquePermutations(digits) {\n    let current = [];\n    let result = new Set();\n    let used = new Array(digits.length).fill(false);\n    digits.sort((a, b) => a - b);\n\n    helper(digits, current, result, used);\n\n    return Array.from(result).sort((a, b) => a - b);\n}\n```\n    \n    1. For each language, the function accepts the input array `digits`.\n2. We sort the input array in non-decreasing order.\n3. We use a helper function to perform recursion and create permutations. The helper function takes parameters for the digits, the current permutation being formed, the set of unique permutations, and a tracking array called `used` to keep track of digits that have been used in the current permutation.\n4. In the helper function, if the length of the current permutation matches the length of the input array, we have a complete permutation, so we convert the current permutation into an integer and insert it into the result set.\n5. If the current permutation is not complete, we iterate through the input array, and for each digit that is not already used in the current permutation, we mark it as used, add it to the current permutation, and call the helper function recursively.\n6. After a recursive call, we remove the last added digit from the current permutation and mark that digit as unused.\n7. Once the helper function is done, we convert the result set into a sorted array and return it.\n    "
    },
    {
        "id": 403,
        "title": "Minimum Number of Operations to Convert Time",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `current` and `correct` representing two **24-hour times**.\n\n24-hour times are formatted as `\"HH:MM \"`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.\n\nIn one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation **any** number of times.\n\nReturn _the **minimum number of operations** needed to convert_ `current` _to_ `correct`.",
            "examples": [
                "**Example 1:**\n\n**Input:** current =  \"02:30 \", correct =  \"04:35 \"\n**Output:** 3\n**Explanation:**\nWe can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes  \"03:30 \".\n- Add 60 minutes to current. current becomes  \"04:30 \".\n- Add 5 minutes to current. current becomes  \"04:35 \".\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations.\n\n",
                "**Example 2:**\n\n**Input:** current =  \"11:00 \", correct =  \"11:01 \"\n**Output:** 1\n**Explanation:** We only have to add one minute to current, so the minimum number of operations needed is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `current` and `correct` are in the format `\"HH:MM \"`\n*   `current <= correct`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"02:30\",\"04:35\"",
                "output": "3"
            },
            {
                "input": "\"11:00\",\"11:01\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nint minimumOperations(String current, String correct) {\n    int ch = Integer.parseInt(current.substring(0, 2)), cm = Integer.parseInt(current.substring(3));\n    int th = Integer.parseInt(correct.substring(0,2)), tm = Integer.parseInt(correct.substring(3));\n    int ct = ch * 60 + cm, tt = th * 60 + tm;\n\n    int operations = 0;\n    while (ct < tt) {\n        if (tt - ct >= 60)\n            ct += 60;\n        else if (tt - ct >= 15)\n            ct += 15;\n        else if (tt - ct >= 5)\n            ct += 5;\n        else\n            ct += 1;\n\n        operations++;\n    }\n    return operations;\n}\n```\n\n    \n    The approach to solving this problem is fairly straightforward. First, we parse the input strings 'current' and 'correct' into hours and minutes. We then calculate the total minutes for both 'current' (ct) and 'correct' (tt).\n\nWe initialize a variable `operations` tokeep track of the minimum number of operations needed.\n\nUsing a while loop, we check if ct is smaller than tt indicating that we still need to perform operations. In each iteration, we choose the largest operation possible (60, 15, 5, or 1 minute(s)) based on the difference between tt and ct. After performing the operation, we increment the operations counter.\n\nThe final result is the value of the `operations` counter at the end of the loop.\n    ",
        "python": "\n    ```python\ndef minimum_operations(current: str, correct: str) -> int:\n    ch, cm = map(int, current.split(':'))\n    th, tm = map(int, correct.split(':'))\n    ct = ch * 60 + cm\n    tt = th * 60 + tm\n\n    operations = 0\n    while ct < tt:\n        if tt - ct >= 60:\n            ct += 60\n        elif tt - ct >= 15:\n            ct += 15\n        elif tt - ct >= 5:\n            ct += 5\n        else:\n            ct += 1\n\n        operations += 1\n\n    return operations\n```\n\n    \n    The approach to solving this problem is fairly straightforward. First, we parse the input strings 'current' and 'correct' into hours and minutes. We then calculate the total minutes for both 'current' (ct) and 'correct' (tt).\n\nWe initialize a variable `operations` tokeep track of the minimum number of operations needed.\n\nUsing a while loop, we check if ct is smaller than tt indicating that we still need to perform operations. In each iteration, we choose the largest operation possible (60, 15, 5, or 1 minute(s)) based on the difference between tt and ct. After performing the operation, we increment the operations counter.\n\nThe final result is the value of the `operations` counter at the end of the loop.\n    ",
        "c++": "\n    ```cpp\nint minimumOperations(string current, string correct) {\n    int ch = stoi(current.substr(0, 2)), cm = stoi(current.substr(3));\n    int th = stoi(correct.substr(0, 2)), tm = stoi(correct.substr(3));\n    int ct = ch * 60 + cm, tt = th * 60 + tm;\n\n    int operations = 0;\n    while (ct < tt) {\n        if (tt - ct >= 60)\n            ct += 60;\n        else if (tt - ct >= 15)\n            ct += 15;\n        else if (tt - ct >= 5)\n            ct += 5;\n        else\n            ct += 1;\n\n        operations++;\n    }\n    return operations;\n}\n```\n\n    \n    The approach to solving this problem is fairly straightforward. First, we parse the input strings 'current' and 'correct' into hours and minutes. We then calculate the total minutes for both 'current' (ct) and 'correct' (tt).\n\nWe initialize a variable `operations` tokeep track of the minimum number of operations needed.\n\nUsing a while loop, we check if ct is smaller than tt indicating that we still need to perform operations. In each iteration, we choose the largest operation possible (60, 15, 5, or 1 minute(s)) based on the difference between tt and ct. After performing the operation, we increment the operations counter.\n\nThe final result is the value of the `operations` counter at the end of the loop.\n    ",
        "js": "\n    ```javascript\nfunction minimumOperations(current, correct) {\n    let [ch, cm] = current.split(':').map(Number);\n    let [th, tm] = correct.split(':').map(Number);\n    let ct = ch * 60 + cm, tt = th * 60 + tm;\n\n    let operations = 0;\n    while (ct < tt) {\n        if (tt - ct >= 60)\n            ct += 60;\n        else if (tt - ct >= 15)\n            ct += 15;\n        else if (tt - ct >= 5)\n            ct += 5;\n        else\n            ct += 1;\n\n        operations++;\n    }\n    return operations;\n}\n```\n\n    \n    The approach to solving this problem is fairly straightforward. First, we parse the input strings 'current' and 'correct' into hours and minutes. We then calculate the total minutes for both 'current' (ct) and 'correct' (tt).\n\nWe initialize a variable `operations` tokeep track of the minimum number of operations needed.\n\nUsing a while loop, we check if ct is smaller than tt indicating that we still need to perform operations. In each iteration, we choose the largest operation possible (60, 15, 5, or 1 minute(s)) based on the difference between tt and ct. After performing the operation, we increment the operations counter.\n\nThe final result is the value of the `operations` counter at the end of the loop.\n    "
    },
    {
        "id": 404,
        "title": "Largest Number After Digit Swaps by Parity",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer `num`. You may swap any two digits of `num` that have the same **parity** (i.e. both odd digits or both even digits).\n\nReturn _the **largest** possible value of_ `num` _after **any** number of swaps._",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 1234\n**Output:** 3412\n**Explanation:** Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.\n\n",
                "**Example 2:**\n\n**Input:** num = 65875\n**Output:** 87655\n**Explanation:** Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 109`",
            "follow_up": null
        },
        "tag": [
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "1234",
                "output": "3412"
            },
            {
                "input": "65875",
                "output": "87655"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic String firstPalindrome(List<String> words) {\n    for (String word : words) {\n        String reversedWord = new StringBuilder(word).reverse().toString();\n        if (word.equals(reversedWord)) {\n            return word;\n        }\n    }\n    return \"\";\n}\n```\n\n    \n    The algorithm used in each function iterates through the given array of strings, and for each string, it checks if it's a palindrome by comparing it to its reversed version. If a palindrome is found, it immediately returns that string. If no palindromes are found after iterating through the entire array, an empty string is returned. Each language's implementation follows similar logic, with some differences:\n\n- C++: We use a range-based loop to iterate through the words, and the `std::reverse()` function to reverse the string.\n- Java: We use a `StringBuilder` to reverse the string, and the `equals()` method to compare the strings.\n- Python: A Pythonic approach is used with slicing to reverse the string.\n- JavaScript: We use the `split()`, `reverse()`, and `join()` methods to reverse the string.\n    ",
        "python": "\n    ```python\ndef first_palindrome(words):\n    for word in words:\n        if word == word[::-1]:\n            return word\n    return \"\"\n```\n\n    \n    The algorithm used in each function iterates through the given array of strings, and for each string, it checks if it's a palindrome by comparing it to its reversed version. If a palindrome is found, it immediately returns that string. If no palindromes are found after iterating through the entire array, an empty string is returned. Each language's implementation follows similar logic, with some differences:\n\n- C++: We use a range-based loop to iterate through the words, and the `std::reverse()` function to reverse the string.\n- Java: We use a `StringBuilder` to reverse the string, and the `equals()` method to compare the strings.\n- Python: A Pythonic approach is used with slicing to reverse the string.\n- JavaScript: We use the `split()`, `reverse()`, and `join()` methods to reverse the string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string firstPalindrome(const std::vector<std::string>& words) {\n    for (const std::string& word : words) {\n        std::string reversedWord = word;\n        std::reverse(reversedWord.begin(), reversedWord.end());\n        if (word == reversedWord) {\n            return word;\n        }\n    }\n    return \"\";\n}\n```\n\n    \n    The algorithm used in each function iterates through the given array of strings, and for each string, it checks if it's a palindrome by comparing it to its reversed version. If a palindrome is found, it immediately returns that string. If no palindromes are found after iterating through the entire array, an empty string is returned. Each language's implementation follows similar logic, with some differences:\n\n- C++: We use a range-based loop to iterate through the words, and the `std::reverse()` function to reverse the string.\n- Java: We use a `StringBuilder` to reverse the string, and the `equals()` method to compare the strings.\n- Python: A Pythonic approach is used with slicing to reverse the string.\n- JavaScript: We use the `split()`, `reverse()`, and `join()` methods to reverse the string.\n    ",
        "js": "\n    ```javascript\nfunction firstPalindrome(words) {\n    for (const word of words) {\n        const reversedWord = word.split('').reverse().join('');\n        if (word === reversedWord) {\n            return word;\n        }\n    }\n    return \"\";\n}\n```\n\n    \n    The algorithm used in each function iterates through the given array of strings, and for each string, it checks if it's a palindrome by comparing it to its reversed version. If a palindrome is found, it immediately returns that string. If no palindromes are found after iterating through the entire array, an empty string is returned. Each language's implementation follows similar logic, with some differences:\n\n- C++: We use a range-based loop to iterate through the words, and the `std::reverse()` function to reverse the string.\n- Java: We use a `StringBuilder` to reverse the string, and the `equals()` method to compare the strings.\n- Python: A Pythonic approach is used with slicing to reverse the string.\n- JavaScript: We use the `split()`, `reverse()`, and `join()` methods to reverse the string.\n    "
    },
    {
        "id": 405,
        "title": "Add Two Integers",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integers `num1` and `num2`, return _the **sum** of the two integers_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 = 12, num2 = 5\n**Output:** 17\n**Explanation:** num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n\n",
                "**Example 2:**\n\n**Input:** num1 = -10, num2 = 4\n**Output:** -6\n**Explanation:** num1 + num2 = -6, so -6 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `-100 <= num1, num2 <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "12,5",
                "output": "17"
            },
            {
                "input": "-10,4",
                "output": "-6"
            }
        ],
        "java": "\n    ```java\npublic String capitalizeTitle(String title) {\n    StringBuilder result = new StringBuilder();\n    boolean newWord = true;\n    \n    for (int i = 0; i < title.length(); ++i) {\n        char character = title.charAt(i);\n        if (newWord && Character.isLetter(character)) {\n            result.append(Character.toUpperCase(character));\n            newWord = false;\n        } else if (character == ' ') {\n            result.append(character);\n            newWord = true;\n        } else {\n            result.append(Character.toLowerCase(character));\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    The algorithm loops through each character of the string `title`. If it encounters a new word edge (either beginning of the title or previous character was a space), the current character is capitalized. In all other cases, the character is converted to lower case. In Python, we use the built-in `.capitalize()` method to capitalize each word in the title. We split the string into words, apply the capitalize method on each word, and join the words by spaces.\n    ",
        "python": "\n    ```python\ndef capitalize_title(title):\n    return ' '.join([word.capitalize() for word in title.split(' ')])\n```\n\n    \n    The algorithm loops through each character of the string `title`. If it encounters a new word edge (either beginning of the title or previous character was a space), the current character is capitalized. In all other cases, the character is converted to lower case. In Python, we use the built-in `.capitalize()` method to capitalize each word in the title. We split the string into words, apply the capitalize method on each word, and join the words by spaces.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring capitalizeTitle(string title) {\n    bool newWord = true;\n    for (int i = 0; i < title.length(); ++i) {\n        if (newWord && isalpha(title[i])) {\n            title[i] = toupper(title[i]);\n            newWord = false;\n        } else if (title[i] == ' ') {\n            newWord = true;\n        } else {\n            title[i] = tolower(title[i]);\n        }\n    }\n    return title;\n}\n```\n\n    \n    The algorithm loops through each character of the string `title`. If it encounters a new word edge (either beginning of the title or previous character was a space), the current character is capitalized. In all other cases, the character is converted to lower case. In Python, we use the built-in `.capitalize()` method to capitalize each word in the title. We split the string into words, apply the capitalize method on each word, and join the words by spaces.\n    ",
        "js": "\n    ```javascript\nfunction capitalizeTitle(title) {\n    const words = title.split(' ');\n\n    for (let i = 0; i < words.length; i++) {\n        words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1).toLowerCase();\n    }\n\n    return words.join(' ');\n}\n```\n\n    \n    The algorithm loops through each character of the string `title`. If it encounters a new word edge (either beginning of the title or previous character was a space), the current character is capitalized. In all other cases, the character is converted to lower case. In Python, we use the built-in `.capitalize()` method to capitalize each word in the title. We split the string into words, apply the capitalize method on each word, and join the words by spaces.\n    "
    },
    {
        "id": 406,
        "title": "Root Equals Sum of Children",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the `root` of a **binary tree** that consists of exactly `3` nodes: the root, its left child, and its right child.\n\nReturn `true` _if the value of the root is equal to the **sum** of the values of its two children, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[10,4,6\\]\n**Output:** true\n**Explanation:** The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,3,1\\]\n**Output:** false\n**Explanation:** The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false."
            ],
            "constraints": "**Constraints:**\n\n*   The tree consists only of the root, its left child, and its right child.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[10,4,6]",
                "output": "true"
            },
            {
                "input": "[5,3,1]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int maxTwinSum(ListNode head) {\n    int sum = 0, max_sum = 0, i = 0;\n    ListNode slow = head, fast = head;\n\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        i++;\n    }\n\n    for (int j = 0; j < i; j++) {\n        sum = slow.val + fast.val;\n        max_sum = Math.max(max_sum, sum);\n        slow = slow.next;\n        fast = fast.prev;\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses two pointers (slow and fast) to simultaneously traverse the linked list. The slow pointer moves forward one step at a time, while the fast pointer moves two steps at a time. This allows the fast_pointer to reach the end of the list when the slow_pointer is exactly halfway through the list.\n\nAfter reaching the middle, the function iterates through the first half of the list, calculating the twin sum of each node with its twin (which is being referenced by the fast pointer) and storing the maximum value. To do this, it advances the slow pointer one step at a time, while the fast pointer moves one step back. At each step, it calculates the sum of the values at the current positions of the slow and fast pointers, updating the maximum twin sum if a higher sum is found.\n\nFinally, after traversing half of the linked list, the function returns the maximum twin sum. \n    ",
        "python": "\n    ```python\ndef max_twin_sum(head):\n    sum = 0\n    max_sum = 0\n    i = 0\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        i += 1\n\n    for j in range(i):\n        sum = slow.val + fast.val\n        max_sum = max(max_sum, sum)\n        slow = slow.next\n        fast = fast.prev\n\n    return max_sum\n```\n    \n    The algorithm uses two pointers (slow and fast) to simultaneously traverse the linked list. The slow pointer moves forward one step at a time, while the fast pointer moves two steps at a time. This allows the fast_pointer to reach the end of the list when the slow_pointer is exactly halfway through the list.\n\nAfter reaching the middle, the function iterates through the first half of the list, calculating the twin sum of each node with its twin (which is being referenced by the fast pointer) and storing the maximum value. To do this, it advances the slow pointer one step at a time, while the fast pointer moves one step back. At each step, it calculates the sum of the values at the current positions of the slow and fast pointers, updating the maximum twin sum if a higher sum is found.\n\nFinally, after traversing half of the linked list, the function returns the maximum twin sum. \n    ",
        "c++": "\n    ```cpp\nint maxTwinSum(ListNode* head) {\n    int sum = 0, max_sum = 0, i = 0;\n    ListNode* slow = head, *fast = head;\n    \n    while (fast && fast->next) {\n        fast = fast->next->next;\n        i++;\n    }\n\n    for (int j = 0; j < i; j++) {\n        sum = slow->val + fast->val;\n        max_sum = max(max_sum, sum);\n        slow = slow->next;\n        fast = fast->prev;\n    }\n    \n    return max_sum;\n}\n```\n    \n    The algorithm uses two pointers (slow and fast) to simultaneously traverse the linked list. The slow pointer moves forward one step at a time, while the fast pointer moves two steps at a time. This allows the fast_pointer to reach the end of the list when the slow_pointer is exactly halfway through the list.\n\nAfter reaching the middle, the function iterates through the first half of the list, calculating the twin sum of each node with its twin (which is being referenced by the fast pointer) and storing the maximum value. To do this, it advances the slow pointer one step at a time, while the fast pointer moves one step back. At each step, it calculates the sum of the values at the current positions of the slow and fast pointers, updating the maximum twin sum if a higher sum is found.\n\nFinally, after traversing half of the linked list, the function returns the maximum twin sum. \n    ",
        "js": "\n    ```javascript\nfunction maxTwinSum(head) {\n    let sum = 0, max_sum = 0, i = 0;\n    let slow = head, fast = head;\n    \n    while (fast && fast.next) {\n        fast = fast.next.next;\n        i++;\n    }\n\n    for (let j = 0; j < i; j++) {\n        sum = slow.val + fast.val;\n        max_sum = Math.max(max_sum, sum);\n        slow = slow.next;\n        fast = fast.prev;\n    }\n    \n    return max_sum;\n}\n```\n    \n    The algorithm uses two pointers (slow and fast) to simultaneously traverse the linked list. The slow pointer moves forward one step at a time, while the fast pointer moves two steps at a time. This allows the fast_pointer to reach the end of the list when the slow_pointer is exactly halfway through the list.\n\nAfter reaching the middle, the function iterates through the first half of the list, calculating the twin sum of each node with its twin (which is being referenced by the fast pointer) and storing the maximum value. To do this, it advances the slow pointer one step at a time, while the fast pointer moves one step back. At each step, it calculates the sum of the values at the current positions of the slow and fast pointers, updating the maximum twin sum if a higher sum is found.\n\nFinally, after traversing half of the linked list, the function returns the maximum twin sum. \n    "
    },
    {
        "id": 407,
        "title": "Find Closest Number to Zero",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` of size `n`, return _the number with the value **closest** to_ `0` _in_ `nums`. If there are multiple answers, return _the number with the **largest** value_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-4,-2,1,4,8\\]\n**Output:** 1\n**Explanation:**\nThe distance from -4 to 0 is |-4| = 4.\nThe distance from -2 to 0 is |-2| = 2.\nThe distance from 1 to 0 is |1| = 1.\nThe distance from 4 to 0 is |4| = 4.\nThe distance from 8 to 0 is |8| = 8.\nThus, the closest number to 0 in the array is 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,-1,1\\]\n**Output:** 1\n**Explanation:** 1 and -1 are both the closest numbers to 0, so 1 being larger is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[-4,-2,1,4,8]",
                "output": "1"
            },
            {
                "input": "[2,-1,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] robotInstructions(int n, int[] startPos, String s) {\n    int[] answer = new int[s.length()];\n\n    for (int idx = 0; idx < s.length(); ++idx) {\n        int row = startPos[0];\n        int col = startPos[1];\n\n        for (int i = idx; i < s.length(); ++i) {\n            char move = s.charAt(i);\n            if (move == 'L') --col;\n            else if (move == 'R') ++col;\n            else if (move == 'U') --row;\n            else if (move == 'D') ++row;\n\n            if (row < 0 || row >= n || col < 0 || col >= n) {\n                break;\n            }\n\n            answer[idx]++;\n        }\n    }\n\n    return answer;\n}\n```\n\n    \n    This algorithm implements a nested loop. The outer loop iterates through each starting instruction index. In the inner loop, we execute the instructions while updating the position of the robot in terms of row and column. If a move will take the robot outside the grid, we break from the inner loop. If the robot hasn't exited the grid, we increase the number of instructions it has executed, which is stored in the answer array indexed by the starting instruction index.\n\nThe time complexity is O(m^2), where m is the length of the instructions string s. The space complexity is O(m), as we need to store the answer for each starting instruction index in an array.\n    ",
        "python": "\n    ```python\ndef robot_instructions(n: int, start_pos: list, s: str) -> list:\n    answer = [0] * len(s)\n\n    for idx in range(len(s)):\n        row, col = start_pos\n\n        for i in range(idx, len(s)):\n            move = s[i]\n            if move == 'L':\n                col -= 1\n            elif move == 'R':\n                col += 1\n            elif move == 'U':\n                row -= 1\n            elif move == 'D':\n                row += 1\n\n            if row < 0 or row >= n or col < 0 or col >= n:\n                break\n\n            answer[idx] += 1\n\n    return answer\n```\n\n    \n    This algorithm implements a nested loop. The outer loop iterates through each starting instruction index. In the inner loop, we execute the instructions while updating the position of the robot in terms of row and column. If a move will take the robot outside the grid, we break from the inner loop. If the robot hasn't exited the grid, we increase the number of instructions it has executed, which is stored in the answer array indexed by the starting instruction index.\n\nThe time complexity is O(m^2), where m is the length of the instructions string s. The space complexity is O(m), as we need to store the answer for each starting instruction index in an array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> robotInstructions(int n, std::vector<int>& startPos, const std::string& s) {\n    std::vector<int> answer(s.length(), 0);\n\n    for (int idx = 0; idx < s.length(); ++idx) {\n        int row = startPos[0];\n        int col = startPos[1];\n\n        for (int i = idx; i < s.length(); ++i) {\n            if (s[i] == 'L') --col;\n            else if (s[i] == 'R') ++col;\n            else if (s[i] == 'U') --row;\n            else if (s[i] == 'D') ++row;\n\n            if (row < 0 || row >= n || col < 0 || col >= n) {\n                break;\n            }\n\n            answer[idx]++;\n        }\n    }\n\n    return answer;\n}\n```\n\n    \n    This algorithm implements a nested loop. The outer loop iterates through each starting instruction index. In the inner loop, we execute the instructions while updating the position of the robot in terms of row and column. If a move will take the robot outside the grid, we break from the inner loop. If the robot hasn't exited the grid, we increase the number of instructions it has executed, which is stored in the answer array indexed by the starting instruction index.\n\nThe time complexity is O(m^2), where m is the length of the instructions string s. The space complexity is O(m), as we need to store the answer for each starting instruction index in an array.\n    ",
        "js": "\n    ```javascript\nfunction robotInstructions(n, startPos, s) {\n    let answer = new Array(s.length).fill(0);\n\n    for (let idx = 0; idx < s.length; ++idx) {\n        let row = startPos[0];\n        let col = startPos[1];\n\n        for (let i = idx; i < s.length; ++i) {\n            let move = s[i];\n            if (move === 'L') --col;\n            else if (move === 'R') ++col;\n            else if (move === 'U') --row;\n            else if (move === 'D') ++row;\n\n            if (row < 0 || row >= n || col < 0 || col >= n) {\n                break;\n            }\n\n            answer[idx]++;\n        }\n    }\n\n    return answer;\n}\n```\n\n    \n    This algorithm implements a nested loop. The outer loop iterates through each starting instruction index. In the inner loop, we execute the instructions while updating the position of the robot in terms of row and column. If a move will take the robot outside the grid, we break from the inner loop. If the robot hasn't exited the grid, we increase the number of instructions it has executed, which is stored in the answer array indexed by the starting instruction index.\n\nThe time complexity is O(m^2), where m is the length of the instructions string s. The space complexity is O(m), as we need to store the answer for each starting instruction index in an array.\n    "
    },
    {
        "id": 408,
        "title": "Calculate Digit Sum of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` consisting of digits and an integer `k`.\n\nA **round** can be completed if the length of `s` is greater than `k`. In one round, do the following:\n\n1.  **Divide** `s` into **consecutive groups** of size `k` such that the first `k` characters are in the first group, the next `k` characters are in the second group, and so on. **Note** that the size of the last group can be smaller than `k`.\n2.  **Replace** each group of `s` with a string representing the sum of all its digits. For example, `\"346 \"` is replaced with `\"13 \"` because `3 + 4 + 6 = 13`.\n3.  **Merge** consecutive groups together to form a new string. If the length of the string is greater than `k`, repeat from step `1`.\n\nReturn `s` _after all rounds have been completed_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"11111222223 \", k = 3\n**Output:**  \"135 \"\n**Explanation:** \n- For the first round, we divide s into groups of size 3:  \"111 \",  \"112 \",  \"222 \", and  \"23 \".\n  Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. \n  So, s becomes  \"3 \" +  \"4 \" +  \"6 \" +  \"5 \" =  \"3465 \" after the first round.\n- For the second round, we divide s into  \"346 \" and  \"5 \".\n  Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. \n  So, s becomes  \"13 \" +  \"5 \" =  \"135 \" after second round. \nNow, s.length <= k, so we return  \"135 \" as the answer.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"00000000 \", k = 3\n**Output:**  \"000 \"\n**Explanation:** \nWe divide s into  \"000 \",  \"000 \", and  \"00 \".\nThen we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. \ns becomes  \"0 \" +  \"0 \" +  \"0 \" =  \"000 \", whose length is equal to k, so we return  \"000 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `2 <= k <= 100`\n*   `s` consists of digits only.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"11111222223\",3",
                "output": "\"135\""
            },
            {
                "input": "\"00000000\",3",
                "output": "\"000\""
            }
        ],
        "java": "\n    ```java\nboolean isAOnlyBeforeB(String s) {\n    int lastIndexA = -1;\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == 'a') {\n            lastIndexA = i;\n        } else if (s.charAt(i) == 'b' && lastIndexA > -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through each character in the given string `s`. It maintains a variable called `lastIndexA` that keeps track of the last index where the character 'a' is found. If it encounters 'a', it updates `lastIndexA` with the current index. If it encounters 'b' and `lastIndexA` is not set to `-1` (meaning there was an 'a' before it), the algorithm returns `false`. If the loop completes without returning `false`, it means that every 'a' appears before every 'b', so the algorithm returns `true`.\n    ",
        "python": "\n    ```python\ndef is_a_only_before_b(s: str) -> bool:\n    last_index_a = -1\n    for i, c in enumerate(s):\n        if c == 'a':\n            last_index_a = i\n        elif c == 'b' and last_index_a > -1:\n            return False\n    return True\n```\n    \n    The algorithm iterates through each character in the given string `s`. It maintains a variable called `lastIndexA` that keeps track of the last index where the character 'a' is found. If it encounters 'a', it updates `lastIndexA` with the current index. If it encounters 'b' and `lastIndexA` is not set to `-1` (meaning there was an 'a' before it), the algorithm returns `false`. If the loop completes without returning `false`, it means that every 'a' appears before every 'b', so the algorithm returns `true`.\n    ",
        "c++": "\n    ```cpp\nbool isAOnlyBeforeB(const std::string& s) {\n    int lastIndexA = -1;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (s[i] == 'a') {\n            lastIndexA = i;\n        } else if (s[i] == 'b' && lastIndexA > -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through each character in the given string `s`. It maintains a variable called `lastIndexA` that keeps track of the last index where the character 'a' is found. If it encounters 'a', it updates `lastIndexA` with the current index. If it encounters 'b' and `lastIndexA` is not set to `-1` (meaning there was an 'a' before it), the algorithm returns `false`. If the loop completes without returning `false`, it means that every 'a' appears before every 'b', so the algorithm returns `true`.\n    ",
        "js": "\n    ```javascript\nfunction isAOnlyBeforeB(s) {\n    let lastIndexA = -1;\n    for (let i = 0; i < s.length; i++) {\n        if (s.charAt(i) === 'a') {\n            lastIndexA = i;\n        } else if (s.charAt(i) === 'b' && lastIndexA > -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through each character in the given string `s`. It maintains a variable called `lastIndexA` that keeps track of the last index where the character 'a' is found. If it encounters 'a', it updates `lastIndexA` with the current index. If it encounters 'b' and `lastIndexA` is not set to `-1` (meaning there was an 'a' before it), the algorithm returns `false`. If the loop completes without returning `false`, it means that every 'a' appears before every 'b', so the algorithm returns `true`.\n    "
    },
    {
        "id": 409,
        "title": "Intersection of Multiple Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a 2D integer array `nums` where `nums[i]` is a non-empty array of **distinct** positive integers, return _the list of integers that are present in **each array** of_ `nums` _sorted in **ascending order**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[\\[**3**,1,2,**4**,5\\],\\[1,2,**3**,**4**\\],\\[**3**,**4**,5,6\\]\\]\n**Output:** \\[3,4\\]\n**Explanation:** \nThe only integers present in each of nums\\[0\\] = \\[**3**,1,2,**4**,5\\], nums\\[1\\] = \\[1,2,**3**,**4**\\], and nums\\[2\\] = \\[**3**,**4**,5,6\\] are 3 and 4, so we return \\[3,4\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** \\[\\]\n**Explanation:** \nThere does not exist any integer present both in nums\\[0\\] and nums\\[1\\], so we return an empty list \\[\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= sum(nums[i].length) <= 1000`\n*   `1 <= nums[i][j] <= 1000`\n*   All the values of `nums[i]` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[[**3**,1,2,**4**,5],[1,2,**3**,**4**],[**3**,**4**,5,6]]",
                "output": "[3,4]"
            },
            {
                "input": "[[1,2,3],[4,5,6]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minCost(int[] cost) {\n    Arrays.sort(cost);\n    int n = cost.length;\n    int min_cost = 0;\n\n    for(int i = n - 1; i >= 0; i -= 3) {\n        min_cost += cost[i];\n        if(i - 1 >= 0) min_cost += cost[i - 1];\n    }\n\n    return min_cost;\n}\n```\n    \n    The algorithm sorts all the candies in the array in descending order of cost, so that the most expensive candies are bought first. Then, it loops over the array, taking two candies at a time (the loop increments 3 positions each iteration) and adding their cost to the total `min_cost`. The choice of the third free candy will always be one of the two already chosen, so its cost is already included in `min_cost`. After iterating through the entire array, the function returns the minimum cost. \n    ",
        "python": "\n    ```python\ndef min_cost(cost):\n    cost.sort(reverse=True)\n    n = len(cost)\n    min_cost = 0\n\n    for i in range(0, n, 3):\n        min_cost += cost[i]\n        if i+1 < n:\n            min_cost += cost[i+1]\n\n    return min_cost\n```\n    \n    The algorithm sorts all the candies in the array in descending order of cost, so that the most expensive candies are bought first. Then, it loops over the array, taking two candies at a time (the loop increments 3 positions each iteration) and adding their cost to the total `min_cost`. The choice of the third free candy will always be one of the two already chosen, so its cost is already included in `min_cost`. After iterating through the entire array, the function returns the minimum cost. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minCost(std::vector<int>& cost) {\n    std::sort(cost.begin(), cost.end(), std::greater<>());\n    int n = cost.size();\n    \n    int min_cost = 0;\n\n    for(int i = 0; i < n; i += 3) {\n        min_cost += cost[i];\n        if(i+1 < n) min_cost += cost[i+1];\n    }\n\n    return min_cost;\n}\n```\n    \n    The algorithm sorts all the candies in the array in descending order of cost, so that the most expensive candies are bought first. Then, it loops over the array, taking two candies at a time (the loop increments 3 positions each iteration) and adding their cost to the total `min_cost`. The choice of the third free candy will always be one of the two already chosen, so its cost is already included in `min_cost`. After iterating through the entire array, the function returns the minimum cost. \n    ",
        "js": "\n    ```javascript\nfunction minCost(cost) {\n    cost.sort((a, b) => b - a);\n    const n = cost.length;\n    let min_cost = 0;\n\n    for(let i = 0; i < n; i += 3) {\n        min_cost += cost[i];\n        if(i+1 < n) min_cost += cost[i+1];\n    }\n\n    return min_cost;\n}\n```\n    \n    The algorithm sorts all the candies in the array in descending order of cost, so that the most expensive candies are bought first. Then, it loops over the array, taking two candies at a time (the loop increments 3 positions each iteration) and adding their cost to the total `min_cost`. The choice of the third free candy will always be one of the two already chosen, so its cost is already included in `min_cost`. After iterating through the entire array, the function returns the minimum cost. \n    "
    },
    {
        "id": 410,
        "title": "Count Prefixes of a Given String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string array `words` and a string `s`, where `words[i]` and `s` comprise only of **lowercase English letters**.\n\nReturn _the **number of strings** in_ `words` _that are a **prefix** of_ `s`.\n\nA **prefix** of a string is a substring that occurs at the beginning of the string. A **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"a \", \"b \", \"c \", \"ab \", \"bc \", \"abc \"\\], s =  \"abc \"\n**Output:** 3\n**Explanation:**\nThe strings in words which are a prefix of s =  \"abc \" are:\n \"a \",  \"ab \", and  \"abc \".\nThus the number of strings in words which are a prefix of s is 3.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"a \"\\], s =  \"aa \"\n**Output:** 2\n**Explanation:**\nBoth of the strings are a prefix of s. \nNote that the same string can occur multiple times in words, and it should be counted each time."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length, s.length <= 10`\n*   `words[i]` and `s` consist of lowercase English letters **only**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"],\"abc\"",
                "output": "3"
            },
            {
                "input": "[\"a\",\"a\"],\"aa\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minSwaps(int[] nums) {\n    int ones = 0, maxOnes = 0, currOnes = 0, left = 0;\n\n    for (int num : nums) {\n        ones += num;\n    }\n\n    for (int right = 0; right < nums.length; ++right) {\n        currOnes += nums[right];\n\n        if (right - left + 1 > ones) {\n            currOnes -= nums[left];\n            ++left;\n        }\n\n        maxOnes = Math.max(maxOnes, currOnes);\n    }\n\n    return ones - maxOnes;\n}\n```\n    \n    1. Count the total number of 1's in the array and store this value in the `ones` variable.\n2. Initialize variables `maxOnes`, `currOnes`, and `left` to 0. These will be used to keep track of the maximum number of 1's in a range and our current window.\n3. Loop through the array using the `right` variable.\n4. Add the value in `nums[right]` to `currOnes`.\n5. Check if the window size (between `right` and `left`) is greater than the total number of 1's.\n6. If it is, remove the value at `nums[left]` from `currOnes`, then increment `left` to reduce our window size.\n7. Update the `maxOnes` variable to store the maximum value between itself and `currOnes`.\n8. After looping through the entire array, subtract `maxOnes` from the total `ones`. The result is the minimum number of swaps needed.\n    ",
        "python": "\n    ```python\ndef minSwaps(nums):\n    ones = maxOnes = currOnes = left = 0\n\n    for num in nums:\n        ones += num\n\n    for right in range(len(nums)):\n        currOnes += nums[right]\n\n        if right - left + 1 > ones:\n            currOnes -= nums[left]\n            left += 1\n\n        maxOnes = max(maxOnes, currOnes)\n\n    return ones - maxOnes\n```\n    \n    1. Count the total number of 1's in the array and store this value in the `ones` variable.\n2. Initialize variables `maxOnes`, `currOnes`, and `left` to 0. These will be used to keep track of the maximum number of 1's in a range and our current window.\n3. Loop through the array using the `right` variable.\n4. Add the value in `nums[right]` to `currOnes`.\n5. Check if the window size (between `right` and `left`) is greater than the total number of 1's.\n6. If it is, remove the value at `nums[left]` from `currOnes`, then increment `left` to reduce our window size.\n7. Update the `maxOnes` variable to store the maximum value between itself and `currOnes`.\n8. After looping through the entire array, subtract `maxOnes` from the total `ones`. The result is the minimum number of swaps needed.\n    ",
        "c++": "\n    ```cpp\nint minSwaps(vector<int>& nums) {\n    int ones = 0, maxOnes = 0, currOnes = 0, left = 0;\n\n    for (int num : nums) {\n        ones += num;\n    }\n\n    for (int right = 0; right < nums.size(); ++right) {\n        currOnes += nums[right];\n\n        if (right - left + 1 > ones) {\n            currOnes -= nums[left];\n            ++left;\n        }\n\n        maxOnes = max(maxOnes, currOnes);\n    }\n\n    return ones - maxOnes;\n}\n```\n    \n    1. Count the total number of 1's in the array and store this value in the `ones` variable.\n2. Initialize variables `maxOnes`, `currOnes`, and `left` to 0. These will be used to keep track of the maximum number of 1's in a range and our current window.\n3. Loop through the array using the `right` variable.\n4. Add the value in `nums[right]` to `currOnes`.\n5. Check if the window size (between `right` and `left`) is greater than the total number of 1's.\n6. If it is, remove the value at `nums[left]` from `currOnes`, then increment `left` to reduce our window size.\n7. Update the `maxOnes` variable to store the maximum value between itself and `currOnes`.\n8. After looping through the entire array, subtract `maxOnes` from the total `ones`. The result is the minimum number of swaps needed.\n    ",
        "js": "\n    ```javascript\nfunction minSwaps(nums) {\n    let ones = 0, maxOnes = 0, currOnes = 0, left = 0;\n\n    for (let num of nums) {\n        ones += num;\n    }\n\n    for (let right = 0; right < nums.length; ++right) {\n        currOnes += nums[right];\n\n        if (right - left + 1 > ones) {\n            currOnes -= nums[left];\n            ++left;\n        }\n\n        maxOnes = Math.max(maxOnes, currOnes);\n    }\n\n    return ones - maxOnes;\n}\n```\n    \n    1. Count the total number of 1's in the array and store this value in the `ones` variable.\n2. Initialize variables `maxOnes`, `currOnes`, and `left` to 0. These will be used to keep track of the maximum number of 1's in a range and our current window.\n3. Loop through the array using the `right` variable.\n4. Add the value in `nums[right]` to `currOnes`.\n5. Check if the window size (between `right` and `left`) is greater than the total number of 1's.\n6. If it is, remove the value at `nums[left]` from `currOnes`, then increment `left` to reduce our window size.\n7. Update the `maxOnes` variable to store the maximum value between itself and `currOnes`.\n8. After looping through the entire array, subtract `maxOnes` from the total `ones`. The result is the minimum number of swaps needed.\n    "
    },
    {
        "id": 411,
        "title": "Remove Digit From Number to Maximize Result",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `number` representing a **positive integer** and a character `digit`.\n\nReturn _the resulting string after removing **exactly one occurrence** of_ `digit` _from_ `number` _such that the value of the resulting string in **decimal** form is **maximized**_. The test cases are generated such that `digit` occurs at least once in `number`.",
            "examples": [
                "**Example 1:**\n\n**Input:** number =  \"123 \", digit =  \"3 \"\n**Output:**  \"12 \"\n**Explanation:** There is only one '3' in  \"123 \". After removing '3', the result is  \"12 \".\n\n",
                "**Example 2:**\n\n**Input:** number =  \"1231 \", digit =  \"1 \"\n**Output:**  \"231 \"\n**Explanation:** We can remove the first '1' to get  \"231 \" or remove the second '1' to get  \"123 \".\nSince 231 > 123, we return  \"231 \".\n\n",
                "**Example 3:**\n\n**Input:** number =  \"551 \", digit =  \"5 \"\n**Output:**  \"51 \"\n**Explanation:** We can remove either the first or second '5' from  \"551 \".\nBoth result in the string  \"51 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= number.length <= 100`\n*   `number` consists of digits from `'1'` to `'9'`.\n*   `digit` is a digit from `'1'` to `'9'`.\n*   `digit` occurs at least once in `number`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Enumeration"
        ],
        "example": [
            {
                "input": "\"123\",\"3\"",
                "output": "\"12\""
            },
            {
                "input": "\"1231\",\"1\"",
                "output": "\"231\""
            },
            {
                "input": "\"551\",\"5\"",
                "output": "\"51\""
            }
        ],
        "java": "\n    ```java\npublic String maxNumberAfterRemoveDigit(String number, char digit) {\n    int index = number.indexOf(digit);\n    return number.substring(0, index) + number.substring(index + 1);\n}\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    ",
        "python": "\n    ```python\ndef max_number_after_remove_digit(number: str, digit: str) -> str:\n    index = number.find(digit)\n    return number[:index] + number[index + 1:]\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    ",
        "c++": "\n    ```cpp\nstd::string maxNumberAfterRemoveDigit(const std::string& number, const char digit) {\n    size_t index = number.find(digit);\n    std::string result = number;\n    result.erase(index, 1);\n    return result;\n}\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberAfterRemoveDigit(number, digit) {\n    const index = number.indexOf(digit);\n    return number.slice(0, index) + number.slice(index + 1);\n}\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    "
    },
    {
        "id": 412,
        "title": "Largest 3-Same-Digit Number in String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `num` representing a large integer. An integer is **good** if it meets the following conditions:\n\n*   It is a **substring** of `num` with length `3`.\n*   It consists of only one unique digit.\n\nReturn _the **maximum good** integer as a **string** or an empty string_ `\" \"` _if no such integer exists_.\n\nNote:\n\n*   A **substring** is a contiguous sequence of characters within a string.\n*   There may be **leading zeroes** in `num` or a good integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"6**777**133339 \"\n**Output:**  \"777 \"\n**Explanation:** There are two distinct good integers:  \"777 \" and  \"333 \".\n \"777 \" is the largest, so we return  \"777 \".\n\n",
                "**Example 2:**\n\n**Input:** num =  \"23**000**19 \"\n**Output:**  \"000 \"\n**Explanation:**  \"000 \" is the only good integer.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"42352338 \"\n**Output:**  \" \"\n**Explanation:** No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= num.length <= 1000`\n*   `num` only consists of digits.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"6**777**133339\"",
                "output": "\"777\""
            },
            {
                "input": "\"23**000**19\"",
                "output": "\"000\""
            },
            {
                "input": "\"42352338\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nint splitAndMinimize(int num) {\n    int a = num / 1000;\n    int b = (num % 1000) / 100;\n    int c = (num % 100) / 10;\n    int d = num % 10;\n    return ((a * 10 + c) * 10 + b) * 10 + d;\n}\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    ",
        "python": "\n    ```python\ndef split_and_minimize(num):\n    a = num // 1000\n    b = (num % 1000) // 100\n    c = (num % 100) // 10\n    d = num % 10\n    return ((a * 10 + c) * 10 + b) * 10 + d\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    ",
        "c++": "\n    ```cpp\nint splitAndMinimize(int num) {\n    int a = num / 1000;\n    int b = (num % 1000) / 100;\n    int c = (num % 100) / 10;\n    int d = num % 10;\n    return ((a * 10 + c) * 10 + b) * 10 + d;\n}\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    ",
        "js": "\n    ```javascript\nfunction splitAndMinimize(num) {\n    let a = Math.floor(num / 1000);\n    let b = Math.floor((num % 1000) / 100);\n    let c = Math.floor((num % 100) / 10);\n    let d = num % 10;\n    return ((a * 10 + c) * 10 + b) * 10 + d;\n}\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    "
    },
    {
        "id": 413,
        "title": "Find the K-Beauty of a Number",
        "difficulty": "Easy",
        "content": {
            "problem": "The **k-beauty** of an integer `num` is defined as the number of **substrings** of `num` when it is read as a string that meet the following conditions:\n\n*   It has a length of `k`.\n*   It is a divisor of `num`.\n\nGiven integers `num` and `k`, return _the k-beauty of_ `num`.\n\nNote:\n\n*   **Leading zeros** are allowed.\n*   `0` is not a divisor of any value.\n\nA **substring** is a contiguous sequence of characters in a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 240, k = 2\n**Output:** 2\n**Explanation:** The following are the substrings of num of length k:\n-  \"24 \" from  \"**24**0 \": 24 is a divisor of 240.\n-  \"40 \" from  \"2**40** \": 40 is a divisor of 240.\nTherefore, the k-beauty is 2.\n\n",
                "**Example 2:**\n\n**Input:** num = 430043, k = 2\n**Output:** 2\n**Explanation:** The following are the substrings of num of length k:\n-  \"43 \" from  \"**43**0043 \": 43 is a divisor of 430043.\n-  \"30 \" from  \"4**30**043 \": 30 is not a divisor of 430043.\n-  \"00 \" from  \"43**00**43 \": 0 is not a divisor of 430043.\n-  \"04 \" from  \"430**04**3 \": 4 is not a divisor of 430043.\n-  \"43 \" from  \"4300**43** \": 43 is a divisor of 430043.\nTherefore, the k-beauty is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 109`\n*   `1 <= k <= num.length` (taking `num` as a string)",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "240,2",
                "output": "2"
            },
            {
                "input": "430043,2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int numElementsWithSmallerAndGreater(int[] nums) {\n    int n = nums.length;\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        boolean hasSmaller = false, hasGreater = false;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (nums[j] > nums[i]) hasGreater = true;\n            if (nums[j] < nums[i]) hasSmaller = true;\n            if (hasSmaller && hasGreater) {\n                res++;\n                break;\n            }\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through the input array `nums`. For each element, it checks if there are both smaller and greater elements in the array. To do this, it uses two boolean variables (`hasSmaller` and `hasGreater`). The inner loop iterates through the array again to compare each pair of distinct elements.\n\nIf a pair of elements that satisfies the condition (one is smaller and the other is greater) is found, the result is incremented by 1, and the inner loop is broken to avoid redundant checks for the current element.\n\nAfter iterating through the entire array, the final result is returned.\n    ",
        "python": "\n    ```python\ndef num_elements_with_smaller_and_greater(nums):\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        has_smaller = has_greater = False\n        for j in range(n):\n            if i == j:\n                continue\n            if nums[j] > nums[i]:\n                has_greater = True\n            if nums[j] < nums[i]:\n                has_smaller = True\n            if has_smaller and has_greater:\n                res += 1\n                break\n    return res\n```\n    \n    The algorithm iterates through the input array `nums`. For each element, it checks if there are both smaller and greater elements in the array. To do this, it uses two boolean variables (`hasSmaller` and `hasGreater`). The inner loop iterates through the array again to compare each pair of distinct elements.\n\nIf a pair of elements that satisfies the condition (one is smaller and the other is greater) is found, the result is incremented by 1, and the inner loop is broken to avoid redundant checks for the current element.\n\nAfter iterating through the entire array, the final result is returned.\n    ",
        "c++": "\n    ```cpp\nint numElementsWithSmallerAndGreater(const std::vector<int>& nums) {\n    int n = nums.size();\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        bool hasSmaller = false, hasGreater = false;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (nums[j] > nums[i]) hasGreater = true;\n            if (nums[j] < nums[i]) hasSmaller = true;\n            if (hasSmaller && hasGreater) {\n                res++;\n                break;\n            }\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through the input array `nums`. For each element, it checks if there are both smaller and greater elements in the array. To do this, it uses two boolean variables (`hasSmaller` and `hasGreater`). The inner loop iterates through the array again to compare each pair of distinct elements.\n\nIf a pair of elements that satisfies the condition (one is smaller and the other is greater) is found, the result is incremented by 1, and the inner loop is broken to avoid redundant checks for the current element.\n\nAfter iterating through the entire array, the final result is returned.\n    ",
        "js": "\n    ```javascript\nfunction numElementsWithSmallerAndGreater(nums) {\n    let n = nums.length;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        let hasSmaller = false, hasGreater = false;\n        for (let j = 0; j < n; j++) {\n            if (i === j) continue;\n            if (nums[j] > nums[i]) hasGreater = true;\n            if (nums[j] < nums[i]) hasSmaller = true;\n            if (hasSmaller && hasGreater) {\n                res++;\n                break;\n            }\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through the input array `nums`. For each element, it checks if there are both smaller and greater elements in the array. To do this, it uses two boolean variables (`hasSmaller` and `hasGreater`). The inner loop iterates through the array again to compare each pair of distinct elements.\n\nIf a pair of elements that satisfies the condition (one is smaller and the other is greater) is found, the result is incremented by 1, and the inner loop is broken to avoid redundant checks for the current element.\n\nAfter iterating through the entire array, the final result is returned.\n    "
    },
    {
        "id": 414,
        "title": "Find Resultant Array After Removing Anagrams",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string array `words`, where `words[i]` consists of lowercase English letters.\n\nIn one operation, select any index `i` such that `0 < i < words.length` and `words[i - 1]` and `words[i]` are **anagrams**, and **delete** `words[i]` from `words`. Keep performing this operation as long as you can select an index that satisfies the conditions.\n\nReturn `words` _after performing all operations_. It can be shown that selecting the indices for each operation in **any** arbitrary order will lead to the same result.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, `\"dacb \"` is an anagram of `\"abdc \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abba \", \"baba \", \"bbaa \", \"cd \", \"cd \"\\]\n**Output:** \\[ \"abba \", \"cd \"\\]\n**Explanation:**\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words\\[2\\] =  \"bbaa \" and words\\[1\\] =  \"baba \" are anagrams, we choose index 2 and delete words\\[2\\].\n  Now words = \\[ \"abba \", \"baba \", \"cd \", \"cd \"\\].\n- Since words\\[1\\] =  \"baba \" and words\\[0\\] =  \"abba \" are anagrams, we choose index 1 and delete words\\[1\\].\n  Now words = \\[ \"abba \", \"cd \", \"cd \"\\].\n- Since words\\[2\\] =  \"cd \" and words\\[1\\] =  \"cd \" are anagrams, we choose index 2 and delete words\\[2\\].\n  Now words = \\[ \"abba \", \"cd \"\\].\nWe can no longer perform any operations, so \\[ \"abba \", \"cd \"\\] is the final answer.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"b \", \"c \", \"d \", \"e \"\\]\n**Output:** \\[ \"a \", \"b \", \"c \", \"d \", \"e \"\\]\n**Explanation:**\nNo two adjacent strings in words are anagrams of each other, so no operations are performed."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "[\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]",
                "output": "[\"abba\",\"cd\"]"
            },
            {
                "input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
                "output": "[\"a\",\"b\",\"c\",\"d\",\"e\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<String> anagramOperations(String[] words) {\n    List<String> result = new ArrayList<>();\n    result.add(words[0]);\n    \n    for (int i = 1; i < words.length; i++) {\n        char[] first = words[i].toCharArray();\n        char[] second = words[i - 1].toCharArray();\n        Arrays.sort(first);\n        Arrays.sort(second);\n        \n        if (!Arrays.equals(first, second)) {\n            result.add(words[i]);\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    ",
        "python": "\n    ```python\ndef anagramOperations(words):\n    i = 1\n    while i < len(words):\n        word1 = sorted(words[i])\n        word2 = sorted(words[i - 1])\n        if word1 == word2:\n            del words[i]\n        else:\n            i += 1\n    return words\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> anagramOperations(std::vector<std::string> &words) {\n    for (int i = 1; i < words.size(); ++i) {\n        std::string s1 = words[i];\n        std::string s2 = words[i - 1];\n        std::sort(s1.begin(), s1.end());\n        std::sort(s2.begin(), s2.end());\n        if (s1 == s2) {\n            words.erase(words.begin() + i);\n            --i;\n        }\n    }\n    return words;\n}\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    ",
        "js": "\n    ```javascript\nfunction anagramOperations(words) {\n  let i = 1;\n  while (i < words.length) {\n    let word1 = words[i].split('').sort().join('');\n    let word2 = words[i - 1].split('').sort().join('');\n    \n    if (word1 === word2) {\n      words.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n  return words;\n}\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    "
    },
    {
        "id": 415,
        "title": "Percentage of Letter in String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` and a character `letter`, return _the **percentage** of characters in_ `s` _that equal_ `letter` _**rounded down** to the nearest whole percent._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"foobar \", letter =  \"o \"\n**Output:** 33\n**Explanation:**\nThe percentage of characters in s that equal the letter 'o' is 2 / 6 \\* 100% = 33% when rounded down, so we return 33.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"jjjj \", letter =  \"k \"\n**Output:** 0\n**Explanation:**\nThe percentage of characters in s that equal the letter 'k' is 0%, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.\n*   `letter` is a lowercase English letter.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"foobar\",\"o\"",
                "output": "33"
            },
            {
                "input": "\"jjjj\",\"k\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int[] threeConsecutiveIntegers(int num) {\n    if (num % 3 == 0) {\n        return new int[]{num / 3 - 1, num / 3, num / 3 + 1};\n    } else if (num % 3 == 1) {\n        return new int[]{(num - 2) / 3, (num + 1) / 3, (num + 4) / 3};\n    } else {\n        return new int[]{};\n    }\n}\n```\n    \n    The algorithm first checks if the number `num` is divisible by 3. If it is, the three consecutive integers must be `{num / 3 - 1, num / 3, num / 3 + 1}`. If `num` is one more than a multiple of 3 (i.e., `num % 3 == 1`), then the three consecutive integers are `{(num - 2) / 3, (num + 1) / 3, (num + 4) / 3}`. If `num` is neither divisible by 3 nor one more than a multiple of 3 (i.e., `num % 3 == 2`), it cannot be expressed as the sum of three consecutive integers, so the function returns an empty array.\n    ",
        "python": "\n    ```python\ndef three_consecutive_integers(num):\n    if num % 3 == 0:\n        return [num // 3 - 1, num // 3, num // 3 + 1]\n    elif num % 3 == 1:\n        return [(num - 2) // 3, (num + 1) // 3, (num + 4) // 3]\n    else:\n        return []\n```\n    \n    The algorithm first checks if the number `num` is divisible by 3. If it is, the three consecutive integers must be `{num / 3 - 1, num / 3, num / 3 + 1}`. If `num` is one more than a multiple of 3 (i.e., `num % 3 == 1`), then the three consecutive integers are `{(num - 2) / 3, (num + 1) / 3, (num + 4) / 3}`. If `num` is neither divisible by 3 nor one more than a multiple of 3 (i.e., `num % 3 == 2`), it cannot be expressed as the sum of three consecutive integers, so the function returns an empty array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> threeConsecutiveIntegers(int num) {\n    if (num % 3 == 0) {\n        return {num / 3 - 1, num / 3, num / 3 + 1};\n    } else if (num % 3 == 1) {\n        return {(num - 2) / 3, (num + 1) / 3, (num + 4) / 3};\n    } else {\n        return {};\n    }\n}\n```\n    \n    The algorithm first checks if the number `num` is divisible by 3. If it is, the three consecutive integers must be `{num / 3 - 1, num / 3, num / 3 + 1}`. If `num` is one more than a multiple of 3 (i.e., `num % 3 == 1`), then the three consecutive integers are `{(num - 2) / 3, (num + 1) / 3, (num + 4) / 3}`. If `num` is neither divisible by 3 nor one more than a multiple of 3 (i.e., `num % 3 == 2`), it cannot be expressed as the sum of three consecutive integers, so the function returns an empty array.\n    ",
        "js": "\n    ```javascript\nfunction threeConsecutiveIntegers(num) {\n    if (num % 3 === 0) {\n        return [num / 3 - 1, num / 3, num / 3 + 1];\n    } else if (num % 3 === 1) {\n        return [(num - 2) / 3, (num + 1) / 3, (num + 4) / 3];\n    } else {\n        return [];\n    }\n}\n```\n    \n    The algorithm first checks if the number `num` is divisible by 3. If it is, the three consecutive integers must be `{num / 3 - 1, num / 3, num / 3 + 1}`. If `num` is one more than a multiple of 3 (i.e., `num % 3 == 1`), then the three consecutive integers are `{(num - 2) / 3, (num + 1) / 3, (num + 4) / 3}`. If `num` is neither divisible by 3 nor one more than a multiple of 3 (i.e., `num % 3 == 2`), it cannot be expressed as the sum of three consecutive integers, so the function returns an empty array.\n    "
    },
    {
        "id": 416,
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string `num` of length `n` consisting of digits.\n\nReturn `true` _if for **every** index_ `i` _in the range_ `0 <= i < n`_, the digit_ `i` _occurs_ `num[i]` _times in_ `num`_, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"1210 \"\n**Output:** true\n**Explanation:**\nnum\\[0\\] = '1'. The digit 0 occurs once in num.\nnum\\[1\\] = '2'. The digit 1 occurs twice in num.\nnum\\[2\\] = '1'. The digit 2 occurs once in num.\nnum\\[3\\] = '0'. The digit 3 occurs zero times in num.\nThe condition holds true for every index in  \"1210 \", so return true.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"030 \"\n**Output:** false\n**Explanation:**\nnum\\[0\\] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.\nnum\\[1\\] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.\nnum\\[2\\] = '0'. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false."
            ],
            "constraints": "**Constraints:**\n\n*   `n == num.length`\n*   `1 <= n <= 10`\n*   `num` consists of digits.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"1210\"",
                "output": "true"
            },
            {
                "input": "\"030\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] rearrangeArray(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 1; i < nums.length - 1; i += 2) {\n        int temp = nums[i];\n        nums[i] = nums[i + 1];\n        nums[i + 1] = temp;\n    }\n    return nums;\n}\n```\n    \n    The algorithm starts by sorting the given integer array `nums` in ascending order. Then, iterates through the sorted array using a for-loop, swapping the numbers at the even index with the number immediately after it. The next step in the loop is done by incrementing the iterator by 2 (i.e., `i += 2`). The algorithm continues until the entire array is rearranged. Finally, the rearranged array is returned.\n    ",
        "python": "\n    ```python\ndef rearrange_array(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n```\n    \n    The algorithm starts by sorting the given integer array `nums` in ascending order. Then, iterates through the sorted array using a for-loop, swapping the numbers at the even index with the number immediately after it. The next step in the loop is done by incrementing the iterator by 2 (i.e., `i += 2`). The algorithm continues until the entire array is rearranged. Finally, the rearranged array is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> rearrangeArray(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    for (int i = 1; i < nums.size() - 1; i += 2) {\n        swap(nums[i], nums[i + 1]);\n    }\n    return nums;\n}\n```\n    \n    The algorithm starts by sorting the given integer array `nums` in ascending order. Then, iterates through the sorted array using a for-loop, swapping the numbers at the even index with the number immediately after it. The next step in the loop is done by incrementing the iterator by 2 (i.e., `i += 2`). The algorithm continues until the entire array is rearranged. Finally, the rearranged array is returned.\n    ",
        "js": "\n    ```javascript\nfunction rearrangeArray(nums) {\n    nums.sort((a, b) => a - b);\n    for (let i = 1; i < nums.length - 1; i += 2) {\n        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    }\n    return nums;\n}\n```\n    \n    The algorithm starts by sorting the given integer array `nums` in ascending order. Then, iterates through the sorted array using a for-loop, swapping the numbers at the even index with the number immediately after it. The next step in the loop is done by incrementing the iterator by 2 (i.e., `i += 2`). The algorithm continues until the entire array is rearranged. Finally, the rearranged array is returned.\n    "
    },
    {
        "id": 417,
        "title": "Rearrange Characters to Make Target String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two **0-indexed** strings `s` and `target`. You can take some letters from `s` and rearrange them to form new strings.\n\nReturn _the **maximum** number of copies of_ `target` _that can be formed by taking letters from_ `s` _and rearranging them._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ilovecodingonleetcode \", target =  \"code \"\n**Output:** 2\n**Explanation:**\nFor the first copy of  \"code \", take the letters at indices 4, 5, 6, and 7.\nFor the second copy of  \"code \", take the letters at indices 17, 18, 19, and 20.\nThe strings that are formed are  \"ecod \" and  \"code \" which can both be rearranged into  \"code \".\nWe can make at most two copies of  \"code \", so we return 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcba \", target =  \"abc \"\n**Output:** 1\n**Explanation:**\nWe can make one copy of  \"abc \" by taking the letters at indices 0, 1, and 2.\nWe can make at most one copy of  \"abc \", so we return 1.\nNote that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of  \"abc \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abbaccaddaeea \", target =  \"aaaaa \"\n**Output:** 1\n**Explanation:**\nWe can make one copy of  \"aaaaa \" by taking the letters at indices 0, 3, 6, 9, and 12.\nWe can make at most one copy of  \"aaaaa \", so we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `1 <= target.length <= 10`\n*   `s` and `target` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"ilovecodingonleetcode\",\"code\"",
                "output": "2"
            },
            {
                "input": "\"abcba\",\"abc\"",
                "output": "1"
            },
            {
                "input": "\"abbaccaddaeea\",\"aaaaa\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxNumberOfCopies(String s, String target) {\n    int[] sCounts = new int[26];\n    int[] targetCounts = new int[26];\n\n    for (char c : s.toCharArray())\n        sCounts[c - 'a']++;\n\n    for (char c : target.toCharArray())\n        targetCounts[c - 'a']++;\n\n    int maxCopies = Integer.MAX_VALUE;\n    for (int i = 0; i < 26; i++) {\n        if (targetCounts[i] > 0)\n            maxCopies = Math.min(maxCopies, sCounts[i] / targetCounts[i]);\n    }\n    return maxCopies;\n}\n```\n\n    \n    1. Create two arrays `s_counts` and `target_counts` of length 26 to count the occurrences of each alphabet in both strings s and target.\n2. Iterate through the input strings s and target, and calculate the frequency of each character in both strings s and target using their ASCII values.\n3. Initialize a variable `max_copies` to store the maximum number of copies that can be formed.\n4. Iterate through the `target_counts` from 0 to 25 (inclusive) and check if the count of each character is greater than 0. If yes, update `max_copies` with the minimum value between the current `max_copies` value and the integer division of `s_counts` and `target_counts` at that index.\n5. Return the `max_copies` as the result.\n    ",
        "python": "\n    ```python\ndef maxNumberOfCopies(s, target):\n    s_counts = [0] * 26\n    target_counts = [0] * 26\n\n    for c in s:\n        s_counts[ord(c) - ord('a')] += 1\n\n    for c in target:\n        target_counts[ord(c) - ord('a')] += 1\n\n    max_copies = float('inf')\n    for i in range(26):\n        if target_counts[i] > 0:\n            max_copies = min(max_copies, s_counts[i] // target_counts[i])\n    return max_copies\n```\n\n    \n    1. Create two arrays `s_counts` and `target_counts` of length 26 to count the occurrences of each alphabet in both strings s and target.\n2. Iterate through the input strings s and target, and calculate the frequency of each character in both strings s and target using their ASCII values.\n3. Initialize a variable `max_copies` to store the maximum number of copies that can be formed.\n4. Iterate through the `target_counts` from 0 to 25 (inclusive) and check if the count of each character is greater than 0. If yes, update `max_copies` with the minimum value between the current `max_copies` value and the integer division of `s_counts` and `target_counts` at that index.\n5. Return the `max_copies` as the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint maxNumberOfCopies(std::string s, std::string target) {\n    std::vector<int> s_counts(26, 0);\n    std::vector<int> target_counts(26, 0);\n\n    for (char c : s)\n        s_counts[c - 'a']++;\n\n    for (char c : target)\n        target_counts[c - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for (int i = 0; i < 26; i++) {\n        if (target_counts[i] > 0)\n            max_copies = std::min(max_copies, s_counts[i] / target_counts[i]);\n    }\n    return max_copies;\n}\n```\n\n    \n    1. Create two arrays `s_counts` and `target_counts` of length 26 to count the occurrences of each alphabet in both strings s and target.\n2. Iterate through the input strings s and target, and calculate the frequency of each character in both strings s and target using their ASCII values.\n3. Initialize a variable `max_copies` to store the maximum number of copies that can be formed.\n4. Iterate through the `target_counts` from 0 to 25 (inclusive) and check if the count of each character is greater than 0. If yes, update `max_copies` with the minimum value between the current `max_copies` value and the integer division of `s_counts` and `target_counts` at that index.\n5. Return the `max_copies` as the result.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberOfCopies(s, target) {\n    let sCounts = new Array(26).fill(0);\n    let targetCounts = new Array(26).fill(0);\n\n    for (let c of s)\n        sCounts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    for (let c of target)\n        targetCounts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    let maxCopies = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < 26; i++) {\n        if (targetCounts[i] > 0)\n            maxCopies = Math.min(maxCopies, Math.floor(sCounts[i] / targetCounts[i]));\n    }\n    return maxCopies;\n}\n```\n\n    \n    1. Create two arrays `s_counts` and `target_counts` of length 26 to count the occurrences of each alphabet in both strings s and target.\n2. Iterate through the input strings s and target, and calculate the frequency of each character in both strings s and target using their ASCII values.\n3. Initialize a variable `max_copies` to store the maximum number of copies that can be formed.\n4. Iterate through the `target_counts` from 0 to 25 (inclusive) and check if the count of each character is greater than 0. If yes, update `max_copies` with the minimum value between the current `max_copies` value and the integer division of `s_counts` and `target_counts` at that index.\n5. Return the `max_copies` as the result.\n    "
    },
    {
        "id": 418,
        "title": "Min Max Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` whose length is a power of `2`.\n\nApply the following algorithm on `nums`:\n\n1.  Let `n` be the length of `nums`. If `n == 1`, **end** the process. Otherwise, **create** a new **0-indexed** integer array `newNums` of length `n / 2`.\n2.  For every **even** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `min(nums[2 * i], nums[2 * i + 1])`.\n3.  For every **odd** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `max(nums[2 * i], nums[2 * i + 1])`.\n4.  **Replace** the array `nums` with `newNums`.\n5.  **Repeat** the entire process starting from step 1.\n\nReturn _the last number that remains in_ `nums` _after applying the algorithm._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,2,4,8,2,2\\]\n**Output:** 1\n**Explanation:** The following arrays are the results of applying the algorithm repeatedly.\nFirst: nums = \\[1,5,4,2\\]\nSecond: nums = \\[1,4\\]\nThird: nums = \\[1\\]\n1 is the last remaining number, so we return 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3\\]\n**Output:** 3\n**Explanation:** 3 is already the last remaining number, so we return 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1024`\n*   `1 <= nums[i] <= 109`\n*   `nums.length` is a power of `2`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,3,5,2,4,8,2,2]",
                "output": "1"
            },
            {
                "input": "[3]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int minSteps(String s, String t) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n\n    for (char c : s.toCharArray()) charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    for (char c : t.toCharArray()) charCount.put(c, charCount.getOrDefault(c, 0) - 1);\n\n    int steps = 0;\n    for (int count : charCount.values()) {\n        steps += Math.abs(count);\n    }\n\n    return steps / 2;\n}\n```\n\n    \n    The algorithm uses a hashmap to keep track of the character counts for both strings. For every character in string s, we increase the count in the hashmap. For every character in string t, we decrease the count in the hashmap. This way, the difference in the count will represent the disparity between the strings.\n\nAfter processing both strings, we iterate through the hashmap and sum the absolute values of the counts. This sum represents the total number of mismatches between the two strings.\n\nFinally, we divide the sum by 2 since every step can fix two mismatches. And this gives us the minimum number of steps required to make s and t anagrams.\n    ",
        "python": "\n    ```python\ndef min_steps(s: str, t: str) -> int:\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for c in t:\n        char_count[c] = char_count.get(c, 0) - 1\n    \n    steps = sum(abs(count) for count in char_count.values())\n    \n    return steps // 2\n```\n\n    \n    The algorithm uses a hashmap to keep track of the character counts for both strings. For every character in string s, we increase the count in the hashmap. For every character in string t, we decrease the count in the hashmap. This way, the difference in the count will represent the disparity between the strings.\n\nAfter processing both strings, we iterate through the hashmap and sum the absolute values of the counts. This sum represents the total number of mismatches between the two strings.\n\nFinally, we divide the sum by 2 since every step can fix two mismatches. And this gives us the minimum number of steps required to make s and t anagrams.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nint minSteps(string s, string t) {\n    unordered_map<char, int> charCount;\n    for (char c : s) charCount[c]++;\n    for (char c : t) charCount[c]--;\n    \n    int steps = 0;\n    for (auto& pair : charCount) {\n        steps += abs(pair.second);\n    }\n    \n    return steps / 2;\n}\n```\n\n    \n    The algorithm uses a hashmap to keep track of the character counts for both strings. For every character in string s, we increase the count in the hashmap. For every character in string t, we decrease the count in the hashmap. This way, the difference in the count will represent the disparity between the strings.\n\nAfter processing both strings, we iterate through the hashmap and sum the absolute values of the counts. This sum represents the total number of mismatches between the two strings.\n\nFinally, we divide the sum by 2 since every step can fix two mismatches. And this gives us the minimum number of steps required to make s and t anagrams.\n    ",
        "js": "\n    ```javascript\nfunction minSteps(s, t) {\n    let charCount = {};\n\n    for (let c of s) charCount[c] = (charCount[c] || 0) + 1;\n    for (let c of t) charCount[c] = (charCount[c] || 0) - 1;\n\n    let steps = 0;\n    for (let count in charCount) {\n        steps += Math.abs(charCount[count]);\n    }\n\n    return steps / 2;\n}\n```\n\n    \n    The algorithm uses a hashmap to keep track of the character counts for both strings. For every character in string s, we increase the count in the hashmap. For every character in string t, we decrease the count in the hashmap. This way, the difference in the count will represent the disparity between the strings.\n\nAfter processing both strings, we iterate through the hashmap and sum the absolute values of the counts. This sum represents the total number of mismatches between the two strings.\n\nFinally, we divide the sum by 2 since every step can fix two mismatches. And this gives us the minimum number of steps required to make s and t anagrams.\n    "
    },
    {
        "id": 419,
        "title": "Strong Password Checker II",
        "difficulty": "Easy",
        "content": {
            "problem": "A password is said to be **strong** if it satisfies all the following criteria:\n\n*   It has at least `8` characters.\n*   It contains at least **one lowercase** letter.\n*   It contains at least **one uppercase** letter.\n*   It contains at least **one digit**.\n*   It contains at least **one special character**. The special characters are the characters in the following string: `\"!@#$%^&*()-+ \"`.\n*   It does **not** contain `2` of the same character in adjacent positions (i.e., `\"aab \"` violates this condition, but `\"aba \"` does not).\n\nGiven a string `password`, return `true` _if it is a **strong** password_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** password =  \"IloveLe3tcode! \"\n**Output:** true\n**Explanation:** The password meets all the requirements. Therefore, we return true.\n\n",
                "**Example 2:**\n\n**Input:** password =  \"Me+You--IsMyDream \"\n**Output:** false\n**Explanation:** The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false.\n\n",
                "**Example 3:**\n\n**Input:** password =  \"1aB! \"\n**Output:** false\n**Explanation:** The password does not meet the length requirement. Therefore, we return false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= password.length <= 100`\n*   `password` consists of letters, digits, and special characters: `\"!@#$%^&*()-+ \"`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"IloveLe3tcode!\"",
                "output": "true"
            },
            {
                "input": "\"Me+You--IsMyDream\"",
                "output": "false"
            },
            {
                "input": "\"1aB!\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode mergeNodesBetweenZeros(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n    ListNode curr = head;\n\n    while (curr != null) {\n        if (curr.val == 0) {\n            int tmpSum = 0;\n            while (curr.next != null && curr.next.val != 0) {\n                tmpSum += curr.next.val;\n                curr = curr.next;\n            }\n            prev.next = new ListNode(tmpSum);\n            prev = prev.next;\n            curr = curr.next;\n        }\n    }\n\n    return dummy.next;\n}\n```\n    \n    1. Create a dummy node and connect it to the head of the given list.\n2. Initialize two pointers: 'prev' pointing at the dummy node, and 'cur' pointing at the head.\n3. Iterate through the list using the 'cur' pointer.\n4. When 'cur' encounters a 0 node, calculate the sum of the nodes between consecutive 0 nodes using a temporary variable (tmp_sum).\n5. Update 'prev' with a new node that contains the value of tmp_sum, update 'prev' to the new node, and move 'cur' to the next node.\n6. Repeat steps 4 and 5 until all consecutive 0 nodes are merged.\n7. Return the modified list by returning the 'next' of the dummy node, as the head of the new list.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_nodes_between_zeros(head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n\n    while cur:\n        if cur.val == 0:\n            tmp_sum = 0\n            while cur.next and cur.next.val != 0:\n                tmp_sum += cur.next.val\n                cur = cur.next\n            prev.next = ListNode(tmp_sum)\n            prev = prev.next\n            cur = cur.next\n\n    return dummy.next\n```\n    \n    1. Create a dummy node and connect it to the head of the given list.\n2. Initialize two pointers: 'prev' pointing at the dummy node, and 'cur' pointing at the head.\n3. Iterate through the list using the 'cur' pointer.\n4. When 'cur' encounters a 0 node, calculate the sum of the nodes between consecutive 0 nodes using a temporary variable (tmp_sum).\n5. Update 'prev' with a new node that contains the value of tmp_sum, update 'prev' to the new node, and move 'cur' to the next node.\n6. Repeat steps 4 and 5 until all consecutive 0 nodes are merged.\n7. Return the modified list by returning the 'next' of the dummy node, as the head of the new list.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* mergeNodesBetweenZeros(ListNode* head) {\n    ListNode* dummy = new ListNode(0);\n    dummy->next = head;\n    ListNode* prev = dummy;\n    ListNode* cur = head;\n\n    while (cur) {\n        if (cur->val == 0) {\n            int tmp_sum = 0;\n            while (cur->next && cur->next->val != 0) {\n                tmp_sum += cur->next->val;\n                cur = cur->next;\n            }\n            prev->next = new ListNode(tmp_sum);\n            prev = prev->next;\n            cur = cur->next;\n        }\n    }\n\n    return dummy->next;\n}\n```\n    \n    1. Create a dummy node and connect it to the head of the given list.\n2. Initialize two pointers: 'prev' pointing at the dummy node, and 'cur' pointing at the head.\n3. Iterate through the list using the 'cur' pointer.\n4. When 'cur' encounters a 0 node, calculate the sum of the nodes between consecutive 0 nodes using a temporary variable (tmp_sum).\n5. Update 'prev' with a new node that contains the value of tmp_sum, update 'prev' to the new node, and move 'cur' to the next node.\n6. Repeat steps 4 and 5 until all consecutive 0 nodes are merged.\n7. Return the modified list by returning the 'next' of the dummy node, as the head of the new list.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction mergeNodesBetweenZeros(head) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    let cur = head;\n\n    while (cur) {\n        if (cur.val === 0) {\n            let tmp_sum = 0;\n            while (cur.next && cur.next.val !== 0) {\n                tmp_sum += cur.next.val;\n                cur = cur.next;\n            }\n            prev.next = new ListNode(tmp_sum);\n            prev = prev.next;\n            cur = cur.next;\n        }\n    }\n\n    return dummy.next;\n}\n```\n    \n    1. Create a dummy node and connect it to the head of the given list.\n2. Initialize two pointers: 'prev' pointing at the dummy node, and 'cur' pointing at the head.\n3. Iterate through the list using the 'cur' pointer.\n4. When 'cur' encounters a 0 node, calculate the sum of the nodes between consecutive 0 nodes using a temporary variable (tmp_sum).\n5. Update 'prev' with a new node that contains the value of tmp_sum, update 'prev' to the new node, and move 'cur' to the next node.\n6. Repeat steps 4 and 5 until all consecutive 0 nodes are merged.\n7. Return the modified list by returning the 'next' of the dummy node, as the head of the new list.\n    "
    },
    {
        "id": 420,
        "title": "Calculate Amount Paid in Taxes",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `brackets` where `brackets[i] = [upperi, percenti]` means that the `ith` tax bracket has an upper bound of `upperi` and is taxed at a rate of `percenti`. The brackets are **sorted** by upper bound (i.e. `upperi-1 < upperi` for `0 < i < brackets.length`).\n\nTax is calculated as follows:\n\n*   The first `upper0` dollars earned are taxed at a rate of `percent0`.\n*   The next `upper1 - upper0` dollars earned are taxed at a rate of `percent1`.\n*   The next `upper2 - upper1` dollars earned are taxed at a rate of `percent2`.\n*   And so on.\n\nYou are given an integer `income` representing the amount of money you earned. Return _the amount of money that you have to pay in taxes._ Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** brackets = \\[\\[3,50\\],\\[7,10\\],\\[12,25\\]\\], income = 10\n**Output:** 2.65000\n**Explanation:**\nBased on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.\nThe tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.\nIn total, you pay $3 \\* 50% + $4 \\* 10% + $3 \\* 25% = $2.65 in taxes.\n\n",
                "**Example 2:**\n\n**Input:** brackets = \\[\\[1,0\\],\\[4,25\\],\\[5,50\\]\\], income = 2\n**Output:** 0.25000\n**Explanation:**\nBased on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket.\nThe tax rate for the two tax brackets is 0% and 25%, respectively.\nIn total, you pay $1 \\* 0% + $1 \\* 25% = $0.25 in taxes.\n\n",
                "**Example 3:**\n\n**Input:** brackets = \\[\\[2,50\\]\\], income = 0\n**Output:** 0.00000\n**Explanation:**\nYou have no income to tax, so you have to pay a total of $0 in taxes."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= brackets.length <= 100`\n*   `1 <= upperi <= 1000`\n*   `0 <= percenti <= 100`\n*   `0 <= income <= 1000`\n*   `upperi` is sorted in ascending order.\n*   All the values of `upperi` are **unique**.\n*   The upper bound of the last tax bracket is greater than or equal to `income`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[3,50],[7,10],[12,25]],10",
                "output": "2.65000"
            },
            {
                "input": "[[1,0],[4,25],[5,50]],2",
                "output": "0.25000"
            },
            {
                "input": "[[2,50]],0",
                "output": "0.00000"
            }
        ],
        "java": "\n    ```java\ndouble taxAmount(int[][] brackets, int income) {\n    double tax = 0;\n    int prev_upper = 0;\n    for (int[] bracket : brackets) {\n        int upper = bracket[0];\n        double percent = bracket[1] / 100.0;\n        tax += (Math.min(upper, income) - prev_upper) * percent;\n        prev_upper = upper;\n        if (income <= upper) break;\n    }\n    return tax;\n}\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    ",
        "python": "\n    ```python\ndef tax_amount(brackets, income):\n    tax = 0\n    prev_upper = 0\n    for upper, percent in brackets:\n        tax += (min(upper, income) - prev_upper) * (percent / 100)\n        prev_upper = upper\n        if income <= upper:\n            break\n    return tax\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    ",
        "c++": "\n    ```cpp\ndouble taxAmount(vector<vector<int>>& brackets, int income) {\n    double tax = 0;\n    int prev_upper = 0;\n    for (vector<int>& bracket : brackets) {\n        int upper = bracket[0];\n        double percent = bracket[1] / 100.0;\n        tax += (min(upper, income) - prev_upper) * percent;\n        prev_upper = upper;\n        if (income <= upper) break;\n    }\n    return tax;\n}\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    ",
        "js": "\n    ```javascript\nfunction taxAmount(brackets, income) {\n    let tax = 0;\n    let prev_upper = 0;\n    for (let bracket of brackets) {\n        let upper = bracket[0];\n        let percent = bracket[1] / 100;\n        tax += (Math.min(upper, income) - prev_upper) * percent;\n        prev_upper = upper;\n        if (income <= upper) break;\n    }\n    return tax;\n}\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    "
    },
    {
        "id": 421,
        "title": "Greatest English Letter in Upper and Lower Case",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string of English letters `s`, return _the **greatest** English letter which occurs as **both** a lowercase and uppercase letter in_ `s`. The returned letter should be in **uppercase**. If no such letter exists, return _an empty string_.\n\nAn English letter `b` is **greater** than another letter `a` if `b` appears **after** `a` in the English alphabet.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"l**Ee**TcOd**E** \"\n**Output:**  \"E \"\n**Explanation:**\nThe letter 'E' is the only letter to appear in both lower and upper case.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a**rR**AzFif \"\n**Output:**  \"R \"\n**Explanation:**\nThe letter 'R' is the greatest letter to appear in both lower and upper case.\nNote that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"AbCdEfGhIjK \"\n**Output:**  \" \"\n**Explanation:**\nThere is no letter that appears in both lower and upper case."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase and uppercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Enumeration"
        ],
        "example": [
            {
                "input": "\"l**Ee**TcOd**E**\"",
                "output": "\"E\""
            },
            {
                "input": "\"a**rR**AzFif\"",
                "output": "\"R\""
            },
            {
                "input": "\"AbCdEfGhIjK\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic int getMaxOccurrences(String text, String pattern) {\n    int[] count = new int[2];\n    for (char c : text.toCharArray()) {\n        if (c == pattern.charAt(1)) {\n            count[1] += count[0];\n        }\n        else if (c == pattern.charAt(0)) {\n            count[0] += 1;\n        }\n    }\n    return count[1];\n}\n```\n    \n    The algorithm iterates through the text string character by character. Two counters, count[0] and count[1], are used to keep track of the occurrences of pattern[0] and pattern[1], respectively. For each character encountered in the text, we check whether it is equal to pattern[0] or pattern[1]. If the character matches pattern[0], we increment counter count[0]. If the character matches pattern[1], we increment the counter count[1] by count[0], because we want to count the number of subsequences formed with the previously found matches of pattern[0]. Finally, after the iteration, the count of pattern[1] returns the maximum number of occurrences of the given pattern.\n    ",
        "python": "\n    ```python\ndef get_max_occurrences(text: str, pattern: str) -> int:\n    count = [0, 0]\n    for c in text:\n        if c == pattern[1]:\n            count[1] += count[0]\n        elif c == pattern[0]:\n            count[0] += 1\n    return count[1]\n```\n    \n    The algorithm iterates through the text string character by character. Two counters, count[0] and count[1], are used to keep track of the occurrences of pattern[0] and pattern[1], respectively. For each character encountered in the text, we check whether it is equal to pattern[0] or pattern[1]. If the character matches pattern[0], we increment counter count[0]. If the character matches pattern[1], we increment the counter count[1] by count[0], because we want to count the number of subsequences formed with the previously found matches of pattern[0]. Finally, after the iteration, the count of pattern[1] returns the maximum number of occurrences of the given pattern.\n    ",
        "c++": "\n    ```cpp\nint getMaxOccurrences(const std::string& text, const std::string& pattern) {\n    int count[2] = {0, 0};\n    for (char c : text) {\n        if (c == pattern[1]) {\n            count[1] += count[0];\n        }\n        else if (c == pattern[0]) {\n            count[0] += 1;\n        }\n    }\n    return count[1];\n}\n```\n    \n    The algorithm iterates through the text string character by character. Two counters, count[0] and count[1], are used to keep track of the occurrences of pattern[0] and pattern[1], respectively. For each character encountered in the text, we check whether it is equal to pattern[0] or pattern[1]. If the character matches pattern[0], we increment counter count[0]. If the character matches pattern[1], we increment the counter count[1] by count[0], because we want to count the number of subsequences formed with the previously found matches of pattern[0]. Finally, after the iteration, the count of pattern[1] returns the maximum number of occurrences of the given pattern.\n    ",
        "js": "\n    ```javascript\nfunction getMaxOccurrences(text, pattern) {\n    let count = [0, 0];\n    for (let c of text) {\n        if (c === pattern[1]) {\n            count[1] += count[0];\n        }\n        else if (c === pattern[0]) {\n            count[0] += 1;\n        }\n    }\n    return count[1];\n}\n```\n    \n    The algorithm iterates through the text string character by character. Two counters, count[0] and count[1], are used to keep track of the occurrences of pattern[0] and pattern[1], respectively. For each character encountered in the text, we check whether it is equal to pattern[0] or pattern[1]. If the character matches pattern[0], we increment counter count[0]. If the character matches pattern[1], we increment the counter count[1] by count[0], because we want to count the number of subsequences formed with the previously found matches of pattern[0]. Finally, after the iteration, the count of pattern[1] returns the maximum number of occurrences of the given pattern.\n    "
    },
    {
        "id": 422,
        "title": "Count Asterisks",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s`, where every **two** consecutive vertical bars `'|'` are grouped into a **pair**. In other words, the 1st and 2nd `'|'` make a pair, the 3rd and 4th `'|'` make a pair, and so forth.\n\nReturn _the number of_ `'*'` _in_ `s`_, **excluding** the_ `'*'` _between each pair of_ `'|'`.\n\n**Note** that each `'|'` will belong to **exactly** one pair.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"l|\\*e\\*et|c\\*\\*o|\\*de| \"\n**Output:** 2\n**Explanation:** The considered characters are underlined:  \"l|\\*e\\*et|c\\*\\*o|\\*de| \".\nThe characters between the first and second '|' are excluded from the answer.\nAlso, the characters between the third and fourth '|' are excluded from the answer.\nThere are 2 asterisks considered. Therefore, we return 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"iamprogrammer \"\n**Output:** 0\n**Explanation:** In this example, there are no asterisks in s. Therefore, we return 0.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"yo|uar|e\\*\\*|b|e\\*\\*\\*au|tifu|l \"\n**Output:** 5\n**Explanation:** The considered characters are underlined:  \"yo|uar|e\\*\\*|b|e\\*\\*\\*au|tifu|l \". There are 5 asterisks considered. Therefore, we return 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters, vertical bars `'|'`, and asterisks `'*'`.\n*   `s` contains an **even** number of vertical bars `'|'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"l|*e*et|c**o|*de|\"",
                "output": "2"
            },
            {
                "input": "\"iamprogrammer\"",
                "output": "0"
            },
            {
                "input": "\"yo|uar|e**|b|e***au|tifu|l\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int countStarsExceptBetweenPair(String s) {\n    int count = 0;\n    int pipeCount = 0;\n\n    for (char c : s.toCharArray()) {\n        if (c == '|') {\n            pipeCount++;\n        } else if (c == '*' && pipeCount % 2 == 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    The algorithm loops through the string with a simple for loop iterating on characters. It keeps track of the number of pipes encountered (pipeCount) and the total count of stars. If a pipe is encountered, increment pipeCount. If a star is encountered and pipeCount is even, increment the count. This condition (pipeCount % 2 == 0) ensures we are not considering stars between a pair of vertical bars. Finally, return the count of stars after processing the entire string.\n    ",
        "python": "\n    ```python\ndef count_stars_except_between_pair(s: str) -> int:\n    count = 0\n    pipe_count = 0\n\n    for c in s:\n        if c == '|':\n            pipe_count += 1\n        elif c == '*' and pipe_count % 2 == 0:\n            count += 1\n\n    return count\n```\n\n    \n    The algorithm loops through the string with a simple for loop iterating on characters. It keeps track of the number of pipes encountered (pipeCount) and the total count of stars. If a pipe is encountered, increment pipeCount. If a star is encountered and pipeCount is even, increment the count. This condition (pipeCount % 2 == 0) ensures we are not considering stars between a pair of vertical bars. Finally, return the count of stars after processing the entire string.\n    ",
        "c++": "\n    ```cpp\nint countStarsExceptBetweenPair(const std::string& s) {\n    int count = 0;\n    int pipeCount = 0;\n\n    for (char c : s) {\n        if (c == '|') {\n            pipeCount++;\n        } else if (c == '*' && pipeCount % 2 == 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    The algorithm loops through the string with a simple for loop iterating on characters. It keeps track of the number of pipes encountered (pipeCount) and the total count of stars. If a pipe is encountered, increment pipeCount. If a star is encountered and pipeCount is even, increment the count. This condition (pipeCount % 2 == 0) ensures we are not considering stars between a pair of vertical bars. Finally, return the count of stars after processing the entire string.\n    ",
        "js": "\n    ```javascript\nfunction countStarsExceptBetweenPair(s) {\n    let count = 0;\n    let pipeCount = 0;\n\n    for (let c of s) {\n        if (c === '|') {\n            pipeCount++;\n        } else if (c === '*' && pipeCount % 2 === 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    The algorithm loops through the string with a simple for loop iterating on characters. It keeps track of the number of pipes encountered (pipeCount) and the total count of stars. If a pipe is encountered, increment pipeCount. If a star is encountered and pipeCount is even, increment the count. This condition (pipeCount % 2 == 0) ensures we are not considering stars between a pair of vertical bars. Finally, return the count of stars after processing the entire string.\n    "
    },
    {
        "id": 423,
        "title": "Check if Matrix Is X-Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "A square matrix is said to be an **X-Matrix** if **both** of the following conditions hold:\n\n1.  All the elements in the diagonals of the matrix are **non-zero**.\n2.  All other elements are 0.\n\nGiven a 2D integer array `grid` of size `n x n` representing a square matrix, return `true` _if_ `grid` _is an X-Matrix_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[2,0,0,1\\],\\[0,3,1,0\\],\\[0,5,2,0\\],\\[4,0,0,2\\]\\]\n**Output:** true\n**Explanation:** Refer to the diagram above. \nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is an X-Matrix.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[5,7,0\\],\\[0,3,1\\],\\[0,5,0\\]\\]\n**Output:** false\n**Explanation:** Refer to the diagram above.\nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is not an X-Matrix."
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `3 <= n <= 100`\n*   `0 <= grid[i][j] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]",
                "output": "true"
            },
            {
                "input": "[[5,7,0],[0,3,1],[0,5,0]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic ArrayList<Integer> longestRepeatSubstring(String s, String queryCharacters, int[] queryIndices) {\n    int k = queryCharacters.length();\n    ArrayList<Integer> lengths = new ArrayList<>();\n\n    StringBuilder sCopy = new StringBuilder(s);\n\n    for (int i = 0; i < k; i++) {\n        sCopy.setCharAt(queryIndices[i], queryCharacters.charAt(i));\n        int maxLen = 0, curLen = 1;\n        for (int j = 1; j < sCopy.length(); j++) {\n            if (sCopy.charAt(j) == sCopy.charAt(j-1)) {\n                curLen++;\n            } else {\n                maxLen = Math.max(maxLen, curLen);\n                curLen = 1;\n            }\n        }\n        maxLen = Math.max(maxLen, curLen);\n        lengths.add(maxLen);\n    }\n\n    return lengths;\n}\n```\n    \n    1. Initialize an empty list/array `lengths` to store the results.\n2. Create a copy of the string `s`, as we will modify it in each query.\n3. Iterate through each query using a for loop based on the length of queryCharacters.\n    a. Update the character at the given index in `sCopy` using the current query.\n    b. Initialize `maxLen` as the maximum length of substring found so far and `curLen` as the current length of the repeating substring.\n    c. Iterate through the modified string and compare adjacent characters.\n        i. If the characters are the same, increment `curLen`.\n        ii. If the characters are different, update `maxLen` with the greater value between `maxLen` and `curLen`, and reset `curLen` to 1.\n   d. After the loop ends, update `maxLen` with the greater value between `maxLen` and `curLen`.\n   e. Append `maxLen` to the `lengths` list/array.\n4. Return the `lengths` list/array containing the length of the longest substring of `sCopy` consisting of only one repeating character after each query.\n    ",
        "python": "\n    ```python\ndef longest_repeat_substring(s, query_characters, query_indices):\n    k = len(query_characters)\n    lengths = []\n    s_copy = list(s)\n\n    for i in range(k):\n        s_copy[query_indices[i]] = query_characters[i]\n        max_len = cur_len = 1\n        for j in range(1, len(s_copy)):\n            if s_copy[j] == s_copy[j-1]:\n                cur_len += 1\n            else:\n                max_len = max(max_len, cur_len)\n                cur_len = 1\n        max_len = max(max_len, cur_len)\n        lengths.append(max_len)\n\n    return lengths\n```\n    \n    1. Initialize an empty list/array `lengths` to store the results.\n2. Create a copy of the string `s`, as we will modify it in each query.\n3. Iterate through each query using a for loop based on the length of queryCharacters.\n    a. Update the character at the given index in `sCopy` using the current query.\n    b. Initialize `maxLen` as the maximum length of substring found so far and `curLen` as the current length of the repeating substring.\n    c. Iterate through the modified string and compare adjacent characters.\n        i. If the characters are the same, increment `curLen`.\n        ii. If the characters are different, update `maxLen` with the greater value between `maxLen` and `curLen`, and reset `curLen` to 1.\n   d. After the loop ends, update `maxLen` with the greater value between `maxLen` and `curLen`.\n   e. Append `maxLen` to the `lengths` list/array.\n4. Return the `lengths` list/array containing the length of the longest substring of `sCopy` consisting of only one repeating character after each query.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> longestRepeatSubstring(const string& s, const string& queryCharacters, const vector<int>& queryIndices) {\n    int k = queryCharacters.size();\n    vector<int> lengths(k);\n    string sCopy = s;\n\n    for (int i = 0; i < k; ++i) {\n        sCopy[queryIndices[i]] = queryCharacters[i];\n        int maxLen = 0, curLen = 1;\n        for (int j = 1; j < sCopy.size(); ++j) {\n            if (sCopy[j] == sCopy[j-1]) {\n                curLen++;\n            } else {\n                maxLen = max(maxLen, curLen);\n                curLen = 1;\n            }\n        }\n        maxLen = max(maxLen, curLen);\n        lengths[i] = maxLen;\n    }\n\n    return lengths;\n}\n```\n    \n    1. Initialize an empty list/array `lengths` to store the results.\n2. Create a copy of the string `s`, as we will modify it in each query.\n3. Iterate through each query using a for loop based on the length of queryCharacters.\n    a. Update the character at the given index in `sCopy` using the current query.\n    b. Initialize `maxLen` as the maximum length of substring found so far and `curLen` as the current length of the repeating substring.\n    c. Iterate through the modified string and compare adjacent characters.\n        i. If the characters are the same, increment `curLen`.\n        ii. If the characters are different, update `maxLen` with the greater value between `maxLen` and `curLen`, and reset `curLen` to 1.\n   d. After the loop ends, update `maxLen` with the greater value between `maxLen` and `curLen`.\n   e. Append `maxLen` to the `lengths` list/array.\n4. Return the `lengths` list/array containing the length of the longest substring of `sCopy` consisting of only one repeating character after each query.\n    ",
        "js": "\n    ```javascript\nfunction longestRepeatSubstring(s, queryCharacters, queryIndices) {\n    const k = queryCharacters.length;\n    const lengths = [];\n    let sCopy = s.split('');\n\n    for (let i = 0; i < k; i++) {\n        sCopy[queryIndices[i]] = queryCharacters[i];\n        let maxLen = 0, curLen = 1;\n        for (let j = 1; j < sCopy.length; j++) {\n            if (sCopy[j] === sCopy[j-1]) {\n                curLen++;\n            } else {\n                maxLen = Math.max(maxLen, curLen);\n                curLen = 1;\n            }\n        }\n        maxLen = Math.max(maxLen, curLen);\n        lengths.push(maxLen);\n    }\n\n    return lengths;\n}\n```\n    \n    1. Initialize an empty list/array `lengths` to store the results.\n2. Create a copy of the string `s`, as we will modify it in each query.\n3. Iterate through each query using a for loop based on the length of queryCharacters.\n    a. Update the character at the given index in `sCopy` using the current query.\n    b. Initialize `maxLen` as the maximum length of substring found so far and `curLen` as the current length of the repeating substring.\n    c. Iterate through the modified string and compare adjacent characters.\n        i. If the characters are the same, increment `curLen`.\n        ii. If the characters are different, update `maxLen` with the greater value between `maxLen` and `curLen`, and reset `curLen` to 1.\n   d. After the loop ends, update `maxLen` with the greater value between `maxLen` and `curLen`.\n   e. Append `maxLen` to the `lengths` list/array.\n4. Return the `lengths` list/array containing the length of the longest substring of `sCopy` consisting of only one repeating character after each query.\n    "
    },
    {
        "id": 424,
        "title": "Decode the Message",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the strings `key` and `message`, which represent a cipher key and a secret message, respectively. The steps to decode `message` are as follows:\n\n1.  Use the **first** appearance of all 26 lowercase English letters in `key` as the **order** of the substitution table.\n2.  Align the substitution table with the regular English alphabet.\n3.  Each letter in `message` is then **substituted** using the table.\n4.  Spaces `' '` are transformed to themselves.\n\n*   For example, given `key = \"**hap**p**y** **bo**y \"` (actual key would have **at least one** instance of each letter in the alphabet), we have the partial substitution table of (`'h' -> 'a'`, `'a' -> 'b'`, `'p' -> 'c'`, `'y' -> 'd'`, `'b' -> 'e'`, `'o' -> 'f'`).\n\nReturn _the decoded message_.",
            "examples": [
                "**Example 1:**\n\n**Input:** key =  \"the quick brown fox jumps over the lazy dog \", message =  \"vkbs bs t suepuv \"\n**Output:**  \"this is a secret \"\n**Explanation:** The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in  \"**the** **quick** **brown** **f**o**x** **j**u**mps** o**v**er the **lazy** **d**o**g** \".\n\n",
                "**Example 2:**\n\n**Input:** key =  \"eljuxhpwnyrdgtqkviszcfmabo \", message =  \"zwx hnfx lqantp mnoeius ycgk vcnjrdb \"\n**Output:**  \"the five boxing wizards jump quickly \"\n**Explanation:** The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in  \"**eljuxhpwnyrdgtqkviszcfmabo** \"."
            ],
            "constraints": "**Constraints:**\n\n*   `26 <= key.length <= 2000`\n*   `key` consists of lowercase English letters and `' '`.\n*   `key` contains every letter in the English alphabet (`'a'` to `'z'`) **at least once**.\n*   `1 <= message.length <= 2000`\n*   `message` consists of lowercase English letters and `' '`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"thequickbrownfoxjumpsoverthelazydog\",\"vkbsbstsuepuv\"",
                "output": "\"thisisasecret\""
            },
            {
                "input": "\"eljuxhpwnyrdgtqkviszcfmabo\",\"zwxhnfxlqantpmnoeiusycgkvcnjrdb\"",
                "output": "\"thefiveboxingwizardsjumpquickly\""
            }
        ],
        "java": "\n    ```java\npublic int validSelections(String s) {\n    int res = 0;\n    for (int i = 1; i < s.length() - 1; i++) {\n        if (!s.substring(i - 1, i).equals(s.substring(i, i + 1)) &&\n            !s.substring(i, i + 1).equals(s.substring(i + 1, i + 2)) &&\n            !s.substring(i - 1, i).equals(s.substring(i + 1, i + 2))) {\n            res++;\n        }\n    }\n    return res;\n}\n```\n    \n    We iterate through the binary string `s` starting from index 1 till the second-last character in the string. For each character `s[i]`, we check three conditions: \n1. s[i-1] should be different from s[i]\n2. s[i] should be different from s[i+1]\n3. s[i+1] should be different from s[i-1]\n\nIf all these conditions are met for the current index `i`, then we can increment the result counter. Finally, we return the result counter, which is the number of valid ways to select 3 buildings.\n    ",
        "python": "\n    ```python\ndef valid_selections(s: str) -> int:\n    res = 0\n    for i in range(1, len(s) - 1):\n        if s[i - 1] != s[i] and s[i] != s[i + 1] and s[i - 1] != s[i + 1]:\n            res += 1\n    return res\n```\n    \n    We iterate through the binary string `s` starting from index 1 till the second-last character in the string. For each character `s[i]`, we check three conditions: \n1. s[i-1] should be different from s[i]\n2. s[i] should be different from s[i+1]\n3. s[i+1] should be different from s[i-1]\n\nIf all these conditions are met for the current index `i`, then we can increment the result counter. Finally, we return the result counter, which is the number of valid ways to select 3 buildings.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nint validSelections(const std::string& s) {\n    int res = 0;\n    for (int i = 1; i < s.size() - 1; ++i) {\n        if (s[i - 1] != s[i] && s[i] != s[i + 1] && s[i + 1] != s[i - 1]) {\n            res++;\n        }\n    }\n    return res;\n}\n```\n    \n    We iterate through the binary string `s` starting from index 1 till the second-last character in the string. For each character `s[i]`, we check three conditions: \n1. s[i-1] should be different from s[i]\n2. s[i] should be different from s[i+1]\n3. s[i+1] should be different from s[i-1]\n\nIf all these conditions are met for the current index `i`, then we can increment the result counter. Finally, we return the result counter, which is the number of valid ways to select 3 buildings.\n    ",
        "js": "\n    ```javascript\nfunction validSelections(s) {\n    let res = 0;\n    for (let i = 1; i < s.length - 1; i++) {\n        if (s[i - 1] !== s[i] && s[i] !== s[i + 1] && s[i - 1] !== s[i + 1]) {\n            res++;\n        }\n    }\n    return res;\n}\n```\n    \n    We iterate through the binary string `s` starting from index 1 till the second-last character in the string. For each character `s[i]`, we check three conditions: \n1. s[i-1] should be different from s[i]\n2. s[i] should be different from s[i+1]\n3. s[i+1] should be different from s[i-1]\n\nIf all these conditions are met for the current index `i`, then we can increment the result counter. Finally, we return the result counter, which is the number of valid ways to select 3 buildings.\n    "
    },
    {
        "id": 425,
        "title": "Evaluate Boolean Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the `root` of a **full binary tree** with the following properties:\n\n*   **Leaf nodes** have either the value `0` or `1`, where `0` represents `False` and `1` represents `True`.\n*   **Non-leaf nodes** have either the value `2` or `3`, where `2` represents the boolean `OR` and `3` represents the boolean `AND`.\n\nThe **evaluation** of a node is as follows:\n\n*   If the node is a leaf node, the evaluation is the **value** of the node, i.e. `True` or `False`.\n*   Otherwise, **evaluate** the node's two children and **apply** the boolean operation of its value with the children's evaluations.\n\nReturn _the boolean result of **evaluating** the_ `root` _node._\n\nA **full binary tree** is a binary tree where each node has either `0` or `2` children.\n\nA **leaf node** is a node that has zero children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[2,1,3,null,null,0,1\\]\n**Output:** true\n**Explanation:** The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0\\]\n**Output:** false\n**Explanation:** The root node is a leaf node and it evaluates to false, so we return false."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `0 <= Node.val <= 3`\n*   Every node has either `0` or `2` children.\n*   Leaf nodes have a value of `0` or `1`.\n*   Non-leaf nodes have a value of `2` or `3`.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[2,1,3,null,null,0,1]",
                "output": "true"
            },
            {
                "input": "[0]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean evalTree(TreeNode root) {\n    if (root.left == null && root.right == null)\n        return root.val == 1;\n    boolean left = evalTree(root.left);\n    boolean right = evalTree(root.right);\n    \n    if (root.val == 2)\n        return left || right;\n    return left && right;\n}\n```\n\n    \n    This problem uses a binary tree to calculate boolean values.\n\nThe algorithm for this problem is a recursive depth-first search.\n1. If the current node is a leaf node, return its value (`True` / `False`).\n2. If the current node is a non-leaf node, recursively compute the values of its left and right children.\n3. If the current node is an `OR` node, return the result of `left || right`. If it's an `AND` node, return the result of `left && right`.\n\nThe base case here is when the node is a leaf node, and the recursion will stop, returning its boolean value. At each level of recursion, it will evaluate the operator associated with the node and build up the final result.\n    ",
        "python": "\n    ```python\ndef evalTree(root: 'TreeNode') -> bool:\n    if not root.left and not root.right:\n        return root.val == 1\n    left = evalTree(root.left)\n    right = evalTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    return left and right\n```\n\n    \n    This problem uses a binary tree to calculate boolean values.\n\nThe algorithm for this problem is a recursive depth-first search.\n1. If the current node is a leaf node, return its value (`True` / `False`).\n2. If the current node is a non-leaf node, recursively compute the values of its left and right children.\n3. If the current node is an `OR` node, return the result of `left || right`. If it's an `AND` node, return the result of `left && right`.\n\nThe base case here is when the node is a leaf node, and the recursion will stop, returning its boolean value. At each level of recursion, it will evaluate the operator associated with the node and build up the final result.\n    ",
        "c++": "\n    ```cpp\nbool evalTree(TreeNode* root) {\n    if (!root->left && !root->right)\n        return root->val;\n    bool left = evalTree(root->left);\n    bool right = evalTree(root->right);\n\n    if (root->val == 2)\n        return left || right;\n    return left && right;\n}\n```\n\n    \n    This problem uses a binary tree to calculate boolean values.\n\nThe algorithm for this problem is a recursive depth-first search.\n1. If the current node is a leaf node, return its value (`True` / `False`).\n2. If the current node is a non-leaf node, recursively compute the values of its left and right children.\n3. If the current node is an `OR` node, return the result of `left || right`. If it's an `AND` node, return the result of `left && right`.\n\nThe base case here is when the node is a leaf node, and the recursion will stop, returning its boolean value. At each level of recursion, it will evaluate the operator associated with the node and build up the final result.\n    ",
        "js": "\n    ```javascript\nfunction evalTree(root) {\n    if (!root.left && !root.right)\n        return root.val === 1;\n    const left = evalTree(root.left);\n    const right = evalTree(root.right);\n\n    if (root.val === 2)\n        return left || right;\n    return left && right;\n}\n```\n\n    \n    This problem uses a binary tree to calculate boolean values.\n\nThe algorithm for this problem is a recursive depth-first search.\n1. If the current node is a leaf node, return its value (`True` / `False`).\n2. If the current node is a non-leaf node, recursively compute the values of its left and right children.\n3. If the current node is an `OR` node, return the result of `left || right`. If it's an `AND` node, return the result of `left && right`.\n\nThe base case here is when the node is a leaf node, and the recursion will stop, returning its boolean value. At each level of recursion, it will evaluate the operator associated with the node and build up the final result.\n    "
    },
    {
        "id": 426,
        "title": "Minimum Amount of Time to Fill Cups",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water.\n\nYou are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return _the **minimum** number of seconds needed to fill up all the cups_.",
            "examples": [
                "**Example 1:**\n\n**Input:** amount = \\[1,4,2\\]\n**Output:** 4\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n\n",
                "**Example 2:**\n\n**Input:** amount = \\[5,4,4\\]\n**Output:** 7\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n\n",
                "**Example 3:**\n\n**Input:** amount = \\[5,0,0\\]\n**Output:** 5\n**Explanation:** Every second, we fill up a cold cup."
            ],
            "constraints": "**Constraints:**\n\n*   `amount.length == 3`\n*   `0 <= amount[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[1,4,2]",
                "output": "4"
            },
            {
                "input": "[5,4,4]",
                "output": "7"
            },
            {
                "input": "[5,0,0]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minSeconds(int[] amount) {\n    int total = amount[0] + amount[1] + amount[2];\n    int largestTwo = Math.max(amount[0] + amount[1], Math.max(amount[1] + amount[2], amount[0] + amount[2]));\n    return (total + 1) / 2 - (largestTwo + 1) / 2 + largestTwo;\n}\n```\n    \n    First, calculate the total number of cups required (total) and the combined amount of the two largest amounts of cups (largest_two). The minimum number of seconds needed is the sum of half the total (rounded up), minus half the largest_two (rounded up) plus largest_two. This should give us the minimum number of seconds to fill up all the cups.\n    ",
        "python": "\n    ```python\ndef min_seconds(amount: List[int]) -> int:\n    total = sum(amount)\n    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])\n    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two\n```\n    \n    First, calculate the total number of cups required (total) and the combined amount of the two largest amounts of cups (largest_two). The minimum number of seconds needed is the sum of half the total (rounded up), minus half the largest_two (rounded up) plus largest_two. This should give us the minimum number of seconds to fill up all the cups.\n    ",
        "c++": "\n    ```cpp\nint min_seconds(vector<int>& amount) {\n    int total = accumulate(amount.begin(), amount.end(), 0);\n    int largest_two = max(amount[0] + amount[1], max(amount[1] + amount[2], amount[0] + amount[2]));\n    return (total + 1) / 2 - (largest_two + 1) / 2 + largest_two;\n}\n```\n    \n    First, calculate the total number of cups required (total) and the combined amount of the two largest amounts of cups (largest_two). The minimum number of seconds needed is the sum of half the total (rounded up), minus half the largest_two (rounded up) plus largest_two. This should give us the minimum number of seconds to fill up all the cups.\n    ",
        "js": "\n    ```javascript\nfunction minSeconds(amount) {\n    const total = amount[0] + amount[1] + amount[2];\n    const largestTwo = Math.max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2]);\n    return Math.floor((total + 1) / 2) - Math.floor((largestTwo + 1) / 2) + largestTwo;\n}\n```\n    \n    First, calculate the total number of cups required (total) and the combined amount of the two largest amounts of cups (largest_two). The minimum number of seconds needed is the sum of half the total (rounded up), minus half the largest_two (rounded up) plus largest_two. This should give us the minimum number of seconds to fill up all the cups.\n    "
    },
    {
        "id": 427,
        "title": "Maximum Number of Pairs in Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. In one operation, you may do the following:\n\n*   Choose **two** integers in `nums` that are **equal**.\n*   Remove both integers from `nums`, forming a **pair**.\n\nThe operation is done on `nums` as many times as possible.\n\nReturn _a **0-indexed** integer array_ `answer` _of size_ `2` _where_ `answer[0]` _is the number of pairs that are formed and_ `answer[1]` _is the number of leftover integers in_ `nums` _after doing the operation as many times as possible_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,1,3,2,2\\]\n**Output:** \\[3,1\\]\n**Explanation:**\nForm a pair with nums\\[0\\] and nums\\[3\\] and remove them from nums. Now, nums = \\[3,2,3,2,2\\].\nForm a pair with nums\\[0\\] and nums\\[2\\] and remove them from nums. Now, nums = \\[2,2,2\\].\nForm a pair with nums\\[0\\] and nums\\[1\\] and remove them from nums. Now, nums = \\[2\\].\nNo more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[1,0\\]\n**Explanation:** Form a pair with nums\\[0\\] and nums\\[1\\] and remove them from nums. Now, nums = \\[\\].\nNo more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0,1\\]\n**Explanation:** No pairs can be formed, and there is 1 number leftover in nums."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,3,2,1,3,2,2]",
                "output": "[3,1]"
            },
            {
                "input": "[1,1]",
                "output": "[1,0]"
            },
            {
                "input": "[0]",
                "output": "[0,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int[] countPairsLeftovers(int[] nums) {\n    HashMap<Integer, Integer> counter = new HashMap<>();\n    int pairs = 0, leftovers = 0;\n\n    for (int n : nums) {\n        counter.put(n, counter.getOrDefault(n, 0) + 1);\n    }\n\n    for (int count : counter.values()) {\n        pairs += count / 2;\n        leftovers += count % 2;\n    }\n\n    return new int[]{pairs, leftovers};\n}\n```\n    \n    The algorithm first initializes an array or hash map (in Java) to count the occurrences of each number in the given `nums` array. Then, it iterates through the input array `nums` and increments the count of each number. \n\nAfter that, the algorithm iterates over the counter array or values (in Java, using `.values()`) and calculates the number of pairs and leftovers for each element. The number of pairs for an element is equal to the integer division of its count by 2 (`count // 2` or `count / 2`), and the number of leftovers is equal to the count modulo 2 (`count % 2`).\n\nFinally, the function returns an array containing the total number of pairs and leftovers.\n    ",
        "python": "\n    ```python\ndef count_pairs_leftovers(nums):\n    counter = [0] * 101\n    pairs, leftovers = 0, 0\n\n    for n in nums:\n        counter[n] += 1\n\n    for count in counter:\n        pairs += count // 2\n        leftovers += count % 2\n\n    return [pairs, leftovers]\n```\n    \n    The algorithm first initializes an array or hash map (in Java) to count the occurrences of each number in the given `nums` array. Then, it iterates through the input array `nums` and increments the count of each number. \n\nAfter that, the algorithm iterates over the counter array or values (in Java, using `.values()`) and calculates the number of pairs and leftovers for each element. The number of pairs for an element is equal to the integer division of its count by 2 (`count // 2` or `count / 2`), and the number of leftovers is equal to the count modulo 2 (`count % 2`).\n\nFinally, the function returns an array containing the total number of pairs and leftovers.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int>& nums) {\n    vector<int> counter(101, 0);\n    int pairs = 0, leftovers = 0;\n\n    for (int n : nums) {\n        counter[n]++;\n    }\n\n    for (int count : counter) {\n        pairs += count / 2;\n        leftovers += count % 2;\n    }\n\n    return {pairs, leftovers};\n}\n```\n    \n    The algorithm first initializes an array or hash map (in Java) to count the occurrences of each number in the given `nums` array. Then, it iterates through the input array `nums` and increments the count of each number. \n\nAfter that, the algorithm iterates over the counter array or values (in Java, using `.values()`) and calculates the number of pairs and leftovers for each element. The number of pairs for an element is equal to the integer division of its count by 2 (`count // 2` or `count / 2`), and the number of leftovers is equal to the count modulo 2 (`count % 2`).\n\nFinally, the function returns an array containing the total number of pairs and leftovers.\n    ",
        "js": "\n    ```javascript\nfunction countPairsLeftovers(nums) {\n    let counter = new Array(101).fill(0);\n    let pairs = 0, leftovers = 0;\n\n    for (let n of nums) {\n        counter[n]++;\n    }\n\n    for (let count of counter) {\n        pairs += Math.floor(count / 2);\n        leftovers += count % 2;\n    }\n\n    return [pairs, leftovers];\n}\n```\n    \n    The algorithm first initializes an array or hash map (in Java) to count the occurrences of each number in the given `nums` array. Then, it iterates through the input array `nums` and increments the count of each number. \n\nAfter that, the algorithm iterates over the counter array or values (in Java, using `.values()`) and calculates the number of pairs and leftovers for each element. The number of pairs for an element is equal to the integer division of its count by 2 (`count // 2` or `count / 2`), and the number of leftovers is equal to the count modulo 2 (`count % 2`).\n\nFinally, the function returns an array containing the total number of pairs and leftovers.\n    "
    },
    {
        "id": 428,
        "title": "Best Poker Hand",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `ranks` and a character array `suits`. You have `5` cards where the `ith` card has a rank of `ranks[i]` and a suit of `suits[i]`.\n\nThe following are the types of **poker hands** you can make from best to worst:\n\n1.  `\"Flush \"`: Five cards of the same suit.\n2.  `\"Three of a Kind \"`: Three cards of the same rank.\n3.  `\"Pair \"`: Two cards of the same rank.\n4.  `\"High Card \"`: Any single card.\n\nReturn _a string representing the **best** type of **poker hand** you can make with the given cards._\n\n**Note** that the return values are **case-sensitive**.",
            "examples": [
                "**Example 1:**\n\n**Input:** ranks = \\[13,2,3,1,9\\], suits = \\[ \"a \", \"a \", \"a \", \"a \", \"a \"\\]\n**Output:**  \"Flush \"\n**Explanation:** The hand with all the cards consists of 5 cards with the same suit, so we have a  \"Flush \".\n\n",
                "**Example 2:**\n\n**Input:** ranks = \\[4,4,2,4,4\\], suits = \\[ \"d \", \"a \", \"a \", \"b \", \"c \"\\]\n**Output:**  \"Three of a Kind \"\n**Explanation:** The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a  \"Three of a Kind \".\nNote that we could also make a  \"Pair \" hand but  \"Three of a Kind \" is a better hand.\nAlso note that other cards could be used to make the  \"Three of a Kind \" hand.\n\n",
                "**Example 3:**\n\n**Input:** ranks = \\[10,10,2,12,9\\], suits = \\[ \"a \", \"b \", \"c \", \"a \", \"d \"\\]\n**Output:**  \"Pair \"\n**Explanation:** The hand with the first and second card consists of 2 cards with the same rank, so we have a  \"Pair \".\nNote that we cannot make a  \"Flush \" or a  \"Three of a Kind \"."
            ],
            "constraints": "**Constraints:**\n\n*   `ranks.length == suits.length == 5`\n*   `1 <= ranks[i] <= 13`\n*   `'a' <= suits[i] <= 'd'`\n*   No two cards have the same rank and suit.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[13,2,3,1,9],[\"a\",\"a\",\"a\",\"a\",\"a\"]",
                "output": "\"Flush\""
            },
            {
                "input": "[4,4,2,4,4],[\"d\",\"a\",\"a\",\"b\",\"c\"]",
                "output": "\"ThreeofaKind\""
            },
            {
                "input": "[10,10,2,12,9],[\"a\",\"b\",\"c\",\"a\",\"d\"]",
                "output": "\"Pair\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static String bestPokerHand(int[] ranks, char[] suits) {\n        Map<Integer, Integer> rankCount = new HashMap<>();\n        Map<Character, Integer> suitCount = new HashMap<>();\n        for (int i = 0; i < ranks.length; i++) {\n            rankCount.put(ranks[i], rankCount.getOrDefault(ranks[i], 0) + 1);\n            suitCount.put(suits[i], suitCount.getOrDefault(suits[i], 0) + 1);\n        }\n        if (suitCount.size() == 1) return \"Flush \";\n        if (rankCount.size() == 3) return \"Three of a Kind \";\n        for (Map.Entry<Integer, Integer> entry : rankCount.entrySet()) {\n            if (entry.getValue() == 2) return \"Pair \";\n        }\n        return \"High Card \";\n    }\n}\n```\n\n    \n    We first iterate through the `ranks` and `suits` arrays and store the count of each rank and suit in two separate hash maps (`rank_count` and `suit_count` respectively). Then we check the following to determine the best poker hand:\n1. If `suit_count` has only one key, it means all cards have the same suit, so the result is a \"Flush \".\n2. If `rank_count` has only three keys, it means there's a \"Three of a Kind \", because there are either 3 of one rank and 1 each of two other ranks or 2 of one rank and 1 each of three other ranks.\n3. If we find a value of 2 in `rank_count`, it implies there's a \"Pair \".\n4. If none of the above conditions are met, the result is a \"High Card \".\n    ",
        "python": "\n    ```python\ndef best_poker_hand(ranks, suits):\n    rank_count = {}\n    suit_count = {}\n    for rank, suit in zip(ranks, suits):\n        rank_count[rank] = rank_count.get(rank, 0) + 1\n        suit_count[suit] = suit_count.get(suit, 0) + 1\n    if len(suit_count) == 1:\n        return \"Flush \"\n    if len(rank_count) == 3:\n        return \"Three of a Kind \"\n    for value in rank_count.values():\n        if value == 2:\n            return \"Pair \"\n    return \"High Card \"\n```\n\n    \n    We first iterate through the `ranks` and `suits` arrays and store the count of each rank and suit in two separate hash maps (`rank_count` and `suit_count` respectively). Then we check the following to determine the best poker hand:\n1. If `suit_count` has only one key, it means all cards have the same suit, so the result is a \"Flush \".\n2. If `rank_count` has only three keys, it means there's a \"Three of a Kind \", because there are either 3 of one rank and 1 each of two other ranks or 2 of one rank and 1 each of three other ranks.\n3. If we find a value of 2 in `rank_count`, it implies there's a \"Pair \".\n4. If none of the above conditions are met, the result is a \"High Card \".\n    ",
        "c++": "\n    ```cpp\n#include <map>\n#include <string>\n#include <vector>\n\nstd::string bestPokerHand(std::vector<int> &ranks, std::vector<char> &suits) {\n    std::map<int, int> rank_count;\n    std::map<char, int> suit_count;\n    for (int i = 0; i < ranks.size(); ++i) {\n        rank_count[ranks[i]]++;\n        suit_count[suits[i]]++;\n    }\n    if (suit_count.size() == 1) return \"Flush \";\n    if (rank_count.size() == 3) return \"Three of a Kind \";\n    for (const auto &pair : rank_count) {\n        if (pair.second == 2) return \"Pair \";\n    }\n    return \"High Card \";\n}\n```\n\n    \n    We first iterate through the `ranks` and `suits` arrays and store the count of each rank and suit in two separate hash maps (`rank_count` and `suit_count` respectively). Then we check the following to determine the best poker hand:\n1. If `suit_count` has only one key, it means all cards have the same suit, so the result is a \"Flush \".\n2. If `rank_count` has only three keys, it means there's a \"Three of a Kind \", because there are either 3 of one rank and 1 each of two other ranks or 2 of one rank and 1 each of three other ranks.\n3. If we find a value of 2 in `rank_count`, it implies there's a \"Pair \".\n4. If none of the above conditions are met, the result is a \"High Card \".\n    ",
        "js": "\n    ```javascript\nfunction bestPokerHand(ranks, suits) {\n    const rankCount = new Map();\n    const suitCount = new Map();\n    for (let i = 0; i < ranks.length; i++) {\n        rankCount.set(ranks[i], (rankCount.get(ranks[i]) || 0) + 1);\n        suitCount.set(suits[i], (suitCount.get(suits[i]) || 0) + 1);\n    }\n    if (suitCount.size === 1) return \"Flush \";\n    if (rankCount.size === 3) return \"Three of a Kind \";\n    for (const value of rankCount.values()) {\n        if (value === 2) return \"Pair \";\n    }\n    return \"High Card \";\n}\n```\n\n    \n    We first iterate through the `ranks` and `suits` arrays and store the count of each rank and suit in two separate hash maps (`rank_count` and `suit_count` respectively). Then we check the following to determine the best poker hand:\n1. If `suit_count` has only one key, it means all cards have the same suit, so the result is a \"Flush \".\n2. If `rank_count` has only three keys, it means there's a \"Three of a Kind \", because there are either 3 of one rank and 1 each of two other ranks or 2 of one rank and 1 each of three other ranks.\n3. If we find a value of 2 in `rank_count`, it implies there's a \"Pair \".\n4. If none of the above conditions are met, the result is a \"High Card \".\n    "
    },
    {
        "id": 429,
        "title": "First Letter to Appear Twice",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` consisting of lowercase English letters, return _the first letter to appear **twice**_.\n\n**Note**:\n\n*   A letter `a` appears twice before another letter `b` if the **second** occurrence of `a` is before the **second** occurrence of `b`.\n*   `s` will contain at least one letter that appears twice.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abccbaacz \"\n**Output:**  \"c \"\n**Explanation:**\nThe letter 'a' appears on the indexes 0, 5 and 6.\nThe letter 'b' appears on the indexes 1 and 4.\nThe letter 'c' appears on the indexes 2, 3 and 7.\nThe letter 'z' appears on the index 8.\nThe letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdd \"\n**Output:**  \"d \"\n**Explanation:**\nThe only letter that appears twice is 'd' so we return 'd'."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 100`\n*   `s` consists of lowercase English letters.\n*   `s` has at least one repeated letter.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "example": [
            {
                "input": "\"abccbaacz\"",
                "output": "\"c\""
            },
            {
                "input": "\"abcdd\"",
                "output": "\"d\""
            }
        ],
        "java": "\n    ```java\npublic char firstLetterToAppearTwice(String s) {\n    int[] occurrences = new int[26];\n    for (char c : s.toCharArray()) {\n        occurrences[c - 'a']++;\n        if (occurrences[c - 'a'] == 2) {\n            return c;\n        }\n    }\n    return '?';\n}\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    ",
        "python": "\n    ```python\ndef first_letter_to_appear_twice(s: str) -> str:\n    occurrences = [0] * 26\n    for c in s:\n        occurrences[ord(c) - ord('a')] += 1\n        if occurrences[ord(c) - ord('a')] == 2:\n            return c\n    return '?'\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    ",
        "c++": "\n    ```cpp\nchar firstLetterToAppearTwice(std::string s) {\n    std::array<int, 26> occurrences;\n    occurrences.fill(0);\n    for (char c : s) {\n        occurrences[c - 'a']++;\n        if (occurrences[c - 'a'] == 2) {\n            return c;\n        }\n    }\n    return '?';\n}\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    ",
        "js": "\n    ```javascript\nfunction firstLetterToAppearTwice(s) {\n    const occurrences = new Array(26).fill(0);\n    for (let c of s) {\n        occurrences[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        if (occurrences[c.charCodeAt(0) - 'a'.charCodeAt(0)] == 2) {\n            return c;\n        }\n    }\n    return '?';\n}\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    "
    },
    {
        "id": 430,
        "title": "Make Array Zero by Subtracting Equal Amounts",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a non-negative integer array `nums`. In one operation, you must:\n\n*   Choose a positive integer `x` such that `x` is less than or equal to the **smallest non-zero** element in `nums`.\n*   Subtract `x` from every **positive** element in `nums`.\n\nReturn _the **minimum** number of operations to make every element in_ `nums` _equal to_ `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,5,0,3,5\\]\n**Output:** 3\n**Explanation:**\nIn the first operation, choose x = 1. Now, nums = \\[0,4,0,2,4\\].\nIn the second operation, choose x = 2. Now, nums = \\[0,2,0,0,2\\].\nIn the third operation, choose x = 2. Now, nums = \\[0,0,0,0,0\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** 0\n**Explanation:** Each element in nums is already 0 so no operations are needed."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,5,0,3,5]",
                "output": "3"
            },
            {
                "input": "[0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int count = 0;\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            count += nums.length - (Arrays.binarySearch(nums, i, nums.length, nums[i] + 1) < 0 ? -Arrays.binarySearch(nums, i, nums.length, nums[i] + 1) - 1 : Arrays.binarySearch(nums, i, nums.length, nums[i] + 1));\n            i = (Arrays.binarySearch(nums, nums[i] + 1) < 0 ? -Arrays.binarySearch(nums, nums[i] + 1) - 2 : Arrays.binarySearch(nums, nums[i] + 1)) - 1;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Sort the given array in non-descending order.\n2. Initialize a variable count to store the number of operations.\n3. Iterate through the sorted array.\n   - If the current element is positive, find the count of elements with the same value.\n   - Add this count to the overall count and update i to skip these elements.\n   - If the current element is not positive, just move to the next element.\n4. Return the overall count (number of operations).\n\nThis algorithm works because after sorting the array, we traverse it and count distinct positive numbers. Each distinct positive number corresponds to a unique operation that reduces it to zero while also reducing any larger numbers in the array. Since the operation only affects positive numbers, we can skip the zero elements. By the end of the algorithm, we have counted the minimum number of operations required to make all elements equal to zero.\n    ",
        "python": "\n    ```python\ndef minOperations(nums):\n    count = 0\n    nums.sort()\n    i = 0\n\n    while i < len(nums):\n        if nums[i] > 0:\n            target = nums[i]\n            while i < len(nums) and nums[i] == target:\n                i += 1\n            count += 1\n        else:\n            i += 1\n\n    return count\n```\n    \n    1. Sort the given array in non-descending order.\n2. Initialize a variable count to store the number of operations.\n3. Iterate through the sorted array.\n   - If the current element is positive, find the count of elements with the same value.\n   - Add this count to the overall count and update i to skip these elements.\n   - If the current element is not positive, just move to the next element.\n4. Return the overall count (number of operations).\n\nThis algorithm works because after sorting the array, we traverse it and count distinct positive numbers. Each distinct positive number corresponds to a unique operation that reduces it to zero while also reducing any larger numbers in the array. Since the operation only affects positive numbers, we can skip the zero elements. By the end of the algorithm, we have counted the minimum number of operations required to make all elements equal to zero.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums) {\n    int count = 0;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            count += nums.end() - (std::upper_bound(nums.begin() + i, nums.end(), nums[i]));\n            i = (std::upper_bound(nums.begin(), nums.end(), nums[i])) - nums.begin() - 1;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Sort the given array in non-descending order.\n2. Initialize a variable count to store the number of operations.\n3. Iterate through the sorted array.\n   - If the current element is positive, find the count of elements with the same value.\n   - Add this count to the overall count and update i to skip these elements.\n   - If the current element is not positive, just move to the next element.\n4. Return the overall count (number of operations).\n\nThis algorithm works because after sorting the array, we traverse it and count distinct positive numbers. Each distinct positive number corresponds to a unique operation that reduces it to zero while also reducing any larger numbers in the array. Since the operation only affects positive numbers, we can skip the zero elements. By the end of the algorithm, we have counted the minimum number of operations required to make all elements equal to zero.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    let count = 0;\n    nums.sort((a, b) => a - b);\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            const target = nums[i];\n            while (i < nums.length && nums[i] === target) {\n                i++;\n            }\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Sort the given array in non-descending order.\n2. Initialize a variable count to store the number of operations.\n3. Iterate through the sorted array.\n   - If the current element is positive, find the count of elements with the same value.\n   - Add this count to the overall count and update i to skip these elements.\n   - If the current element is not positive, just move to the next element.\n4. Return the overall count (number of operations).\n\nThis algorithm works because after sorting the array, we traverse it and count distinct positive numbers. Each distinct positive number corresponds to a unique operation that reduces it to zero while also reducing any larger numbers in the array. Since the operation only affects positive numbers, we can skip the zero elements. By the end of the algorithm, we have counted the minimum number of operations required to make all elements equal to zero.\n    "
    },
    {
        "id": 431,
        "title": "Merge Similar Items",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two 2D integer arrays, `items1` and `items2`, representing two sets of items. Each array `items` has the following properties:\n\n*   `items[i] = [valuei, weighti]` where `valuei` represents the **value** and `weighti` represents the **weight** of the `ith` item.\n*   The value of each item in `items` is **unique**.\n\nReturn _a 2D integer array_ `ret` _where_ `ret[i] = [valuei, weighti]`_,_ _with_ `weighti` _being the **sum of weights** of all items with value_ `valuei`.\n\n**Note:** `ret` should be returned in **ascending** order by value.",
            "examples": [
                "**Example 1:**\n\n**Input:** items1 = \\[\\[1,1\\],\\[4,5\\],\\[3,8\\]\\], items2 = \\[\\[3,1\\],\\[1,5\\]\\]\n**Output:** \\[\\[1,6\\],\\[3,9\\],\\[4,5\\]\\]\n**Explanation:** \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\nThe item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\nThe item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \nTherefore, we return \\[\\[1,6\\],\\[3,9\\],\\[4,5\\]\\].\n\n",
                "**Example 2:**\n\n**Input:** items1 = \\[\\[1,1\\],\\[3,2\\],\\[2,3\\]\\], items2 = \\[\\[2,1\\],\\[3,2\\],\\[1,3\\]\\]\n**Output:** \\[\\[1,4\\],\\[2,4\\],\\[3,4\\]\\]\n**Explanation:** \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\nThe item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\nThe item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\nTherefore, we return \\[\\[1,4\\],\\[2,4\\],\\[3,4\\]\\].\n\n",
                "**Example 3:**\n\n**Input:** items1 = \\[\\[1,3\\],\\[2,2\\]\\], items2 = \\[\\[7,1\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** \\[\\[1,7\\],\\[2,4\\],\\[7,1\\]\\]\n**Explanation:**\nThe item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \nThe item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \nThe item with value = 7 occurs in items2 with weight = 1, total weight = 1.\nTherefore, we return \\[\\[1,7\\],\\[2,4\\],\\[7,1\\]\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= items1.length, items2.length <= 1000`\n*   `items1[i].length == items2[i].length == 2`\n*   `1 <= valuei, weighti <= 1000`\n*   Each `valuei` in `items1` is **unique**.\n*   Each `valuei` in `items2` is **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[1,1],[4,5],[3,8]],[[3,1],[1,5]]",
                "output": "[[1,6],[3,9],[4,5]]"
            },
            {
                "input": "[[1,1],[3,2],[2,3]],[[2,1],[3,2],[1,3]]",
                "output": "[[1,4],[2,4],[3,4]]"
            },
            {
                "input": "[[1,3],[2,2]],[[7,1],[2,2],[1,4]]",
                "output": "[[1,7],[2,4],[7,1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Main {\n    public static List<List<Integer>> sumWeights(List<List<Integer>> items1, List<List<Integer>> items2) {\n        Map<Integer, Integer> weightSums = new TreeMap<>();\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (List<Integer> item : items1) {\n            weightSums.put(item.get(0), weightSums.getOrDefault(item.get(0), 0) + item.get(1));\n        }\n        for (List<Integer> item : items2) {\n            weightSums.put(item.get(0), weightSums.getOrDefault(item.get(0), 0) + item.get(1));\n        }\n\n        for (Map.Entry<Integer, Integer> entry : weightSums.entrySet()) {\n            result.add(Arrays.asList(entry.getKey(), entry.getValue()));\n        }\n\n        return result;\n    }\n}\n```\n    \n    1. Create a map called `weightSums` to store the sum of weights for every `value`. Initialize an empty list `result` for returning the solution.\n2. Iterate over the `items1` and `items2` arrays. For each `[value, weight]` pair, add the weight to the `weightSums` map for that value. If the value is not present in the map, set its value to be equal to the current weight.\n3. Loop through the sorted `weightSums` items (by key/values in ascending order), and append each `[value, weight]` to the `result` list.\n4. Return the `result` list.\n    ",
        "python": "\n    ```python\ndef sum_weights(items1, items2):\n    weight_sums = {}\n    result = []\n\n    for value, weight in items1:\n        weight_sums[value] = weight_sums.get(value, 0) + weight\n    for value, weight in items2:\n        weight_sums[value] = weight_sums.get(value, 0) + weight\n\n    for value, weight in sorted(weight_sums.items()):\n        result.append([value, weight])\n\n    return result\n```\n    \n    1. Create a map called `weightSums` to store the sum of weights for every `value`. Initialize an empty list `result` for returning the solution.\n2. Iterate over the `items1` and `items2` arrays. For each `[value, weight]` pair, add the weight to the `weightSums` map for that value. If the value is not present in the map, set its value to be equal to the current weight.\n3. Loop through the sorted `weightSums` items (by key/values in ascending order), and append each `[value, weight]` to the `result` list.\n4. Return the `result` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\nusing namespace std;\n\nvector<vector<int>> sumWeights(vector<vector<int>>& items1, vector<vector<int>>& items2) {\n    map<int, int> weightSums;\n    vector<vector<int>> result;\n\n    for (const auto& item : items1) {\n        weightSums[item[0]] += item[1];\n    }\n    for (const auto& item : items2) {\n        weightSums[item[0]] += item[1];\n    }\n\n    for (const auto& entry : weightSums) {\n        result.push_back({entry.first, entry.second});\n    }\n\n    return result;\n}\n```\n    \n    1. Create a map called `weightSums` to store the sum of weights for every `value`. Initialize an empty list `result` for returning the solution.\n2. Iterate over the `items1` and `items2` arrays. For each `[value, weight]` pair, add the weight to the `weightSums` map for that value. If the value is not present in the map, set its value to be equal to the current weight.\n3. Loop through the sorted `weightSums` items (by key/values in ascending order), and append each `[value, weight]` to the `result` list.\n4. Return the `result` list.\n    ",
        "js": "\n    ```javascript\nfunction sumWeights(items1, items2) {\n    const weightSums = new Map();\n    const result = [];\n\n    items1.forEach(([value, weight]) => {\n        weightSums.set(value, (weightSums.get(value) || 0) + weight);\n    });\n    items2.forEach(([value, weight]) => {\n        weightSums.set(value, (weightSums.get(value) || 0) + weight);\n    });\n\n    for (const [value, weight] of Array.from(weightSums.entries()).sort((a, b) => a[0] - b[0])) {\n        result.push([value, weight]);\n    }\n\n    return result;\n}\n```\n    \n    1. Create a map called `weightSums` to store the sum of weights for every `value`. Initialize an empty list `result` for returning the solution.\n2. Iterate over the `items1` and `items2` arrays. For each `[value, weight]` pair, add the weight to the `weightSums` map for that value. If the value is not present in the map, set its value to be equal to the current weight.\n3. Loop through the sorted `weightSums` items (by key/values in ascending order), and append each `[value, weight]` to the `result` list.\n4. Return the `result` list.\n    "
    },
    {
        "id": 432,
        "title": "Number of Arithmetic Triplets",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed**, **strictly increasing** integer array `nums` and a positive integer `diff`. A triplet `(i, j, k)` is an **arithmetic triplet** if the following conditions are met:\n\n*   `i < j < k`,\n*   `nums[j] - nums[i] == diff`, and\n*   `nums[k] - nums[j] == diff`.\n\nReturn _the number of unique **arithmetic triplets**._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,4,6,7,10\\], diff = 3\n**Output:** 2\n**Explanation:**\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,8,9\\], diff = 2\n**Output:** 2\n**Explanation:**\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 200`\n*   `0 <= nums[i] <= 200`\n*   `1 <= diff <= 50`\n*   `nums` is **strictly** increasing.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[0,1,4,6,7,10],3",
                "output": "2"
            },
            {
                "input": "[4,5,6,7,8,9],2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countArithmeticTriplets(int[] nums, int diff) {\n    int count = 0;\n    HashMap<Integer, Integer> mp = new HashMap<>();\n    for (int num : nums) {\n        if (mp.containsKey(num - diff))\n            count += mp.get(num - diff);\n        mp.put(num, mp.getOrDefault(num, 0) + 1);\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    ",
        "python": "\n    ```python\ndef count_arithmetic_triplets(nums, diff):\n    count = 0\n    mp = {}\n    for num in nums:\n        if num - diff in mp:\n            count += mp[num - diff]\n        mp[num] = mp.get(num, 0) + 1\n    return count\n```\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    ",
        "c++": "\n    ```cpp\nint countArithmeticTriplets(vector<int> &nums, int diff) {\n    int count = 0;\n    unordered_map<int, int> mp;\n    for (int num : nums) {\n        if (mp.count(num - diff))\n            count += mp[num - diff];\n        mp[num]++;\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    ",
        "js": "\n    ```javascript\nfunction countArithmeticTriplets(nums, diff) {\n    let count = 0;\n    const mp = new Map();\n    for (const num of nums) {\n        if (mp.has(num - diff))\n            count += mp.get(num - diff);\n        mp.set(num, (mp.get(num) || 0) + 1);\n    }\n    return count;\n}\n```\n\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    "
    },
    {
        "id": 433,
        "title": "Largest Local Values in a Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `n x n` integer matrix `grid`.\n\nGenerate an integer matrix `maxLocal` of size `(n - 2) x (n - 2)` such that:\n\n*   `maxLocal[i][j]` is equal to the **largest** value of the `3 x 3` matrix in `grid` centered around row `i + 1` and column `j + 1`.\n\nIn other words, we want to find the largest value in every contiguous `3 x 3` matrix in `grid`.\n\nReturn _the generated matrix_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[9,9,8,1\\],\\[5,6,2,6\\],\\[8,2,6,4\\],\\[6,2,2,2\\]\\]\n**Output:** \\[\\[9,9\\],\\[8,6\\]\\]\n**Explanation:** The diagram above shows the original matrix and the generated matrix.\nNotice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1,1,1\\],\\[1,1,1,1,1\\],\\[1,1,2,1,1\\],\\[1,1,1,1,1\\],\\[1,1,1,1,1\\]\\]\n**Output:** \\[\\[2,2,2\\],\\[2,2,2\\],\\[2,2,2\\]\\]\n**Explanation:** Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid."
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `3 <= n <= 100`\n*   `1 <= grid[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]",
                "output": "[[9,9],[8,6]]"
            },
            {
                "input": "[[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]",
                "output": "[[2,2,2],[2,2,2],[2,2,2]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic ArrayList<ArrayList<Integer>> largestMatrix(int[][] grid) {\n    int n = grid.length;\n    ArrayList<ArrayList<Integer>> maxLocal = new ArrayList<>();\n\n    for (int i = 1; i < n - 1; ++i) {\n        maxLocal.add(new ArrayList<>());\n        for (int j = 1; j < n - 1; ++j) {\n            int max_val = grid[i - 1][j - 1];\n            for (int x = -1; x <= 1; ++x) {\n                for (int y = -1; y <= 1; ++y) {\n                    max_val = Math.max(max_val, grid[i + x][j + y]);\n                }\n            }\n            maxLocal.get(i - 1).add(max_val);\n        }\n    }\n\n    return maxLocal;\n}\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    ",
        "python": "\n    ```python\ndef largest_matrix(grid):\n    n = len(grid)\n    maxLocal = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            max_val = grid[i - 1][j - 1]\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    max_val = max(max_val, grid[i + x][j + y])\n            maxLocal[i - 1][j - 1] = max_val\n\n    return maxLocal\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> largestMatrix(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    std::vector<std::vector<int>> maxLocal(n - 2, std::vector<int>(n - 2));\n    \n    for (int i = 1; i < n - 1; ++i) {\n        for (int j = 1; j < n - 1; ++j) {\n            int max_val = grid[i - 1][j - 1];\n            for (int x = -1; x <= 1; ++x) {\n                for (int y = -1; y <= 1; ++y) {\n                    max_val = std::max(max_val, grid[i + x][j + y]);\n                }\n            }\n            maxLocal[i - 1][j - 1] = max_val;\n        }\n    }\n    \n    return maxLocal;\n}\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    ",
        "js": "\n    ```javascript\nfunction largestMatrix(grid) {\n    const n = grid.length;\n    const maxLocal = Array.from({ length: n - 2 }, () => Array(n - 2).fill(0));\n\n    for (let i = 1; i < n - 1; ++i) {\n        for (let j = 1; j < n - 1; ++j) {\n            let max_val = grid[i - 1][j - 1];\n            for (let x = -1; x <= 1; ++x) {\n                for (let y = -1; y <= 1; ++y) {\n                    max_val = Math.max(max_val, grid[i + x][j + y]);\n                }\n            }\n            maxLocal[i - 1][j - 1] = max_val;\n        }\n    }\n\n    return maxLocal;\n}\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    "
    },
    {
        "id": 434,
        "title": "Minimum Recolors to Get K Consecutive Black Blocks",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string `blocks` of length `n`, where `blocks[i]` is either `'W'` or `'B'`, representing the color of the `ith` block. The characters `'W'` and `'B'` denote the colors white and black, respectively.\n\nYou are also given an integer `k`, which is the desired number of **consecutive** black blocks.\n\nIn one operation, you can **recolor** a white block such that it becomes a black block.\n\nReturn _the **minimum** number of operations needed such that there is at least **one** occurrence of_ `k` _consecutive black blocks._",
            "examples": [
                "**Example 1:**\n\n**Input:** blocks =  \"WBBWWBBWBW \", k = 7\n**Output:** 3\n**Explanation:**\nOne way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\nso that blocks =  \"BBBBBBBWBW \". \nIt can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\nTherefore, we return 3.\n\n",
                "**Example 2:**\n\n**Input:** blocks =  \"WBWBBBW \", k = 2\n**Output:** 0\n**Explanation:**\nNo changes need to be made, since 2 consecutive black blocks already exist.\nTherefore, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == blocks.length`\n*   `1 <= n <= 100`\n*   `blocks[i]` is either `'W'` or `'B'`.\n*   `1 <= k <= n`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"WBBWWBBWBW\",7",
                "output": "3"
            },
            {
                "input": "\"WBWBBBW\",2",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint minOperations(String blocks, int k) {\n    int n = blocks.length(), res = k, w = 0, b = 0;\n    for (int i = 0, j = 0; j < n; ++j) {\n        if (blocks.charAt(j) == 'W') w++;\n        while (b > k || (b == k && blocks.charAt(i) == 'B')) {\n            if (blocks.charAt(i++) == 'W') w--;\n            else b--;\n        }\n        if (b == k) res = Math.min(res, w);\n        else b++;\n    }\n    return res;\n}\n```\n    \n    The algorithm keeps a sliding window over the blocks string. It simultaneously counts the number of black blocks, `b`, and white blocks, `w`, in the sliding window. \n\nInitially, both the left and right pointers of the sliding window, `i` and `j`, are set to 0. We iterate over the string using the right pointer, `j`. When the black count `b` equals `k`, we minimize the answer by taking the minimum of the current result and the white count `w`.\n\nIf the black count `b` is greater than `k`, or equal to `k` but the left pointer `i` points to a black block, we need to adjust the left pointer to keep only `k` black blocks in the sliding window. To do this, we increment the left pointer and decrement the corresponding color count.\n\nFinally, we return the minimum operation count we found.\n\nNotice that the algorithm executes in linear time. This is because each block is visited exactly twice (once by the right pointer and once by the left pointer), and the color counts are updated during the traversal. This leads to an overall time complexity of O(n) for the algorithm.\n    ",
        "python": "\n    ```python\ndef min_operations(blocks, k):\n    n = len(blocks)\n    res = k\n    w = b = 0\n    i = j = 0\n\n    while j < n:\n        if blocks[j] == 'W':\n            w += 1\n        while b > k or (b == k and blocks[i] == 'B'):\n            if blocks[i] == 'W':\n                w -= 1\n                i += 1\n            else:\n                b -= 1\n                i += 1\n        if b == k:\n            res = min(res, w)\n        else:\n            b += 1\n        j += 1\n    \n    return res\n```\n    \n    The algorithm keeps a sliding window over the blocks string. It simultaneously counts the number of black blocks, `b`, and white blocks, `w`, in the sliding window. \n\nInitially, both the left and right pointers of the sliding window, `i` and `j`, are set to 0. We iterate over the string using the right pointer, `j`. When the black count `b` equals `k`, we minimize the answer by taking the minimum of the current result and the white count `w`.\n\nIf the black count `b` is greater than `k`, or equal to `k` but the left pointer `i` points to a black block, we need to adjust the left pointer to keep only `k` black blocks in the sliding window. To do this, we increment the left pointer and decrement the corresponding color count.\n\nFinally, we return the minimum operation count we found.\n\nNotice that the algorithm executes in linear time. This is because each block is visited exactly twice (once by the right pointer and once by the left pointer), and the color counts are updated during the traversal. This leads to an overall time complexity of O(n) for the algorithm.\n    ",
        "c++": "\n    ```cpp\nint minOperations(string blocks, int k) {\n    int n = blocks.length(), res = k, w = 0, b = 0;\n    for (int i = 0, j = 0; j < n; ++j) {\n        if (blocks[j] == 'W') w++;\n        while (b > k || (b == k && blocks[i] == 'B')) {\n            if (blocks[i++] == 'W') w--;\n            else b--;\n        }\n        if (b == k) res = min(res, w);\n        else b++;\n    }\n    return res;\n}\n```\n    \n    The algorithm keeps a sliding window over the blocks string. It simultaneously counts the number of black blocks, `b`, and white blocks, `w`, in the sliding window. \n\nInitially, both the left and right pointers of the sliding window, `i` and `j`, are set to 0. We iterate over the string using the right pointer, `j`. When the black count `b` equals `k`, we minimize the answer by taking the minimum of the current result and the white count `w`.\n\nIf the black count `b` is greater than `k`, or equal to `k` but the left pointer `i` points to a black block, we need to adjust the left pointer to keep only `k` black blocks in the sliding window. To do this, we increment the left pointer and decrement the corresponding color count.\n\nFinally, we return the minimum operation count we found.\n\nNotice that the algorithm executes in linear time. This is because each block is visited exactly twice (once by the right pointer and once by the left pointer), and the color counts are updated during the traversal. This leads to an overall time complexity of O(n) for the algorithm.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(blocks, k) {\n    let n = blocks.length, res = k, w = 0, b = 0;\n    for (let i = 0, j = 0; j < n; ++j) {\n        if (blocks[j] === 'W') w++;\n        while (b > k || (b === k && blocks[i] === 'B')) {\n            if (blocks[i++] === 'W') w--;\n            else b--;\n        }\n        if (b === k) res = Math.min(res, w);\n        else b++;\n    }\n    return res;\n}\n```\n    \n    The algorithm keeps a sliding window over the blocks string. It simultaneously counts the number of black blocks, `b`, and white blocks, `w`, in the sliding window. \n\nInitially, both the left and right pointers of the sliding window, `i` and `j`, are set to 0. We iterate over the string using the right pointer, `j`. When the black count `b` equals `k`, we minimize the answer by taking the minimum of the current result and the white count `w`.\n\nIf the black count `b` is greater than `k`, or equal to `k` but the left pointer `i` points to a black block, we need to adjust the left pointer to keep only `k` black blocks in the sliding window. To do this, we increment the left pointer and decrement the corresponding color count.\n\nFinally, we return the minimum operation count we found.\n\nNotice that the algorithm executes in linear time. This is because each block is visited exactly twice (once by the right pointer and once by the left pointer), and the color counts are updated during the traversal. This leads to an overall time complexity of O(n) for the algorithm.\n    "
    },
    {
        "id": 435,
        "title": "Longest Subsequence With Limited Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` of length `n`, and an integer array `queries` of length `m`.\n\nReturn _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the **maximum** size of a **subsequence** that you can take from_ `nums` _such that the **sum** of its elements is less than or equal to_ `queries[i]`.\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,5,2,1\\], queries = \\[3,10,21\\]\n**Output:** \\[2,3,4\\]\n**Explanation:** We answer the queries as follows:\n- The subsequence \\[2,1\\] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer\\[0\\] = 2.\n- The subsequence \\[4,5,1\\] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer\\[1\\] = 3.\n- The subsequence \\[4,5,2,1\\] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer\\[2\\] = 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,4,5\\], queries = \\[1\\]\n**Output:** \\[0\\]\n**Explanation:** The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer\\[0\\] = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `m == queries.length`\n*   `1 <= n, m <= 1000`\n*   `1 <= nums[i], queries[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[4,5,2,1],[3,10,21]",
                "output": "[2,3,4]"
            },
            {
                "input": "[2,3,4,5],[1]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] maxSizeSubsequenceSumQueries(int[] nums, int[] queries) {\n    Arrays.sort(nums);\n    int[] prefixSums = new int[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i) {\n        prefixSums[i + 1] = prefixSums[i] + nums[i];\n    }\n\n    int[] answer = new int[queries.length];\n    for (int i = 0; i < queries.length; ++i) {\n        int idx = Arrays.binarySearch(prefixSums, queries[i]);\n        if (idx < 0) {\n            idx = -idx - 1;\n        }\n        answer[i] = idx - 1;\n    }\n\n    return answer;\n}\n```\n    \n    The algorithm sorts the `nums` array in ascending order, then calculates the prefix sums for easy sum checks. For each query, it finds the position for the query in the prefix sums array using binary search, and the index of that position minus one represents the maximum size of a subsequence whose sum is less than or equal to the query. It adds that value to the answer array.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect\n\ndef maxSizeSubsequenceSumQueries(nums, queries):\n    nums.sort()\n    prefixSums = [0] * (len(nums) + 1)\n    for i, x in enumerate(nums):\n        prefixSums[i + 1] = prefixSums[i] + x\n\n    answer = []\n    for q in queries:\n        idx = bisect(prefixSums, q)\n        answer.append(idx - 1)\n\n    return answer\n```\n    \n    The algorithm sorts the `nums` array in ascending order, then calculates the prefix sums for easy sum checks. For each query, it finds the position for the query in the prefix sums array using binary search, and the index of that position minus one represents the maximum size of a subsequence whose sum is less than or equal to the query. It adds that value to the answer array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nstd::vector<int> maxSizeSubsequenceSumQueries(std::vector<int>& nums, std::vector<int>& queries) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<int> prefixSums(nums.size() + 1);\n    std::partial_sum(nums.begin(), nums.end(), prefixSums.begin() + 1);\n    \n    std::vector<int> answer(queries.size());\n    for (int i = 0; i < queries.size(); ++i) {\n        answer[i] = std::upper_bound(prefixSums.begin(), prefixSums.end(), queries[i]) - prefixSums.begin() - 1;\n    }\n    \n    return answer;\n}\n```\n    \n    The algorithm sorts the `nums` array in ascending order, then calculates the prefix sums for easy sum checks. For each query, it finds the position for the query in the prefix sums array using binary search, and the index of that position minus one represents the maximum size of a subsequence whose sum is less than or equal to the query. It adds that value to the answer array.\n    ",
        "js": "\n    ```javascript\nfunction maxSizeSubsequenceSumQueries(nums, queries) {\n    nums.sort((a, b) => a - b);\n    const prefixSums = Array(nums.length + 1).fill(0);\n    for (let i = 0; i < nums.length; ++i) {\n        prefixSums[i + 1] = prefixSums[i] + nums[i];\n    }\n\n    const answer = [];\n    for (const query of queries) {\n        const idx = prefixSums.upperBound(query);\n        answer.push(idx - 1);\n    }\n\n    if (!Array.prototype.upperBound) {\n        Array.prototype.upperBound = function(val) {\n            let left = 0;\n            let right = this.length;\n            while (left < right) {\n                const mid = (left + right) >>> 1;\n                if (this[mid] <= val) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            return left;\n        };\n    }\n\n    return answer;\n}\n```\n    \n    The algorithm sorts the `nums` array in ascending order, then calculates the prefix sums for easy sum checks. For each query, it finds the position for the query in the prefix sums array using binary search, and the index of that position minus one represents the maximum size of a subsequence whose sum is less than or equal to the query. It adds that value to the answer array.\n    "
    },
    {
        "id": 436,
        "title": "Find Subarrays With Equal Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, determine whether there exist **two** subarrays of length `2` with **equal** sum. Note that the two subarrays must begin at **different** indices.\n\nReturn `true` _if these subarrays exist, and_ `false` _otherwise._\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,4\\]\n**Output:** true\n**Explanation:** The subarrays with elements \\[4,2\\] and \\[2,4\\] have the same sum of 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** false\n**Explanation:** No two subarrays of size 2 have the same sum.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** true\n**Explanation:** The subarrays \\[nums\\[0\\],nums\\[1\\]\\] and \\[nums\\[1\\],nums\\[2\\]\\] have the same sum of 0. \nNote that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[4,2,4]",
                "output": "true"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "false"
            },
            {
                "input": "[0,0,0]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean equalSumSubarrays(int[] nums) {\n    Set<Integer> sums = new HashSet<>();\n    for (int i = 1; i < nums.length; ++i) {\n        int sum = nums[i] + nums[i - 1];\n        if (sums.contains(sum)) return true;\n        sums.add(sum);\n    }\n    return false;\n}\n```\n    \n    The algorithm works by iterating through the array, calculating the sum of each pair of adjacent elements, and using a set to store the seen sums. If the current sum already exists in the set, it means that there are two subarrays with equal sums, so the function returns `true`. At the end of the loop, if no such subarrays were found, the function returns `false`.\n\nTime complexity is O(n), where n is the size of the input array, since we are iterating through the elements only once. Space complexity is also O(n) as at worst we have to store all possible sums in the set.\n    ",
        "python": "\n    ```python\ndef equal_sum_subarrays(nums):\n    sums = set()\n    for i in range(1, len(nums)):\n        current_sum = nums[i] + nums[i - 1]\n        if current_sum in sums:\n            return True\n        sums.add(current_sum)\n    return False\n```\n    \n    The algorithm works by iterating through the array, calculating the sum of each pair of adjacent elements, and using a set to store the seen sums. If the current sum already exists in the set, it means that there are two subarrays with equal sums, so the function returns `true`. At the end of the loop, if no such subarrays were found, the function returns `false`.\n\nTime complexity is O(n), where n is the size of the input array, since we are iterating through the elements only once. Space complexity is also O(n) as at worst we have to store all possible sums in the set.\n    ",
        "c++": "\n    ```cpp\nbool equalSumSubarrays(vector<int>& nums) {\n    unordered_set<int> sums;\n    for (int i = 1; i < nums.size(); ++i) {\n        int sum = nums[i] + nums[i - 1];\n        if (sums.count(sum)) return true;\n        sums.insert(sum);\n    }\n    return false;\n}\n```\n    \n    The algorithm works by iterating through the array, calculating the sum of each pair of adjacent elements, and using a set to store the seen sums. If the current sum already exists in the set, it means that there are two subarrays with equal sums, so the function returns `true`. At the end of the loop, if no such subarrays were found, the function returns `false`.\n\nTime complexity is O(n), where n is the size of the input array, since we are iterating through the elements only once. Space complexity is also O(n) as at worst we have to store all possible sums in the set.\n    ",
        "js": "\n    ```javascript\nfunction equalSumSubarrays(nums) {\n    const sums = new Set();\n    for (let i = 1; i < nums.length; ++i) {\n        const sum = nums[i] + nums[i - 1];\n        if (sums.has(sum)) return true;\n        sums.add(sum);\n    }\n    return false;\n}\n```\n    \n    The algorithm works by iterating through the array, calculating the sum of each pair of adjacent elements, and using a set to store the seen sums. If the current sum already exists in the set, it means that there are two subarrays with equal sums, so the function returns `true`. At the end of the loop, if no such subarrays were found, the function returns `false`.\n\nTime complexity is O(n), where n is the size of the input array, since we are iterating through the elements only once. Space complexity is also O(n) as at worst we have to store all possible sums in the set.\n    "
    },
    {
        "id": 437,
        "title": "Check Distances Between Same Letters",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string `s` consisting of only lowercase English letters, where each letter in `s` appears **exactly** **twice**. You are also given a **0-indexed** integer array `distance` of length `26`.\n\nEach letter in the alphabet is numbered from `0` to `25` (i.e. `'a' -> 0`, `'b' -> 1`, `'c' -> 2`, ... , `'z' -> 25`).\n\nIn a **well-spaced** string, the number of letters between the two occurrences of the `ith` letter is `distance[i]`. If the `ith` letter does not appear in `s`, then `distance[i]` can be **ignored**.\n\nReturn `true` _if_ `s` _is a **well-spaced** string, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abaccb \", distance = \\[1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\]\n**Output:** true\n**Explanation:**\n- 'a' appears at indices 0 and 2 so it satisfies distance\\[0\\] = 1.\n- 'b' appears at indices 1 and 5 so it satisfies distance\\[1\\] = 3.\n- 'c' appears at indices 3 and 4 so it satisfies distance\\[2\\] = 0.\nNote that distance\\[3\\] = 5, but since 'd' does not appear in s, it can be ignored.\nReturn true because s is a well-spaced string.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", distance = \\[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\]\n**Output:** false\n**Explanation:**\n- 'a' appears at indices 0 and 1 so there are zero letters between them.\nBecause distance\\[0\\] = 1, s is not a well-spaced string."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 52`\n*   `s` consists only of lowercase English letters.\n*   Each letter appears in `s` exactly twice.\n*   `distance.length == 26`\n*   `0 <= distance[i] <= 50`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"abaccb\",[1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]",
                "output": "true"
            },
            {
                "input": "\"aa\",[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean wellSpacedString(String s, int[] distance) {\n    Integer[] first = new Integer[26];\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s.charAt(i);\n        if (first[c - 'a'] == null) {\n            first[c - 'a'] = i;\n        } else {\n            if (distance[c - 'a'] != i - first[c - 'a'] - 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the characters of the given string `s`. If it encounters a character for the first time, it stores the character along with its index in a map `first`. If it encounters the character for the second time, it checks whether the difference between the current index and the first occurrence of the character minus 1 is equal to the required distance given in the `distance` array. If this condition is not met, the function returns `false`. If the iteration is completed without failing the condition, the function returns `true`.\n    ",
        "python": "\n    ```python\ndef well_spaced_string(s: str, distance: List[int]) -> bool:\n    first = {}\n    for i, c in enumerate(s):\n        if c not in first:\n            first[c] = i\n        else:\n            if distance[ord(c) - ord('a')] != i - first[c] - 1:\n                return False\n    return True\n```\n    \n    The algorithm iterates through the characters of the given string `s`. If it encounters a character for the first time, it stores the character along with its index in a map `first`. If it encounters the character for the second time, it checks whether the difference between the current index and the first occurrence of the character minus 1 is equal to the required distance given in the `distance` array. If this condition is not met, the function returns `false`. If the iteration is completed without failing the condition, the function returns `true`.\n    ",
        "c++": "\n    ```cpp\nbool wellSpacedString(std::string s, std::vector<int> distance) {\n    std::unordered_map<char, int> first;\n    for (int i = 0; i < s.size(); ++i) {\n        char c = s[i];\n        if (first.find(c) == first.end()) {\n            first[c] = i;\n        } else {\n            if (distance[c - 'a'] != i - first[c] - 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the characters of the given string `s`. If it encounters a character for the first time, it stores the character along with its index in a map `first`. If it encounters the character for the second time, it checks whether the difference between the current index and the first occurrence of the character minus 1 is equal to the required distance given in the `distance` array. If this condition is not met, the function returns `false`. If the iteration is completed without failing the condition, the function returns `true`.\n    ",
        "js": "\n    ```javascript\nfunction wellSpacedString(s, distance) {\n    const first = {};\n    for (let i = 0; i < s.length; ++i) {\n        const c = s[i];\n        if (c in first === false) {\n            first[c] = i;\n        } else {\n            if (distance[c.charCodeAt(0) - 'a'.charCodeAt(0)] !== i - first[c] - 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the characters of the given string `s`. If it encounters a character for the first time, it stores the character along with its index in a map `first`. If it encounters the character for the second time, it checks whether the difference between the current index and the first occurrence of the character minus 1 is equal to the required distance given in the `distance` array. If this condition is not met, the function returns `false`. If the iteration is completed without failing the condition, the function returns `true`.\n    "
    },
    {
        "id": 438,
        "title": "Most Frequent Even Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the most frequent even element_.\n\nIf there is a tie, return the **smallest** one. If there is no such element, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,2,4,4,1\\]\n**Output:** 2\n**Explanation:**\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,4,4,9,2,4\\]\n**Output:** 4\n**Explanation:** 4 is the even element appears the most.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[29,47,21,41,13,37,25,7\\]\n**Output:** -1\n**Explanation:** There is no even element."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `0 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[0,1,2,2,4,4,1]",
                "output": "2"
            },
            {
                "input": "[4,4,4,9,2,4]",
                "output": "4"
            },
            {
                "input": "[29,47,21,41,13,37,25,7]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int mostFrequentEven(int[] nums) {\n    Map<Integer, Integer> count = new HashMap<>();\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n    }\n    int maxCount = Integer.MIN_VALUE;\n    int mostFrequent = -1;\n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n        int num = entry.getKey();\n        int freq = entry.getValue();\n        if (freq > maxCount || (freq == maxCount && num < mostFrequent)) {\n            maxCount = freq;\n            mostFrequent = num;\n        }\n    }\n    return mostFrequent;\n}\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    ",
        "python": "\n    ```python\ndef most_frequent_even(nums):\n    count = {}\n    for num in nums:\n        if num % 2 == 0:\n            count[num] = count.get(num, 0) + 1\n    max_count = float('-inf')\n    most_frequent = -1\n    for num, freq in count.items():\n        if freq > max_count or (freq == max_count and num < most_frequent):\n            max_count = freq\n            most_frequent = num\n    return most_frequent\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    ",
        "c++": "\n    ```cpp\nint mostFrequentEven(vector<int>& nums) {\n    unordered_map<int, int> count;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            count[num]++;\n        }\n    }\n    int max_count = INT_MIN;\n    int most_frequent = -1;\n    for (auto& [num, freq] : count) {\n        if (freq > max_count || (freq == max_count && num < most_frequent)) {\n            max_count = freq;\n            most_frequent = num;\n        }\n    }\n    return most_frequent;\n}\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    ",
        "js": "\n    ```javascript\nfunction mostFrequentEven(nums) {\n    let count = {};\n    for (let num of nums) {\n        if (num % 2 === 0) {\n            count[num] = (count[num] || 0) + 1;\n        }\n    }\n    let maxCount = Number.MIN_SAFE_INTEGER;\n    let mostFrequent = -1;\n    for (let num in count) {\n        let freq = count[num];\n        if (freq > maxCount || (freq === maxCount && parseInt(num) < mostFrequent)) {\n            maxCount = freq;\n            mostFrequent = parseInt(num);\n        }\n    }\n    return mostFrequent;\n}\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    "
    },
    {
        "id": 439,
        "title": "Count Days Spent Together",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice and Bob are traveling to Rome for separate business meetings.\n\nYou are given 4 strings `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob`. Alice will be in the city from the dates `arriveAlice` to `leaveAlice` (**inclusive**), while Bob will be in the city from the dates `arriveBob` to `leaveBob` (**inclusive**). Each will be a 5-character string in the format `\"MM-DD \"`, corresponding to the month and day of the date.\n\nReturn _the total number of days that Alice and Bob are in Rome together._\n\nYou can assume that all dates occur in the **same** calendar year, which is **not** a leap year. Note that the number of days per month can be represented as: `[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arriveAlice =  \"08-15 \", leaveAlice =  \"08-18 \", arriveBob =  \"08-16 \", leaveBob =  \"08-19 \"\n**Output:** 3\n**Explanation:** Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\n",
                "**Example 2:**\n\n**Input:** arriveAlice =  \"10-01 \", leaveAlice =  \"10-31 \", arriveBob =  \"11-01 \", leaveBob =  \"12-31 \"\n**Output:** 0\n**Explanation:** There is no day when Alice and Bob are in Rome together, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   All dates are provided in the format `\"MM-DD \"`.\n*   Alice and Bob's arrival dates are **earlier than or equal to** their leaving dates.\n*   The given dates are valid dates of a **non-leap** year.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"08-15\",\"08-18\",\"08-16\",\"08-19\"",
                "output": "3"
            },
            {
                "input": "\"10-01\",\"10-31\",\"11-01\",\"12-31\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int daysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\n    int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int arriveDaysAlice = dateToDays(arriveAlice, daysInMonth);\n    int leaveDaysAlice = dateToDays(leaveAlice, daysInMonth);\n    int arriveDaysBob = dateToDays(arriveBob, daysInMonth);\n    int leaveDaysBob = dateToDays(leaveBob, daysInMonth);\n\n    int commonStartDate = Math.max(arriveDaysAlice, arriveDaysBob);\n    int commonEndDate = Math.min(leaveDaysAlice, leaveDaysBob);\n\n    return Math.max(0, commonEndDate - commonStartDate + 1);\n}\n\nprivate int dateToDays(String date, int[] daysInMonth) {\n    int month = Integer.parseInt(date.substring(0, 2));\n    int day = Integer.parseInt(date.substring(3, 5));\n    int days = day;\n\n    for (int i = 1; i < month; i++) {\n        days += daysInMonth[i];\n    }\n\n    return days;\n}\n```\n    \n    1. Store the days in each month of a non-leap year in an array `daysInMonth`.\n2. Define a function `dateToDays` that takes a date string and the `daysInMonth` array, then converts the date string to the total number of days from the beginning of the year. Calculate this by summing up days from prior months plus the day of the month.\n3. Compute the total number of days for `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob` by calling `dateToDays`.\n4. Calculate the common starting date by taking the max of `arriveDaysAlice` and `arriveDaysBob`.\n5. Calculate the common end date by taking the min of `leaveDaysAlice` and `leaveDaysBob`.\n6. Calculate and return the total number of days Alice and Bob are in Rome together by finding the difference between the common end and start dates, adding 1, and taking the max between that result and 0.\n    ",
        "python": "\n    ```python\ndef days_together(arrive_alice, leave_alice, arrive_bob, leave_bob):\n    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def date_to_days(date):\n        month, day = map(int, date.split('-'))\n        return sum(days_in_month[:month]) + day\n\n    arrive_days_alice = date_to_days(arrive_alice)\n    leave_days_alice = date_to_days(leave_alice)\n    arrive_days_bob = date_to_days(arrive_bob)\n    leave_days_bob = date_to_days(leave_bob)\n\n    common_start_date = max(arrive_days_alice, arrive_days_bob)\n    common_end_date = min(leave_days_alice, leave_days_bob)\n\n    return max(0, common_end_date - common_start_date + 1)\n```\n    \n    1. Store the days in each month of a non-leap year in an array `daysInMonth`.\n2. Define a function `dateToDays` that takes a date string and the `daysInMonth` array, then converts the date string to the total number of days from the beginning of the year. Calculate this by summing up days from prior months plus the day of the month.\n3. Compute the total number of days for `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob` by calling `dateToDays`.\n4. Calculate the common starting date by taking the max of `arriveDaysAlice` and `arriveDaysBob`.\n5. Calculate the common end date by taking the min of `leaveDaysAlice` and `leaveDaysBob`.\n6. Calculate and return the total number of days Alice and Bob are in Rome together by finding the difference between the common end and start dates, adding 1, and taking the max between that result and 0.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n\nint daysTogether(const std::string& arriveAlice, const std::string& leaveAlice, const std::string& arriveBob, const std::string& leaveBob) {\n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    auto dateToDays = [&](const std::string& date) {\n        int month = stoi(date.substr(0, 2));\n        int day = stoi(date.substr(3, 2));\n        int days = day;\n        for (int i = 1; i < month; ++i) {\n            days += daysInMonth[i];\n        }\n        return days;\n    };\n\n    int arriveDaysAlice = dateToDays(arriveAlice);\n    int leaveDaysAlice = dateToDays(leaveAlice);\n    int arriveDaysBob = dateToDays(arriveBob);\n    int leaveDaysBob = dateToDays(leaveBob);\n\n    int commonStartDate = std::max(arriveDaysAlice, arriveDaysBob);\n    int commonEndDate = std::min(leaveDaysAlice, leaveDaysBob);\n\n    return std::max(0, commonEndDate - commonStartDate + 1);\n}\n```\n    \n    1. Store the days in each month of a non-leap year in an array `daysInMonth`.\n2. Define a function `dateToDays` that takes a date string and the `daysInMonth` array, then converts the date string to the total number of days from the beginning of the year. Calculate this by summing up days from prior months plus the day of the month.\n3. Compute the total number of days for `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob` by calling `dateToDays`.\n4. Calculate the common starting date by taking the max of `arriveDaysAlice` and `arriveDaysBob`.\n5. Calculate the common end date by taking the min of `leaveDaysAlice` and `leaveDaysBob`.\n6. Calculate and return the total number of days Alice and Bob are in Rome together by finding the difference between the common end and start dates, adding 1, and taking the max between that result and 0.\n    ",
        "js": "\n    ```javascript\nfunction daysTogether(arriveAlice, leaveAlice, arriveBob, leaveBob) {\n    const daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    function dateToDays(date) {\n        const [month, day] = date.split('-').map(str => parseInt(str, 10));\n        return daysInMonth.slice(0, month).reduce((a, b) => a + b, day);\n    }\n\n    const arriveDaysAlice = dateToDays(arriveAlice);\n    const leaveDaysAlice = dateToDays(leaveAlice);\n    const arriveDaysBob = dateToDays(arriveBob);\n    const leaveDaysBob = dateToDays(leaveBob);\n\n    const commonStartDate = Math.max(arriveDaysAlice, arriveDaysBob);\n    const commonEndDate = Math.min(leaveDaysAlice, leaveDaysBob);\n\n    return Math.max(0, commonEndDate - commonStartDate + 1);\n}\n```\n    \n    1. Store the days in each month of a non-leap year in an array `daysInMonth`.\n2. Define a function `dateToDays` that takes a date string and the `daysInMonth` array, then converts the date string to the total number of days from the beginning of the year. Calculate this by summing up days from prior months plus the day of the month.\n3. Compute the total number of days for `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob` by calling `dateToDays`.\n4. Calculate the common starting date by taking the max of `arriveDaysAlice` and `arriveDaysBob`.\n5. Calculate the common end date by taking the min of `leaveDaysAlice` and `leaveDaysBob`.\n6. Calculate and return the total number of days Alice and Bob are in Rome together by finding the difference between the common end and start dates, adding 1, and taking the max between that result and 0.\n    "
    },
    {
        "id": 440,
        "title": "Smallest Even Multiple",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **positive** integer `n`, return _the smallest positive integer that is a multiple of **both**_ `2` _and_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 10\n**Explanation:** The smallest multiple of both 5 and 2 is 10.\n\n",
                "**Example 2:**\n\n**Input:** n = 6\n**Output:** 6\n**Explanation:** The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 150`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "5",
                "output": "10"
            },
            {
                "input": "6",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int smallestMultiple(int n) {\n    return n % 2 == 0 ? n : n * 2;\n}\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "python": "\n    ```python\ndef smallest_multiple(n):\n    return n if n % 2 == 0 else n * 2\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "c++": "\n    ```cpp\nint smallestMultiple(int n) {\n    return n % 2 == 0 ? n : n * 2;\n}\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "js": "\n    ```javascript\nfunction smallestMultiple(n) {\n    return n % 2 === 0 ? n : n * 2;\n}\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    "
    },
    {
        "id": 441,
        "title": "Sort the People",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of strings `names`, and an array `heights` that consists of **distinct** positive integers. Both arrays are of length `n`.\n\nFor each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person.\n\nReturn `names` _sorted in **descending** order by the people's heights_.",
            "examples": [
                "**Example 1:**\n\n**Input:** names = \\[ \"Mary \", \"John \", \"Emma \"\\], heights = \\[180,165,170\\]\n**Output:** \\[ \"Mary \", \"Emma \", \"John \"\\]\n**Explanation:** Mary is the tallest, followed by Emma and John.\n\n",
                "**Example 2:**\n\n**Input:** names = \\[ \"Alice \", \"Bob \", \"Bob \"\\], heights = \\[155,185,150\\]\n**Output:** \\[ \"Bob \", \"Alice \", \"Bob \"\\]\n**Explanation:** The first Bob is the tallest, followed by Alice and the second Bob."
            ],
            "constraints": "**Constraints:**\n\n*   `n == names.length == heights.length`\n*   `1 <= n <= 103`\n*   `1 <= names[i].length <= 20`\n*   `1 <= heights[i] <= 105`\n*   `names[i]` consists of lower and upper case English letters.\n*   All the values of `heights` are distinct.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "[\"Mary\",\"John\",\"Emma\"],[180,165,170]",
                "output": "[\"Mary\",\"Emma\",\"John\"]"
            },
            {
                "input": "[\"Alice\",\"Bob\",\"Bob\"],[155,185,150]",
                "output": "[\"Bob\",\"Alice\",\"Bob\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic List<String> sortNamesByHeight(String[] names, int[] heights) {\n    List<Pair> nameHeightPairs = new ArrayList<>();\n\n    for(int i = 0; i < names.length; i++) {\n        nameHeightPairs.add(new Pair(heights[i], names[i]));\n    }\n\n    nameHeightPairs.sort((a, b) -> b.height - a.height);\n\n    List<String> sortedNames = new ArrayList<>();\n    for(Pair pair : nameHeightPairs) {\n        sortedNames.add(pair.name);\n    }\n\n    return sortedNames;\n}\n\nclass Pair {\n    int height;\n    String name;\n\n    public Pair(int height, String name) {\n        this.height = height;\n        this.name = name;\n    }\n}\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "python": "\n    ```python\ndef sort_names_by_height(names, heights):\n    name_height_pairs = sorted(zip(heights, names), reverse=True)\n    sorted_names = [pair[1] for pair in name_height_pairs]\n    return sorted_names\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> sortNamesByHeight(std::vector<std::string>& names, std::vector<int>& heights) {\n    std::vector<std::pair<int, std::string>> name_height_pairs;\n\n    for(int i = 0; i < names.size(); i++) {\n        name_height_pairs.push_back(std::make_pair(heights[i], names[i]));\n    }\n\n    std::sort(name_height_pairs.rbegin(), name_height_pairs.rend());\n\n    std::vector<std::string> sorted_names;\n    for(auto& pair : name_height_pairs) {\n        sorted_names.push_back(pair.second);\n    }\n\n    return sorted_names;\n}\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "js": "\n    ```javascript\nfunction sortNamesByHeight(names, heights) {\n    let nameHeightPairs = [];\n\n    for(let i = 0; i < names.length; i++) {\n        nameHeightPairs.push({name: names[i], height: heights[i]});\n    }\n\n    nameHeightPairs.sort((a, b) => b.height - a.height);\n\n    let sortedNames = nameHeightPairs.map(pair => pair.name);\n\n    return sortedNames;\n}\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    "
    },
    {
        "id": 442,
        "title": "Remove Letter To Equalize Frequency",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string `word`, consisting of lowercase English letters. You need to select **one** index and **remove** the letter at that index from `word` so that the **frequency** of every letter present in `word` is equal.\n\nReturn `true` _if it is possible to remove one letter so that the frequency of all letters in_ `word` _are equal, and_ `false` _otherwise_.\n\n**Note:**\n\n*   The **frequency** of a letter `x` is the number of times it occurs in the string.\n*   You **must** remove exactly one letter and cannot chose to do nothing.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"abcc \"\n**Output:** true\n**Explanation:** Select index 3 and delete it: word becomes  \"abc \" and each character has a frequency of 1.\n\n",
                "**Example 2:**\n\n**Input:** word =  \"aazz \"\n**Output:** false\n**Explanation:** We must delete a character, so either the frequency of  \"a \" is 1 and the frequency of  \"z \" is 2, or vice versa. It is impossible to make all present letters have equal frequency."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= word.length <= 100`\n*   `word` consists of lowercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"abcc\"",
                "output": "true"
            },
            {
                "input": "\"aazz\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean canEqualFrequency(String word) {\n    HashMap<Character, Integer> freq = new HashMap<>();\n    for (char c : word.toCharArray()) {\n        freq.put(c, freq.getOrDefault(c, 0) + 1);\n    }\n\n    HashMap<Integer, Integer> count_freq = new HashMap<>();\n    for (int f : freq.values()) {\n        count_freq.put(f, count_freq.getOrDefault(f, 0) + 1);\n    }\n\n    if (count_freq.size() != 2) {\n        return false;\n    }\n\n    int a = (int) count_freq.keySet().toArray()[0];\n    int acount = count_freq.get(a);\n    int b = (int) count_freq.keySet().toArray()[1];\n    int bcount = count_freq.get(b);\n\n    return (acount == 1 && (a - 1 == b || a == 1)) || (bcount == 1 && (b - 1 == a || b == 1));\n}\n```\n    \n    1. First, we create a frequency map `freq` that counts the frequency of each character in the given `word`.\n2. Then, we create another map `count_freq` that counts the frequencies of the values in the `freq` map.\n3. If the size of `count_freq` is not 2, return false since we must remove exactly one character.\n4. If the size of `count_freq` is 2, we iterate through the items of the `count_freq` map.\n5. We check if the map contains a single entry with frequency 1 and either the other frequency is one less than the single entry frequency or it is 1.\n6. If either of the above two conditions is met, we can remove one character so that the remaining letters have equal frequencies. In this case, we return `true`. Otherwise, we return `false`.\n    ",
        "python": "\n    ```python\ndef can_equal_frequency(word: str) -> bool:\n    freq = {}\n    for c in word:\n        freq[c] = freq.get(c, 0) + 1\n\n    count_freq = {}\n    for f in freq.values():\n        count_freq[f] = count_freq.get(f, 0) + 1\n\n    if len(count_freq) != 2:\n        return False\n\n    a, acount = next(iter(count_freq.items()))\n    b, bcount = next(reversed(list(count_freq.items())))\n\n    return (acount == 1 and (a - 1 == b or a == 1)) or (bcount == 1 and (b - 1 == a or b == 1))\n```\n    \n    1. First, we create a frequency map `freq` that counts the frequency of each character in the given `word`.\n2. Then, we create another map `count_freq` that counts the frequencies of the values in the `freq` map.\n3. If the size of `count_freq` is not 2, return false since we must remove exactly one character.\n4. If the size of `count_freq` is 2, we iterate through the items of the `count_freq` map.\n5. We check if the map contains a single entry with frequency 1 and either the other frequency is one less than the single entry frequency or it is 1.\n6. If either of the above two conditions is met, we can remove one character so that the remaining letters have equal frequencies. In this case, we return `true`. Otherwise, we return `false`.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nbool canEqualFrequency(std::string word) {\n    std::unordered_map<char, int> freq;\n    for (char c : word) {\n        freq[c]++;\n    }\n    \n    std::unordered_map<int, int> count_freq;\n    for (auto &[c, f] : freq) {\n        count_freq[f]++;\n    }\n    \n    if (count_freq.size() != 2) {\n        return false;\n    }\n    \n    auto it = count_freq.begin();\n    auto &[a, acount] = *it;\n    it++;\n    auto &[b, bcount] = *it;\n    \n    return (acount == 1 && (a - 1 == b || a == 1)) || (bcount == 1 && (b - 1 == a || b == 1));\n}\n```\n    \n    1. First, we create a frequency map `freq` that counts the frequency of each character in the given `word`.\n2. Then, we create another map `count_freq` that counts the frequencies of the values in the `freq` map.\n3. If the size of `count_freq` is not 2, return false since we must remove exactly one character.\n4. If the size of `count_freq` is 2, we iterate through the items of the `count_freq` map.\n5. We check if the map contains a single entry with frequency 1 and either the other frequency is one less than the single entry frequency or it is 1.\n6. If either of the above two conditions is met, we can remove one character so that the remaining letters have equal frequencies. In this case, we return `true`. Otherwise, we return `false`.\n    ",
        "js": "\n    ```javascript\nfunction canEqualFrequency(word) {\n    const freq = new Map();\n    for (const c of word) {\n        freq.set(c, (freq.get(c) || 0) + 1);\n    }\n\n    const count_freq = new Map();\n    for (const f of freq.values()) {\n        count_freq.set(f, (count_freq.get(f) || 0) + 1);\n    }\n\n    if (count_freq.size != 2) {\n        return false;\n    }\n\n    const [[a, acount], [b, bcount]] = count_freq.entries();\n\n    return (acount === 1 && (a - 1 === b || a === 1)) || (bcount === 1 && (b - 1 === a || b === 1));\n}\n```\n    \n    1. First, we create a frequency map `freq` that counts the frequency of each character in the given `word`.\n2. Then, we create another map `count_freq` that counts the frequencies of the values in the `freq` map.\n3. If the size of `count_freq` is not 2, return false since we must remove exactly one character.\n4. If the size of `count_freq` is 2, we iterate through the items of the `count_freq` map.\n5. We check if the map contains a single entry with frequency 1 and either the other frequency is one less than the single entry frequency or it is 1.\n6. If either of the above two conditions is met, we can remove one character so that the remaining letters have equal frequencies. In this case, we return `true`. Otherwise, we return `false`.\n    "
    },
    {
        "id": 443,
        "title": "Number of Common Factors",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two positive integers `a` and `b`, return _the number of **common** factors of_ `a` _and_ `b`.\n\nAn integer `x` is a **common factor** of `a` and `b` if `x` divides both `a` and `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = 12, b = 6\n**Output:** 4\n**Explanation:** The common factors of 12 and 6 are 1, 2, 3, 6.\n\n",
                "**Example 2:**\n\n**Input:** a = 25, b = 30\n**Output:** 2\n**Explanation:** The common factors of 25 and 30 are 1, 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a, b <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "example": [
            {
                "input": "12,6",
                "output": "4"
            },
            {
                "input": "25,30",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int commonFactors(int a, int b) {\n    int gcd = gcd(a, b);\n    int count = 0;\n    for (int i = 1; i * i <= gcd; i++) {\n        if (gcd % i == 0) {\n            count++;\n            if (i * i != gcd)\n                count++;\n        }\n    }\n    return count;\n}\n\nprivate int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    ",
        "python": "\n    ```python\ndef common_factors(a: int, b: int) -> int:\n    from math import gcd\n\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i * i != g:\n                count += 1\n    return count\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    ",
        "c++": "\n    ```cpp\nint commonFactors(int a, int b) {\n    int gcd = std::__gcd(a, b); \n    int count = 0;\n    for (int i = 1; i * i <= gcd; i++) {\n        if (gcd % i == 0) {\n            count++;\n            if (i * i != gcd)\n                count++;\n        }\n    }\n    return count;\n}\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    ",
        "js": "\n    ```javascript\nfunction commonFactors(a, b) {\n    let gcd = (a, b) => b === 0 ? a : gcd(b, a % b);\n    let g = gcd(a, b);\n    let count = 0;\n    for (let i = 1; i * i <= g; i++) {\n        if (g % i === 0) {\n            count++;\n            if (i * i !== g)\n                count++;\n        }\n    }\n    return count;\n}\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    "
    },
    {
        "id": 444,
        "title": "The Employee That Worked on the Longest Task",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` employees, each with a unique id from `0` to `n - 1`.\n\nYou are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where:\n\n*   `idi` is the id of the employee that worked on the `ith` task, and\n*   `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**.\n\nNote that the `ith` task starts the moment right after the `(i - 1)th` task ends, and the `0th` task starts at time `0`.\n\nReturn _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10, logs = \\[\\[0,3\\],\\[2,5\\],\\[0,9\\],\\[1,15\\]\\]\n**Output:** 1\n**Explanation:** \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 26, logs = \\[\\[1,1\\],\\[3,7\\],\\[2,12\\],\\[7,17\\]\\]\n**Output:** 3\n**Explanation:** \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n\n",
                "**Example 3:**\n\n**Input:** n = 2, logs = \\[\\[0,10\\],\\[1,20\\]\\]\n**Output:** 0\n**Explanation:** \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 500`\n*   `1 <= logs.length <= 500`\n*   `logs[i].length == 2`\n*   `0 <= idi <= n - 1`\n*   `1 <= leaveTimei <= 500`\n*   `idi != idi+1`\n*   `leaveTimei` are sorted in a strictly increasing order.",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "10,[[0,3],[2,5],[0,9],[1,15]]",
                "output": "1"
            },
            {
                "input": "26,[[1,1],[3,7],[2,12],[7,17]]",
                "output": "3"
            },
            {
                "input": "2,[[0,10],[1,20]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int workerWithLongestTask(int n, int[][] logs) {\n    int result = 0;\n    int max_time = logs[0][1] - 0;\n\n    for (int i = 1; i < logs.length; ++i) {\n        int time = logs[i][1] - logs[i-1][1];\n        if (time > max_time) {\n            max_time = time;\n            result = logs[i][0];\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the array `logs` one task at a time. For each task, the algorithm computes the time it took to complete the task by subtracting the leave time of the previous task from the leave time of the current task. We initialize the `max_time` with the first task duration and set the `result` to the ID of the first task worker.\n\nDuring iteration, if the computed time for the current task is greater than the `max_time`, the algorithm updates the `max_time` to the current task's time and selects the worker of the current task as `result`.\n\nAfter iterating through all tasks, the algorithm returns the worker ID in `result`, which is the worker that worked the task with the longest time. If there is a tie, the algorithm will return the smallest ID among them since we only update the `result` when we find a strictly greater time.\n    ",
        "python": "\n    ```python\ndef worker_with_longest_task(n, logs):\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result\n```\n    \n    The algorithm iterates through the array `logs` one task at a time. For each task, the algorithm computes the time it took to complete the task by subtracting the leave time of the previous task from the leave time of the current task. We initialize the `max_time` with the first task duration and set the `result` to the ID of the first task worker.\n\nDuring iteration, if the computed time for the current task is greater than the `max_time`, the algorithm updates the `max_time` to the current task's time and selects the worker of the current task as `result`.\n\nAfter iterating through all tasks, the algorithm returns the worker ID in `result`, which is the worker that worked the task with the longest time. If there is a tie, the algorithm will return the smallest ID among them since we only update the `result` when we find a strictly greater time.\n    ",
        "c++": "\n    ```cpp\nint workerWithLongestTask(int n, vector<vector<int>>& logs) {\n    int result = 0;\n    int max_time = logs[0][1] - 0;\n\n    for (int i = 1; i < logs.size(); ++i) {\n        int time = logs[i][1] - logs[i-1][1];\n        if (time > max_time) {\n            max_time = time;\n            result = logs[i][0];\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the array `logs` one task at a time. For each task, the algorithm computes the time it took to complete the task by subtracting the leave time of the previous task from the leave time of the current task. We initialize the `max_time` with the first task duration and set the `result` to the ID of the first task worker.\n\nDuring iteration, if the computed time for the current task is greater than the `max_time`, the algorithm updates the `max_time` to the current task's time and selects the worker of the current task as `result`.\n\nAfter iterating through all tasks, the algorithm returns the worker ID in `result`, which is the worker that worked the task with the longest time. If there is a tie, the algorithm will return the smallest ID among them since we only update the `result` when we find a strictly greater time.\n    ",
        "js": "\n    ```javascript\nfunction workerWithLongestTask(n, logs) {\n    let result = 0;\n    let max_time = logs[0][1] - 0;\n\n    for (let i = 1; i < logs.length; ++i) {\n        let time = logs[i][1] - logs[i-1][1];\n        if (time > max_time) {\n            max_time = time;\n            result = logs[i][0];\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the array `logs` one task at a time. For each task, the algorithm computes the time it took to complete the task by subtracting the leave time of the previous task from the leave time of the current task. We initialize the `max_time` with the first task duration and set the `result` to the ID of the first task worker.\n\nDuring iteration, if the computed time for the current task is greater than the `max_time`, the algorithm updates the `max_time` to the current task's time and selects the worker of the current task as `result`.\n\nAfter iterating through all tasks, the algorithm returns the worker ID in `result`, which is the worker that worked the task with the longest time. If there is a tie, the algorithm will return the smallest ID among them since we only update the `result` when we find a strictly greater time.\n    "
    },
    {
        "id": 445,
        "title": "Number of Valid Clock Times",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string of length `5` called `time`, representing the current time on a digital clock in the format `\"hh:mm \"`. The **earliest** possible time is `\"00:00 \"` and the **latest** possible time is `\"23:59 \"`.\n\nIn the string `time`, the digits represented by the `?` symbol are **unknown**, and must be **replaced** with a digit from `0` to `9`.\n\nReturn _an integer_ `answer`_, the number of valid clock times that can be created by replacing every_ `?` _with a digit from_ `0` _to_ `9`.",
            "examples": [
                "**Example 1:**\n\n**Input:** time =  \"?5:00 \"\n**Output:** 2\n**Explanation:** We can replace the ? with either a 0 or 1, producing  \"05:00 \" or  \"15:00 \". Note that we cannot replace it with a 2, since the time  \"25:00 \" is invalid. In total, we have two choices.\n\n",
                "**Example 2:**\n\n**Input:** time =  \"0?:0? \"\n**Output:** 100\n**Explanation:** Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\n",
                "**Example 3:**\n\n**Input:** time =  \"??:?? \"\n**Output:** 1440\n**Explanation:** There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 \\* 60 = 1440 choices."
            ],
            "constraints": "**Constraints:**\n\n*   `time` is a valid string of length `5` in the format `\"hh:mm \"`.\n*   `\"00 \" <= hh <= \"23 \"`\n*   `\"00 \" <= mm <= \"59 \"`\n*   Some of the digits might be replaced with `'?'` and need to be replaced with digits from `0` to `9`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Enumeration"
        ],
        "example": [
            {
                "input": "\"?5:00\"",
                "output": "2"
            },
            {
                "input": "\"0?:0?\"",
                "output": "100"
            },
            {
                "input": "\"??:??\"",
                "output": "1440"
            }
        ],
        "java": "\n    ```java\npublic int countValidTimes(String time) {\n    int count = 1;\n    if(time.charAt(0) == '?') {\n        count *= (time.charAt(1) == '?' || time.charAt(1) < '4') ? 3 : 2;\n    }\n    if(time.charAt(1) == '?') {\n        count *= (time.charAt(0) == '2') ? 4 : 10;\n    }\n    if(time.charAt(3) == '?') {\n        count *= 6;\n    }\n    if(time.charAt(4) == '?') {\n        count *= 10;\n    }\n    return count;\n}\n```\n\n    \n    1. If the first character is '?', check if the second character is also '?' or less than '4', in that case the valid possibilities for the first character are '0', '1' or '2', so we multiply our count by 3. If the second character is greater than or equal to '4', then the valid possibilities for the first character are only '0' or '1', so we multiply our count by 2.\n2. If the second character is '?', check if the first character is '2', in that case, the valid possibilities for the second character are '0', '1', '2' and '3', so we multiply our count by 4. If the first character is not '2', then the valid possibilities for the second character are 0 to 9, so we multiply our count by 10.\n3. If the third character is '?', the valid possibilities are '0' to '5', so we multiply our count by 6.\n4. If the fourth character is '?', the valid possibilities are 0 to 9, so we multiply our count by 10.\n\nAt the end, return the `count` value which represents the number of valid clock times that can be created by replacing '?' with a digit from 0 to 9.\n    ",
        "python": "\n    ```python\ndef count_valid_times(time: str) -> int:\n    count = 1\n    if time[0] == '?':\n        count *= 3 if time[1] == '?' or time[1] < '4' else 2\n    if time[1] == '?':\n        count *= 4 if time[0] == '2' else 10\n    if time[3] == '?':\n        count *= 6\n    if time[4] == '?':\n        count *= 10\n    return count\n```\n\n    \n    1. If the first character is '?', check if the second character is also '?' or less than '4', in that case the valid possibilities for the first character are '0', '1' or '2', so we multiply our count by 3. If the second character is greater than or equal to '4', then the valid possibilities for the first character are only '0' or '1', so we multiply our count by 2.\n2. If the second character is '?', check if the first character is '2', in that case, the valid possibilities for the second character are '0', '1', '2' and '3', so we multiply our count by 4. If the first character is not '2', then the valid possibilities for the second character are 0 to 9, so we multiply our count by 10.\n3. If the third character is '?', the valid possibilities are '0' to '5', so we multiply our count by 6.\n4. If the fourth character is '?', the valid possibilities are 0 to 9, so we multiply our count by 10.\n\nAt the end, return the `count` value which represents the number of valid clock times that can be created by replacing '?' with a digit from 0 to 9.\n    ",
        "c++": "\n    ```cpp\nint countValidTimes(std::string time) {\n    int count = 1;\n    if(time[0] == '?') {\n        count *= (time[1] == '?' || time[1] < '4') ? 3 : 2;\n    }\n    if(time[1] == '?') {\n        count *= (time[0] == '2') ? 4 : 10;\n    }\n    if(time[3] == '?') {\n        count *= 6;\n    }\n    if(time[4] == '?') {\n        count *= 10;\n    }\n    return count;\n}\n```\n\n    \n    1. If the first character is '?', check if the second character is also '?' or less than '4', in that case the valid possibilities for the first character are '0', '1' or '2', so we multiply our count by 3. If the second character is greater than or equal to '4', then the valid possibilities for the first character are only '0' or '1', so we multiply our count by 2.\n2. If the second character is '?', check if the first character is '2', in that case, the valid possibilities for the second character are '0', '1', '2' and '3', so we multiply our count by 4. If the first character is not '2', then the valid possibilities for the second character are 0 to 9, so we multiply our count by 10.\n3. If the third character is '?', the valid possibilities are '0' to '5', so we multiply our count by 6.\n4. If the fourth character is '?', the valid possibilities are 0 to 9, so we multiply our count by 10.\n\nAt the end, return the `count` value which represents the number of valid clock times that can be created by replacing '?' with a digit from 0 to 9.\n    ",
        "js": "\n    ```javascript\nfunction countValidTimes(time) {\n    let count = 1;\n    if(time[0] === '?') {\n        count *= (time[1] === '?' || time[1] < '4') ? 3 : 2;\n    }\n    if(time[1] === '?') {\n        count *= (time[0] === '2') ? 4 : 10;\n    }\n    if(time[3] === '?') {\n        count *= 6;\n    }\n    if(time[4] === '?') {\n        count *= 10;\n    }\n    return count;\n}\n```\n\n    \n    1. If the first character is '?', check if the second character is also '?' or less than '4', in that case the valid possibilities for the first character are '0', '1' or '2', so we multiply our count by 3. If the second character is greater than or equal to '4', then the valid possibilities for the first character are only '0' or '1', so we multiply our count by 2.\n2. If the second character is '?', check if the first character is '2', in that case, the valid possibilities for the second character are '0', '1', '2' and '3', so we multiply our count by 4. If the first character is not '2', then the valid possibilities for the second character are 0 to 9, so we multiply our count by 10.\n3. If the third character is '?', the valid possibilities are '0' to '5', so we multiply our count by 6.\n4. If the fourth character is '?', the valid possibilities are 0 to 9, so we multiply our count by 10.\n\nAt the end, return the `count` value which represents the number of valid clock times that can be created by replacing '?' with a digit from 0 to 9.\n    "
    },
    {
        "id": 446,
        "title": "Largest Positive Integer That Exists With Its Negative",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` that **does not contain** any zeros, find **the largest positive** integer `k` such that `-k` also exists in the array.\n\nReturn _the positive integer_ `k`. If there is no such integer, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,2,-3,3\\]\n**Output:** 3\n**Explanation:** 3 is the only valid k we can find in the array.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,10,6,7,-7,1\\]\n**Output:** 7\n**Explanation:** Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-10,8,6,7,-2,-3\\]\n**Output:** -1\n**Explanation:** There is no a single valid k, we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-1000 <= nums[i] <= 1000`\n*   `nums[i] != 0`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[-1,2,-3,3]",
                "output": "3"
            },
            {
                "input": "[-1,10,6,7,-7,1]",
                "output": "7"
            },
            {
                "input": "[-10,8,6,7,-2,-3]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findK(int[] nums) {\n    Set<Integer> set = new HashSet<>();\n    for (int num : nums) {\n        set.add(num);\n    }\n    int k = -1;\n    for (int num : nums) {\n        if (set.contains(-num)) {\n            k = Math.max(k, Math.abs(num));\n        }\n    }\n    return k;\n}\n```\n\n    \n    The algorithm puts all numbers in `nums` into a set `s` and then iterates through the numbers in the array. For each of the numbers, it checks whether `-k` is present in the set. If it is, it updates `k` to be the maximum of the absolute values of `k` and the current element (`num`). The maximum positive integer `k` is returned if it exists, otherwise `-1` is returned. This way, it finds the largest positive `k` such that both `k` and `-k` exist in the input array `nums`.\n    ",
        "python": "\n    ```python\ndef find_K(nums):\n    s = set(nums)\n    k = -1\n    for num in nums:\n        if -num in s:\n            k = max(k, abs(num))\n    return k\n```\n\n    \n    The algorithm puts all numbers in `nums` into a set `s` and then iterates through the numbers in the array. For each of the numbers, it checks whether `-k` is present in the set. If it is, it updates `k` to be the maximum of the absolute values of `k` and the current element (`num`). The maximum positive integer `k` is returned if it exists, otherwise `-1` is returned. This way, it finds the largest positive `k` such that both `k` and `-k` exist in the input array `nums`.\n    ",
        "c++": "\n    ```cpp\nint findK(vector<int>& nums) {\n    set<int> s(nums.begin(), nums.end());\n    int k = -1;\n    for (const int& num : nums) {\n        if (s.find(-num) != s.end()) {\n            k = max(k, abs(num));\n        }\n    }\n    return k;\n}\n```\n\n    \n    The algorithm puts all numbers in `nums` into a set `s` and then iterates through the numbers in the array. For each of the numbers, it checks whether `-k` is present in the set. If it is, it updates `k` to be the maximum of the absolute values of `k` and the current element (`num`). The maximum positive integer `k` is returned if it exists, otherwise `-1` is returned. This way, it finds the largest positive `k` such that both `k` and `-k` exist in the input array `nums`.\n    ",
        "js": "\n    ```javascript\nfunction findK(nums) {\n    const s = new Set(nums);\n    let k = -1;\n    for (const num of nums) {\n        if (s.has(-num)) {\n            k = Math.max(k, Math.abs(num));\n        }\n    }\n    return k;\n}\n```\n\n    \n    The algorithm puts all numbers in `nums` into a set `s` and then iterates through the numbers in the array. For each of the numbers, it checks whether `-k` is present in the set. If it is, it updates `k` to be the maximum of the absolute values of `k` and the current element (`num`). The maximum positive integer `k` is returned if it exists, otherwise `-1` is returned. This way, it finds the largest positive `k` such that both `k` and `-k` exist in the input array `nums`.\n    "
    },
    {
        "id": 447,
        "title": "Determine if Two Events Have Conflict",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two arrays of strings that represent two inclusive events that happened **on the same day**, `event1` and `event2`, where:\n\n*   `event1 = [startTime1, endTime1]` and\n*   `event2 = [startTime2, endTime2]`.\n\nEvent times are valid 24 hours format in the form of `HH:MM`.\n\nA **conflict** happens when two events have some non-empty intersection (i.e., some moment is common to both events).\n\nReturn `true` _if there is a conflict between two events. Otherwise, return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** event1 = \\[ \"01:15 \", \"02:00 \"\\], event2 = \\[ \"02:00 \", \"03:00 \"\\]\n**Output:** true\n**Explanation:** The two events intersect at time 2:00.\n\n",
                "**Example 2:**\n\n**Input:** event1 = \\[ \"01:00 \", \"02:00 \"\\], event2 = \\[ \"01:20 \", \"03:00 \"\\]\n**Output:** true\n**Explanation:** The two events intersect starting from 01:20 to 02:00.\n\n",
                "**Example 3:**\n\n**Input:** event1 = \\[ \"10:00 \", \"11:00 \"\\], event2 = \\[ \"14:00 \", \"15:00 \"\\]\n**Output:** false\n**Explanation:** The two events do not intersect."
            ],
            "constraints": "**Constraints:**\n\n*   `evnet1.length == event2.length == 2.`\n*   `event1[i].length == event2[i].length == 5`\n*   `startTime1 <= endTime1`\n*   `startTime2 <= endTime2`\n*   All the event times follow the `HH:MM` format.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"01:15\",\"02:00\"],[\"02:00\",\"03:00\"]",
                "output": "true"
            },
            {
                "input": "[\"01:00\",\"02:00\"],[\"01:20\",\"03:00\"]",
                "output": "true"
            },
            {
                "input": "[\"10:00\",\"11:00\"],[\"14:00\",\"15:00\"]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean hasEventConflict(String start1, String end1, String start2, String end2) {\n    int startHour1 = Integer.parseInt(start1.substring(0, 2));\n    int startMin1 = Integer.parseInt(start1.substring(3, 5));\n    int startHour2 = Integer.parseInt(start2.substring(0, 2));\n    int startMin2 = Integer.parseInt(start2.substring(3, 5));\n\n    int endHour1 = Integer.parseInt(end1.substring(0, 2));\n    int endMin1 = Integer.parseInt(end1.substring(3, 5));\n    int endHour2 = Integer.parseInt(end2.substring(0, 2));\n    int endMin2 = Integer.parseInt(end2.substring(3, 5));\n\n    int totalMin1Start = startHour1 * 60 + startMin1;\n    int totalMin1End = endHour1 * 60 + endMin1;\n    int totalMin2Start = startHour2 * 60 + startMin2;\n    int totalMin2End = endHour2 * 60 + endMin2;\n\n    return !(totalMin1End <= totalMin2Start || totalMin1Start >= totalMin2End);\n}\n```\n    \n    The algorithm first parses the input strings and separates the hour and minute parts of each event. Then, it converts the event times to the total minutes from 00:00 to account for easier comparisons. Finally, it checks if the two events have any intersection by comparing the start and end time of each event in minutes. If there's a conflict, return true; otherwise, return false.\n    ",
        "python": "\n    ```python\ndef has_event_conflict(start1: str, end1: str, start2: str, end2: str) -> bool:\n    start_hour1, start_min1 = map(int, start1.split(\":\"))\n    start_hour2, start_min2 = map(int, start2.split(\":\"))\n    end_hour1, end_min1 = map(int, end1.split(\":\"))\n    end_hour2, end_min2 = map(int, end2.split(\":\"))\n\n    total_min1_start = start_hour1 * 60 + start_min1\n    total_min1_end = end_hour1 * 60 + end_min1\n    total_min2_start = start_hour2 * 60 + start_min2\n    total_min2_end = end_hour2 * 60 + end_min2\n\n    return not (total_min1_end <= total_min2_start or total_min1_start >= total_min2_end)\n```\n    \n    The algorithm first parses the input strings and separates the hour and minute parts of each event. Then, it converts the event times to the total minutes from 00:00 to account for easier comparisons. Finally, it checks if the two events have any intersection by comparing the start and end time of each event in minutes. If there's a conflict, return true; otherwise, return false.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nbool hasEventConflict(const std::string& start1, const std::string& end1,\n                      const std::string& start2, const std::string& end2) {\n    int startHour1 = stoi(start1.substr(0, 2));\n    int startMin1 = stoi(start1.substr(3, 2));\n    int startHour2 = stoi(start2.substr(0, 2));\n    int startMin2 = stoi(start2.substr(3, 2));\n    \n    int endHour1 = stoi(end1.substr(0, 2));\n    int endMin1 = stoi(end1.substr(3, 2));\n    int endHour2 = stoi(end2.substr(0, 2));\n    int endMin2 = stoi(end2.substr(3, 2));\n    \n    int totalMin1Start = startHour1*60 + startMin1;\n    int totalMin1End = endHour1*60 + endMin1;\n    int totalMin2Start = startHour2*60 + startMin2;\n    int totalMin2End = endHour2*60 + endMin2;\n    \n    return !(totalMin1End <= totalMin2Start || totalMin1Start >= totalMin2End);\n}\n```\n    \n    The algorithm first parses the input strings and separates the hour and minute parts of each event. Then, it converts the event times to the total minutes from 00:00 to account for easier comparisons. Finally, it checks if the two events have any intersection by comparing the start and end time of each event in minutes. If there's a conflict, return true; otherwise, return false.\n    ",
        "js": "\n    ```javascript\nfunction hasEventConflict(start1, end1, start2, end2) {\n    let startHour1 = parseInt(start1.slice(0, 2));\n    let startMin1 = parseInt(start1.slice(3, 5));\n    let startHour2 = parseInt(start2.slice(0, 2));\n    let startMin2 = parseInt(start2.slice(3, 5));\n\n    let endHour1 = parseInt(end1.slice(0, 2));\n    let endMin1 = parseInt(end1.slice(3, 5));\n    let endHour2 = parseInt(end2.slice(0, 2));\n    let endMin2 = parseInt(end2.slice(3, 5));\n\n    let totalMin1Start = startHour1 * 60 + startMin1;\n    let totalMin1End = endHour1 * 60 + endMin1;\n    let totalMin2Start = startHour2 * 60 + startMin2;\n    let totalMin2End = endHour2 * 60 + endMin2;\n\n    return !(totalMin1End <= totalMin2Start || totalMin1Start >= totalMin2End);\n}\n```\n    \n    The algorithm first parses the input strings and separates the hour and minute parts of each event. Then, it converts the event times to the total minutes from 00:00 to account for easier comparisons. Finally, it checks if the two events have any intersection by comparing the start and end time of each event in minutes. If there's a conflict, return true; otherwise, return false.\n    "
    },
    {
        "id": 448,
        "title": "Odd String Difference",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of equal-length strings `words`. Assume that the length of each string is `n`.\n\nEach string `words[i]` can be converted into a **difference integer array** `difference[i]` of length `n - 1` where `difference[i][j] = words[i][j+1] - words[i][j]` where `0 <= j <= n - 2`. Note that the difference between two letters is the difference between their **positions** in the alphabet i.e. the position of `'a'` is `0`, `'b'` is `1`, and `'z'` is `25`.\n\n*   For example, for the string `\"acb \"`, the difference integer array is `[2 - 0, 1 - 2] = [2, -1]`.\n\nAll the strings in words have the same difference integer array, **except one**. You should find that string.\n\nReturn _the string in_ `words` _that has different **difference integer array**._",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"adc \", \"wzy \", \"abc \"\\]\n**Output:**  \"abc \"\n**Explanation:** \n- The difference integer array of  \"adc \" is \\[3 - 0, 2 - 3\\] = \\[3, -1\\].\n- The difference integer array of  \"wzy \" is \\[25 - 22, 24 - 25\\]= \\[3, -1\\].\n- The difference integer array of  \"abc \" is \\[1 - 0, 2 - 1\\] = \\[1, 1\\]. \nThe odd array out is \\[1, 1\\], so we return the corresponding string,  \"abc \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"aaa \", \"bob \", \"ccc \", \"ddd \"\\]\n**Output:**  \"bob \"\n**Explanation:** All the integer arrays are \\[0, 0\\] except for  \"bob \", which corresponds to \\[13, -13\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= words.length <= 100`\n*   `n == words[i].length`\n*   `2 <= n <= 20`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"adc\",\"wzy\",\"abc\"]",
                "output": "\"abc\""
            },
            {
                "input": "[\"aaa\",\"bob\",\"ccc\",\"ddd\"]",
                "output": "\"bob\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String stringWithDifferentDifference(String[] words) {\n    List<List<Integer>> diffArrays = new ArrayList<>();\n    for (String word : words) {\n        diffArrays.add(getDifferenceArray(word));\n    }\n    \n    int oddArrayIndex = -1;\n    for (int i = 1; i < diffArrays.size(); i++) {\n        int matchCount = 0;\n        for (int j = 0; j < diffArrays.get(i).size(); j++) {\n            if (diffArrays.get(0).get(j) == diffArrays.get(i).get(j)) {\n                matchCount++;\n            }\n        }\n        \n        if (matchCount == 0) {\n            oddArrayIndex = i;\n            break;\n        }\n    }\n\n    return words[oddArrayIndex];\n}\n\nprivate List<Integer> getDifferenceArray(String word) {\n    List<Integer> differenceArray = new ArrayList<>();\n    for (int i = 1; i < word.length(); i++) {\n        differenceArray.add(word.charAt(i) - word.charAt(i - 1));\n    }\n    return differenceArray;\n}\n```\n    \n    The algorithm starts by creating a helper function `getDifferenceArray`, which creates an array containing the differences of consecutive characters in the given string. Then, for each string in the `words` array, I call the helper function to generate difference arrays and store them in a new array `diffArrays`.`\n\nAfter that, a loop iterates over `diffArrays`, comparing each difference array with the first one in the array (`diffArrays[0]`). If there are no matches at all (meaning it's completely different from the first difference array), I set `oddArrayIndex` to that index and break the loop. Finally, I return the string in the `words` array at the index of `oddArrayIndex`.\n    ",
        "python": "\n    ```python\ndef stringWithDifferentDifference(words):\n    def get_difference_array(word):\n        return [ord(word[i+1]) - ord(word[i]) for i in range(len(word) - 1)]\n\n    diffArrays = [get_difference_array(word) for word in words]\n    \n    oddArrayIndex = -1\n    for i in range(1, len(diffArrays)):\n        matchCount = sum(diffArrays[0][j] == diffArrays[i][j] for j in range(len(diffArrays[i])))\n        if matchCount == 0:\n            oddArrayIndex = i\n            break\n\n    return words[oddArrayIndex]\n```\n    \n    The algorithm starts by creating a helper function `getDifferenceArray`, which creates an array containing the differences of consecutive characters in the given string. Then, for each string in the `words` array, I call the helper function to generate difference arrays and store them in a new array `diffArrays`.`\n\nAfter that, a loop iterates over `diffArrays`, comparing each difference array with the first one in the array (`diffArrays[0]`). If there are no matches at all (meaning it's completely different from the first difference array), I set `oddArrayIndex` to that index and break the loop. Finally, I return the string in the `words` array at the index of `oddArrayIndex`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string stringWithDifferentDifference(std::vector<std::string>& words) {\n    auto getDifferenceArray = [](const std::string& word) {\n        std::vector<int> differenceArray;\n        for (size_t i = 1; i < word.size(); i++) {\n            differenceArray.push_back(word[i] - word[i - 1]);\n        }\n        return differenceArray;\n    };\n    \n    std::vector<std::vector<int>> diffArrays;\n    for (const auto& word : words) {\n        diffArrays.push_back(getDifferenceArray(word));\n    }\n    \n    int oddArrayIndex = -1;\n    for (int i = 1; i < diffArrays.size(); i++) {\n        int matchCount = 0;\n        for (int j = 0; j < diffArrays[i].size(); j++) {\n            if (diffArrays[0][j] == diffArrays[i][j]) {\n                matchCount++;\n            }\n        }\n        \n        if (matchCount == 0) {\n            oddArrayIndex = i;\n            break;\n        }\n    }\n\n    return words[oddArrayIndex];\n}\n```\n    \n    The algorithm starts by creating a helper function `getDifferenceArray`, which creates an array containing the differences of consecutive characters in the given string. Then, for each string in the `words` array, I call the helper function to generate difference arrays and store them in a new array `diffArrays`.`\n\nAfter that, a loop iterates over `diffArrays`, comparing each difference array with the first one in the array (`diffArrays[0]`). If there are no matches at all (meaning it's completely different from the first difference array), I set `oddArrayIndex` to that index and break the loop. Finally, I return the string in the `words` array at the index of `oddArrayIndex`.\n    ",
        "js": "\n    ```javascript\nfunction stringWithDifferentDifference(words) {\n    const getDifferenceArray = (word) => {\n        const differenceArray = [];\n        for (let i = 1; i < word.length; i++) {\n            differenceArray.push(word.charCodeAt(i) - word.charCodeAt(i - 1));\n        }\n        return differenceArray;\n    };\n    \n    const diffArrays = words.map(getDifferenceArray);\n    \n    let oddArrayIndex = -1;\n    for (let i = 1; i < diffArrays.length; i++) {\n        let matchCount = 0;\n        for (let j = 0; j < diffArrays[i].length; j++) {\n            if (diffArrays[0][j] == diffArrays[i][j]) {\n                matchCount++;\n            }\n        }\n        \n        if (matchCount == 0) {\n            oddArrayIndex = i;\n            break;\n        }\n    }\n\n    return words[oddArrayIndex];\n}\n```\n\n    \n    The algorithm starts by creating a helper function `getDifferenceArray`, which creates an array containing the differences of consecutive characters in the given string. Then, for each string in the `words` array, I call the helper function to generate difference arrays and store them in a new array `diffArrays`.`\n\nAfter that, a loop iterates over `diffArrays`, comparing each difference array with the first one in the array (`diffArrays[0]`). If there are no matches at all (meaning it's completely different from the first difference array), I set `oddArrayIndex` to that index and break the loop. Finally, I return the string in the `words` array at the index of `oddArrayIndex`.\n    "
    },
    {
        "id": 449,
        "title": "Average Value of Even Numbers That Are Divisible by Three",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` of **positive** integers, return _the average value of all even integers that are divisible by_ `3`_._\n\nNote that the **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,6,10,12,15\\]\n**Output:** 9\n**Explanation:** 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,4,7,10\\]\n**Output:** 0\n**Explanation:** There is no single number that satisfies the requirement, so return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,3,6,10,12,15]",
                "output": "9"
            },
            {
                "input": "[1,2,4,7,10]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int averageEvenDivisibleByThree(int[] nums) {\n    int sum = 0;\n    int count = 0;\n    for (int num : nums) {\n        if (num % 2 == 0 && num % 3 == 0) {\n            sum += num;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : sum / count;\n}\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "python": "\n    ```python\ndef average_even_divisible_by_three(nums):\n    total = 0\n    count = 0\n    for num in nums:\n        if num % 2 == 0 and num % 3 == 0:\n            total += num\n            count += 1\n    return total // count if count > 0 else 0\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "c++": "\n    ```cpp\nint averageEvenDivisibleByThree(const std::vector<int>& nums) {\n    int sum = 0;\n    int count = 0;\n    for (int num : nums) {\n        if (num % 2 == 0 && num % 3 == 0) {\n            sum += num;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : sum / count;\n}\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "js": "\n    ```javascript\nfunction averageEvenDivisibleByThree(nums) {\n    let sum = 0;\n    let count = 0;\n    for (let num of nums) {\n        if (num % 2 === 0 && num % 3 === 0) {\n            sum += num;\n            count++;\n        }\n    }\n    return count === 0 ? 0 : Math.floor(sum / count);\n}\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    "
    },
    {
        "id": 450,
        "title": "Apply Operations to an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** array `nums` of size `n` consisting of **non-negative** integers.\n\nYou need to apply `n - 1` operations to this array where, in the `ith` operation (**0-indexed**), you will apply the following on the `ith` element of `nums`:\n\n*   If `nums[i] == nums[i + 1]`, then multiply `nums[i]` by `2` and set `nums[i + 1]` to `0`. Otherwise, you skip this operation.\n\nAfter performing **all** the operations, **shift** all the `0`'s to the **end** of the array.\n\n*   For example, the array `[1,0,2,0,0,1]` after shifting all its `0`'s to the end, is `[1,2,1,0,0,0]`.\n\nReturn _the resulting array_.\n\n**Note** that the operations are applied **sequentially**, not all at once.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,1,1,0\\]\n**Output:** \\[1,4,2,0,0,0\\]\n**Explanation:** We do the following operations:\n- i = 0: nums\\[0\\] and nums\\[1\\] are not equal, so we skip this operation.\n- i = 1: nums\\[1\\] and nums\\[2\\] are equal, we multiply nums\\[1\\] by 2 and change nums\\[2\\] to 0. The array becomes \\[1,**4**,**0**,1,1,0\\].\n- i = 2: nums\\[2\\] and nums\\[3\\] are not equal, so we skip this operation.\n- i = 3: nums\\[3\\] and nums\\[4\\] are equal, we multiply nums\\[3\\] by 2 and change nums\\[4\\] to 0. The array becomes \\[1,4,0,**2**,**0**,0\\].\n- i = 4: nums\\[4\\] and nums\\[5\\] are equal, we multiply nums\\[4\\] by 2 and change nums\\[5\\] to 0. The array becomes \\[1,4,0,2,**0**,**0**\\].\nAfter that, we shift the 0's to the end, which gives the array \\[1,4,2,0,0,0\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** \\[1,0\\]\n**Explanation:** No operation can be applied, we just shift the 0 to the end."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 2000`\n*   `0 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,2,2,1,1,0]",
                "output": "[1,4,2,0,0,0]"
            },
            {
                "input": "[0,1]",
                "output": "[1,0]"
            }
        ],
        "java": "\n    ```java\npublic int[] performOps(int[] nums) {\n    int n = nums.length;\n    for (int i = 0; i < n - 1; ++i) {\n        if (nums[i] == nums[i + 1]) {\n            nums[i] *= 2;\n            nums[i + 1] = 0;\n        }\n    }\n    int nonZeroIndex = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != 0) {\n            nums[nonZeroIndex++] = nums[i];\n        }\n    }\n    while (nonZeroIndex < n) {\n        nums[nonZeroIndex++] = 0;\n    }\n    return nums;\n}\n```\n    \n    Iterate through the `nums` array from index `0` to `n - 2`.\nFor each index `i`, check if `nums[i]` equals `nums[i + 1]`. If equal, multiply `nums[i]` by `2` and set `nums[i + 1]` to `0`.\nAfter the operations, shift all `0`'s to the end of the array. To do this, keep track of a `nonZeroIndex` and copy only non-zero elements to that index. Increment the `nonZeroIndex` for every non-zero element copied. Finally, fill the rest of the array with `0`'s starting from the `nonZeroIndex`.\n    ",
        "python": "\n    ```python\ndef performOps(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        if nums[i] == nums[i + 1]:\n            nums[i] *= 2\n            nums[i + 1] = 0\n    nonZeroIndex = 0\n    for i in range(n):\n        if nums[i] != 0:\n            nums[nonZeroIndex] = nums[i]\n            nonZeroIndex += 1\n    while(nonZeroIndex < n):\n        nums[nonZeroIndex] = 0\n        nonZeroIndex += 1\n    return nums\n```\n    \n    Iterate through the `nums` array from index `0` to `n - 2`.\nFor each index `i`, check if `nums[i]` equals `nums[i + 1]`. If equal, multiply `nums[i]` by `2` and set `nums[i + 1]` to `0`.\nAfter the operations, shift all `0`'s to the end of the array. To do this, keep track of a `nonZeroIndex` and copy only non-zero elements to that index. Increment the `nonZeroIndex` for every non-zero element copied. Finally, fill the rest of the array with `0`'s starting from the `nonZeroIndex`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> performOps(vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n - 1; ++i) {\n        if (nums[i] == nums[i + 1]) {\n            nums[i] *= 2;\n            nums[i + 1] = 0;\n        }\n    }\n    int nonZeroIndex = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != 0) {\n            nums[nonZeroIndex++] = nums[i];\n        }\n    }\n    while (nonZeroIndex < n) {\n        nums[nonZeroIndex++] = 0;\n    }\n    return nums;\n}\n```\n    \n    Iterate through the `nums` array from index `0` to `n - 2`.\nFor each index `i`, check if `nums[i]` equals `nums[i + 1]`. If equal, multiply `nums[i]` by `2` and set `nums[i + 1]` to `0`.\nAfter the operations, shift all `0`'s to the end of the array. To do this, keep track of a `nonZeroIndex` and copy only non-zero elements to that index. Increment the `nonZeroIndex` for every non-zero element copied. Finally, fill the rest of the array with `0`'s starting from the `nonZeroIndex`.\n    ",
        "js": "\n    ```javascript\nfunction performOps(nums) {\n    const n = nums.length;\n    for (let i = 0; i < n - 1; ++i) {\n        if (nums[i] === nums[i + 1]) {\n            nums[i] *= 2;\n            nums[i + 1] = 0;\n        }\n    }\n    let nonZeroIndex = 0;\n    for (let i = 0; i < n; ++i) {\n        if (nums[i] !== 0) {\n            nums[nonZeroIndex++] = nums[i];\n        }\n    }\n    while(nonZeroIndex < n) {\n        nums[nonZeroIndex++] = 0;\n    }\n    return nums;\n}\n```\n    \n    Iterate through the `nums` array from index `0` to `n - 2`.\nFor each index `i`, check if `nums[i]` equals `nums[i + 1]`. If equal, multiply `nums[i]` by `2` and set `nums[i + 1]` to `0`.\nAfter the operations, shift all `0`'s to the end of the array. To do this, keep track of a `nonZeroIndex` and copy only non-zero elements to that index. Increment the `nonZeroIndex` for every non-zero element copied. Finally, fill the rest of the array with `0`'s starting from the `nonZeroIndex`.\n    "
    },
    {
        "id": 451,
        "title": "Number of Distinct Averages",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` of **even** length.\n\nAs long as `nums` is **not** empty, you must repetitively:\n\n*   Find the minimum number in `nums` and remove it.\n*   Find the maximum number in `nums` and remove it.\n*   Calculate the average of the two removed numbers.\n\nThe **average** of two numbers `a` and `b` is `(a + b) / 2`.\n\n*   For example, the average of `2` and `3` is `(2 + 3) / 2 = 2.5`.\n\nReturn _the number of **distinct** averages calculated using the above process_.\n\n**Note** that when there is a tie for a minimum or maximum number, any can be removed.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,1,4,0,3,5\\]\n**Output:** 2\n**Explanation:**\n1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = \\[4,1,4,3\\].\n2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = \\[4,3\\].\n3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.\nSince there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,100\\]\n**Output:** 1\n**Explanation:**\nThere is only one average to be calculated after removing 1 and 100, so we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 100`\n*   `nums.length` is even.\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,1,4,0,3,5]",
                "output": "2"
            },
            {
                "input": "[1,100]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int distinctAverages(int[] nums) {\n    Set<Double> averages = new HashSet<>();\n    Arrays.sort(nums);\n    int n = nums.length;\n    for (int i = 0; i < n / 2; i++) {\n        averages.add((nums[i] + nums[n - 1 - i]) / 2.0);\n    }\n    return averages.size();\n}\n```\n    \n    1. Initialize an empty sets called 'averages' to store the distinct averages.\n2. Sort the input array 'nums'.\n3. Iterate through the first half of the sorted array and calculate the average of the current number and its counterpart from the other end, then add this average to the 'averages' set.\n4. Return the size of the 'averages' set which represents the distinct averages calculated using the given process.\n    ",
        "python": "\n    ```python\ndef distinctAverages(nums):\n    averages = set()\n    nums.sort()\n    n = len(nums)\n    for i in range(n // 2):\n        averages.add((nums[i] + nums[n - 1 - i]) / 2.0)\n    return len(averages)\n```\n    \n    1. Initialize an empty sets called 'averages' to store the distinct averages.\n2. Sort the input array 'nums'.\n3. Iterate through the first half of the sorted array and calculate the average of the current number and its counterpart from the other end, then add this average to the 'averages' set.\n4. Return the size of the 'averages' set which represents the distinct averages calculated using the given process.\n    ",
        "c++": "\n    ```cpp\nint distinctAverages(vector<int>& nums) {\n    set<double> averages;\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    for (int i = 0; i < n / 2; i++) {\n        averages.insert((nums[i] + nums[n - 1 - i]) / 2.0);\n    }\n    return averages.size();\n}\n```\n    \n    1. Initialize an empty sets called 'averages' to store the distinct averages.\n2. Sort the input array 'nums'.\n3. Iterate through the first half of the sorted array and calculate the average of the current number and its counterpart from the other end, then add this average to the 'averages' set.\n4. Return the size of the 'averages' set which represents the distinct averages calculated using the given process.\n    ",
        "js": "\n    ```javascript\nfunction distinctAverages(nums) {\n    let averages = new Set();\n    nums.sort((a, b) => a - b);\n    let n = nums.length;\n    for (let i = 0; i < n / 2; i++) {\n        averages.add((nums[i] + nums[n - 1 - i]) / 2.0);\n    }\n    return averages.size;\n}\n```\n    \n    1. Initialize an empty sets called 'averages' to store the distinct averages.\n2. Sort the input array 'nums'.\n3. Iterate through the first half of the sorted array and calculate the average of the current number and its counterpart from the other end, then add this average to the 'averages' set.\n4. Return the size of the 'averages' set which represents the distinct averages calculated using the given process.\n    "
    },
    {
        "id": 452,
        "title": "Convert the Temperature",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a non-negative floating point number rounded to two decimal places `celsius`, that denotes the **temperature in Celsius**.\n\nYou should convert Celsius into **Kelvin** and **Fahrenheit** and return it as an array `ans = [kelvin, fahrenheit]`.\n\nReturn _the array `ans`._ Answers within `10-5` of the actual answer will be accepted.\n\n**Note that:**\n\n*   `Kelvin = Celsius + 273.15`\n*   `Fahrenheit = Celsius * 1.80 + 32.00`",
            "examples": [
                "**Example 1:**\n\n**Input:** celsius = 36.50\n**Output:** \\[309.65000,97.70000\\]\n**Explanation:** Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.\n\n",
                "**Example 2:**\n\n**Input:** celsius = 122.11\n**Output:** \\[395.26000,251.79800\\]\n**Explanation:** Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= celsius <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "36.50",
                "output": "[309.65000,97.70000]"
            },
            {
                "input": "122.11",
                "output": "[395.26000,251.79800]"
            }
        ],
        "java": "\n    ```java\npublic double[] convertTemperature(double celsius) {\n    double kelvin = celsius + 273.15;\n    double fahrenheit = celsius * 1.80 + 32.00;\n    return new double[]{kelvin, fahrenheit};\n}\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    ",
        "python": "\n    ```python\ndef convert_temperature(celsius):\n    kelvin = celsius + 273.15\n    fahrenheit = celsius * 1.8 + 32\n    return [kelvin, fahrenheit]\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<double> convertTemperature(double celsius) {\n    double kelvin = celsius + 273.15;\n    double fahrenheit = celsius * 1.80 + 32.00;\n    return {kelvin, fahrenheit};\n}\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    ",
        "js": "\n    ```javascript\nfunction convertTemperature(celsius) {\n    const kelvin = celsius + 273.15;\n    const fahrenheit = celsius * 1.80 + 32.00;\n    return [kelvin, fahrenheit];\n}\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    "
    },
    {
        "id": 453,
        "title": "Number of Unequal Triplets in Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** array of positive integers `nums`. Find the number of triplets `(i, j, k)` that meet the following conditions:\n\n*   `0 <= i < j < k < nums.length`\n*   `nums[i]`, `nums[j]`, and `nums[k]` are **pairwise distinct**.\n    *   In other words, `nums[i] != nums[j]`, `nums[i] != nums[k]`, and `nums[j] != nums[k]`.\n\nReturn _the number of triplets that meet the conditions._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,4,2,4,3\\]\n**Output:** 3\n**Explanation:** The following triplets meet the conditions:\n- (0, 2, 4) because 4 != 2 != 3\n- (1, 2, 4) because 4 != 2 != 3\n- (2, 3, 4) because 2 != 4 != 3\nSince there are 3 triplets, we return 3.\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,1\\]\n**Output:** 0\n**Explanation:** No triplets meet the conditions so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 100`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,4,2,4,3]",
                "output": "3"
            },
            {
                "input": "[1,1,1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countTriplets(int[] nums) {\n    int count = 0;\n    int n = nums.length;\n\n    for(int i = 0; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n            for(int k = j + 1; k < n; k++) {\n                if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    ",
        "python": "\n    ```python\ndef countTriplets(nums):\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                    count += 1\n    \n    return count\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    ",
        "c++": "\n    ```cpp\nint countTriplets(vector<int>& nums) {\n    int count = 0;\n    int n = nums.size();\n    \n    for(int i = 0; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n            for(int k = j + 1; k < n; k++) {\n                if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    ",
        "js": "\n    ```javascript\nfunction countTriplets(nums) {\n    let count = 0;\n    let n = nums.length;\n\n    for(let i = 0; i < n; i++) {\n        for(let j = i + 1; j < n; j++) {\n            for(let k = j + 1; k < n; k++) {\n                if(nums[i] !== nums[j] && nums[i] !== nums[k] && nums[j] !== nums[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    "
    },
    {
        "id": 454,
        "title": "Minimum Cuts to Divide a Circle",
        "difficulty": "Easy",
        "content": {
            "problem": "A **valid cut** in a circle can be:\n\n*   A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\n*   A cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n\nSome valid and invalid cuts are shown in the figures below.\n\nGiven the integer `n`, return _the **minimum** number of cuts needed to divide a circle into_ `n` _equal slices_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** \nThe above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:**\nAt least 3 cuts are needed to divide the circle into 3 equal slices. \nIt can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\nAlso note that the first cut will not divide the circle into distinct parts."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nint minCuts(int n) {\n    if (n % 2 == 0)\n        return n / 2;\n    else\n        return n;\n}\n```\n\n    \n    If `n` is an even number, then each cut divides the circle into two equal slices, and thus the minimum number of cuts required is `n / 2`. If `n` is an odd number, then each cut divides the circle into one equal slice, and thus the minimum number of cuts required is `n`.\n    ",
        "python": "\n    ```python\ndef min_cuts(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return n\n```\n\n    \n    If `n` is an even number, then each cut divides the circle into two equal slices, and thus the minimum number of cuts required is `n / 2`. If `n` is an odd number, then each cut divides the circle into one equal slice, and thus the minimum number of cuts required is `n`.\n    ",
        "c++": "\n    ```cpp\nint min_cuts(int n) {\n    if (n % 2 == 0)\n        return n / 2;\n    else\n        return n;\n}\n```\n\n    \n    If `n` is an even number, then each cut divides the circle into two equal slices, and thus the minimum number of cuts required is `n / 2`. If `n` is an odd number, then each cut divides the circle into one equal slice, and thus the minimum number of cuts required is `n`.\n    ",
        "js": "\n    ```javascript\nfunction minCuts(n) {\n    if (n % 2 === 0)\n        return n / 2;\n    else\n        return n;\n}\n```\n\n    \n    If `n` is an even number, then each cut divides the circle into two equal slices, and thus the minimum number of cuts required is `n / 2`. If `n` is an odd number, then each cut divides the circle into one equal slice, and thus the minimum number of cuts required is `n`.\n    "
    },
    {
        "id": 455,
        "title": "Find the Pivot Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer `n`, find the **pivot integer** `x` such that:\n\n*   The sum of all elements between `1` and `x` inclusively equals the sum of all elements between `x` and `n` inclusively.\n\nReturn _the pivot integer_ `x`. If no such integer exists, return `-1`. It is guaranteed that there will be at most one pivot index for the given input.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 8\n**Output:** 6\n**Explanation:** 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** 1 is the pivot integer since: 1 = 1.\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** -1\n**Explanation:** It can be proved that no such integer exist."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "8",
                "output": "6"
            },
            {
                "input": "1",
                "output": "1"
            },
            {
                "input": "4",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findPivot(int n) {\n    int sum = n * (n + 1) / 2;\n    int left_sum = 0;\n    for (int x = 1; x <= n; x++) {\n        left_sum += x;\n        if (left_sum * 2 == sum) {\n            return x;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through all the integers between 1 and n (inclusive), calculating the left_sum as it goes. On each iteration, it checks if the left_sum * 2 equals the total sum (calculated as n * (n + 1) / 2). If it does, the algorithm returns the current integer as the pivot integer. If the loop ends without finding a pivot integer, it returns -1.\n    ",
        "python": "\n    ```python\ndef find_pivot(n: int) -> int:\n    total = n * (n + 1) // 2\n    left_sum = 0\n    for x in range(1, n + 1):\n        left_sum += x\n        if 2 * left_sum == total:\n            return x\n    return -1\n```\n    \n    The algorithm iterates through all the integers between 1 and n (inclusive), calculating the left_sum as it goes. On each iteration, it checks if the left_sum * 2 equals the total sum (calculated as n * (n + 1) / 2). If it does, the algorithm returns the current integer as the pivot integer. If the loop ends without finding a pivot integer, it returns -1.\n    ",
        "c++": "\n    ```cpp\nint findPivot(int n) {\n    int sum = n * (n + 1) / 2;\n    int left_sum = 0;\n    for (int x = 1; x <= n; ++x) {\n        left_sum += x;\n        if (2 * left_sum == sum) {\n            return x;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through all the integers between 1 and n (inclusive), calculating the left_sum as it goes. On each iteration, it checks if the left_sum * 2 equals the total sum (calculated as n * (n + 1) / 2). If it does, the algorithm returns the current integer as the pivot integer. If the loop ends without finding a pivot integer, it returns -1.\n    ",
        "js": "\n    ```javascript\nfunction findPivot(n) {\n    const sum = n * (n + 1) / 2;\n    let left_sum = 0;\n    for (let x = 1; x <= n; x++) {\n        left_sum += x;\n        if (left_sum * 2 == sum) {\n            return x;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through all the integers between 1 and n (inclusive), calculating the left_sum as it goes. On each iteration, it checks if the left_sum * 2 equals the total sum (calculated as n * (n + 1) / 2). If it does, the algorithm returns the current integer as the pivot integer. If the loop ends without finding a pivot integer, it returns -1.\n    "
    },
    {
        "id": 456,
        "title": "Circular Sentence",
        "difficulty": "Easy",
        "content": {
            "problem": "A **sentence** is a list of words that are separated by a **single** space with no leading or trailing spaces.\n\n*   For example, `\"Hello World \"`, `\"HELLO \"`, `\"hello world hello world \"` are all sentences.\n\nWords consist of **only** uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\n\nA sentence is **circular** if:\n\n*   The last character of a word is equal to the first character of the next word.\n*   The last character of the last word is equal to the first character of the first word.\n\nFor example, `\"leetcode exercises sound delightful \"`, `\"eetcode \"`, `\"leetcode eats soul \"` are all circular sentences. However, `\"Leetcode is cool \"`, `\"happy Leetcode \"`, `\"Leetcode \"` and `\"I like Leetcode \"` are **not** circular sentences.\n\nGiven a string `sentence`, return `true` _if it is circular_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence =  \"leetcode exercises sound delightful \"\n**Output:** true\n**Explanation:** The words in sentence are \\[ \"leetcode \",  \"exercises \",  \"sound \",  \"delightful \"\\].\n- leetcode's last character is equal to exercises's first character.\n- exercises's last character is equal to sound's first character.\n- sound's last character is equal to delightful's first character.\n- delightful's last character is equal to leetcode's first character.\nThe sentence is circular.\n\n",
                "**Example 2:**\n\n**Input:** sentence =  \"eetcode \"\n**Output:** true\n**Explanation:** The words in sentence are \\[ \"eetcode \"\\].\n- eetcode's last character is equal to eetcode's first character.\nThe sentence is circular.\n\n",
                "**Example 3:**\n\n**Input:** sentence =  \"Leetcode is cool \"\n**Output:** false\n**Explanation:** The words in sentence are \\[ \"Leetcode \",  \"is \",  \"cool \"\\].\n- Leetcode's last character is **not** equal to is's first character.\nThe sentence is **not** circular."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 500`\n*   `sentence` consist of only lowercase and uppercase English letters and spaces.\n*   The words in `sentence` are separated by a single space.\n*   There are no leading or trailing spaces.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"leetcodeexercisessounddelightful\"",
                "output": "true"
            },
            {
                "input": "\"eetcode\"",
                "output": "true"
            },
            {
                "input": "\"Leetcodeiscool\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isCircular(String sentence) {\n    String[] words = sentence.split(\" \");\n    for (int i = 1; i < words.length; i++) {\n        if (words[i - 1].charAt(words[i - 1].length() - 1) != words[i].charAt(0)) {\n            return false;\n        }\n    }\n    return words[words.length - 1].charAt(words[words.length - 1].length() - 1) == words[0].charAt(0);\n}\n```\n    \n    The algorithm is straightforward:\n1. We split the input `sentence` into individual strings in an array by using the space character as a delimiter.\n2. We iterate through the words in the array, checking if the last character of the previous word is equal to the first character of the current word. If not, return `false`.\n3. After the iteration, we check if the last character of the last word in the array is equal to the first character of the first word. If so, we return `true`; otherwise, return `false`.\n    ",
        "python": "\n    ```python\ndef is_circular(sentence: str) -> bool:\n    words = sentence.split()\n    for i in range(1, len(words)):\n        if words[i - 1][-1] != words[i][0]:\n            return False\n    return words[-1][-1] == words[0][0]\n```\n    \n    The algorithm is straightforward:\n1. We split the input `sentence` into individual strings in an array by using the space character as a delimiter.\n2. We iterate through the words in the array, checking if the last character of the previous word is equal to the first character of the current word. If not, return `false`.\n3. After the iteration, we check if the last character of the last word in the array is equal to the first character of the first word. If so, we return `true`; otherwise, return `false`.\n    ",
        "c++": "\n    ```cpp\nbool isCircular(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word, prev;\n    \n    while (ss >> word) {\n        if (!prev.empty() && prev.back() != word.front()) {\n            return false;\n        }\n        prev = word;\n    }\n    \n    return word.back() == sentence.front();\n}\n```\n    \n    The algorithm is straightforward:\n1. We split the input `sentence` into individual strings in an array by using the space character as a delimiter.\n2. We iterate through the words in the array, checking if the last character of the previous word is equal to the first character of the current word. If not, return `false`.\n3. After the iteration, we check if the last character of the last word in the array is equal to the first character of the first word. If so, we return `true`; otherwise, return `false`.\n    ",
        "js": "\n    ```javascript\nfunction isCircular(sentence) {\n    const words = sentence.split(' ');\n    for (let i = 1; i < words.length; i++) {\n        if (words[i - 1].slice(-1) !== words[i][0]) {\n            return false;\n        }\n    }\n    return words[words.length - 1].slice(-1) === words[0][0];\n}\n```\n    \n    The algorithm is straightforward:\n1. We split the input `sentence` into individual strings in an array by using the space character as a delimiter.\n2. We iterate through the words in the array, checking if the last character of the previous word is equal to the first character of the current word. If not, return `false`.\n3. After the iteration, we check if the last character of the last word in the array is equal to the first character of the first word. If so, we return `true`; otherwise, return `false`.\n    "
    },
    {
        "id": 457,
        "title": "Maximum Value of a String in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "The **value** of an alphanumeric string can be defined as:\n\n*   The **numeric** representation of the string in base `10`, if it comprises of digits **only**.\n*   The **length** of the string, otherwise.\n\nGiven an array `strs` of alphanumeric strings, return _the **maximum value** of any string in_ `strs`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"alic3 \", \"bob \", \"3 \", \"4 \", \"00000 \"\\]\n**Output:** 5\n**Explanation:** \n-  \"alic3 \" consists of both letters and digits, so its value is its length, i.e. 5.\n-  \"bob \" consists only of letters, so its value is also its length, i.e. 3.\n-  \"3 \" consists only of digits, so its value is its numeric equivalent, i.e. 3.\n-  \"4 \" also consists only of digits, so its value is 4.\n-  \"00000 \" consists only of digits, so its value is 0.\nHence, the maximum value is 5, of  \"alic3 \".\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"1 \", \"01 \", \"001 \", \"0001 \"\\]\n**Output:** 1\n**Explanation:** \nEach string in the array has value 1. Hence, we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 100`\n*   `1 <= strs[i].length <= 9`\n*   `strs[i]` consists of only lowercase English letters and digits.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]",
                "output": "5"
            },
            {
                "input": "[\"1\",\"01\",\"001\",\"0001\"]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int maxValue(List<String> strs) {\n    int maxValue = 0;\n    for (String str : strs) {\n        int value;\n        if (str.chars().allMatch(Character::isDigit)) {\n            value = Integer.parseInt(str);\n        } else {\n            value = str.length();\n        }\n        maxValue = Math.max(maxValue, value);\n    }\n    return maxValue;\n}\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    ",
        "python": "\n    ```python\ndef maxValue(strs) -> int:\n    max_value = 0\n    for str in strs:\n        if str.isdigit():\n            value = int(str)\n        else:\n            value = len(str)\n        max_value = max(max_value, value)\n    return max_value\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint maxValue(std::vector<std::string>& strs) {\n    int max_value = 0;\n    for (const std::string& str : strs) {\n        int value;\n        if (str.find_first_not_of(\"0123456789\") == std::string::npos) {\n            value = std::stoi(str);\n        } else {\n            value = static_cast<int>(str.length());\n        }\n        max_value = std::max(max_value, value);\n    }\n    return max_value;\n}\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(strs) {\n    let maxValue = 0;\n    for (const str of strs) {\n        let value;\n        if (/^\\d+$/.test(str)) {\n            value = parseInt(str, 10);\n        } else {\n            value = str.length;\n        }\n        maxValue = Math.max(maxValue, value);\n    }\n    return maxValue;\n}\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    "
    },
    {
        "id": 458,
        "title": "Delete Greatest Value in Each Row",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` matrix `grid` consisting of positive integers.\n\nPerform the following operation until `grid` becomes empty:\n\n*   Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\n*   Add the maximum of deleted elements to the answer.\n\n**Note** that the number of columns decreases by one after each operation.\n\nReturn _the answer after performing the operations described above_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,2,4\\],\\[3,3,1\\]\\]\n**Output:** 8\n**Explanation:** The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[10\\]\\]\n**Output:** 10\n**Explanation:** The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,2,4],[3,3,1]]",
                "output": "8"
            },
            {
                "input": "[[10]]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\nint maxValueAfterOperations(int[][] grid) {\n    int ans = 0;\n    while (grid.length != 0) {\n        int maxVal = 0, maxRow = -1;\n\n        for (int i = 0; i < grid.length; ++i) {\n            int rowMax = Arrays.stream(grid[i]).max().getAsInt();\n            if (rowMax > maxVal) {\n                maxVal = rowMax;\n                maxRow = i;\n            }\n            grid[i] = Arrays.stream(grid[i]).filter(e -> e != rowMax).toArray();\n        }\n\n        ans += maxVal;\n        if (grid[maxRow].length == 0) {\n            grid = Arrays.stream(grid).filter(row -> row.length != 0).toArray(int[][]::new);\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    - Loop until 'grid' becomes empty.\n- Search for the greatest element in each row and delete any of them if there's a tie. Keep track of the maximum of deleted elements and the respective row number.\n- Add the maximum of deleted elements to 'ans'.\n- If the row with initially found maximum becomes empty, remove that row from 'grid'.\n- Finally, return the sum of all maximum deleted elements 'ans'.\n    ",
        "python": "\n    ```python\ndef maxValueAfterOperations(grid):\n    ans = 0\n    while grid:\n        maxVal = 0\n        maxRow = -1\n\n        for i, row in enumerate(grid):\n            rowMax = max(row)\n            if rowMax > maxVal:\n                maxVal = rowMax\n                maxRow = i\n            grid[i] = [e for e in row if e != rowMax]\n\n        ans += maxVal\n        if not grid[maxRow]:\n            grid.pop(maxRow)\n\n    return ans\n```\n\n    \n    - Loop until 'grid' becomes empty.\n- Search for the greatest element in each row and delete any of them if there's a tie. Keep track of the maximum of deleted elements and the respective row number.\n- Add the maximum of deleted elements to 'ans'.\n- If the row with initially found maximum becomes empty, remove that row from 'grid'.\n- Finally, return the sum of all maximum deleted elements 'ans'.\n    ",
        "c++": "\n    ```cpp\nint maxValueAfterOperations(vector<vector<int>>& grid) {\n    int ans = 0;\n    while (!grid.empty()) {\n        int maxVal = 0, maxRow = -1;\n\n        for(int i = 0; i < grid.size(); ++i) {\n            auto it = max_element(grid[i].begin(), grid[i].end());\n            if(*it > maxVal) {\n                maxVal = *it;\n                maxRow = i;\n            }\n            grid[i].erase(it);\n        }\n\n        ans += maxVal;\n        if (grid[maxRow].empty()) {\n            grid.erase(grid.begin() + maxRow);\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    - Loop until 'grid' becomes empty.\n- Search for the greatest element in each row and delete any of them if there's a tie. Keep track of the maximum of deleted elements and the respective row number.\n- Add the maximum of deleted elements to 'ans'.\n- If the row with initially found maximum becomes empty, remove that row from 'grid'.\n- Finally, return the sum of all maximum deleted elements 'ans'.\n    ",
        "js": "\n    ```javascript\nfunction maxValueAfterOperations(grid) {\n    let ans = 0;\n    while (grid.length) {\n        let maxVal = 0;\n        let maxRow = -1;\n\n        grid.forEach((row, i) => {\n            let rowMax = Math.max(...row);\n            if (rowMax > maxVal) {\n                maxVal = rowMax;\n                maxRow = i;\n            }\n            grid[i] = row.filter(e => e !== rowMax);\n        });\n\n        ans += maxVal;\n        if (!grid[maxRow].length) {\n            grid.splice(maxRow, 1);\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    - Loop until 'grid' becomes empty.\n- Search for the greatest element in each row and delete any of them if there's a tie. Keep track of the maximum of deleted elements and the respective row number.\n- Add the maximum of deleted elements to 'ans'.\n- If the row with initially found maximum becomes empty, remove that row from 'grid'.\n- Finally, return the sum of all maximum deleted elements 'ans'.\n    "
    },
    {
        "id": 459,
        "title": "Count Pairs Of Similar Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string array `words`.\n\nTwo strings are **similar** if they consist of the same characters.\n\n*   For example, `\"abca \"` and `\"cba \"` are similar since both consist of characters `'a'`, `'b'`, and `'c'`.\n*   However, `\"abacba \"` and `\"bcfd \"` are not similar since they do not consist of the same characters.\n\nReturn _the number of pairs_ `(i, j)` _such that_ `0 <= i < j <= word.length - 1` _and the two strings_ `words[i]` _and_ `words[j]` _are similar_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"aba \", \"aabb \", \"abcd \", \"bac \", \"aabc \"\\]\n**Output:** 2\n**Explanation:** There are 2 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words\\[0\\] and words\\[1\\] only consist of characters 'a' and 'b'. \n- i = 3 and j = 4 : both words\\[3\\] and words\\[4\\] only consist of characters 'a', 'b', and 'c'. \n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"aabb \", \"ab \", \"ba \"\\]\n**Output:** 3\n**Explanation:** There are 3 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words\\[0\\] and words\\[1\\] only consist of characters 'a' and 'b'. \n- i = 0 and j = 2 : both words\\[0\\] and words\\[2\\] only consist of characters 'a' and 'b'.\n- i = 1 and j = 2 : both words\\[1\\] and words\\[2\\] only consist of characters 'a' and 'b'.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"nba \", \"cba \", \"dba \"\\]\n**Output:** 0\n**Explanation:** Since there does not exist any pair that satisfies the conditions, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]",
                "output": "2"
            },
            {
                "input": "[\"aabb\",\"ab\",\"ba\"]",
                "output": "3"
            },
            {
                "input": "[\"nba\",\"cba\",\"dba\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int countSimilarPairs(String[] words) {\n    int count = 0;\n    for (int i = 0; i < words.length; ++i) {\n        for (int j = i + 1; j < words.length; ++j) {\n            Set<Character> set1 = new HashSet<>();\n            Set<Character> set2 = new HashSet<>();\n            for (char c : words[i].toCharArray()) set1.add(c);\n            for (char c : words[j].toCharArray()) set2.add(c);\n            if (set1.equals(set2)) count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    We will use a nested loop to iterate through all pairs (i, j) such that 0 <= i < j <= words.length - 1. For each pair of words, create two sets containing the constituent characters for each string. To create the sets, use a set object initialized with the characters from the corresponding word. Compare the two sets to see if they are equal. If they are, increment a counter. After iterating through all possible pairs of words, return the counter as the total number of similar pairs.\n    ",
        "python": "\n    ```python\ndef count_similar_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            set1 = set(words[i])\n            set2 = set(words[j])\n            if set1 == set2:\n                count += 1\n    return count\n```\n\n    \n    We will use a nested loop to iterate through all pairs (i, j) such that 0 <= i < j <= words.length - 1. For each pair of words, create two sets containing the constituent characters for each string. To create the sets, use a set object initialized with the characters from the corresponding word. Compare the two sets to see if they are equal. If they are, increment a counter. After iterating through all possible pairs of words, return the counter as the total number of similar pairs.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nint count_similar_pairs(std::vector<std::string>& words) {\n    int count = 0;\n    for (int i = 0; i < words.size(); ++i) {\n        for (int j = i + 1; j < words.size(); ++j) {\n            std::unordered_set<char> set1{words[i].begin(), words[i].end()};\n            std::unordered_set<char> set2{words[j].begin(), words[j].end()};\n            if (set1 == set2) count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    We will use a nested loop to iterate through all pairs (i, j) such that 0 <= i < j <= words.length - 1. For each pair of words, create two sets containing the constituent characters for each string. To create the sets, use a set object initialized with the characters from the corresponding word. Compare the two sets to see if they are equal. If they are, increment a counter. After iterating through all possible pairs of words, return the counter as the total number of similar pairs.\n    ",
        "js": "\n    ```javascript\nfunction countSimilarPairs(words) {\n    let count = 0;\n    for (let i = 0; i < words.length; ++i) {\n        for (let j = i + 1; j < words.length; ++j) {\n            let set1 = new Set(words[i]);\n            let set2 = new Set(words[j]);\n            if (areSetsEqual(set1, set2)) count++;\n        }\n    }\n    return count;\n\n    function areSetsEqual(set1, set2) {\n        if (set1.size !== set2.size) return false;\n        for (let item of set1) {\n            if (!set2.has(item)) return false;\n        }\n        return true;\n    }\n}\n```\n\n    \n    We will use a nested loop to iterate through all pairs (i, j) such that 0 <= i < j <= words.length - 1. For each pair of words, create two sets containing the constituent characters for each string. To create the sets, use a set object initialized with the characters from the corresponding word. Compare the two sets to see if they are equal. If they are, increment a counter. After iterating through all possible pairs of words, return the counter as the total number of similar pairs.\n    "
    },
    {
        "id": 460,
        "title": "Maximum Enemy Forts That Can Be Captured",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `forts` of length `n` representing the positions of several forts. `forts[i]` can be `-1`, `0`, or `1` where:\n\n*   `-1` represents there is **no fort** at the `ith` position.\n*   `0` indicates there is an **enemy** fort at the `ith` position.\n*   `1` indicates the fort at the `ith` the position is under your command.\n\nNow you have decided to move your army from one of your forts at position `i` to an empty position `j` such that:\n\n*   `0 <= i, j <= n - 1`\n*   The army travels over enemy forts **only**. Formally, for all `k` where `min(i,j) < k < max(i,j)`, `forts[k] == 0.`\n\nWhile moving the army, all the enemy forts that come in the way are **captured**.\n\nReturn _the **maximum** number of enemy forts that can be captured_. In case it is **impossible** to move your army, or you do not have any fort under your command, return `0`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** forts = \\[1,0,0,-1,0,0,0,0,1\\]\n**Output:** 4\n**Explanation:**\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\n",
                "**Example 2:**\n\n**Input:** forts = \\[0,0,1,-1\\]\n**Output:** 0\n**Explanation:** Since no enemy fort can be captured, 0 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= forts.length <= 1000`\n*   `-1 <= forts[i] <= 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[1,0,0,-1,0,0,0,0,1]",
                "output": "4"
            },
            {
                "input": "[0,0,1,-1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxCapturedForts(int[] forts) {\n    int n = forts.length;\n    int maxCapture = 0;\n    for(int i = 0; i < n; i++) {\n        if(forts[i] == 1) {\n            for(int j = i + 1; j < n; j++) {\n                if(forts[j] != -1) {\n                    int capture = 0;\n                    for(int k = i + 1; k < j; k++) {\n                        if(forts[k] == 0) capture++;\n                    }\n                    if(forts[j] == 1) maxCapture = Math.max(maxCapture, capture);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}\n```\n\n    \n    For each of our fort (1), we try to move our army to another our fort (1) through enemy forts (0). For each pair of our forts, we count how many enemy forts we can capture in between our forts. We are only interested in the pair that captures the maximum number of enemy forts.\n\n1. Iterate through each element in the array.\n2. If the current fort is our fort (1), we iterate through the rest of the elements.\n3. If the next element `j` is not an empty position (-1), we count the number of enemy forts we can capture.\n4. If `forts[j]` is equal to 1, it means it's our fort, and we update the maximum number of captures.\n5. After iterating through all elements, return the maximum number of captures.\n    ",
        "python": "\n    ```python\ndef max_captured_forts(forts):\n    n = len(forts)\n    max_capture = 0\n    for i in range(n):\n        if forts[i] == 1:\n            for j in range(i+1, n):\n                if forts[j] != -1:\n                    capture = sum(1 for k in range(i+1, j) if forts[k] == 0)\n                    if forts[j] == 1:\n                        max_capture = max(max_capture, capture)\n    return max_capture\n```\n\n    \n    For each of our fort (1), we try to move our army to another our fort (1) through enemy forts (0). For each pair of our forts, we count how many enemy forts we can capture in between our forts. We are only interested in the pair that captures the maximum number of enemy forts.\n\n1. Iterate through each element in the array.\n2. If the current fort is our fort (1), we iterate through the rest of the elements.\n3. If the next element `j` is not an empty position (-1), we count the number of enemy forts we can capture.\n4. If `forts[j]` is equal to 1, it means it's our fort, and we update the maximum number of captures.\n5. After iterating through all elements, return the maximum number of captures.\n    ",
        "c++": "\n    ```cpp\nint maxCapturedForts(vector<int>& forts) {\n    int n = forts.size();\n    int maxCapture = 0;\n    for(int i = 0; i < n; i++) {\n        if(forts[i] == 1) {\n            for(int j = i + 1; j < n; j++) {\n                if(forts[j] != -1) {\n                    int capture = 0;\n                    for(int k = i + 1; k < j; k++) {\n                        if(forts[k] == 0) capture++;\n                    }\n                    if(forts[j] == 1) maxCapture = max(maxCapture, capture);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}\n```\n\n    \n    For each of our fort (1), we try to move our army to another our fort (1) through enemy forts (0). For each pair of our forts, we count how many enemy forts we can capture in between our forts. We are only interested in the pair that captures the maximum number of enemy forts.\n\n1. Iterate through each element in the array.\n2. If the current fort is our fort (1), we iterate through the rest of the elements.\n3. If the next element `j` is not an empty position (-1), we count the number of enemy forts we can capture.\n4. If `forts[j]` is equal to 1, it means it's our fort, and we update the maximum number of captures.\n5. After iterating through all elements, return the maximum number of captures.\n    ",
        "js": "\n    ```javascript\nfunction maxCapturedForts(forts) {\n    const n = forts.length;\n    let maxCapture = 0;\n    for(let i = 0; i < n; i++) {\n        if(forts[i] === 1) {\n            for(let j = i + 1; j < n; j++) {\n                if(forts[j] !== -1) {\n                    let capture = 0;\n                    for(let k = i + 1; k < j; k++) {\n                        if(forts[k] === 0) capture++;\n                    }\n                    if(forts[j] === 1) maxCapture = Math.max(maxCapture, capture);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}\n```\n\n    \n    For each of our fort (1), we try to move our army to another our fort (1) through enemy forts (0). For each pair of our forts, we count how many enemy forts we can capture in between our forts. We are only interested in the pair that captures the maximum number of enemy forts.\n\n1. Iterate through each element in the array.\n2. If the current fort is our fort (1), we iterate through the rest of the elements.\n3. If the next element `j` is not an empty position (-1), we count the number of enemy forts we can capture.\n4. If `forts[j]` is equal to 1, it means it's our fort, and we update the maximum number of captures.\n5. After iterating through all elements, return the maximum number of captures.\n    "
    },
    {
        "id": 461,
        "title": "Shortest Distance to Target String in a Circular Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** **circular** string array `words` and a string `target`. A **circular array** means that the array's end connects to the array's beginning.\n\n*   Formally, the next element of `words[i]` is `words[(i + 1) % n]` and the previous element of `words[i]` is `words[(i - 1 + n) % n]`, where `n` is the length of `words`.\n\nStarting from `startIndex`, you can move to either the next word or the previous word with `1` step at a time.\n\nReturn _the **shortest** distance needed to reach the string_ `target`. If the string `target` does not exist in `words`, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"hello \", \"i \", \"am \", \"leetcode \", \"hello \"\\], target =  \"hello \", startIndex = 1\n**Output:** 1\n**Explanation:** We start from index 1 and can reach  \"hello \" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach  \"hello \" is 1.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"b \", \"leetcode \"\\], target =  \"leetcode \", startIndex = 0\n**Output:** 1\n**Explanation:** We start from index 0 and can reach  \"leetcode \" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach  \"leetcode \" is 1.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"i \", \"eat \", \"leetcode \"\\], target =  \"ate \", startIndex = 0\n**Output:** -1\n**Explanation:** Since  \"ate \" does not exist in `words`, we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` and `target` consist of only lowercase English letters.\n*   `0 <= startIndex < words.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"],\"hello\",1",
                "output": "1"
            },
            {
                "input": "[\"a\",\"b\",\"leetcode\"],\"leetcode\",0",
                "output": "1"
            },
            {
                "input": "[\"i\",\"eat\",\"leetcode\"],\"ate\",0",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int shortest_distance(String[] words, String target, int startIndex) {\n    int n = words.length;\n    int left = 0, right = 0, i = startIndex;\n    while (true) {\n        if (words[i].equals(target)) {\n            return Math.min(left, right);\n        }\n        left++;\n        right++;\n        i = (i + 1) % n;\n        if (left == n) {\n            break;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm initializes the variables left, right, and i to count the minimum steps taken to reach the target string. It starts searching from the startIndex and iterates in a circular manner with the help of the modulo operator. When the word at the current index i matches the target, the minimum of left and right is returned as the shortest distance. If no matching word is found after the entire traversal, the algorithm returns -1. The reason for maintaining both left and right counters is that we are allowed to move in both directions (previous or next) from the startIndex. Both left and right counters are incremented in each iteration for every step taken during the search.\n\nThe code provided above is directly focused on solving the given problem, looping over until either the target is found or the traversal is complete, and in each language, the syntax is adapted to match the respective language conventions. The logic and algorithm stay the same across all languages.\n    ",
        "python": "\n    ```python\ndef shortest_distance(words, target, startIndex):\n    n = len(words)\n    left, right, i = 0, 0, startIndex\n    while True:\n        if words[i] == target:\n            return min(left, right)\n        left += 1\n        right += 1\n        i = (i + 1) % n\n        if left == n:\n            break\n    return -1\n```\n    \n    The algorithm initializes the variables left, right, and i to count the minimum steps taken to reach the target string. It starts searching from the startIndex and iterates in a circular manner with the help of the modulo operator. When the word at the current index i matches the target, the minimum of left and right is returned as the shortest distance. If no matching word is found after the entire traversal, the algorithm returns -1. The reason for maintaining both left and right counters is that we are allowed to move in both directions (previous or next) from the startIndex. Both left and right counters are incremented in each iteration for every step taken during the search.\n\nThe code provided above is directly focused on solving the given problem, looping over until either the target is found or the traversal is complete, and in each language, the syntax is adapted to match the respective language conventions. The logic and algorithm stay the same across all languages.\n    ",
        "c++": "\n    ```cpp\nint shortest_distance(vector<string>& words, string target, int startIndex) {\n    int n = words.size();\n    int left = 0, right = 0, i = startIndex;\n    while (true) {\n        if (words[i] == target) {\n            return min(left, right);\n        }\n        left++;\n        right++;\n        i = (i + 1) % n;\n        if (left == n) {\n            break;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm initializes the variables left, right, and i to count the minimum steps taken to reach the target string. It starts searching from the startIndex and iterates in a circular manner with the help of the modulo operator. When the word at the current index i matches the target, the minimum of left and right is returned as the shortest distance. If no matching word is found after the entire traversal, the algorithm returns -1. The reason for maintaining both left and right counters is that we are allowed to move in both directions (previous or next) from the startIndex. Both left and right counters are incremented in each iteration for every step taken during the search.\n\nThe code provided above is directly focused on solving the given problem, looping over until either the target is found or the traversal is complete, and in each language, the syntax is adapted to match the respective language conventions. The logic and algorithm stay the same across all languages.\n    ",
        "js": "\n    ```javascript\nfunction shortest_distance(words, target, startIndex) {\n    let n = words.length;\n    let left = 0, right = 0, i = startIndex;\n    while (true) {\n        if (words[i] === target) {\n            return Math.min(left, right);\n        }\n        left++;\n        right++;\n        i = (i + 1) % n;\n        if (left === n) {\n            break;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm initializes the variables left, right, and i to count the minimum steps taken to reach the target string. It starts searching from the startIndex and iterates in a circular manner with the help of the modulo operator. When the word at the current index i matches the target, the minimum of left and right is returned as the shortest distance. If no matching word is found after the entire traversal, the algorithm returns -1. The reason for maintaining both left and right counters is that we are allowed to move in both directions (previous or next) from the startIndex. Both left and right counters are incremented in each iteration for every step taken during the search.\n\nThe code provided above is directly focused on solving the given problem, looping over until either the target is found or the traversal is complete, and in each language, the syntax is adapted to match the respective language conventions. The logic and algorithm stay the same across all languages.\n    "
    },
    {
        "id": 462,
        "title": "Count the Digits That Divide a Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, return _the number of digits in `num` that divide_ `num`.\n\nAn integer `val` divides `nums` if `nums % val == 0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 7\n**Output:** 1\n**Explanation:** 7 divides itself, hence the answer is 1.\n\n",
                "**Example 2:**\n\n**Input:** num = 121\n**Output:** 2\n**Explanation:** 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.\n\n",
                "**Example 3:**\n\n**Input:** num = 1248\n**Output:** 4\n**Explanation:** 1248 is divisible by all of its digits, hence the answer is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 109`\n*   `num` does not contain `0` as one of its digits.",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "7",
                "output": "1"
            },
            {
                "input": "121",
                "output": "2"
            },
            {
                "input": "1248",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int digitsDividingNum(int num) {\n    int count = 0, temp = num;\n    while (temp > 0) {\n        int digit = temp % 10;\n        if (num % digit == 0) {\n            count++;\n        }\n        temp /= 10;\n    }\n    return count;\n}\n```\n\n    \n    The algorithm for counting the number of digits in `num` that divide `num` is as follows:\n\n1. Create a variable `count` to store the count of such digits, and set it to 0.\n2. Create a temporary variable `temp` equal to the given `num`.\n3. While `temp` is greater than 0, follow these steps:\n    a. Find the last digit of `temp` by calculating the remainder of the division `temp % 10`.\n    b. Check if `num % digit` is equal to 0; if so, increment the `count` by 1.\n    c. Remove the last digit of `temp` by integer dividing it by 10 (i.e., `temp /= 10` in C++ and Java, `temp //= 10` in Python, or `temp = Math.floor(temp / 10)` in JavaScript).\n4. Return the `count`.\n\nEach language implements these steps in a fairly similar way, with only minor syntax differences between them.\n    ",
        "python": "\n    ```python\ndef digits_dividing_num(num):\n    count = 0\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n        if num % digit == 0:\n            count += 1\n        temp //= 10\n    return count\n```\n\n    \n    The algorithm for counting the number of digits in `num` that divide `num` is as follows:\n\n1. Create a variable `count` to store the count of such digits, and set it to 0.\n2. Create a temporary variable `temp` equal to the given `num`.\n3. While `temp` is greater than 0, follow these steps:\n    a. Find the last digit of `temp` by calculating the remainder of the division `temp % 10`.\n    b. Check if `num % digit` is equal to 0; if so, increment the `count` by 1.\n    c. Remove the last digit of `temp` by integer dividing it by 10 (i.e., `temp /= 10` in C++ and Java, `temp //= 10` in Python, or `temp = Math.floor(temp / 10)` in JavaScript).\n4. Return the `count`.\n\nEach language implements these steps in a fairly similar way, with only minor syntax differences between them.\n    ",
        "c++": "\n    ```cpp\nint digitsDividingNum(int num) {\n    int count = 0, temp = num;\n    while (temp > 0) {\n        int digit = temp % 10;\n        if (num % digit == 0) {\n            count++;\n        }\n        temp /= 10;\n    }\n    return count;\n}\n```\n\n    \n    The algorithm for counting the number of digits in `num` that divide `num` is as follows:\n\n1. Create a variable `count` to store the count of such digits, and set it to 0.\n2. Create a temporary variable `temp` equal to the given `num`.\n3. While `temp` is greater than 0, follow these steps:\n    a. Find the last digit of `temp` by calculating the remainder of the division `temp % 10`.\n    b. Check if `num % digit` is equal to 0; if so, increment the `count` by 1.\n    c. Remove the last digit of `temp` by integer dividing it by 10 (i.e., `temp /= 10` in C++ and Java, `temp //= 10` in Python, or `temp = Math.floor(temp / 10)` in JavaScript).\n4. Return the `count`.\n\nEach language implements these steps in a fairly similar way, with only minor syntax differences between them.\n    ",
        "js": "\n    ```javascript\nfunction digitsDividingNum(num) {\n    let count = 0, temp = num;\n    while (temp > 0) {\n        let digit = temp % 10;\n        if (num % digit === 0) {\n            count++;\n        }\n        temp = Math.floor(temp / 10);\n    }\n    return count;\n}\n```\n\n    \n    The algorithm for counting the number of digits in `num` that divide `num` is as follows:\n\n1. Create a variable `count` to store the count of such digits, and set it to 0.\n2. Create a temporary variable `temp` equal to the given `num`.\n3. While `temp` is greater than 0, follow these steps:\n    a. Find the last digit of `temp` by calculating the remainder of the division `temp % 10`.\n    b. Check if `num % digit` is equal to 0; if so, increment the `count` by 1.\n    c. Remove the last digit of `temp` by integer dividing it by 10 (i.e., `temp /= 10` in C++ and Java, `temp //= 10` in Python, or `temp = Math.floor(temp / 10)` in JavaScript).\n4. Return the `count`.\n\nEach language implements these steps in a fairly similar way, with only minor syntax differences between them.\n    "
    },
    {
        "id": 463,
        "title": "Categorize Box According to Criteria",
        "difficulty": "Easy",
        "content": {
            "problem": "Given four integers `length`, `width`, `height`, and `mass`, representing the dimensions and mass of a box, respectively, return _a string representing the **category** of the box_.\n\n*   The box is `\"Bulky \"` if:\n    *   **Any** of the dimensions of the box is greater or equal to `104`.\n    *   Or, the **volume** of the box is greater or equal to `109`.\n*   If the mass of the box is greater or equal to `100`, it is `\"Heavy \".`\n*   If the box is both `\"Bulky \"` and `\"Heavy \"`, then its category is `\"Both \"`.\n*   If the box is neither `\"Bulky \"` nor `\"Heavy \"`, then its category is `\"Neither \"`.\n*   If the box is `\"Bulky \"` but not `\"Heavy \"`, then its category is `\"Bulky \"`.\n*   If the box is `\"Heavy \"` but not `\"Bulky \"`, then its category is `\"Heavy \"`.\n\n**Note** that the volume of the box is the product of its length, width and height.",
            "examples": [
                "**Example 1:**\n\n**Input:** length = 1000, width = 35, height = 700, mass = 300\n**Output:**  \"Heavy \"\n**Explanation:** \nNone of the dimensions of the box is greater or equal to 104. \nIts volume = 24500000 <= 109. So it cannot be categorized as  \"Bulky \".\nHowever mass >= 100, so the box is  \"Heavy \".\nSince the box is not  \"Bulky \" but  \"Heavy \", we return  \"Heavy \".\n\n",
                "**Example 2:**\n\n**Input:** length = 200, width = 50, height = 800, mass = 50\n**Output:**  \"Neither \"\n**Explanation:** \nNone of the dimensions of the box is greater or equal to 104.\nIts volume = 8 \\* 106 <= 109. So it cannot be categorized as  \"Bulky \".\nIts mass is also less than 100, so it cannot be categorized as  \"Heavy \" either. \nSince its neither of the two above categories, we return  \"Neither \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= length, width, height <= 105`\n*   `1 <= mass <= 103`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "1000,35,700,300",
                "output": "\"Heavy\""
            },
            {
                "input": "200,50,800,50",
                "output": "\"Neither\""
            }
        ],
        "java": "\n    ```java\npublic String boxCategory(int length, int width, int height, int mass) {\n    boolean bulky = length >= 10000 || width >= 10000 || height >= 10000 || (long)length * width * height >= 1000000000;\n    boolean heavy = mass >= 100;\n    \n    if (bulky && heavy) return \"Both \";\n    if (bulky) return \"Bulky \";\n    if (heavy) return \"Heavy \";\n    return \"Neither \";\n}\n```\n    \n    The algorithm first checks if the box is bulky by verifying if any of the dimensions equal or exceed 10^4, or if the volume of the box is equal to or greater than 10^9. If the mass of the box is greater or equal to 100, then it's considered heavy.\n\nWe then use conditional statements to determine the category of the box according to the values of the bulky and heavy variables.\n\nIf both the bulky and heavy conditions are true, we return \"Both \". If bulky is true and heavy is false, we return \"Bulky \". If heavy is true and bulky is false, we return \"Heavy \". Otherwise, if neither condition is true, we return \"Neither \".\n    ",
        "python": "\n    ```python\ndef boxCategory(length: int, width: int, height: int, mass: int) -> str:\n    bulky = length >= 10000 or width >= 10000 or height >= 10000 or int(length) * width * height >= 1000000000\n    heavy = mass >= 100\n    \n    if bulky and heavy:\n        return \"Both \"\n    if bulky:\n        return \"Bulky \"\n    if heavy:\n        return \"Heavy \"\n    return \"Neither \"\n```\n    \n    The algorithm first checks if the box is bulky by verifying if any of the dimensions equal or exceed 10^4, or if the volume of the box is equal to or greater than 10^9. If the mass of the box is greater or equal to 100, then it's considered heavy.\n\nWe then use conditional statements to determine the category of the box according to the values of the bulky and heavy variables.\n\nIf both the bulky and heavy conditions are true, we return \"Both \". If bulky is true and heavy is false, we return \"Bulky \". If heavy is true and bulky is false, we return \"Heavy \". Otherwise, if neither condition is true, we return \"Neither \".\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string boxCategory(int length, int width, int height, int mass) {\n    bool bulky = length >= 10000 || width >= 10000 || height >= 10000 || (long)length * width * height >= 1000000000;\n    bool heavy = mass >= 100;\n    \n    if (bulky && heavy) return \"Both \";\n    if (bulky) return \"Bulky \";\n    if (heavy) return \"Heavy \";\n    return \"Neither \";\n}\n```\n    \n    The algorithm first checks if the box is bulky by verifying if any of the dimensions equal or exceed 10^4, or if the volume of the box is equal to or greater than 10^9. If the mass of the box is greater or equal to 100, then it's considered heavy.\n\nWe then use conditional statements to determine the category of the box according to the values of the bulky and heavy variables.\n\nIf both the bulky and heavy conditions are true, we return \"Both \". If bulky is true and heavy is false, we return \"Bulky \". If heavy is true and bulky is false, we return \"Heavy \". Otherwise, if neither condition is true, we return \"Neither \".\n    ",
        "js": "\n    ```javascript\nfunction boxCategory(length, width, height, mass) {\n    const bulky = length >= 10000 || width >= 10000 || height >= 10000 || length * width * height >= 1000000000;\n    const heavy = mass >= 100;\n\n    if (bulky && heavy) return \"Both \";\n    if (bulky) return \"Bulky \";\n    if (heavy) return \"Heavy \";\n    return \"Neither \";\n}\n```\n    \n    The algorithm first checks if the box is bulky by verifying if any of the dimensions equal or exceed 10^4, or if the volume of the box is equal to or greater than 10^9. If the mass of the box is greater or equal to 100, then it's considered heavy.\n\nWe then use conditional statements to determine the category of the box according to the values of the bulky and heavy variables.\n\nIf both the bulky and heavy conditions are true, we return \"Both \". If bulky is true and heavy is false, we return \"Bulky \". If heavy is true and bulky is false, we return \"Heavy \". Otherwise, if neither condition is true, we return \"Neither \".\n    "
    },
    {
        "id": 464,
        "title": "Maximum Count of Positive Integer and Negative Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` sorted in **non-decreasing** order, return _the maximum between the number of positive integers and the number of negative integers._\n\n*   In other words, if the number of positive integers in `nums` is `pos` and the number of negative integers is `neg`, then return the maximum of `pos` and `neg`.\n\n**Note** that `0` is neither positive nor negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,-1,-1,1,2,3\\]\n**Output:** 3\n**Explanation:** There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-3,-2,-1,0,0,1,2\\]\n**Output:** 3\n**Explanation:** There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[5,20,66,1314\\]\n**Output:** 4\n**Explanation:** There are 4 positive integers and 0 negative integers. The maximum count among them is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `-2000 <= nums[i] <= 2000`\n*   `nums` is sorted in a **non-decreasing order**.\n\n**",
            "follow_up": "Follow up:** Can you solve the problem in `O(log(n))` time complexity?"
        },
        "tag": [
            "Array",
            "Binary Search",
            "Counting"
        ],
        "example": [
            {
                "input": "[-2,-1,-1,1,2,3]",
                "output": "3"
            },
            {
                "input": "[-3,-2,-1,0,0,1,2]",
                "output": "3"
            },
            {
                "input": "[5,20,66,1314]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxPositiveNegativeCount(int[] nums) {\n    int pos = 0;\n    while (pos < nums.length && nums[pos] < 0) {\n        pos++;\n    }\n    int neg = nums.length - pos;\n    return Math.max(pos, neg);\n}\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    ",
        "python": "\n    ```python\ndef max_positive_negative_count(nums):\n    pos = next((i for i, x in enumerate(nums) if x >= 0), len(nums))\n    neg = len(nums) - pos\n    return max(pos, neg)\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    ",
        "c++": "\n    ```cpp\nint maxPositiveNegativeCount(const vector<int>& nums) {\n    int pos = upper_bound(nums.begin(), nums.end(), -1) - nums.begin();\n    int neg = nums.size() - pos;\n    return max(pos, neg);\n}\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    ",
        "js": "\n    ```javascript\nfunction maxPositiveNegativeCount(nums) {\n    let pos = 0;\n    while (pos < nums.length && nums[pos] < 0) {\n        pos++;\n    }\n    let neg = nums.length - pos;\n    return Math.max(pos, neg);\n}\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    "
    },
    {
        "id": 465,
        "title": "Difference Between Element Sum and Digit Sum of an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer array `nums`.\n\n*   The **element sum** is the sum of all the elements in `nums`.\n*   The **digit sum** is the sum of all the digits (not necessarily distinct) that appear in `nums`.\n\nReturn _the **absolute** difference between the **element sum** and **digit sum** of_ `nums`.\n\n**Note** that the absolute difference between two integers `x` and `y` is defined as `|x - y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,15,6,3\\]\n**Output:** 9\n**Explanation:** \nThe element sum of nums is 1 + 15 + 6 + 3 = 25.\nThe digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\nThe absolute difference between the element sum and digit sum is |25 - 16| = 9.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 0\n**Explanation:**\nThe element sum of nums is 1 + 2 + 3 + 4 = 10.\nThe digit sum of nums is 1 + 2 + 3 + 4 = 10.\nThe absolute difference between the element sum and digit sum is |10 - 10| = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `1 <= nums[i] <= 2000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,15,6,3]",
                "output": "9"
            },
            {
                "input": "[1,2,3,4]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int differenceBetweenElementAndDigitSum(int[] nums) {\n    int element_sum = 0, digit_sum = 0;\n    for (int num : nums) {\n        element_sum += num;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n    }\n    return Math.abs(element_sum - digit_sum);\n}\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "python": "\n    ```python\ndef difference_between_element_and_digit_sum(nums):\n    element_sum = sum(nums)\n    digit_sum = sum(sum(int(digit) for digit in str(num)) for num in nums)\n    return abs(element_sum - digit_sum)\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "c++": "\n    ```cpp\nint differenceBetweenElementAndDigitSum(vector<int>& nums) {\n    int element_sum = 0, digit_sum = 0;\n    for (int num : nums) {\n        element_sum += num;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n    }\n    return abs(element_sum - digit_sum);\n}\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "js": "\n    ```javascript\nfunction differenceBetweenElementAndDigitSum(nums) {\n    let element_sum = 0, digit_sum = 0;\n    for (let num of nums) {\n        element_sum += num;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n    }\n    return Math.abs(element_sum - digit_sum);\n}\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    "
    },
    {
        "id": 466,
        "title": "Alternating Digit Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer `n`. Each digit of `n` has a sign according to the following rules:\n\n*   The **most significant digit** is assigned a **positive** sign.\n*   Each other digit has an opposite sign to its adjacent digits.\n\nReturn _the sum of all digits with their corresponding sign_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 521\n**Output:** 4\n**Explanation:** (+5) + (-2) + (+1) = 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 111\n**Output:** 1\n**Explanation:** (+1) + (-1) + (+1) = 1.\n\n",
                "**Example 3:**\n\n**Input:** n = 886996\n**Output:** 0\n**Explanation:** (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "521",
                "output": "4"
            },
            {
                "input": "111",
                "output": "1"
            },
            {
                "input": "886996",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int sumOfDigits(int n) {\n    int sum = 0;\n    boolean positive = true;\n\n    while (n > 0) {\n        int digit = n % 10;\n        n /= 10;\n\n        if (positive) {\n            sum += digit;\n        } else {\n            sum -= digit;\n        }\n\n        positive = !positive;\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    ",
        "python": "\n    ```python\ndef sum_of_digits(n: int) -> int:\n    total = 0\n    positive = True\n\n    while n > 0:\n        digit = n % 10\n        n //= 10\n\n        if positive:\n            total += digit\n        else:\n            total -= digit\n\n        positive = not positive\n\n    return total\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    ",
        "c++": "\n    ```cpp\nint sumOfDigits(int n) {\n    int sum = 0;\n    bool positive = true;\n\n    while (n > 0) {\n        int digit = n % 10;\n        n /= 10;\n\n        if (positive) {\n            sum += digit;\n        } else {\n            sum -= digit;\n        }\n\n        positive = !positive;\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    ",
        "js": "\n    ```javascript\nfunction sumOfDigits(n) {\n    let sum = 0;\n    let positive = true;\n\n    while (n > 0) {\n        let digit = n % 10;\n        n = Math.floor(n / 10);\n\n        if (positive) {\n            sum += digit;\n        } else {\n            sum -= digit;\n        }\n\n        positive = !positive;\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    "
    },
    {
        "id": 467,
        "title": "Count Distinct Numbers on Board",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer `n`, that is initially placed on a board. Every day, for `109` days, you perform the following procedure:\n\n*   For each number `x` present on the board, find all numbers `1 <= i <= n` such that `x % i == 1`.\n*   Then, place those numbers on the board.\n\nReturn _the number of **distinct** integers present on the board after_ `109` _days have elapsed_.\n\n**Note:**\n\n*   Once a number is placed on the board, it will remain on it until the end.\n*   `%` stands for the modulo operation. For example, `14 % 3` is `2`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 4\n**Explanation:** Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "5",
                "output": "4"
            },
            {
                "input": "3",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int distinctNumbers(int n) {\n    return n - 1;\n}\n```\n\n    \n    For a given `n`, we only calculate the count of distinct integers that can be added to the board because of `n`.\n\nIt can be observed that only the numbers in the range `[2, n]` will satisfy the condition `x % i == 1`, where `x = n`. It is because when `i` is 1, we have `n % 1 == 0`. So, the numbers `[2, n-1]`, inclusive, will be added to the board, making the count of distinct integers on the board equal to `n - 1`.\n\nSince we are only concerned about the count of distinct integers and not the actual integers on the board, this algorithm works regardless of the value of `10^9` days.\n    ",
        "python": "\n    ```python\ndef distinct_numbers(n):\n    return n - 1\n```\n\n    \n    For a given `n`, we only calculate the count of distinct integers that can be added to the board because of `n`.\n\nIt can be observed that only the numbers in the range `[2, n]` will satisfy the condition `x % i == 1`, where `x = n`. It is because when `i` is 1, we have `n % 1 == 0`. So, the numbers `[2, n-1]`, inclusive, will be added to the board, making the count of distinct integers on the board equal to `n - 1`.\n\nSince we are only concerned about the count of distinct integers and not the actual integers on the board, this algorithm works regardless of the value of `10^9` days.\n    ",
        "c++": "\n    ```cpp\nint distinctNumbers(int n) {\n    return n - 1;\n}\n```\n\n    \n    For a given `n`, we only calculate the count of distinct integers that can be added to the board because of `n`.\n\nIt can be observed that only the numbers in the range `[2, n]` will satisfy the condition `x % i == 1`, where `x = n`. It is because when `i` is 1, we have `n % 1 == 0`. So, the numbers `[2, n-1]`, inclusive, will be added to the board, making the count of distinct integers on the board equal to `n - 1`.\n\nSince we are only concerned about the count of distinct integers and not the actual integers on the board, this algorithm works regardless of the value of `10^9` days.\n    ",
        "js": "\n    ```javascript\nfunction distinctNumbers(n) {\n    return n - 1;\n}\n```\n\n    \n    For a given `n`, we only calculate the count of distinct integers that can be added to the board because of `n`.\n\nIt can be observed that only the numbers in the range `[2, n]` will satisfy the condition `x % i == 1`, where `x = n`. It is because when `i` is 1, we have `n % 1 == 0`. So, the numbers `[2, n-1]`, inclusive, will be added to the board, making the count of distinct integers on the board equal to `n - 1`.\n\nSince we are only concerned about the count of distinct integers and not the actual integers on the board, this algorithm works regardless of the value of `10^9` days.\n    "
    },
    {
        "id": 468,
        "title": "Separate the Digits in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of positive integers `nums`, return _an array_ `answer` _that consists of the digits of each integer in_ `nums` _after separating them in **the same order** they appear in_ `nums`.\n\nTo separate the digits of an integer is to get all the digits it has in the same order.\n\n*   For example, for the integer `10921`, the separation of its digits is `[1,0,9,2,1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[13,25,83,77\\]\n**Output:** \\[1,3,2,5,8,3,7,7\\]\n**Explanation:** \n- The separation of 13 is \\[1,3\\].\n- The separation of 25 is \\[2,5\\].\n- The separation of 83 is \\[8,3\\].\n- The separation of 77 is \\[7,7\\].\nanswer = \\[1,3,2,5,8,3,7,7\\]. Note that answer contains the separations in the same order.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,1,3,9\\]\n**Output:** \\[7,1,3,9\\]\n**Explanation:** The separation of each integer in nums is itself.\nanswer = \\[7,1,3,9\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[13,25,83,77]",
                "output": "[1,3,2,5,8,3,7,7]"
            },
            {
                "input": "[7,1,3,9]",
                "output": "[7,1,3,9]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> separateDigits(int[] nums) {\n    List<Integer> answer = new ArrayList<>();\n    for (int num : nums) {\n        String numStr = Integer.toString(num);\n        for (char ch : numStr.toCharArray()) {\n            answer.add(Character.getNumericValue(ch));\n        }\n    }\n    return answer;\n}\n```\n\n    \n    For each number num in the nums array:\n\n1. Convert the number to its string representation.\n2. Iterate through the string and extract the digits, appending them to the answer array.\n\nRepeat this process for all numbers in the nums array.\n    ",
        "python": "\n    ```python\ndef separate_digits(nums):\n    answer = []\n    for num in nums:\n        digits = [int(d) for d in str(num)]\n        answer.extend(digits)\n    return answer\n```\n\n    \n    For each number num in the nums array:\n\n1. Convert the number to its string representation.\n2. Iterate through the string and extract the digits, appending them to the answer array.\n\nRepeat this process for all numbers in the nums array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> separateDigits(const std::vector<int>& nums) {\n    std::vector<int> answer;\n    for(auto num : nums) {\n        std::vector<int> digits;\n        while(num) {\n            digits.insert(digits.begin(), num % 10);\n            num /= 10;\n        }\n        answer.insert(answer.end(), digits.begin(), digits.end());\n    }\n    return answer;\n}\n```\n\n    \n    For each number num in the nums array:\n\n1. Convert the number to its string representation.\n2. Iterate through the string and extract the digits, appending them to the answer array.\n\nRepeat this process for all numbers in the nums array.\n    ",
        "js": "\n    ```javascript\nfunction separateDigits(nums) {\n    const answer = [];\n    for (const num of nums) {\n        const digits = num.toString().split(\"\").map(Number);\n        answer.push(...digits);\n    }\n    return answer;\n}\n```\n\n    \n    For each number num in the nums array:\n\n1. Convert the number to its string representation.\n2. Iterate through the string and extract the digits, appending them to the answer array.\n\nRepeat this process for all numbers in the nums array.\n    "
    },
    {
        "id": 469,
        "title": "Take Gifts From the Richest Pile",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `gifts` denoting the number of gifts in various piles. Every second, you do the following:\n\n*   Choose the pile with the maximum number of gifts.\n*   If there is more than one pile with the maximum number of gifts, choose any.\n*   Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\n\nReturn _the number of gifts remaining after_ `k` _seconds._",
            "examples": [
                "**Example 1:**\n\n**Input:** gifts = \\[25,64,9,4,100\\], k = 4\n**Output:** 29\n**Explanation:** \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are \\[5,8,9,4,3\\], so the total number of gifts remaining is 29.\n\n",
                "**Example 2:**\n\n**Input:** gifts = \\[1,1,1,1\\], k = 4\n**Output:** 4\n**Explanation:** \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= gifts.length <= 103`\n*   `1 <= gifts[i] <= 109`\n*   `1 <= k <= 103`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "example": [
            {
                "input": "[25,64,9,4,100],4",
                "output": "29"
            },
            {
                "input": "[1,1,1,1],4",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int giftsRemaining(int[] gifts, int k) {\n    for (int i = 0; i < k; i++) {\n        Arrays.sort(gifts);\n        int maxIndex = gifts.length - 1;\n        gifts[maxIndex] -= (int) Math.sqrt(gifts[maxIndex]);\n    }\n    int remaining_gifts = 0;\n    for (int gift : gifts) remaining_gifts += gift;\n    return remaining_gifts;\n}\n```\n    \n    The algorithm iterates `k` times, in each iteration:\n1. Sort the array `gifts` in non-decreasing order.\n2. Find the maximum number of gifts in the pile (last element after sorting).\n3. Update the maximum pile by removing the taken gifts from it, which is the number of gifts minus the floor of its square root.\n4. After the `k` iterations, calculate the sum of the elements in the `gifts` array and return it.\n    ",
        "python": "\n    ```python\nimport math\n\ndef giftsRemaining(gifts, k):\n    for i in range(k):\n        gifts.sort()\n        max_index = len(gifts) - 1\n        gifts[max_index] -= int(math.sqrt(gifts[max_index]))\n    return sum(gifts)\n```\n    \n    The algorithm iterates `k` times, in each iteration:\n1. Sort the array `gifts` in non-decreasing order.\n2. Find the maximum number of gifts in the pile (last element after sorting).\n3. Update the maximum pile by removing the taken gifts from it, which is the number of gifts minus the floor of its square root.\n4. After the `k` iterations, calculate the sum of the elements in the `gifts` array and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nint giftsRemaining(std::vector<int>& gifts, int k) {\n    for (int i = 0; i < k; i++) {\n        std::sort(gifts.begin(), gifts.end());\n        int maxIndex = gifts.size() - 1;\n        gifts[maxIndex] -= (int)(sqrt(gifts[maxIndex]));\n    }\n    int remaining_gifts = 0;\n    for (int gift : gifts) remaining_gifts += gift;\n    return remaining_gifts;\n}\n```\n    \n    The algorithm iterates `k` times, in each iteration:\n1. Sort the array `gifts` in non-decreasing order.\n2. Find the maximum number of gifts in the pile (last element after sorting).\n3. Update the maximum pile by removing the taken gifts from it, which is the number of gifts minus the floor of its square root.\n4. After the `k` iterations, calculate the sum of the elements in the `gifts` array and return it.\n    ",
        "js": "\n    ```javascript\nfunction giftsRemaining(gifts, k) {\n    for (let i = 0; i < k; i++) {\n        gifts.sort((a, b) => a - b);\n        let maxIndex = gifts.length - 1;\n        gifts[maxIndex] -= Math.floor(Math.sqrt(gifts[maxIndex]));\n    }\n    return gifts.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n}\n```\n    \n    The algorithm iterates `k` times, in each iteration:\n1. Sort the array `gifts` in non-decreasing order.\n2. Find the maximum number of gifts in the pile (last element after sorting).\n3. Update the maximum pile by removing the taken gifts from it, which is the number of gifts minus the floor of its square root.\n4. After the `k` iterations, calculate the sum of the elements in the `gifts` array and return it.\n    "
    },
    {
        "id": 470,
        "title": "Find the Array Concatenation Value",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`.\n\nThe **concatenation** of two numbers is the number formed by concatenating their numerals.\n\n*   For example, the concatenation of `15`, `49` is `1549`.\n\nThe **concatenation value** of `nums` is initially equal to `0`. Perform this operation until `nums` becomes empty:\n\n*   If there exists more than one number in `nums`, pick the first element and last element in `nums` respectively and add the value of their concatenation to the **concatenation value** of `nums`, then delete the first and last element from `nums`.\n*   If one element exists, add its value to the **concatenation value** of `nums`, then delete it.\n\nReturn _the concatenation value of the `nums`_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,52,2,4\\]\n**Output:** 596\n**Explanation:** Before performing any operation, nums is \\[7,52,2,4\\] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to \\[52,2\\].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,14,13,8,12\\]\n**Output:** 673\n**Explanation:** Before performing any operation, nums is \\[5,14,13,8,12\\] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to \\[14,13,8\\].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to \\[13\\].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Simulation"
        ],
        "example": [
            {
                "input": "[7,52,2,4]",
                "output": "596"
            },
            {
                "input": "[5,14,13,8,12]",
                "output": "673"
            }
        ],
        "java": "\n    ```java\npublic int concatenationValue(int[] nums) {\n    int value = 0;\n    int n = nums.length;\n    for (int i = 0; i < n; i += 2) {\n        if (i == n - 1 - i) {\n            value += nums[i];\n        } else {\n            value += Integer.parseInt(String.valueOf(nums[i]) + String.valueOf(nums[n - 1 - i]));\n        }\n    }\n    return value;\n}\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "python": "\n    ```python\ndef concatenationValue(nums):\n    value = 0\n    while nums:\n        n = len(nums)\n        if n == 1:\n            value += nums[0]\n            nums.pop()\n        else:\n            value += int(str(nums[0]) + str(nums[-1]))\n            nums.pop(0)\n            nums.pop()\n    return value\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "c++": "\n    ```cpp\nint concatenationValue(vector<int>& nums) {\n    int value = 0;\n    while (!nums.empty()) {\n        int n = nums.size();\n        if (n == 1) {\n            value += nums[0];\n            nums.pop_back();\n        } else {\n            value += stoi(to_string(nums[0]) + to_string(nums[n - 1]));\n            nums.erase(nums.begin());\n            nums.pop_back();\n        }\n    }\n    return value;\n}\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "js": "\n    ```javascript\nfunction concatenationValue(nums) {\n    let value = 0;\n    while (nums.length > 0) {\n        let n = nums.length;\n        if (n === 1) {\n            value += nums[0];\n            nums.pop();\n        } else {\n            value += parseInt(nums[0].toString() + nums[n - 1].toString());\n            nums.shift();\n            nums.pop();\n        }\n    }\n    return value;\n}\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    "
    },
    {
        "id": 471,
        "title": "Maximum Difference by Remapping a Digit",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `num`. You know that Danny Mittal will sneakily **remap** one of the `10` possible digits (`0` to `9`) to another digit.\n\nReturn _the difference between the maximum and minimum_ _values Danny can make by remapping **exactly** **one** digit_ _in_ `num`.\n\n**Notes:**\n\n*   When Danny remaps a digit d1 to another digit d2, Danny replaces all occurrences of `d1` in `num` with `d2`.\n*   Danny can remap a digit to itself, in which case `num` does not change.\n*   Danny can remap different digits for obtaining minimum and maximum values respectively.\n*   The resulting number after remapping can contain leading zeroes.\n*   We mentioned \"Danny Mittal \" to congratulate him on being in the top 10 in Weekly Contest 326.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 11891\n**Output:** 99009\n**Explanation:** \nTo achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899.\nTo achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890.\nThe difference between these two numbers is 99009.\n\n",
                "**Example 2:**\n\n**Input:** num = 90\n**Output:** 99\n**Explanation:**\nThe maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).\nThus, we return 99."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 108`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "11891",
                "output": "99009"
            },
            {
                "input": "90",
                "output": "99"
            }
        ],
        "java": "\n    ```java\nint diffMaxMin(int num) {\n    int maxRemap = 1, minRemap = 9;\n    String numStr = Integer.toString(num);\n    for (int i = 0; i < numStr.length(); i++) {\n        int digit = numStr.charAt(i) - '0';\n        maxRemap = Math.max(maxRemap, 9 - digit);\n        if (digit != 0) {\n            minRemap = Math.min(minRemap, digit);\n        }\n    }\n    int maxValue = num + maxRemap * (numStr.length() - numStr.replaceAll(Character.toString((char)('9' - maxRemap)), \"\").length());\n    int minValue = num - minRemap * (numStr.length() - numStr.replaceAll(Character.toString((char)(minRemap + '0')), \"\").length());\n    return maxValue - minValue;\n}\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    ",
        "python": "\n    ```python\ndef diffMaxMin(num):\n    max_remap = 1\n    min_remap = 9\n    num_str = str(num)\n    \n    for c in num_str:\n        digit = int(c)\n        max_remap = max(max_remap, 9 - digit)\n        if digit != 0:\n            min_remap = min(min_remap, digit)\n\n    max_value = num + max_remap * (len(num_str) - num_str.count(str(9 - max_remap)))\n    min_value = num - min_remap * num_str.count(str(min_remap))\n    return max_value - min_value\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    ",
        "c++": "\n    ```cpp\nint diffMaxMin(int num) {\n    int maxRemap = 1, minRemap = 9;\n    string numStr = to_string(num);\n    for (char c : numStr) {\n        int digit = c - '0';\n        maxRemap = max(maxRemap, 9 - digit);\n        if (digit != 0) {\n            minRemap = min(minRemap, digit);\n        }\n    }\n    int maxValue = num + maxRemap * (numStr.length() - count(numStr.begin(), numStr.end(), '9' - maxRemap));\n    int minValue = num - minRemap * count(numStr.begin(), numStr.end(), minRemap + '0');\n    return maxValue - minValue;\n}\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    ",
        "js": "\n    ```javascript\nfunction diffMaxMin(num) {\n    let maxRemap = 1, minRemap = 9;\n    let numStr = String(num);\n    for (const c of numStr) {\n        let digit = parseInt(c);\n        maxRemap = Math.max(maxRemap, 9 - digit);\n        if (digit !== 0) {\n            minRemap = Math.min(minRemap, digit);\n        }\n    }\n    let maxValue = num + maxRemap * (numStr.length - numStr.split('' + (9 - maxRemap)).length + 1);\n    let minValue = num - minRemap * (numStr.length - numStr.split('' + minRemap).length + 1);\n    return maxValue - minValue;\n}\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    "
    },
    {
        "id": 472,
        "title": "Merge Two 2D Arrays by Summing Values",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two **2D** integer arrays `nums1` and `nums2.`\n\n*   `nums1[i] = [idi, vali]` indicate that the number with the id `idi` has a value equal to `vali`.\n*   `nums2[i] = [idi, vali]` indicate that the number with the id `idi` has a value equal to `vali`.\n\nEach array contains **unique** ids and is sorted in **ascending** order by id.\n\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\n*   Only ids that appear in at least one of the two arrays should be included in the resulting array.\n*   Each id should be included **only once** and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be `0`.\n\nReturn _the resulting array_. The returned array must be sorted in ascending order by id.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[\\[1,2\\],\\[2,3\\],\\[4,5\\]\\], nums2 = \\[\\[1,4\\],\\[3,2\\],\\[4,1\\]\\]\n**Output:** \\[\\[1,6\\],\\[2,3\\],\\[3,2\\],\\[4,6\\]\\]\n**Explanation:** The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[\\[2,4\\],\\[3,6\\],\\[5,5\\]\\], nums2 = \\[\\[1,3\\],\\[4,3\\]\\]\n**Output:** \\[\\[1,3\\],\\[2,4\\],\\[3,6\\],\\[4,3\\],\\[5,5\\]\\]\n**Explanation:** There are no common ids, so we just include each id with its value in the resulting list."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 200`\n*   `nums1[i].length == nums2[j].length == 2`\n*   `1 <= idi, vali <= 1000`\n*   Both arrays contain unique ids.\n*   Both arrays are in strictly ascending order by id.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[4,5]],[[1,4],[3,2],[4,1]]",
                "output": "[[1,6],[2,3],[3,2],[4,6]]"
            },
            {
                "input": "[[2,4],[3,6],[5,5]],[[1,3],[4,3]]",
                "output": "[[1,3],[2,4],[3,6],[4,3],[5,5]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<Integer>> merge_nums(List<List<Integer>> nums1, List<List<Integer>> nums2) {\n    Map<Integer, Integer> merged_map = new HashMap<>();;\n    List<List<Integer>> merged = new ArrayList<>();\n\n    for(List<Integer> p : nums1) {\n        merged_map.put(p.get(0), merged_map.getOrDefault(p.get(0), 0) + p.get(1));\n    }\n\n    for(List<Integer> p : nums2) {\n        merged_map.put(p.get(0), merged_map.getOrDefault(p.get(0), 0) + p.get(1));\n    }\n\n    for(Map.Entry<Integer, Integer> entry : merged_map.entrySet()) {\n        List<Integer> tmp = new ArrayList<>();\n        tmp.add(entry.getKey());\n        tmp.add(entry.getValue());\n        merged.add(tmp);\n    }\n\n    return merged;\n}\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    ",
        "python": "\n    ```python\ndef merge_nums(nums1, nums2):\n    merged_map = {}\n    merged = []\n\n    for id_val_pair in nums1:\n        id_, val_ = id_val_pair\n        if id_ not in merged_map:\n            merged_map[id_] = val_\n        else:\n            merged_map[id_] += val_\n\n    for id_val_pair in nums2:\n        id_, val_ = id_val_pair\n        if id_ not in merged_map:\n            merged_map[id_] = val_\n        else:\n            merged_map[id_] += val_\n\n    for id_, val_ in merged_map.items():\n        merged.append([id_, val_])\n    \n    return merged\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n\nstd::vector<std::vector<int>> merge_nums(std::vector<std::vector<int>>& nums1, std::vector<std::vector<int>>& nums2) {\n    std::map<int, int> merged_map;\n    std::vector<std::vector<int>> merged;\n\n    for (const auto& p : nums1) {\n        merged_map[p[0]] += p[1];\n    }\n\n    for (const auto& p : nums2) {\n        merged_map[p[0]] += p[1];\n    }\n\n    for (const auto& p : merged_map) {\n        merged.push_back({p.first, p.second});\n    }\n\n    return merged;\n}\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    ",
        "js": "\n    ```javascript\nfunction merge_nums(nums1, nums2) {\n    const merged_map = new Map();\n    const merged = [];\n\n    for(const [id, val] of nums1) {\n        merged_map.set(id, (merged_map.get(id) || 0) + val);\n    }\n\n    for(const [id, val] of nums2) {\n        merged_map.set(id, (merged_map.get(id) || 0) + val);\n    }\n\n    for(const [id, val] of merged_map.entries()) {\n        merged.push([id, val]);\n    }\n\n    return merged;\n}\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    "
    },
    {
        "id": 473,
        "title": "Left and Right Sum Differences",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, find a **0-indexed** integer array `answer` where:\n\n*   `answer.length == nums.length`.\n*   `answer[i] = |leftSum[i] - rightSum[i]|`.\n\nWhere:\n\n*   `leftSum[i]` is the sum of elements to the left of the index `i` in the array `nums`. If there is no such element, `leftSum[i] = 0`.\n*   `rightSum[i]` is the sum of elements to the right of the index `i` in the array `nums`. If there is no such element, `rightSum[i] = 0`.\n\nReturn _the array_ `answer`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[10,4,8,3\\]\n**Output:** \\[15,1,11,22\\]\n**Explanation:** The array leftSum is \\[0,10,14,22\\] and the array rightSum is \\[15,11,3,0\\].\nThe array answer is \\[|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|\\] = \\[15,1,11,22\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[0\\]\n**Explanation:** The array leftSum is \\[0\\] and the array rightSum is \\[0\\].\nThe array answer is \\[|0 - 0|\\] = \\[0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[10,4,8,3]",
                "output": "[15,1,11,22]"
            },
            {
                "input": "[1]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\npublic int[] getAnswer(int[] nums) {\n    int n = nums.length;\n    int[] leftSum = new int[n];\n    int[] rightSum = new int[n];\n    int[] answer = new int[n];\n\n    for (int i = 1; i < n; i++) {\n        leftSum[i] = leftSum[i - 1] + nums[i - 1];\n    }\n\n    for (int i = n - 2; i >= 0; i--) {\n        rightSum[i] = rightSum[i + 1] + nums[i + 1];\n    }\n\n    for (int i = 0; i < n; i++) {\n        answer[i] = Math.abs(leftSum[i] - rightSum[i]);\n    }\n\n    return answer;\n}\n```\n\n    \n    We create three arrays of the same length as `nums` called `leftSum`, `rightSum`, and `answer`. \n\nWe then iterate over the `nums` array starting from 1 and populate the `leftSum` array with the sums of elements to the left of the index i.\n\nSimilarly, we iterate over the `nums` array in reverse order (starting from the second last element) and populate the `rightSum` array with the sums of elements to the right of the index i.\n\nFinally, we iterate over the `leftSum` and `rightSum` arrays and compute the absolute difference between the corresponding elements, storing the result in the `answer` array.\n    ",
        "python": "\n    ```python\ndef get_answer(nums):\n    n = len(nums)\n    left_sum, right_sum, answer = [0] * n, [0] * n, [0] * n\n\n    for i in range(1, n):\n        left_sum[i] = left_sum[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_sum[i] = right_sum[i + 1] + nums[i + 1]\n\n    for i in range(n):\n        answer[i] = abs(left_sum[i] - right_sum[i])\n\n    return answer\n```\n\n    \n    We create three arrays of the same length as `nums` called `leftSum`, `rightSum`, and `answer`. \n\nWe then iterate over the `nums` array starting from 1 and populate the `leftSum` array with the sums of elements to the left of the index i.\n\nSimilarly, we iterate over the `nums` array in reverse order (starting from the second last element) and populate the `rightSum` array with the sums of elements to the right of the index i.\n\nFinally, we iterate over the `leftSum` and `rightSum` arrays and compute the absolute difference between the corresponding elements, storing the result in the `answer` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nvector<int> getAnswer(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> leftSum(n, 0), rightSum(n, 0), answer(n, 0);\n\n    for (int i = 1; i < n; i++) {\n        leftSum[i] = leftSum[i - 1] + nums[i - 1];\n    }\n\n    for (int i = n - 2; i >= 0; i--) {\n        rightSum[i] = rightSum[i + 1] + nums[i + 1];\n    }\n\n    for (int i = 0; i < n; i++) {\n        answer[i] = abs(leftSum[i] - rightSum[i]);\n    }\n\n    return answer;\n}\n```\n\n    \n    We create three arrays of the same length as `nums` called `leftSum`, `rightSum`, and `answer`. \n\nWe then iterate over the `nums` array starting from 1 and populate the `leftSum` array with the sums of elements to the left of the index i.\n\nSimilarly, we iterate over the `nums` array in reverse order (starting from the second last element) and populate the `rightSum` array with the sums of elements to the right of the index i.\n\nFinally, we iterate over the `leftSum` and `rightSum` arrays and compute the absolute difference between the corresponding elements, storing the result in the `answer` array.\n    ",
        "js": "\n    ```javascript\nfunction getAnswer(nums) {\n    let n = nums.length;\n    let leftSum = new Array(n).fill(0);\n    let rightSum = new Array(n).fill(0);\n    let answer = new Array(n).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        leftSum[i] = leftSum[i - 1] + nums[i - 1];\n    }\n\n    for (let i = n - 2; i >= 0; i--) {\n        rightSum[i] = rightSum[i + 1] + nums[i + 1];\n    }\n\n    for (let i = 0; i < n; i++) {\n        answer[i] = Math.abs(leftSum[i] - rightSum[i]);\n    }\n\n    return answer;\n}\n```\n\n    \n    We create three arrays of the same length as `nums` called `leftSum`, `rightSum`, and `answer`. \n\nWe then iterate over the `nums` array starting from 1 and populate the `leftSum` array with the sums of elements to the left of the index i.\n\nSimilarly, we iterate over the `nums` array in reverse order (starting from the second last element) and populate the `rightSum` array with the sums of elements to the right of the index i.\n\nFinally, we iterate over the `leftSum` and `rightSum` arrays and compute the absolute difference between the corresponding elements, storing the result in the `answer` array.\n    "
    },
    {
        "id": 474,
        "title": "Split With Minimum Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer `num`, split it into two non-negative integers `num1` and `num2` such that:\n\n*   The concatenation of `num1` and `num2` is a permutation of `num`.\n    *   In other words, the sum of the number of occurrences of each digit in `num1` and `num2` is equal to the number of occurrences of that digit in `num`.\n*   `num1` and `num2` can contain leading zeros.\n\nReturn _the **minimum** possible sum of_ `num1` _and_ `num2`.\n\n**Notes:**\n\n*   It is guaranteed that `num` does not contain any leading zeros.\n*   The order of occurrence of the digits in `num1` and `num2` may differ from the order of occurrence of `num`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 4325\n**Output:** 59\n**Explanation:** We can split 4325 so that `num1` is 24 and num2 `is` 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n\n",
                "**Example 2:**\n\n**Input:** num = 687\n**Output:** 75\n**Explanation:** We can split 687 so that `num1` is 68 and `num2` is 7, which would give an optimal sum of 75."
            ],
            "constraints": "**Constraints:**\n\n*   `10 <= num <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "4325",
                "output": "59"
            },
            {
                "input": "687",
                "output": "75"
            }
        ],
        "java": "\n    ```java\nint minSumOfTwoNumbers(String num) {\n    int[] cnt = new int[10];\n    for (char c : num.toCharArray()) \n        cnt[c - '0']++;\n\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= 9; i += 2) {\n        int temp = cnt[i];\n        while (temp-- > 0)\n            num1 = num1 * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2) {\n        int temp = cnt[i];\n        while (temp-- > 0)\n            num2 = num2 * 10 + i;\n    }\n    return num1 + num2;\n}\n```\n    \n    The algorithm first creates a frequency count of each digit in the given number. Then, it initializes two variables representing `num1` and `num2`. Next, the algorithm iterates through the frequency count array, adding all odd digits to `num1` and all even digits to `num2`. Finally, the algorithm returns the sum of `num1` and `num2`.\n\nNote that the algorithm for each language is quite similar, with minor variations in syntax or the ways to compute the counts.\n    ",
        "python": "\n    ```python\ndef min_sum_of_two_numbers(num: str) -> int:\n    cnt = [0] * 10\n    for c in num:\n        cnt[int(c)] += 1\n\n    num1, num2 = 0, 0\n    for i in range(1, 10, 2):\n        temp = cnt[i]\n        while temp > 0:\n            num1 = num1 * 10 + i\n            temp -= 1\n    for i in range(0, 10, 2):\n        temp = cnt[i]\n        while temp > 0:\n            num2 = num2 * 10 + i\n            temp -= 1\n    return num1 + num2\n```\n    \n    The algorithm first creates a frequency count of each digit in the given number. Then, it initializes two variables representing `num1` and `num2`. Next, the algorithm iterates through the frequency count array, adding all odd digits to `num1` and all even digits to `num2`. Finally, the algorithm returns the sum of `num1` and `num2`.\n\nNote that the algorithm for each language is quite similar, with minor variations in syntax or the ways to compute the counts.\n    ",
        "c++": "\n    ```cpp\nint minSumOfTwoNumbers(string num) {\n    vector<int> cnt(10, 0);\n    for (char c : num) \n        cnt[c - '0']++;\n\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= 9; i += 2) {\n        int temp = cnt[i];\n        while (temp--)\n            num1 = num1 * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2) {\n        int temp = cnt[i];\n        while (temp--)\n            num2 = num2 * 10 + i;\n    }\n    return num1 + num2;\n}\n```\n    \n    The algorithm first creates a frequency count of each digit in the given number. Then, it initializes two variables representing `num1` and `num2`. Next, the algorithm iterates through the frequency count array, adding all odd digits to `num1` and all even digits to `num2`. Finally, the algorithm returns the sum of `num1` and `num2`.\n\nNote that the algorithm for each language is quite similar, with minor variations in syntax or the ways to compute the counts.\n    ",
        "js": "\n    ```javascript\nfunction minSumOfTwoNumbers(num) {\n    let cnt = new Array(10).fill(0);\n    for (let c of num) \n        cnt[c - '0']++;\n\n    let num1 = 0, num2 = 0;\n    for (let i = 1; i <= 9; i += 2) {\n        let temp = cnt[i];\n        while (temp--)\n            num1 = num1 * 10 + i;\n    }\n    for (let i = 0; i <= 9; i += 2) {\n        let temp = cnt[i];\n        while (temp--)\n            num2 = num2 * 10 + i;\n    }\n    return num1 + num2;\n}\n```\n    \n    The algorithm first creates a frequency count of each digit in the given number. Then, it initializes two variables representing `num1` and `num2`. Next, the algorithm iterates through the frequency count array, adding all odd digits to `num1` and all even digits to `num2`. Finally, the algorithm returns the sum of `num1` and `num2`.\n\nNote that the algorithm for each language is quite similar, with minor variations in syntax or the ways to compute the counts.\n    "
    },
    {
        "id": 475,
        "title": "Pass the Pillow",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` people standing in a line labeled from `1` to `n`. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\n*   For example, once the pillow reaches the `nth` person they pass it to the `n - 1th` person, then to the `n - 2th` person and so on.\n\nGiven the two positive integers `n` and `time`, return _the index of the person holding the pillow after_ `time` _seconds_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, time = 5\n**Output:** 2\n**Explanation:** People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfer five seconds, the pillow is given to the 2nd person.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, time = 2\n**Output:** 3\n**Explanation:** People pass the pillow in the following way: 1 -> 2 -> 3.\nAfer two seconds, the pillow is given to the 3rd person."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= time <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "4,5",
                "output": "2"
            },
            {
                "input": "3,2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int pillowHolder(int n, int time) {\n    time %= (2 * n - 2);\n    if (time <= n - 1) return time + 1;\n    else return 2 * n - time - 1;\n}\n```\n    \n    The algorithm uses modulo to find the person holding the pillow after a given amount of time. First, find the time modulo `2 * n - 2` (since the cycle of passing the pillow back and forth will repeat every `2 * n - 2` seconds). If the resulting time is less than or equal to `n - 1`, then the current holder of the pillow is at index `time + 1`. If not, the current holder is at index `2 * n - time - 1`. This accounts for the reverse direction in which the pillow is being passed back to the front of the line after reaching the end.\n    ",
        "python": "\n    ```python\ndef pillowHolder(n, time):\n    time %= (2 * n - 2)\n    if time <= n - 1:\n        return time + 1\n    else:\n        return 2 * n - time - 1\n```\n    \n    The algorithm uses modulo to find the person holding the pillow after a given amount of time. First, find the time modulo `2 * n - 2` (since the cycle of passing the pillow back and forth will repeat every `2 * n - 2` seconds). If the resulting time is less than or equal to `n - 1`, then the current holder of the pillow is at index `time + 1`. If not, the current holder is at index `2 * n - time - 1`. This accounts for the reverse direction in which the pillow is being passed back to the front of the line after reaching the end.\n    ",
        "c++": "\n    ```cpp\nint pillowHolder(int n, int time) {\n    time %= (2 * n - 2);\n    if (time <= n - 1) return time + 1;\n    else return 2 * n - time - 1;\n}\n```\n    \n    The algorithm uses modulo to find the person holding the pillow after a given amount of time. First, find the time modulo `2 * n - 2` (since the cycle of passing the pillow back and forth will repeat every `2 * n - 2` seconds). If the resulting time is less than or equal to `n - 1`, then the current holder of the pillow is at index `time + 1`. If not, the current holder is at index `2 * n - time - 1`. This accounts for the reverse direction in which the pillow is being passed back to the front of the line after reaching the end.\n    ",
        "js": "\n    ```javascript\nfunction pillowHolder(n, time) {\n    time %= (2 * n - 2);\n    if (time <= n - 1) return time + 1;\n    else return 2 * n - time - 1;\n}\n```\n    \n    The algorithm uses modulo to find the person holding the pillow after a given amount of time. First, find the time modulo `2 * n - 2` (since the cycle of passing the pillow back and forth will repeat every `2 * n - 2` seconds). If the resulting time is less than or equal to `n - 1`, then the current holder of the pillow is at index `time + 1`. If not, the current holder is at index `2 * n - time - 1`. This accounts for the reverse direction in which the pillow is being passed back to the front of the line after reaching the end.\n    "
    },
    {
        "id": 476,
        "title": "Count the Number of Vowel Strings in Range",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** array of string `words` and two integers `left` and `right`.\n\nA string is called a **vowel string** if it starts with a vowel character and ends with a vowel character where vowel characters are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`.\n\nReturn _the number of vowel strings_ `words[i]` _where_ `i` _belongs to the inclusive range_ `[left, right]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"are \", \"amy \", \"u \"\\], left = 0, right = 2\n**Output:** 2\n**Explanation:** \n-  \"are \" is a vowel string because it starts with 'a' and ends with 'e'.\n-  \"amy \" is not a vowel string because it does not end with a vowel.\n-  \"u \" is a vowel string because it starts with 'u' and ends with 'u'.\nThe number of vowel strings in the mentioned range is 2.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"hey \", \"aeo \", \"mu \", \"ooo \", \"artro \"\\], left = 1, right = 4\n**Output:** 3\n**Explanation:** \n-  \"aeo \" is a vowel string because it starts with 'a' and ends with 'o'.\n-  \"mu \" is not a vowel string because it does not start with a vowel.\n-  \"ooo \" is a vowel string because it starts with 'o' and ends with 'o'.\n-  \"artro \" is a vowel string because it starts with 'a' and ends with 'o'.\nThe number of vowel strings in the mentioned range is 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of only lowercase English letters.\n*   `0 <= left <= right < words.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"are\",\"amy\",\"u\"],0,2",
                "output": "2"
            },
            {
                "input": "[\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"],1,4",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic boolean isVowel(char c) {\n  return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\npublic int countVowelStrings(String[] words, int left, int right) {\n  int count = 0;\n  for (int i = left; i <= right; i++) {\n    if (isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length() - 1))) {\n      count++;\n    }\n  }\n  return count;\n}\n```\n    \n    We define `is_vowel` function that checks whether a given character is a vowel or not. In our `count_vowel_strings` function, we iterate over the range `[left, right]` and check if the first and last characters of the word at position `i` are vowels. If both are vowels, we increment the `count`. Finally, we return `count` as the result.\n    ",
        "python": "\n    ```python\ndef is_vowel(c):\n  return c in 'aeiou'\n\ndef count_vowel_strings(words, left, right):\n  count = 0\n  for i in range(left, right + 1):\n    if is_vowel(words[i][0]) and is_vowel(words[i][-1]):\n      count += 1\n  return count\n```\n    \n    We define `is_vowel` function that checks whether a given character is a vowel or not. In our `count_vowel_strings` function, we iterate over the range `[left, right]` and check if the first and last characters of the word at position `i` are vowels. If both are vowels, we increment the `count`. Finally, we return `count` as the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nbool is_vowel(char c) {\n  return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nint count_vowel_strings(std::vector<std::string>& words, int left, int right) {\n  int count = 0;\n  for (int i = left; i <= right; i++) {\n    if (is_vowel(words[i][0]) && is_vowel(words[i][words[i].length() - 1])) {\n      count++;\n    }\n  }\n  return count;\n}\n```\n    \n    We define `is_vowel` function that checks whether a given character is a vowel or not. In our `count_vowel_strings` function, we iterate over the range `[left, right]` and check if the first and last characters of the word at position `i` are vowels. If both are vowels, we increment the `count`. Finally, we return `count` as the result.\n    ",
        "js": "\n    ```javascript\nfunction isVowel(c) {\n  return ['a', 'e', 'i', 'o', 'u'].includes(c);\n}\n\nfunction countVowelStrings(words, left, right) {\n  let count = 0;\n  for (let i = left; i <= right; i++) {\n    if (isVowel(words[i][0]) && isVowel(words[i][words[i].length - 1])) {\n      count++;\n    }\n  }\n  return count;\n}\n```\n    \n    We define `is_vowel` function that checks whether a given character is a vowel or not. In our `count_vowel_strings` function, we iterate over the range `[left, right]` and check if the first and last characters of the word at position `i` are vowels. If both are vowels, we increment the `count`. Finally, we return `count` as the result.\n    "
    },
    {
        "id": 477,
        "title": "Distribute Money to Maximum Children",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `money` denoting the amount of money (in dollars) that you have and another integer `children` denoting the number of children that you must distribute the money to.\n\nYou have to distribute the money according to the following rules:\n\n*   All money must be distributed.\n*   Everyone must receive at least `1` dollar.\n*   Nobody receives `4` dollars.\n\nReturn _the **maximum** number of children who may receive **exactly**_ `8` _dollars if you distribute the money according to the aforementioned rules_. If there is no way to distribute the money, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** money = 20, children = 3\n**Output:** 1\n**Explanation:** \nThe maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:\n- 8 dollars to the first child.\n- 9 dollars to the second child. \n- 3 dollars to the third child.\nIt can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.\n\n",
                "**Example 2:**\n\n**Input:** money = 16, children = 2\n**Output:** 2\n**Explanation:** Each child can be given 8 dollars."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= money <= 200`\n*   `2 <= children <= 30`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "20,3",
                "output": "1"
            },
            {
                "input": "16,2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int maximumChildrenWithEightDollars(int money, int children) {\n    if (money < children * 1 || money > children * 8) return -1;\n    int max_eights = (money - children) / 7;\n    return max_eights >= children ? children : max_eights;\n}\n```\n    \n    In this problem, we calculate the maximum number of children who get exactly 8 dollars by making sure that we follow the given rules. We first check if it's possible to distribute money with these constraints. If the amount of money is less than the product of the number of children and 1 or greater than the product of the number of children and 8, return -1 as it's not possible.\n\nThen, find the maximum number of eights by subtracting the number of children from the amount of money and dividing the result by 7. We divide the result by 7, as we're trying to maximize the children getting exactly 8 dollars, and the other amounts could range from 1 to 3 or 5 to 7. \n\nFinally, if the maximum number of eights is greater than or equal to the number of children, return the number of children. Otherwise, return the maximum number of eights. This calculation ensures that we're getting the maximum number of children who get exactly 8 dollars.\n    ",
        "python": "\n    ```python\ndef maximum_children_with_eight_dollars(money, children):\n    if money < children * 1 or money > children * 8:\n        return -1\n    max_eights = (money - children) // 7\n    return children if max_eights >= children else max_eights\n```\n    \n    In this problem, we calculate the maximum number of children who get exactly 8 dollars by making sure that we follow the given rules. We first check if it's possible to distribute money with these constraints. If the amount of money is less than the product of the number of children and 1 or greater than the product of the number of children and 8, return -1 as it's not possible.\n\nThen, find the maximum number of eights by subtracting the number of children from the amount of money and dividing the result by 7. We divide the result by 7, as we're trying to maximize the children getting exactly 8 dollars, and the other amounts could range from 1 to 3 or 5 to 7. \n\nFinally, if the maximum number of eights is greater than or equal to the number of children, return the number of children. Otherwise, return the maximum number of eights. This calculation ensures that we're getting the maximum number of children who get exactly 8 dollars.\n    ",
        "c++": "\n    ```cpp\nint maximumChildrenWithEightDollars(int money, int children) {\n    if (money < children * 1 || money > children * 8) return -1;\n    int max_eights = (money - children) / 7;\n    return max_eights >= children ? children : max_eights;\n}\n```\n    \n    In this problem, we calculate the maximum number of children who get exactly 8 dollars by making sure that we follow the given rules. We first check if it's possible to distribute money with these constraints. If the amount of money is less than the product of the number of children and 1 or greater than the product of the number of children and 8, return -1 as it's not possible.\n\nThen, find the maximum number of eights by subtracting the number of children from the amount of money and dividing the result by 7. We divide the result by 7, as we're trying to maximize the children getting exactly 8 dollars, and the other amounts could range from 1 to 3 or 5 to 7. \n\nFinally, if the maximum number of eights is greater than or equal to the number of children, return the number of children. Otherwise, return the maximum number of eights. This calculation ensures that we're getting the maximum number of children who get exactly 8 dollars.\n    ",
        "js": "\n    ```javascript\nfunction maximumChildrenWithEightDollars(money, children) {\n    if (money < children * 1 || money > children * 8) return -1;\n    let max_eights = Math.floor((money - children) / 7);\n    return max_eights >= children ? children : max_eights;\n}\n```\n    \n    In this problem, we calculate the maximum number of children who get exactly 8 dollars by making sure that we follow the given rules. We first check if it's possible to distribute money with these constraints. If the amount of money is less than the product of the number of children and 1 or greater than the product of the number of children and 8, return -1 as it's not possible.\n\nThen, find the maximum number of eights by subtracting the number of children from the amount of money and dividing the result by 7. We divide the result by 7, as we're trying to maximize the children getting exactly 8 dollars, and the other amounts could range from 1 to 3 or 5 to 7. \n\nFinally, if the maximum number of eights is greater than or equal to the number of children, return the number of children. Otherwise, return the maximum number of eights. This calculation ensures that we're getting the maximum number of children who get exactly 8 dollars.\n    "
    },
    {
        "id": 478,
        "title": "Number of Even and Odd Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **positive** integer `n`.\n\nLet `even` denote the number of even indices in the binary representation of `n` (**0-indexed**) with value `1`.\n\nLet `odd` denote the number of odd indices in the binary representation of `n` (**0-indexed**) with value `1`.\n\nReturn _an integer array_ `answer` _where_ `answer = [even, odd]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 17\n**Output:** \\[2,0\\]\n**Explanation:** The binary representation of 17 is 10001. \nIt contains 1 on the 0th and 4th indices. \nThere are 2 even and 0 odd indices.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** \\[0,1\\]\n**Explanation:** The binary representation of 2 is 10.\nIt contains 1 on the 1st index. \nThere are 0 even and 1 odd indices."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "17",
                "output": "[2,0]"
            },
            {
                "input": "2",
                "output": "[0,1]"
            }
        ],
        "java": "\n    ```java\npublic int[] evenOddIndices(int n) {\n    int[] answer = new int[2];\n    int index = 0;\n    while (n > 0) {\n        if (n % 2 == 1)\n            answer[index % 2] += 1;\n        n /= 2;\n        index += 1;\n    }\n    return answer;\n}\n```\n    \n    The algorithm iterates through the bits of the input number `n` one by one. For each bit, it checks whether the bit is set (1) or not. If the bit is set and its index (0-indexed) is even, it increments the `even` count in `answer`. If the bit is set and its index is odd, it increments the `odd` count in `answer`. The algorithm continues until all bits of the number have been processed. Finally, it returns the `answer` array containing the counts of even and odd indices with the value of 1 in the binary representation of `n`.\n    ",
        "python": "\n    ```python\ndef even_odd_indices(n: int) -> List[int]:\n    answer = [0, 0]\n    index = 0\n    while n > 0:\n        if n % 2:\n            answer[index % 2] += 1\n        n //= 2\n        index += 1\n    return answer\n```\n    \n    The algorithm iterates through the bits of the input number `n` one by one. For each bit, it checks whether the bit is set (1) or not. If the bit is set and its index (0-indexed) is even, it increments the `even` count in `answer`. If the bit is set and its index is odd, it increments the `odd` count in `answer`. The algorithm continues until all bits of the number have been processed. Finally, it returns the `answer` array containing the counts of even and odd indices with the value of 1 in the binary representation of `n`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> evenOddIndices(int n) {\n    std::vector<int> answer(2, 0);\n    int index = 0;\n    while (n > 0) {\n        if (n % 2)\n            answer[index % 2] += 1;\n        n /= 2;\n        index += 1;\n    }\n    return answer;\n}\n```\n    \n    The algorithm iterates through the bits of the input number `n` one by one. For each bit, it checks whether the bit is set (1) or not. If the bit is set and its index (0-indexed) is even, it increments the `even` count in `answer`. If the bit is set and its index is odd, it increments the `odd` count in `answer`. The algorithm continues until all bits of the number have been processed. Finally, it returns the `answer` array containing the counts of even and odd indices with the value of 1 in the binary representation of `n`.\n    ",
        "js": "\n    ```javascript\nfunction evenOddIndices(n) {\n    let answer = [0, 0];\n    let index = 0;\n    while (n > 0) {\n        if (n % 2)\n            answer[index % 2] += 1;\n        n = Math.floor(n / 2);\n        index += 1;\n    }\n    return answer;\n}\n```\n    \n    The algorithm iterates through the bits of the input number `n` one by one. For each bit, it checks whether the bit is set (1) or not. If the bit is set and its index (0-indexed) is even, it increments the `even` count in `answer`. If the bit is set and its index is odd, it increments the `odd` count in `answer`. The algorithm continues until all bits of the number have been processed. Finally, it returns the `answer` array containing the counts of even and odd indices with the value of 1 in the binary representation of `n`.\n    "
    },
    {
        "id": 479,
        "title": "K Items With the Maximum Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a bag that consists of items, each item has a number `1`, `0`, or `-1` written on it.\n\nYou are given four **non-negative** integers `numOnes`, `numZeros`, `numNegOnes`, and `k`.\n\nThe bag initially contains:\n\n*   `numOnes` items with `1`s written on them.\n*   `numZeroes` items with `0`s written on them.\n*   `numNegOnes` items with `-1`s written on them.\n\nWe want to pick exactly `k` items among the available items. Return _the **maximum** possible sum of numbers written on the items_.",
            "examples": [
                "**Example 1:**\n\n**Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n**Output:** 2\n**Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.\nIt can be proven that 2 is the maximum possible sum.\n\n",
                "**Example 2:**\n\n**Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n**Output:** 3\n**Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.\nIt can be proven that 3 is the maximum possible sum."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= numOnes, numZeros, numNegOnes <= 50`\n*   `0 <= k <= numOnes + numZeros + numNegOnes`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "3,2,0,2",
                "output": "2"
            },
            {
                "input": "3,2,0,4",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int maxSum(int numOnes, int numZeros, int numNegOnes, int k) {\n    int maxSum = 0;\n    for (int i = 0; i <= k; ++i) {\n        int ones = Math.min(i, numOnes);\n        int negOnes = Math.min(k - i, numNegOnes);\n        maxSum = Math.max(maxSum, ones - negOnes);\n    }\n    return maxSum;\n}\n```\n    \n    We want to find the maximum sum of __k__ items that can be picked from the given bag. Iterate through __0__ to __k__, and pick the minimum between __i__ and __numOnes__ as the count of ones, and pick the minimum between __k-i__ and __numNegOnes__ as the count of -1s. Since 1 - (-1) = 2, every 1 combined with a -1 will increase max_sum by 2. Calculate the maximum between the current `max_sum` and the sum of ones minus negative ones for each iteration. Return the final `max_sum` after the loop has finished, which will have the maximum possible sum of items.\n    ",
        "python": "\n    ```python\ndef max_sum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n    max_sum = 0\n    for i in range(k + 1):\n        ones = min(i, numOnes)\n        neg_ones = min(k - i, numNegOnes)\n        max_sum = max(max_sum, ones - neg_ones)\n    return max_sum\n```\n    \n    We want to find the maximum sum of __k__ items that can be picked from the given bag. Iterate through __0__ to __k__, and pick the minimum between __i__ and __numOnes__ as the count of ones, and pick the minimum between __k-i__ and __numNegOnes__ as the count of -1s. Since 1 - (-1) = 2, every 1 combined with a -1 will increase max_sum by 2. Calculate the maximum between the current `max_sum` and the sum of ones minus negative ones for each iteration. Return the final `max_sum` after the loop has finished, which will have the maximum possible sum of items.\n    ",
        "c++": "\n    ```cpp\nint maxSum(int numOnes, int numZeros, int numNegOnes, int k) {\n    int max_sum = 0;\n    for (int i = 0; i <= k; ++i) {\n        int ones = min(i, numOnes);\n        int neg_ones = min(k - i, numNegOnes);\n        max_sum = max(max_sum, ones - neg_ones);\n    }\n    return max_sum;\n}\n```\n    \n    We want to find the maximum sum of __k__ items that can be picked from the given bag. Iterate through __0__ to __k__, and pick the minimum between __i__ and __numOnes__ as the count of ones, and pick the minimum between __k-i__ and __numNegOnes__ as the count of -1s. Since 1 - (-1) = 2, every 1 combined with a -1 will increase max_sum by 2. Calculate the maximum between the current `max_sum` and the sum of ones minus negative ones for each iteration. Return the final `max_sum` after the loop has finished, which will have the maximum possible sum of items.\n    ",
        "js": "\n    ```javascript\nfunction maxSum(numOnes, numZeros, numNegOnes, k) {\n    let maxSum = 0;\n    for (let i = 0; i <= k; ++i) {\n        let ones = Math.min(i, numOnes);\n        let negOnes = Math.min(k - i, numNegOnes);\n        maxSum = Math.max(maxSum, ones - negOnes);\n    }\n    return maxSum;\n}\n```\n    \n    We want to find the maximum sum of __k__ items that can be picked from the given bag. Iterate through __0__ to __k__, and pick the minimum between __i__ and __numOnes__ as the count of ones, and pick the minimum between __k-i__ and __numNegOnes__ as the count of -1s. Since 1 - (-1) = 2, every 1 combined with a -1 will increase max_sum by 2. Calculate the maximum between the current `max_sum` and the sum of ones minus negative ones for each iteration. Return the final `max_sum` after the loop has finished, which will have the maximum possible sum of items.\n    "
    },
    {
        "id": 480,
        "title": "Form Smallest Number From Two Digit Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two arrays of **unique** digits `nums1` and `nums2`, return _the **smallest** number that contains **at least** one digit from each array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[4,1,3\\], nums2 = \\[5,7\\]\n**Output:** 15\n**Explanation:** The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[3,5,2,6\\], nums2 = \\[3,1,7\\]\n**Output:** 3\n**Explanation:** The number 3 contains the digit 3 which exists in both arrays."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 9`\n*   `1 <= nums1[i], nums2[i] <= 9`\n*   All digits in each array are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[4,1,3],[5,7]",
                "output": "15"
            },
            {
                "input": "[3,5,2,6],[3,1,7]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int smallestNumberWithAtLeastOneDigitFromEachArray(int[] nums1, int[] nums2) {\n    int min1 = Arrays.stream(nums1).min().getAsInt();\n    int min2 = Arrays.stream(nums2).min().getAsInt();\n    for (int num1 : nums1) {\n        for (int num2 : nums2) {\n            if (num1 == num2) {\n                return num1;\n            }\n        }\n    }\n    return min1 * 10 + min2;\n}\n```\n    \n    The algorithm works as follows:\n1. Find the smallest numbers `min1` and `min2` in each input array `nums1` and `nums2` respectively.\n2. Check if there is any identical number `num1` and `num2` in `nums1` and `nums2` respectively (`num1 == num2`). If found, return that shared number. This is because the problem states that we need the smallest number that contains at least one digit from each array, and a shared number will always be smaller than the result obtained by concatenating the smallest digits from each array (due to the unique digits constraint in the problem statement).\n3. If no shared number is found, concatenate the smallest numbers of each array (`min1 * 10 + min2`). This gives the smallest possible number containing at least one digit from each array.\n    ",
        "python": "\n    ```python\ndef smallest_number_with_at_least_one_digit_from_each_array(nums1, nums2):\n    min1 = min(nums1)\n    min2 = min(nums2)\n    for num1 in nums1:\n        for num2 in nums2:\n            if num1 == num2:\n                return num1\n    return min1 * 10 + min2\n```\n    \n    The algorithm works as follows:\n1. Find the smallest numbers `min1` and `min2` in each input array `nums1` and `nums2` respectively.\n2. Check if there is any identical number `num1` and `num2` in `nums1` and `nums2` respectively (`num1 == num2`). If found, return that shared number. This is because the problem states that we need the smallest number that contains at least one digit from each array, and a shared number will always be smaller than the result obtained by concatenating the smallest digits from each array (due to the unique digits constraint in the problem statement).\n3. If no shared number is found, concatenate the smallest numbers of each array (`min1 * 10 + min2`). This gives the smallest possible number containing at least one digit from each array.\n    ",
        "c++": "\n    ```cpp\nint smallestNumberWithAtLeastOneDigitFromEachArray(vector<int>& nums1, vector<int>& nums2) {\n    int min1 = *min_element(nums1.begin(), nums1.end());\n    int min2 = *min_element(nums2.begin(), nums2.end());\n    for (int num1 : nums1) {\n        for (int num2 : nums2) {\n            if (num1 == num2) {\n                return num1;\n            }\n        }\n    }\n    return min1 * 10 + min2;\n}\n```\n    \n    The algorithm works as follows:\n1. Find the smallest numbers `min1` and `min2` in each input array `nums1` and `nums2` respectively.\n2. Check if there is any identical number `num1` and `num2` in `nums1` and `nums2` respectively (`num1 == num2`). If found, return that shared number. This is because the problem states that we need the smallest number that contains at least one digit from each array, and a shared number will always be smaller than the result obtained by concatenating the smallest digits from each array (due to the unique digits constraint in the problem statement).\n3. If no shared number is found, concatenate the smallest numbers of each array (`min1 * 10 + min2`). This gives the smallest possible number containing at least one digit from each array.\n    ",
        "js": "\n    ```javascript\nfunction smallestNumberWithAtLeastOneDigitFromEachArray(nums1, nums2) {\n    const min1 = Math.min(...nums1);\n    const min2 = Math.min(...nums2);\n    for (const num1 of nums1) {\n        for (const num2 of nums2) {\n            if (num1 === num2) {\n                return num1;\n            }\n        }\n    }\n    return min1 * 10 + min2;\n}\n```\n    \n    The algorithm works as follows:\n1. Find the smallest numbers `min1` and `min2` in each input array `nums1` and `nums2` respectively.\n2. Check if there is any identical number `num1` and `num2` in `nums1` and `nums2` respectively (`num1 == num2`). If found, return that shared number. This is because the problem states that we need the smallest number that contains at least one digit from each array, and a shared number will always be smaller than the result obtained by concatenating the smallest digits from each array (due to the unique digits constraint in the problem statement).\n3. If no shared number is found, concatenate the smallest numbers of each array (`min1 * 10 + min2`). This gives the smallest possible number containing at least one digit from each array.\n    "
    },
    {
        "id": 481,
        "title": "Find the Longest Balanced Substring of a Binary String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a binary string `s` consisting only of zeroes and ones.\n\nA substring of `s` is considered balanced if **all zeroes are before ones** and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.\n\nReturn _the length of the longest balanced substring of_ `s`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"01000111 \"\n**Output:** 6\n**Explanation:** The longest balanced substring is  \"000111 \", which has length 6.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"00111 \"\n**Output:** 4\n**Explanation:** The longest balanced substring is  \"0011 \", which has length 4. \n\n",
                "**Example 3:**\n\n**Input:** s =  \"111 \"\n**Output:** 0\n**Explanation:** There is no balanced substring except the empty substring, so the answer is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 50`\n*   `'0' <= s[i] <= '1'`",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"01000111\"",
                "output": "6"
            },
            {
                "input": "\"00111\"",
                "output": "4"
            },
            {
                "input": "\"111\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int longestBalancedSubstring(String s) {\n    int max_len = 0;\n    int zeros = 0;\n    int ones = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (s.charAt(i) == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n        if (zeros == ones) {\n            max_len = Math.max(max_len, zeros * 2);\n        } else if (zeros > ones) {\n            zeros = ones = 0;\n        }\n    }\n    zeros = ones = 0;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        if (s.charAt(i) == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n        if (zeros == ones) {\n            max_len = Math.max(max_len, zeros * 2);\n        } else if (zeros < ones) {\n            zeros = ones = 0;\n        }\n    }\n    return max_len;\n}\n```\n    \n    The algorithm scans the string `s` twice. In the first pass, it counts the number of zeros and ones. \n1. Whenever the count of zeros and ones is the same, the maximum length of the balanced substring should be updated by selecting the maximum value between `max_len` and `zeros * 2`.\n2. If the count of zeros is greater than the count of ones, the current possibility of a balanced substring has failed, so `zeros` and `ones` are reset to 0.\n\nIn the second pass, the process is almost the same, but this time it iterates from the end of the string to the beginning. When the count of ones is greater than the count of zeros, `zeros` and `ones` are reset to 0.\n\nAfter the two passes, the variable `max_len` stores the length of the longest balanced substring in the input string `s`.\n    ",
        "python": "\n    ```python\ndef longestBalancedSubstring(s):\n    max_len = 0\n    zeros = ones = 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n        if zeros == ones:\n            max_len = max(max_len, zeros * 2)\n        elif zeros > ones:\n            zeros = ones = 0\n    zeros = ones = 0\n    for c in reversed(s):\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n        if zeros == ones:\n            max_len = max(max_len, zeros * 2)\n        elif zeros < ones:\n            zeros = ones = 0\n    return max_len\n```\n    \n    The algorithm scans the string `s` twice. In the first pass, it counts the number of zeros and ones. \n1. Whenever the count of zeros and ones is the same, the maximum length of the balanced substring should be updated by selecting the maximum value between `max_len` and `zeros * 2`.\n2. If the count of zeros is greater than the count of ones, the current possibility of a balanced substring has failed, so `zeros` and `ones` are reset to 0.\n\nIn the second pass, the process is almost the same, but this time it iterates from the end of the string to the beginning. When the count of ones is greater than the count of zeros, `zeros` and `ones` are reset to 0.\n\nAfter the two passes, the variable `max_len` stores the length of the longest balanced substring in the input string `s`.\n    ",
        "c++": "\n    ```cpp\nint longestBalancedSubstring(string s) {\n    int max_len = 0;\n    int zeros = 0;\n    int ones = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n        if (zeros == ones) {\n            max_len = max(max_len, zeros * 2);\n        } else if (zeros > ones) {\n            zeros = ones = 0;\n        }\n    }\n    zeros = ones = 0;\n    for (int i = s.size() - 1; i >= 0; --i) {\n        if (s[i] == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n        if (zeros == ones) {\n            max_len = max(max_len, zeros * 2);\n        } else if (zeros < ones) {\n            zeros = ones = 0;\n        }\n    }\n    return max_len;\n}\n```\n    \n    The algorithm scans the string `s` twice. In the first pass, it counts the number of zeros and ones. \n1. Whenever the count of zeros and ones is the same, the maximum length of the balanced substring should be updated by selecting the maximum value between `max_len` and `zeros * 2`.\n2. If the count of zeros is greater than the count of ones, the current possibility of a balanced substring has failed, so `zeros` and `ones` are reset to 0.\n\nIn the second pass, the process is almost the same, but this time it iterates from the end of the string to the beginning. When the count of ones is greater than the count of zeros, `zeros` and `ones` are reset to 0.\n\nAfter the two passes, the variable `max_len` stores the length of the longest balanced substring in the input string `s`.\n    ",
        "js": "\n    ```javascript\nfunction longestBalancedSubstring(s) {\n    let max_len = 0;\n    let zeros = 0;\n    let ones = 0;\n    for (const c of s) {\n        if (c === '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n        if (zeros === ones) {\n            max_len = Math.max(max_len, zeros * 2);\n        } else if (zeros > ones) {\n            zeros = ones = 0;\n        }\n    }\n    zeros = ones = 0;\n    for (let i = s.length - 1; i >= 0; --i) {\n        if (s[i] === '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n        if (zeros === ones) {\n            max_len = Math.max(max_len, zeros * 2);\n        } else if (zeros < ones) {\n            zeros = ones = 0;\n        }\n    }\n    return max_len;\n}\n```\n    \n    The algorithm scans the string `s` twice. In the first pass, it counts the number of zeros and ones. \n1. Whenever the count of zeros and ones is the same, the maximum length of the balanced substring should be updated by selecting the maximum value between `max_len` and `zeros * 2`.\n2. If the count of zeros is greater than the count of ones, the current possibility of a balanced substring has failed, so `zeros` and `ones` are reset to 0.\n\nIn the second pass, the process is almost the same, but this time it iterates from the end of the string to the beginning. When the count of ones is greater than the count of zeros, `zeros` and `ones` are reset to 0.\n\nAfter the two passes, the variable `max_len` stores the length of the longest balanced substring in the input string `s`.\n    "
    }
]
[
    {
        "thought_name": "Longest Substring Without Repeating Characters",
        "thought_question": "Given a string `s`, find the length of the **longest** **substring** without repeating characters.",
        "thought_answer": "\n    ```python\ndef length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Longest Palindromic Substring",
        "thought_question": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.",
        "thought_answer": "\n    ```python\ndef longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Zigzag Conversion",
        "thought_question": "The string `\"PAYPALISHIRING \"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR \"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);",
        "thought_answer": "\n    ```python\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)\n```\n    \n    1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it.\n    ",
        "tag": [
            "String"
        ]
    },
    {
        "thought_name": "Reverse Integer",
        "thought_question": "Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**",
        "thought_answer": "\n    ```python\ndef reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "String to Integer (atoi)",
        "thought_question": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
        "thought_answer": "\n    ```python\ndef myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "tag": []
    },
    {
        "thought_name": "Integer to Roman",
        "thought_question": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.",
        "thought_answer": "\n    ```python\ndef int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ]
    },
    {
        "thought_name": "3Sum",
        "thought_question": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
        "thought_answer": "\n    ```python\ndef threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ]
    },
    {
        "thought_name": "3Sum Closest",
        "thought_question": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution.",
        "thought_answer": "\n    ```python\ndef threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ]
    },
    {
        "thought_name": "Letter Combinations of a Phone Number",
        "thought_question": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
        "thought_answer": "\n    ```python\ndef letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Backtracking"
        ]
    },
    {
        "thought_name": "4Sum",
        "thought_question": "Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n*   `0 <= a, b, c, d < n`\n*   `a`, `b`, `c`, and `d` are **distinct**.\n*   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**.",
        "thought_answer": "\n    ```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if cur_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]: left += 1\n                    while left < right and nums[right] == nums[right + 1]: right -= 1\n                elif cur_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ]
    },
    {
        "thought_name": "Generate Parentheses",
        "thought_question": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.",
        "thought_answer": "\n    ```python\ndef generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "tag": [
            "String",
            "Dynamic Programming",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Divide Two Integers",
        "thought_question": "Given two integers `dividend` and `divisor`, divide two integers **without** using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`.\n\nReturn _the **quotient** after dividing_ `dividend` _by_ `divisor`.\n\n**Note:** Assume we are dealing with an environment that could only store integers within the **32-bit** signed integer range: `[-231, 231 - 1]`. For this problem, if the quotient is **strictly greater than** `231 - 1`, then return `231 - 1`, and if the quotient is **strictly less than** `-231`, then return `-231`.",
        "thought_answer": "\n    ```python\ndef divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "tag": [
            "Math",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Search in Rotated Sorted Array",
        "thought_question": "There is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\n\nGiven the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
        "thought_answer": "\n    ```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Find First and Last Position of Element in Sorted Array",
        "thought_question": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
        "thought_answer": "\n    ```python\ndef searchRange(nums, target):\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Count and Say",
        "thought_question": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n\n*   `countAndSay(1) = \"1 \"`\n*   `countAndSay(n)` is the way you would \"say \" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say \" a digit string, split it into the **minimal** number of substrings such that each substring contains exactly **one** unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n\nFor example, the saying and conversion for digit string `\"3322251 \"`:\n\nGiven a positive integer `n`, return _the_ `nth` _term of the **count-and-say** sequence_.",
        "thought_answer": "\n    ```python\ndef count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "tag": [
            "String"
        ]
    },
    {
        "thought_name": "Combination Sum II",
        "thought_question": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:** The solution set must not contain duplicate combinations.",
        "thought_answer": "\n    ```python\ndef combinationSum2(candidates, target):\n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "tag": [
            "Array",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Jump Game II",
        "thought_question": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.",
        "thought_answer": "\n    ```python\ndef jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Maximum Subarray",
        "thought_question": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.",
        "thought_answer": "\n    ```python\ndef maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "tag": [
            "Array",
            "Divide and Conquer",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Spiral Matrix",
        "thought_question": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.",
        "thought_answer": "\n    ```python\ndef spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Merge Intervals",
        "thought_question": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.",
        "thought_answer": "\n    ```python\ndef merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "tag": [
            "Array",
            "Sorting"
        ]
    },
    {
        "thought_name": "Spiral Matrix II",
        "thought_question": "Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.",
        "thought_answer": "\n    ```python\ndef generateMatrix(n: int) -> List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix\n```\n    \n    The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n^2. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Unique Paths",
        "thought_question": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.",
        "thought_answer": "\n    ```python\ndef uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ]
    },
    {
        "thought_name": "Unique Paths II",
        "thought_question": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.",
        "thought_answer": "\n    ```python\ndef uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ]
    },
    {
        "thought_name": "Minimum Path Sum",
        "thought_question": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.",
        "thought_answer": "\n    ```python\ndef minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ]
    },
    {
        "thought_name": "Simplify Path",
        "thought_question": "Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.\n\nIn a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.\n\nThe **canonical path** should have the following format:\n\n*   The path starts with a single slash `'/'`.\n*   Any two directories are separated by a single slash `'/'`.\n*   The path does not end with a trailing `'/'`.\n*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)\n\nReturn _the simplified **canonical path**_.",
        "thought_answer": "\n    ```python\ndef simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "tag": [
            "String",
            "Stack"
        ]
    },
    {
        "thought_name": "Subsets",
        "thought_question": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
        "thought_answer": "\n    ```python\ndef subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "tag": [
            "Array",
            "Backtracking",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Gray Code",
        "thought_question": "An **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n*   Every integer is in the **inclusive** range `[0, 2n - 1]`,\n*   The first integer is `0`,\n*   An integer appears **no more than once** in the sequence,\n*   The binary representation of every pair of **adjacent** integers differs by **exactly one bit**, and\n*   The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n`, return _any valid **n-bit gray code sequence**_.",
        "thought_answer": "\n    ```python\ndef grayCode(n):\n    result = []\n    for i in range(1 << n):\n        result.append(i ^ (i >> 1))\n    return result\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "tag": [
            "Math",
            "Backtracking",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Decode Ways",
        "thought_question": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Unique Binary Search Trees",
        "thought_question": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.",
        "thought_answer": "\n    ```python\ndef numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ]
    },
    {
        "thought_name": "Triangle",
        "thought_question": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.",
        "thought_answer": "\n    ```python\ndef minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Best Time to Buy and Sell Stock II",
        "thought_question": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.",
        "thought_answer": "\n    ```python\ndef max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Longest Consecutive Sequence",
        "thought_question": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time.",
        "thought_answer": "\n    ```python\ndef longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Union Find"
        ]
    },
    {
        "thought_name": "Clone Graph",
        "thought_question": "Given a reference of a node in a **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.\n\nReturn a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n\nclass Node {\n    public int val;\n    public List neighbors;\n}\n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.",
        "thought_answer": "\n    ```python\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node, visited=None):\n    if node is None:\n        return None\n\n    if visited is None:\n        visited = {}\n\n    if node in visited:\n        return visited[node]\n\n    cloneNode = Node(node.val)\n    visited[node] = cloneNode\n\n    for neighbor in node.neighbors:\n        cloneNode.neighbors.append(cloneGraph(neighbor, visited))\n\n    return cloneNode\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to traverse the graph and make a deep copy of the nodes. Here is the algorithm:\n\n1. Create a `visited` dictionary (C++: `unordered_map`, Java: `HashMap`, Python: `dict`, JavaScript: `Map`) to track visited nodes and keep their clones.\n2. Define a recursive helper function `cloneGraph` that takes a node and the visited dictionary as input.\n3. If the input node is `null`, return `null`.\n4. If the input node is already in the visited dictionary, return its clone.\n5. Otherwise, create a new clone node with the same value as the input node, and add it to the visited dictionary.\n6. Iterate through the neighbors of the input node, and call the `cloneGraph` helper function recursively for each neighbor, adding the returned clones to the clone node's neighbors.\n7. Return the clone node.\n\nFinally, call the `cloneGraph` helper function with the given node and the initially empty visited dictionary.\n    ",
        "tag": [
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ]
    },
    {
        "thought_name": "Gas Station",
        "thought_question": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**",
        "thought_answer": "\n    ```python\ndef can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Single Number II",
        "thought_question": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. _Find the single element and return it_.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
        "thought_answer": "\n    ```python\ndef singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "tag": [
            "Array",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Evaluate Reverse Polish Notation",
        "thought_question": "You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nEvaluate the expression. Return _an integer that represents the value of the expression_.\n\n**Note** that:\n\n*   The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Each operand may be an integer or another expression.\n*   The division between two integers always **truncates toward zero**.\n*   There will not be any division by zero.\n*   The input represents a valid arithmetic expression in a reverse polish notation.\n*   The answer and all the intermediate calculations can be represented in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef evalRPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]\n```\n    \n    The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively.\n    ",
        "tag": [
            "Array",
            "Math",
            "Stack"
        ]
    },
    {
        "thought_name": "Maximum Product Subarray",
        "thought_question": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Find Minimum in Rotated Sorted Array",
        "thought_question": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n*   `[0,1,2,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.\n\nYou must write an algorithm that runs in `O(log n) time.`",
        "thought_answer": "\n    ```python\ndef find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Longest Substring with At Most Two Distinct Characters",
        "thought_question": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_.",
        "thought_answer": "\n    ```python\ndef lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find Peak Element",
        "thought_question": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -∞`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in `O(log n)` time.",
        "thought_answer": "\n    ```python\ndef findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Compare Version Numbers",
        "thought_question": "Given two version numbers, `version1` and `version2`, compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.\n\nTo compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.\n\n_Return the following:_\n\n*   If `version1 < version2`, return `-1`.\n*   If `version1 > version2`, return `1`.\n*   Otherwise, return `0`.",
        "thought_answer": "\n    ```python\ndef compare_version(version1, version2):\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n        \n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "tag": [
            "Two Pointers",
            "String"
        ]
    },
    {
        "thought_name": "Fraction to Recurring Decimal",
        "thought_question": "Given two integers representing the `numerator` and `denominator` of a fraction, return _the fraction in string format_.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return **any of them**.\n\nIt is **guaranteed** that the length of the answer string is less than `104` for all the given inputs.",
        "thought_answer": "\n    ```python\ndef fraction_to_decimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)\n```\n\n    \n    The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string.\n    ",
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ]
    },
    {
        "thought_name": "Two Sum II - Input Array Is Sorted",
        "thought_question": "Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space.",
        "thought_answer": "\n    ```python\ndef twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "tag": []
    },
    {
        "thought_name": "Factorial Trailing Zeroes",
        "thought_question": "Given an integer `n`, return _the number of trailing zeroes in_ `n!`.\n\nNote that `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`.",
        "thought_answer": "\n    ```python\ndef trailing_zeroes(n: int) -> int:\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "House Robber",
        "thought_question": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
        "thought_answer": "\n    ```python\ndef rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Bitwise AND of Numbers Range",
        "thought_question": "Given two integers `left` and `right` that represent the range `[left, right]`, return _the bitwise AND of all numbers in this range, inclusive_.",
        "thought_answer": "\n    ```python\ndef range_bitwise_and(left: int, right: int) -> int:\n    shift = 0\n    while left != right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "tag": [
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Count Primes",
        "thought_question": "Given an integer `n`, return _the number of prime numbers that are strictly less than_ `n`.",
        "thought_answer": "\n    ```python\ndef countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "tag": [
            "Array",
            "Math",
            "Enumeration",
            "Number Theory"
        ]
    },
    {
        "thought_name": "Minimum Size Subarray Sum",
        "thought_question": "Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _subarray_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead.",
        "thought_answer": "\n    ```python\ndef minSubArrayLen(target: int, nums: List[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "House Robber II",
        "thought_question": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
        "thought_answer": "\n    ```python\ndef rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Kth Largest Element in an Array",
        "thought_question": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity.",
        "thought_answer": "\n    ```python\ndef findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "tag": [
            "Array",
            "Divide and Conquer",
            "Sorting",
            "Heap (Priority Queue)",
            "Quickselect"
        ]
    },
    {
        "thought_name": "Combination Sum III",
        "thought_question": "Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n*   Only numbers `1` through `9` are used.\n*   Each number is used **at most once**.\n\nReturn _a list of all possible valid combinations_. The list must not contain the same combination twice, and the combinations may be returned in any order.",
        "thought_answer": "\n    ```python\ndef combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "tag": [
            "Array",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Maximal Square",
        "thought_question": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.",
        "thought_answer": "\n    ```python\ndef maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ]
    },
    {
        "thought_name": "Rectangle Area",
        "thought_question": "Given the coordinates of two **rectilinear** rectangles in a 2D plane, return _the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1, ay1)` and its **top-right** corner `(ax2, ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1, by1)` and its **top-right** corner `(bx2, by2)`.",
        "thought_answer": "\n    ```python\ndef total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n\n    return area1 + area2 - overlap_area\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "tag": [
            "Math",
            "Geometry"
        ]
    },
    {
        "thought_name": "Majority Element II",
        "thought_question": "Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times.",
        "thought_answer": "\n    ```python\ndef majorityElement(nums):\n    n = len(nums)\n    count = {}\n    result = []\n\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n        if count[num] > n / 3 and num not in result:\n            result.append(num)\n\n    return result\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ]
    },
    {
        "thought_name": "Product of Array Except Self",
        "thought_question": "Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.",
        "thought_answer": "\n    ```python\ndef productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    left = 1\n    for i in range(n):\n        answer[i] *= left\n        left *= nums[i]\n    \n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    \n    return answer\n```\n    \n    The basic idea is to create an array `answer` with the same size as `nums`. We start by initializing all elements of the `answer` array to 1.\n\nWe then perform two passes through the `nums` array. During the first pass, we keep track of the running product of elements to the left of the current index in a variable called `left`, and we multiply the corresponding element in the `answer` array by this running product.\n\nDuring the second pass, we move in the reverse direction, and we perform a similar operation for the elements to the right of the current index using a variable called `right`. This will result in `answer[i]` being equal to the product of all elements in the `nums` array except for the current element, `nums[i]`.\n\nSince we only have two passes through the input array, the algorithm has an O(n) time complexity.\n    ",
        "tag": [
            "Array",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Strobogrammatic Number II",
        "thought_question": "Given an integer `n`, return all the **strobogrammatic numbers** that are of length `n`. You may return the answer in **any order**.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
        "thought_answer": "\n    ```python\ndef findStrobogrammatic(n):\n    def helper(n, m):\n        if n == 0:\n            return [\"\"]\n        if n == 1:\n            return [\"0\", \"1\", \"8\"]\n\n        list = helper(n - 2, m)\n        res = []\n\n        for s in list:\n            if n != m:\n                res.append(\"0\" + s + \"0\")\n\n            res.append(\"1\" + s + \"1\")\n            res.append(\"6\" + s + \"9\")\n            res.append(\"8\" + s + \"8\")\n            res.append(\"9\" + s + \"6\")\n\n        return res\n\n    return helper(n, n)\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "tag": []
    },
    {
        "thought_name": "Paint House",
        "thought_question": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_.",
        "thought_answer": "\n    ```python\ndef minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "tag": []
    },
    {
        "thought_name": "3Sum Smaller",
        "thought_question": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
        "thought_answer": "\n    ```python\ndef threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "tag": []
    },
    {
        "thought_name": "Ugly Number II",
        "thought_question": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return _the_ `nth` _**ugly number**_.",
        "thought_answer": "\n    ```python\ndef nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]\n\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ",
        "tag": [
            "Hash Table",
            "Math",
            "Dynamic Programming",
            "Heap (Priority Queue)"
        ]
    },
    {
        "thought_name": "H-Index",
        "thought_question": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.",
        "thought_answer": "\n    ```python\ndef hIndex(citations: List[int]) -> int:\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "tag": [
            "Array",
            "Sorting",
            "Counting Sort"
        ]
    },
    {
        "thought_name": "H-Index II",
        "thought_question": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in **ascending order**, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\nYou must write an algorithm that runs in logarithmic time.",
        "thought_answer": "\n    ```python\ndef hIndex(citations: List[int]) -> int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if citations[mid] == n - mid:\n            return n - mid\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return n - left\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Paint Fence",
        "thought_question": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_.",
        "thought_answer": "\n    ```python\ndef numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Perfect Squares",
        "thought_question": "Given an integer `n`, return _the least number of perfect square numbers that sum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.",
        "thought_answer": "\n    ```python\ndef numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Breadth-First Search"
        ]
    },
    {
        "thought_name": "Find the Duplicate Number",
        "thought_question": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in `nums`, return _this repeated number_.\n\nYou must solve the problem **without** modifying the array `nums` and uses only constant extra space.",
        "thought_answer": "\n    ```python\ndef findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Game of Life",
        "thought_question": "According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. \"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by over-population.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.",
        "thought_answer": "\n    ```python\ndef gameOfLife(board):\n    m, n = len(board), len(board[0])\n    result = [[0] * n for _ in range(m)]\n    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n    for i in range(m):\n        for j in range(n):\n            liveNeighbors = 0\n            \n            for dir in dirs:\n                newRow = i + dir[0]\n                newCol = j + dir[1]\n                \n                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:\n                    liveNeighbors += 1\n            \n            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):\n                result[i][j] = 1\n            elif board[i][j] == 0 and liveNeighbors == 3:\n                result[i][j] = 1\n                \n    return result\n```\n    \n    Create a new board called `result` with the same dimensions as the input board. For each cell in the input board, count the live neighbors (the 8 neighboring cells). Then apply the following rules:\n1. Any live cell with two or three live neighbors survives.\n2. Any dead cell with exactly three live neighbors becomes a live cell.\n3. All other live cells die and all other dead cells stay dead.\n\nTo count live neighbors, iterate through a predefined list of relative coordinates `dirs` representing the eight neighboring cells. For each neighboring coordinate, check if it is inside the grid, and if the corresponding cell in the input board is live. If so, increment the counter of live neighbors.\n\nFinally, update the cell in the result board using the rules.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Bulls and Cows",
        "thought_question": "You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n*   The number of \"bulls \", which are digits in the guess that are in the correct position.\n*   The number of \"cows \", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.\n\nThe hint should be formatted as `\"xAyB \"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.",
        "thought_answer": "\n    ```python\ndef get_hint(secret: str, guess: str) -> str:\n    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n   \n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n    \n    return f\"{bulls}A{cows}B\"\n```\n\n    \n    The algorithm first initializes the counts for bulls and cows to be 0. We also create two arrays called secret_count and guess_count to store the count of each digit from '0' to '9' in the secret and guess strings.\n\nWe then loop through both the secret and the guess strings. For each position, if the digits are the same in both strings (i.e., secret[i] == guess[i]), we increase the bulls count. If not, we increment the corresponding count for the secret and guess digits.\n\nAfter iterating through the strings, we loop through the count arrays and add the minimum of the counts of each digit in secret_count and guess_count to the cows count.\n\nFinally, we return the result in the \"xAyB\" format by concatenating the values of bulls and cows.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ]
    },
    {
        "thought_name": "Longest Increasing Subsequence",
        "thought_question": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.",
        "thought_answer": "\n    ```python\ndef lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Sparse Matrix Multiplication",
        "thought_question": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.",
        "thought_answer": "\n    ```python\ndef multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "tag": []
    },
    {
        "thought_name": "Super Ugly Number",
        "thought_question": "A **super ugly number** is a positive integer whose prime factors are in the array `primes`.\n\nGiven an integer `n` and an array of integers `primes`, return _the_ `nth` _**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit** signed integer.",
        "thought_answer": "\n    ```python\ndef nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ",
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Remove Duplicate Letters",
        "thought_question": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.",
        "thought_answer": "\n    ```python\ndef removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)   \n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "tag": [
            "String",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Maximum Product of Word Lengths",
        "thought_question": "Given a string array `words`, return _the maximum value of_ `length(word[i]) * length(word[j])` _where the two words do not share common letters_. If no such two words exist, return `0`.",
        "thought_answer": "\n    ```python\ndef maxProduct(words):\n    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n    \n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n    \n    return max_product\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "tag": [
            "Array",
            "String",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Bulb Switcher",
        "thought_question": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.",
        "thought_answer": "\n    ```python\ndef bulbSwitch(n):\n    return int(n**0.5)\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "tag": [
            "Math",
            "Brainteaser"
        ]
    },
    {
        "thought_name": "Coin Change",
        "thought_question": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
        "thought_answer": "\n    ```python\ndef coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Breadth-First Search"
        ]
    },
    {
        "thought_name": "Number of Connected Components in an Undirected Graph",
        "thought_question": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_.",
        "thought_answer": "\n    ```python\ndef countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "tag": []
    },
    {
        "thought_name": "Maximum Size Subarray Sum Equals k",
        "thought_question": "Given an integer array `nums` and an integer `k`, return _the maximum length of a_ _subarray_ _that sums to_ `k`. If there is not one, return `0` instead.",
        "thought_answer": "\n    ```python\ndef maxSubArrayLen(nums: List[int], k: int) -> int:\n    sum_index = {}\n    maxLength = sum = 0\n    for i, num in enumerate(nums):\n        sum += num\n        if sum == k:\n            maxLength = i + 1\n        if sum - k in sum_index:\n            maxLength = max(maxLength, i - sum_index[sum - k])\n        if sum not in sum_index:\n            sum_index[sum] = i\n    return maxLength\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "tag": []
    },
    {
        "thought_name": "Longest Substring with At Most K Distinct Characters",
        "thought_question": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_.",
        "thought_answer": "\n    ```python\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Integer Break",
        "thought_question": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_.",
        "thought_answer": "\n    ```python\ndef integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Android Unlock Patterns",
        "thought_question": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an \"unlock pattern \" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a **valid** unlock pattern if both of the following are true:\n\n*   All the dots in the sequence are **distinct**.\n*   If the line segment connecting two consecutive dots in the sequence passes through the **center** of any other dot, the other dot **must have previously appeared** in the sequence. No jumps through the center non-selected dots are allowed.\n    *   For example, connecting dots `2` and `9` without dots `5` or `6` appearing beforehand is valid because the line from dot `2` to dot `9` does not pass through the center of either dot `5` or `6`.\n    *   However, connecting dots `1` and `3` without dot `2` appearing beforehand is invalid because the line from dot `1` to dot `3` passes through the center of dot `2`.\n\nHere are some example valid and invalid unlock patterns:\n\n*   The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n*   The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n*   The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n*   The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return _the **number of unique and valid unlock patterns** of the Android grid lock screen that consist of **at least**_ `m` _keys and **at most**_ `n` _keys._\n\nTwo unlock patterns are considered **unique** if there is a dot in one sequence that is not in the other, or the order of the dots is different.",
        "thought_answer": "\n    ```python\ndef numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "tag": []
    },
    {
        "thought_name": "Count Numbers with Unique Digits",
        "thought_question": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.",
        "thought_answer": "\n    ```python\ndef countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Sort Transformed Array",
        "thought_question": "Given a **sorted** integer array `nums` and three integers `a`, `b` and `c`, apply a quadratic function of the form `f(x) = ax2 + bx + c` to each element `nums[i]` in the array, and return _the array in a sorted order_.",
        "thought_answer": "\n    ```python\ndef sort_transformed_array(nums, a, b, c):\n    result = [0] * len(nums)\n    i, j = 0, len(nums) - 1\n    index = len(nums) - 1 if a >= 0 else 0\n    \n    while i <= j:\n        left = nums[i] * nums[i] * a + nums[i] * b + c\n        right = nums[j] * nums[j] * a + nums[j] * b + c\n        \n        if a >= 0:\n            if left >= right:\n                result[index] = left\n                index -= 1\n                i += 1\n            else:\n                result[index] = right\n                index -= 1\n                j -= 1\n        else:\n            if left <= right:\n                result[index] = left\n                index += 1\n                i += 1\n            else:\n                result[index] = right\n                index += 1\n                j -= 1\n    return result\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "tag": []
    },
    {
        "thought_name": "Bomb Enemy",
        "thought_question": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.",
        "thought_answer": "\n    ```python\ndef maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Range Addition",
        "thought_question": "You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.\n\nYou have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.\n\nReturn `arr` _after applying all the_ `updates`.",
        "thought_answer": "\n    ```python\ndef get_updated_array(length, updates):\n    arr = [0] * length\n\n    for start, end, inc in updates:\n        arr[start] += inc\n        if end + 1 < length:\n            arr[end + 1] -= inc\n\n    for i in range(1, length):\n        arr[i] += arr[i - 1]\n\n    return arr\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "tag": []
    },
    {
        "thought_name": "Sum of Two Integers",
        "thought_question": "Given two integers `a` and `b`, return _the sum of the two integers without using the operators_ `+` _and_ `-`.",
        "thought_answer": "\n    ```python\ndef add(a, b):\n    MAX = 0x7FFFFFFF\n    MASK = 0xFFFFFFFF\n    while b:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    return a if a <= MAX else ~(a ^ MASK)\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "tag": [
            "Math",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Guess Number Higher or Lower II",
        "thought_question": "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.",
        "thought_answer": "\n    ```python\ndef getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Game Theory"
        ]
    },
    {
        "thought_name": "Wiggle Subsequence",
        "thought_question": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`.",
        "thought_answer": "\n    ```python\ndef wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Elimination Game",
        "thought_question": "You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`:\n\n*   Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n*   Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n*   Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nGiven the integer `n`, return _the last number that remains in_ `arr`.",
        "thought_answer": "\n    ```python\ndef last_remaining(n: int) -> int:\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "tag": [
            "Math",
            "Recursion"
        ]
    },
    {
        "thought_name": "Decode String",
        "thought_question": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\n\nThe test cases are generated so that the length of the output will never exceed `105`.",
        "thought_answer": "\n    ```python\ndef decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "tag": [
            "String",
            "Stack",
            "Recursion"
        ]
    },
    {
        "thought_name": "Longest Substring with At Least K Repeating Characters",
        "thought_question": "Given a string `s` and an integer `k`, return _the length of the longest substring of_ `s` _such that the frequency of each character in this substring is greater than or equal to_ `k`.",
        "thought_answer": "\n    ```python\ndef longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    char_count = {}\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    for char, count in char_count.items():\n        if count < k:\n            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))\n    return len(s)\n```\n    \n    The algorithm starts by counting the frequency of each character in the input string `s`. If the count of any character is less than `k`, then that character cannot be part of any substring with characters having a frequency greater than or equal to `k`. Therefore, we split the input string around such characters and recursively apply the same logic on each substring. The longest substring's length across different recursive calls is returned.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Divide and Conquer",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Rotate Function",
        "thought_question": "You are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions clock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n*   `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0), F(1), ..., F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ",
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Integer Replacement",
        "thought_question": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.",
        "thought_answer": "\n    ```python\ndef min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "tag": [
            "Dynamic Programming",
            "Greedy",
            "Bit Manipulation",
            "Memoization"
        ]
    },
    {
        "thought_name": "Nth Digit",
        "thought_question": "Given an integer `n`, return the `nth` digit of the infinite integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`.",
        "thought_answer": "\n    ```python\ndef findNthDigit(n):\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])\n```\n    \n    The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer.\n    ",
        "tag": [
            "Math",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Remove K Digits",
        "thought_question": "Given string num representing a non-negative integer `num`, and an integer `k`, return _the smallest possible integer after removing_ `k` _digits from_ `num`.",
        "thought_answer": "\n    ```python\ndef remove_k_digits(num, k):\n    stack = []\n    for c in num:\n        while k > 0 and stack and stack[-1] > c:\n            stack.pop()\n            k -= 1\n        stack.append(c)\n    while k > 0:\n        stack.pop()\n        k -= 1\n    return ''.join(stack).lstrip('0') or '0'\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ",
        "tag": [
            "String",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Arithmetic Slices",
        "thought_question": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\nGiven an integer array `nums`, return _the number of arithmetic **subarrays** of_ `nums`.\n\nA **subarray** is a contiguous subsequence of the array.",
        "thought_answer": "\n    ```python\ndef numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Pacific Atlantic Water Flow",
        "thought_question": "There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn _a **2D list** of grid coordinates_ `result` _where_ `result[i] = [ri, ci]` _denotes that rain water can flow from cell_ `(ri, ci)` _to **both** the Pacific and Atlantic oceans_.",
        "thought_answer": "\n    ```python\ndef pacificAtlantic(heights):\n    def dfs(r, c, prev_height, visited):\n        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):\n            return\n        if heights[r][c] >= prev_height and not visited[r][c]:\n            visited[r][c] = True\n            dfs(r - 1, c, heights[r][c], visited)\n            dfs(r + 1, c, heights[r][c], visited)\n            dfs(r, c - 1, heights[r][c], visited)\n            dfs(r, c + 1, heights[r][c], visited)\n\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n\n    for r in range(m):\n        dfs(r, 0, -1, pacific)\n        dfs(r, n - 1, -1, atlantic)\n    for c in range(n):\n        dfs(0, c, -1, pacific)\n        dfs(m - 1, c, -1, atlantic)\n\n    result = []\n    for r in range(m):\n        for c in range(n):\n            if pacific[r][c] and atlantic[r][c]:\n                result.append([r, c])\n    return result\n```\n\n    \n    We use DFS to traverse the island, starting from the ocean borders. We create two separate matrices (`pacific` and `atlantic`) keeping track of which cells can flow water to the corresponding ocean. For each cell, we perform DFS in all 4 directions if the neighboring cell's height is less than or equal to the current cell's height.\n\nAfter finishing the DFS search for both oceans, we iterate through the matrices to find the intersections (cells that can flow water to both oceans). If a cell can flow water to both oceans, we add its coordinates to the result list.\n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ]
    },
    {
        "thought_name": "Sentence Screen Fitting",
        "thought_question": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.\n\nThe order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.",
        "thought_answer": "\n    ```python\ndef words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "tag": []
    },
    {
        "thought_name": "Battleships in a Board",
        "thought_question": "Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",
        "thought_answer": "\n    ```python\ndef countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Matrix"
        ]
    },
    {
        "thought_name": "Maximum XOR of Two Numbers in an Array",
        "thought_question": "Given an integer array `nums`, return _the maximum result of_ `nums[i] XOR nums[j]`, where `0 <= i <= j < n`.",
        "thought_answer": "\n    ```python\ndef findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n\n        possible_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ possible_max in prefixes:\n                max_xor = possible_max\n                break\n\n    return max_xor\n```\n    \n    1. Initialize max_xor and mask to 0.\n2. Loop through the 32-bit integer type from the most significant bit to the least significant bit.\n3. In each iteration, find the longest prefix of the XOR value, which is built from more significant bits to less significant bit. Update mask by left-shifting 1 and bitwise OR with the mask.\n4. Add each element bitwise AND the mask into a set called prefixes.\n5. Calculate the possible max XOR value up to the current bit by bitwise OR with (1 << i) and the current max_xor.\n6. Loop through the prefixes and check if the XOR of prefix and possible_max is in the set of prefixes.\n7. If it's in the set, update max_xor to the possible_max and break the loop, otherwise, continue with the next bit.\n8. After processing all bits, return max_xor as the final result.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Trie"
        ]
    },
    {
        "thought_name": "Reconstruct Original Digits from English",
        "thought_question": "Given a string `s` containing an out-of-order English representation of digits `0-9`, return _the digits in **ascending** order_.",
        "thought_answer": "\n    ```python\ndef find_digits_in_ascending_order(s):\n    count = [0] * 10\n    for c in s:\n        if c == 'z': count[0] += 1\n        if c == 'w': count[2] += 1\n        if c == 'u': count[4] += 1\n        if c == 'x': count[6] += 1\n        if c == 'g': count[8] += 1\n        if c == 'o': count[1] += 1\n        if c == 'h': count[3] += 1\n        if c == 'f': count[5] += 1\n        if c == 's': count[7] += 1\n        if c == 'i': count[9] += 1\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    \n    res = []\n    for i in range(10):\n        res.extend([str(i)] * count[i])\n    return ''.join(res)\n```\n\n    \n    The algorithm consists of the following steps:\n1. Initialize an array `count` of size 10 to store the count of digits from 0 to 9.\n2. Iterate through the given string (`s`). Update the `count` array according to the appearance of characters as follows:\n    - Count `0` for every `'z'`\n    - Count `2` for every `'w'`\n    - Count `4` for every `'u'`\n    - Count `6` for every `'x'`\n    - Count `8` for every `'g'`\n    - Count `1` for every `'o'` (one + two + four)\n    - Count `3` for every `'h'` (three + eight)\n    - Count `5` for every `'f'` (five + seven)\n    - Count `7` for every `'s'` (six + seven)\n    - Count `9` for every `'i'` (five + six + eight + nine)\n3. Update the counts of digits `1`, `3`, `5`, `7`, and `9` by subtracting the overlapping counts of other digits.\n4. Iterate through the `count` array and append the digit (i) `count[i]` times to the result string. This ensures we have the digits in ascending order.\n5. Return the result.\n    ",
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ]
    },
    {
        "thought_name": "Longest Repeating Character Replacement",
        "thought_question": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn _the length of the longest substring containing the same letter you can get after performing the above operations_.",
        "thought_answer": "\n    ```python\ndef characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Non-overlapping Intervals",
        "thought_question": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.",
        "thought_answer": "\n    ```python\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Find Right Interval",
        "thought_question": "You are given an array of `intervals`, where `intervals[i] = [starti, endi]` and each `starti` is **unique**.\n\nThe **right interval** for an interval `i` is an interval `j` such that `startj >= endi` and `startj` is **minimized**. Note that `i` may equal `j`.\n\nReturn _an array of **right interval** indices for each interval `i`_. If no **right interval** exists for interval `i`, then put `-1` at index `i`.",
        "thought_answer": "\n    ```python\ndef findRightInterval(intervals):\n    starts = {interval[0]: index for index, interval in enumerate(intervals)}\n    res = []\n\n    for interval in intervals:\n        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)\n        res.append(starts[right] if right != -1 else -1)\n\n    return res\n```\n    \n    The algorithm first creates a map, `starts`, to store the start times of each interval with their corresponding index in the original array. Then, we iterate through each interval, finding the minimum interval start time greater than or equal to the interval's end time using either lower_bound (C++) or ceilingEntry (Java) or filter (Python, JavaScript). If we find a valid start time, we get the corresponding index from the `starts` map and store it in the result array, otherwise we store -1.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Sorting"
        ]
    },
    {
        "thought_name": "Find All Anagrams in a String",
        "thought_question": "Given two strings `s` and `p`, return _an array of all the start indices of_ `p`_'s anagrams in_ `s`. You may return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "thought_answer": "\n    ```python\ndef find_anagrams(s, p):\n    if len(s) < len(p):\n        return []\n\n    s_count = [0] * 26\n    p_count = [0] * 26\n    for c in p:\n        p_count[ord(c) - ord('a')] += 1\n\n    result = []\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n\n    return result\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Ternary Expression Parser",
        "thought_question": "Given a string `expression` representing arbitrarily nested ternary expressions, evaluate the expression, and return _the result of it_.\n\nYou can always assume that the given expression is valid and only contains digits, `'?'`, `':'`, `'T'`, and `'F'` where `'T'` is true and `'F'` is false. All the numbers in the expression are **one-digit** numbers (i.e., in the range `[0, 9]`).\n\nThe conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, `'T'` or `'F'`.",
        "thought_answer": "\n    ```python\ndef parseTernary(expression: str) -> str:\n    stack = []\n    for c in reversed(expression):\n        if stack and stack[-1] == '?':\n            stack.pop()  # Pop '?'\n            first = stack.pop()\n            stack.pop()  # Pop ':'\n            second = stack.pop()\n            stack.append(first if c == 'T' else second)\n        else:\n            stack.append(c)\n    return stack[-1]\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find All Duplicates in an Array",
        "thought_question": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, return _an array of all the integers that appears **twice**_.\n\nYou must write an algorithm that runs in `O(n)` time and uses only constant extra space.",
        "thought_answer": "\n    ```python\ndef find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "tag": [
            "Array",
            "Hash Table"
        ]
    },
    {
        "thought_name": "Number of Boomerangs",
        "thought_question": "You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.\n\nReturn _the number of boomerangs_.",
        "thought_answer": "\n    ```python\ndef numberOfBoomerangs(points):\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Math"
        ]
    },
    {
        "thought_name": "Serialize and Deserialize BST",
        "thought_question": "Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a **binary search tree**. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.\n\n**The encoded string should be as compact as possible.**",
        "thought_answer": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root:\n        return \"#\"\n    return str(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = next(values)\n        if val == \"#\":\n            return None\n        node = TreeNode(int(val))\n        node.left = deserialize_helper(values)\n        node.right = deserialize_helper(values)\n        return node\n\n    values = iter(data.split(\",\"))\n    return deserialize_helper(values)\n```\n\n    \n    The algorithm utilizes a pre-order traversal to serialize the binary search tree. When the tree is serialized, the val of each TreeNode is visited before its children. Empty nodes are represented by \"#\" and commas are used to separate values in the serialized string.\n\nTo deserialize, the function processes the serialized string and reconstructs the tree using the pre-order traversal pattern. When an empty node is encountered (indicated by \"#\"), it returns null. Otherwise, it constructs a TreeNode for the current value, recursively deserializes the left and right children, and returns the constructed node. \n    ",
        "tag": [
            "String",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Design",
            "Binary Search Tree",
            "Binary Tree"
        ]
    },
    {
        "thought_name": "Minimum Number of Arrows to Burst Balloons",
        "thought_question": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.",
        "thought_answer": "\n    ```python\ndef findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Minimum Moves to Equal Array Elements",
        "thought_question": "Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.\n\nIn one move, you can increment `n - 1` elements of the array by `1`.",
        "thought_answer": "\n    ```python\ndef min_moves(nums):\n    min_element = min(nums)\n    moves = sum(num - min_element for num in nums)\n    return moves\n```\n\n    \n    The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1).\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "4Sum II",
        "thought_question": "Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4` all of length `n`, return the number of tuples `(i, j, k, l)` such that:\n\n*   `0 <= i, j, k, l < n`\n*   `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`",
        "thought_answer": "\n    ```python\ndef fourSumCount(nums1, nums2, nums3, nums4):\n    hashMap = {}\n    count = 0\n\n    for i in nums1:\n        for j in nums2:\n            hashMap[i + j] = hashMap.get(i + j, 0) + 1\n\n    for k in nums3:\n        for l in nums4:\n            count += hashMap.get(-(k + l), 0)\n\n    return count\n```\n    \n    The algorithm follows these steps to solve the problem:\n1. Create an empty hashmap to store the sum of two integers and their frequency.\n2. Iterate through the first two arrays nums1 and nums2, calculate their sum and store their frequency in the hashmap.\n3. Iterate through the third and fourth arrays nums3 and nums4, and for each pair of elements, calculate their sum, and check if the negative of this sum exists in the hashmap. If it exists, add the frequency of that sum to the result count.\n4. Finally, return the count.\n    ",
        "tag": [
            "Array",
            "Hash Table"
        ]
    },
    {
        "thought_name": "Minimum Moves to Equal Array Elements II",
        "thought_question": "Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.\n\nIn one move, you can increment or decrement an element of the array by `1`.\n\nTest cases are designed so that the answer will fit in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef min_moves2(nums):\n    nums.sort()\n    mid = nums[len(nums) // 2]\n    moves = 0\n    for num in nums:\n        moves += abs(num - mid)\n    return moves\n```\n    \n    1. Sort the array `nums` in ascending order.\n2. Find the middle element (median) of the sorted array.\n3. Initialize a variable `moves` to store the number of moves required.\n4. Iterate through the array, and for each element, calculate the absolute difference between the element and the median. Add this difference to the `moves` variable.\n5. Return the total `moves`.\n\nThe algorithm takes advantage of the fact that the optimal solution is to move all elements towards the median, as it minimizes the total distance between the elements.\n    ",
        "tag": [
            "Array",
            "Math",
            "Sorting"
        ]
    },
    {
        "thought_name": "Unique Substrings in Wraparound String",
        "thought_question": "We define the string `base` to be the infinite wraparound string of `\"abcdefghijklmnopqrstuvwxyz \"`, so `base` will look like this:\n\n*   `\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.... \"`.\n\nGiven a string `s`, return _the number of **unique non-empty substrings** of_ `s` _are present in_ `base`.",
        "thought_answer": "\n    ```python\ndef findSubstringInWraproundString(p: str) -> int:\n    cnt = [0] * 26\n    length = 0\n\n    for i in range(len(p)):\n        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):\n            length += 1\n        else:\n            length = 1\n        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)\n\n    return sum(cnt)\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Validate IP Address",
        "thought_question": "Given a string `queryIP`, return `\"IPv4 \"` if IP is a valid IPv4 address, `\"IPv6 \"` if IP is a valid IPv6 address or `\"Neither \"` if IP is not a correct IP of any type.\n\n**A valid IPv4** address is an IP in the form `\"x1.x2.x3.x4 \"` where `0 <= xi <= 255` and `xi` **cannot contain** leading zeros. For example, `\"192.168.1.1 \"` and `\"192.168.1.0 \"` are valid IPv4 addresses while `\"192.168.01.1 \"`, `\"192.168.1.00 \"`, and `\"192.168@1.1 \"` are invalid IPv4 addresses.\n\n**A valid IPv6** address is an IP in the form `\"x1:x2:x3:x4:x5:x6:x7:x8 \"` where:\n\n*   `1 <= xi.length <= 4`\n*   `xi` is a **hexadecimal string** which may contain digits, lowercase English letter (`'a'` to `'f'`) and upper-case English letters (`'A'` to `'F'`).\n*   Leading zeros are allowed in `xi`.\n\nFor example, \"`2001:0db8:85a3:0000:0000:8a2e:0370:7334 \"` and \"`2001:db8:85a3:0:0:8A2E:0370:7334 \"` are valid IPv6 addresses, while \"`2001:0db8:85a3::8A2E:037j:7334 \"` and \"`02001:0db8:85a3:0000:0000:8a2e:0370:7334 \"` are invalid IPv6 addresses.",
        "thought_answer": "\n    ```python\ndef validateIP(queryIP):\n    ipv4_parts = queryIP.split('.')\n    ipv6_parts = queryIP.split(':')\n\n    if len(ipv4_parts) == 4:\n        if is_valid_ipv4(ipv4_parts):\n            return \"IPv4\"\n    elif len(ipv6_parts) == 8:\n        if is_valid_ipv6(ipv6_parts):\n            return \"IPv6\"\n\n    return \"Neither\"\n\ndef is_valid_ipv4(parts):\n    for part in parts:\n        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):\n            return False\n\n        if not part.isdigit() or int(part) < 0 or int(part) > 255:\n            return False\n\n    return True\n\ndef is_valid_ipv6(parts):\n    for part in parts:\n        if not part or len(part) > 4:\n            return False\n\n        for ch in part:\n            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):\n                return False\n\n    return True\n```\n    \n    The algorithm checks if the given `queryIP` is an IPv4 or IPv6, then proceeds as follows:\n\n1. For IPv4, we split the input by dots '.' and validate if there are exactly 4 parts. Each part should be a string with length between 1 and 3, and should not have leading zeros. We then check if each character of the part is a digit and if the integer value of the part is between 0 and 255 inclusive.\n\n2. For IPv6, we split the input by colons ':' and validate if there are exactly 8 parts. Each part should be a string with length between 1 and 4. We then check if each character of the part is a hexadecimal digit (0-9, a-f or A-F).\n\nIf the given `queryIP` passes either of the above validations, it is considered a valid IPv4 or IPv6 address. Otherwise, it is considered \"Neither\".\n    ",
        "tag": [
            "String"
        ]
    },
    {
        "thought_name": "Ones and Zeroes",
        "thought_question": "You are given an array of binary strings `strs` and two integers `m` and `n`.\n\nReturn _the size of the largest subset of `strs` such that there are **at most**_ `m` `0`_'s and_ `n` `1`_'s in the subset_.\n\nA set `x` is a **subset** of a set `y` if all elements of `x` are also elements of `y`.",
        "thought_answer": "\n    ```python\ndef findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ",
        "tag": [
            "Array",
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Heaters",
        "thought_question": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.\n\nEvery house can be warmed, as long as the house is within the heater's warm radius range.\n\nGiven the positions of `houses` and `heaters` on a horizontal line, return _the minimum radius standard of heaters so that those heaters could cover all houses._\n\n**Notice** that all the `heaters` follow your radius standard, and the warm radius will the same.",
        "thought_answer": "\n    ```python\ndef findRadius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    result, i = 0, 0\n\n    for house in houses:\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        result = max(result, abs(heaters[i] - house))\n\n    return result\n```\n    \n    1. Sort both the arrays `houses` and `heaters`.\n2. Initialize two variables `result` and `i` to store the minimum required radius and the current heater index, respectively.\n3. Iterate through the `houses` array.\n   1. Using a nested while loop:\n   2. Increment `i` until the current heater is closer to the current house than the next heater.\n   3. Update `result` with the maximum distance between a house and a heater we have seen so far.\n4. After iterating through all houses, `result` contains the minimum radius for the heaters to cover all houses.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ]
    },
    {
        "thought_name": "Total Hamming Distance",
        "thought_question": "The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.\n\nGiven an integer array `nums`, return _the sum of **Hamming distances** between all the pairs of the integers in_ `nums`.",
        "thought_answer": "\n    ```python\ndef total_hamming_distance(nums):\n    total_distance = 0\n    n = len(nums)\n\n    for i in range(32):\n        bit_count = sum(((num >> i) & 1) for num in nums)\n        total_distance += bit_count * (n - bit_count)\n\n    return total_distance\n```\n    \n    The algorithm iterates through the 32-bit positions of the integers. For each bit position, it counts the number of integers in the array that have a 1 at that position. Then, it calculates the Hamming distance for that bit position by multiplying the number of 1s by the number of 0s at that position. Finally, it sums up the Hamming distances for all the bit positions to find the total Hamming distance between all the pairs of integers in the array. This way, the algorithm has a linear runtime complexity with respect to the size of the input array.\n    ",
        "tag": [
            "Array",
            "Math",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Magical String",
        "thought_question": "A magical string `s` consists of only `'1'` and `'2'` and obeys the following rules:\n\n*   The string s is magical because concatenating the number of contiguous occurrences of characters `'1'` and `'2'` generates the string `s` itself.\n\nThe first few elements of `s` is `s = \"1221121221221121122...... \"`. If we group the consecutive `1`'s and `2`'s in `s`, it will be `\"1 22 11 2 1 22 1 22 11 2 11 22 ...... \"` and the occurrences of `1`'s or `2`'s in each group are `\"1 2 2 1 1 2 1 2 2 1 2 2 ...... \"`. You can see that the occurrence sequence is `s` itself.\n\nGiven an integer `n`, return the number of `1`'s in the first `n` number in the magical string `s`.",
        "thought_answer": "\n    ```python\ndef magical_string(n: int) -> int:\n    if n == 0:\n        return 0\n    if n <= 3:\n        return 1\n\n    magic = [1, 2, 2]\n    count_ones = 1\n    index = 2\n    value = 1\n\n    while len(magic) < n:\n        for _ in range(magic[index]):\n            magic.append(value)\n            if value == 1 and len(magic) <= n:\n                count_ones += 1\n        value = 3 - value\n        index += 1\n\n    return count_ones\n```\n\n    \n    1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable.\n    ",
        "tag": [
            "Two Pointers",
            "String"
        ]
    },
    {
        "thought_name": "Max Consecutive Ones II",
        "thought_question": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array if you can flip at most one_ `0`.",
        "thought_answer": "\n    ```python\ndef findMaxConsecutiveOnes(nums: List[int]) -> int:\n    max_count, count_zeros, left = 0, 0, 0\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            count_zeros += 1\n        while count_zeros > 1:\n            if nums[left] == 0:\n                count_zeros -= 1\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count\n```\n    \n    We can use the sliding window technique to solve this problem. We maintain a window, and traverse through the array from the left side to the right side. When we find a 0, we increment the count of zeros in the window. If the count of zeros is greater than 1, we remove elements from the left side of the window until we have only 1 zero in the window. This way, we make sure we calculate the maximum number of consecutive ones when a single zero is flipped.\n\nFor each window, we update the maximum consecutive ones by comparing the current window size (right - left + 1) with max_count.\n\nIn the follow-up case where the input numbers come in one by one as an infinite stream, we can still use the same sliding window technique efficiently. We don't need to store all numbers, as we only need to store the current window of numbers which has at most size N (in the worst case where all numbers are 1). The time complexity is O(N) for the entire stream of numbers.\n    ",
        "tag": []
    },
    {
        "thought_name": "Target Sum",
        "thought_question": "You are given an integer array `nums` and an integer `target`.\n\nYou want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n\n*   For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `\"+2-1 \"`.\n\nReturn the number of different **expressions** that you can build, which evaluates to `target`.",
        "thought_answer": "\n    ```python\ndef findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n```\n\n    \n    The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array.\n    ",
        "tag": [
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Longest Palindromic Subsequence",
        "thought_question": "Given a string `s`, find _the longest palindromic **subsequence**'s length in_ `s`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
        "thought_answer": "\n    ```python\ndef longestPalindromeSubseq(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                \n    return dp[0][n - 1]\n```\n    \n    The algorithm uses dynamic programming to find the longest palindromic subsequence's length. It initializes a 2D table (dp) of size nxn, where n is the length of the string. The entries `dp[i][j]` represent the length of the longest palindromic subsequence in the string for the substring starting from index i and ending at index j.\n\nThe algorithm first fills the diagonal creating a single character palindrome. Then, it iterates through the string comparing the characters. When equal, the length of the longest palindromic subsequence increases by 2 plus the length of the longest palindrome found inside of these characters. If unequal, the longer subsequence length between the substrings not containing those characters is taken. \n\nFinally, the function returns the length of the longest palindromic subsequence found in the entire string (`dp[0][n-1]`).\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Coin Change II",
        "thought_question": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the number of combinations that make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is **guaranteed** to fit into a signed **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef change(amount, coins):\n    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Longest Uncommon Subsequence II",
        "thought_question": "Given an array of strings `strs`, return _the length of the **longest uncommon subsequence** between them_. If the longest uncommon subsequence does not exist, return `-1`.\n\nAn **uncommon subsequence** between an array of strings is a string that is a **subsequence of one string but not the others**.\n\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string).",
        "thought_answer": "\n    ```python\ndef find_lus_length(strs):\n    max_length = -1\n    for i in range(len(strs)):\n        is_uncommon = True\n        for j in range(len(strs)):\n            if i != j and strs[i] in strs[j]:\n                is_uncommon = False\n                break\n        if is_uncommon:\n            max_length = max(max_length, len(strs[i]))\n    return max_length\n```\n\n    \n    The algorithm first initializes a variable `maxLength` which will store the maximum length of the uncommon subsequence. Then it iterates through the input array of strings. For each string, it checks if it is an uncommon subsequence among the array elements. This check is done by iterating through the input array again, comparing the current string with all other strings in the array. If it's found that the current string is a subsequence of another string in the array, the current string cannot be the uncommon subsequence. If the current string is uncommon, its length is compared to the current value of `maxLength` and the maximum value is stored in `maxLength`. Finally, the `maxLength` will contain the length of the longest uncommon subsequence, or -1 if such a subsequence does not exist.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "String",
            "Sorting"
        ]
    },
    {
        "thought_name": "Longest Word in Dictionary through Deleting",
        "thought_question": "Given a string `s` and a string array `dictionary`, return _the longest string in the dictionary that can be formed by deleting some of the given string characters_. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.",
        "thought_answer": "\n    ```python\ndef findLongestWord(s, dictionary):\n    def is_subsequence(target, source):\n        iter_source = iter(source)\n        return all(char in iter_source for char in target)\n\n    dictionary = sorted(dictionary)\n    longest = ''\n    for word in dictionary:\n        if is_subsequence(word, s) and len(word) > len(longest):\n            longest = word\n    return longest\n```\n\n    \n    1. First, sort the dictionary so that word comparison will be in lexicographical order.\n2. Define a helper function `isSubsequence` which checks if a given word can be formed by deleting some of the given string characters.\n3. Iterate through the dictionary and for each word, check if it can be formed using the helper function. If a word can be formed and its length is longer than the current longest word, set it as the new longest word.\n4. Return the longest word found, or an empty string if no match was found.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "String",
            "Sorting"
        ]
    },
    {
        "thought_name": "Contiguous Array",
        "thought_question": "Given a binary array `nums`, return _the maximum length of a contiguous subarray with an equal number of_ `0` _and_ `1`.",
        "thought_answer": "\n    ```python\ndef findMaxLength(nums):\n    counts = {0: -1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counts:\n            max_len = max(max_len, i - counts[count])\n        else:\n            counts[count] = i\n    return max_len\n```\n    \n    This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Beautiful Arrangement",
        "thought_question": "Suppose you have `n` integers labeled `1` through `n`. A permutation of those `n` integers `perm` (**1-indexed**) is considered a **beautiful arrangement** if for every `i` (`1 <= i <= n`), **either** of the following is true:\n\n*   `perm[i]` is divisible by `i`.\n*   `i` is divisible by `perm[i]`.\n\nGiven an integer `n`, return _the **number** of the **beautiful arrangements** that you can construct_.",
        "thought_answer": "\n    ```python\ndef countArrangement(n: int) -> int:\n    def helper(idx: int, visited: List[bool], n: int) -> int:\n        if idx > n:\n            return 1\n\n        count = 0\n        for i in range(1, n+1):\n            if not visited[i] and (idx % i == 0 or i % idx == 0):\n                visited[i] = True\n                count += helper(idx+1, visited, n)\n                visited[i] = False\n\n        return count\n\n    visited = [False] * (n+1)\n    return helper(1, visited, n)\n```\n    \n    This problem can be solved using a backtracking algorithm. We can start by creating a helper function (a recursive function) that will iterate through all possibilities. The base case for the recursion is when the current index (idx) is greater than the given integer n. When this condition is met, increment the result (res) by 1.\n\nIn the helper function, iterate a loop for each integer i (1 <= i <= n). Check if i is not visited (visited[i] == false) and if i is divisible by idx or idx is divisible by i. If either of these conditions is true, mark i as visited and call the helper function recursively with the index incremented by 1. After the recursive call, unmark i as visited to backtrack to the previous state.\n\nInitially, pass an array or vector of visited flags, which are all initialized to false along with the integer n and index 1 to the helper function. The helper function will traverse all possibilities and return the result (res) as the final count of beautiful arrangements.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ]
    },
    {
        "thought_name": "Lonely Pixel I",
        "thought_question": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position where the same row and same column don't have **any other** black pixels.",
        "thought_answer": "\n    ```python\ndef findLonelyPixel(picture):\n    m, n = len(picture), len(picture[0])\n    row, col = [0] * m, [0] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row[i] += 1\n                col[j] += 1\n                \n    lonely = 0\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:\n                lonely += 1\n                \n    return lonely\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "tag": []
    },
    {
        "thought_name": "K-diff Pairs in an Array",
        "thought_question": "Given an array of integers `nums` and an integer `k`, return _the number of **unique** k-diff pairs in the array_.\n\nA **k-diff** pair is an integer pair `(nums[i], nums[j])`, where the following are true:\n\n*   `0 <= i, j < nums.length`\n*   `i != j`\n*   `nums[i] - nums[j] == k`\n\n**Notice** that `|val|` denotes the absolute value of `val`.",
        "thought_answer": "\n    ```python\ndef find_pairs(nums, k):\n    if k < 0:\n        return 0\n    starters = set()\n    occurrences = {}\n    for num in nums:\n        if num + k in occurrences:\n            starters.add(num)\n        if num - k in occurrences:\n            starters.add(num - k)\n        occurrences[num] = occurrences.get(num, 0) + 1\n    return len(starters)\n```\n    \n    1. If k is less than 0, return 0 as there are no pairs with a negative difference.\n2. Initialize an empty set called `starters` to store the unique starting elements of k-diff pairs.\n3. Initialize an empty map called `occurrences` to store the occurrences of each number in the input array.\n4. Iterate through the input array, and for each number, check if the number + k exists in occurrences, and the number - k exists in occurrences.\n5. If either condition is true, add the corresponding starting element of the k-diff pair to the starters set, and update the occurrences map with the current number.\n6. After iterating through the input array, return the size of the starters set, as it represents the number of unique k-diff pairs.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ]
    },
    {
        "thought_name": "Lonely Pixel II",
        "thought_question": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels and an integer target, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position `(r, c)` where:\n\n*   Row `r` and column `c` both contain exactly `target` black pixels.\n*   For all rows that have a black pixel at column `c`, they should be exactly the same as row `r`.",
        "thought_answer": "\n    ```python\ndef findBlackPixel(picture, target):\n    m, n = len(picture), len(picture[0])\n    rows = [0] * m\n    cols = [0] * n\n    rowCounts = {}\n    for i in range(m):\n        row = \"\"\n        for j in range(n):\n            if picture[i][j] == 'B':\n                rows[i] += 1\n                cols[j] += 1\n            row += picture[i][j]\n        if rows[i] == target:\n            rowCounts[row] = rowCounts.get(row, 0) + 1\n    ans = 0\n    for row, count in rowCounts.items():\n        if count == target:\n            for j in range(n):\n                if row[j] == 'B' and cols[j] == target:\n                    ans += count\n    return ans\n```\n    \n    1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels).\n    ",
        "tag": []
    },
    {
        "thought_name": "Encode and Decode TinyURL",
        "thought_question": "> Note: This is a companion problem to the [System Design](https://leetcode.com/discuss/interview-question/system-design/) problem: [Design TinyURL](https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/).\n\nTinyURL is a URL shortening service where you enter a URL such as `https://leetcode.com/problems/design-tinyurl` and it returns a short URL such as `http://tinyurl.com/4e9iAk`. Design a class to encode a URL and decode a tiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\nImplement the `Solution` class:\n\n*   `Solution()` Initializes the object of the system.\n*   `String encode(String longUrl)` Returns a tiny URL for the given `longUrl`.\n*   `String decode(String shortUrl)` Returns the original long URL for the given `shortUrl`. It is guaranteed that the given `shortUrl` was encoded by the same object.",
        "thought_answer": "\n    ```python\nimport random\nimport string\n\nclass Solution:\n    def __init__(self):\n        self.url_map = {}\n        self.alphabet = string.ascii_letters + string.digits\n\n    def encode(self, longUrl: str) -> str:\n        key = ''.join(random.choices(self.alphabet, k=6))\n\n        while key in self.url_map:\n            key = ''.join(random.choices(self.alphabet, k=6))\n\n        self.url_map[key] = longUrl\n        return \"http://tinyurl.com/\" + key\n\n    def decode(self, shortUrl: str) -> str:\n        return self.url_map[shortUrl[-6:]]\n```\n    \n    The algorithm generates a random 6-character key using a combination of lowercase, uppercase letters, and digits. It then checks if the generated key already exists in the mapping. If not, it adds the long URL and its corresponding key into the mapping. The shortened URL is created by appending the key to a fixed base URL (e.g., \"http://tinyurl.com/\"). When decoding, it obtains the key from the given shortened URL and looks up the original long URL from the mapping. This algorithm ensures that every long URL has its unique shortened URL, and it's capable of encoding and decoding URLs successfully.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Design",
            "Hash Function"
        ]
    },
    {
        "thought_name": "Complex Number Multiplication",
        "thought_question": "A [complex number](https://en.wikipedia.org/wiki/Complex_number) can be represented as a string on the form `\"**real**+**imaginary**i \"` where:\n\n*   `real` is the real part and is an integer in the range `[-100, 100]`.\n*   `imaginary` is the imaginary part and is an integer in the range `[-100, 100]`.\n*   `i2 == -1`.\n\nGiven two complex numbers `num1` and `num2` as strings, return _a string of the complex number that represents their multiplications_.",
        "thought_answer": "\n    ```python\ndef complexNumberMultiply(num1: str, num2: str) -> str:\n    real1, imag1 = map(int, num1[:-1].split('+'))\n    real2, imag2 = map(int, num2[:-1].split('+'))\n\n    real = real1 * real2 - imag1 * imag2\n    imag = real1 * imag2 + real2 * imag1\n\n    return f\"{real}+{imag}i\"\n```\n    \n    The algorithm first extracts the real and imaginary parts of the input complex numbers. In C++, sscanf is used to read formatted data from a string. In Java, we use split with a regex that matches both \"+\" and \"i\". In Python and JavaScript, we use split and map for the conversions.\n\nOnce we have real and imaginary parts of both numbers, we multiply the complex numbers using the formula:\n(real1 * real2 - imag1 * imag2) + (real1 * imag2 + real2 * imag1)i\n\nFinally, we convert the result into a string in the required format and return it.\n    ",
        "tag": [
            "Math",
            "String",
            "Simulation"
        ]
    },
    {
        "thought_name": "Minimum Time Difference",
        "thought_question": "Given a list of 24-hour clock time points in **\"HH:MM \"** format, return _the minimum **minutes** difference between any two time-points in the list_.",
        "thought_answer": "\n    ```python\ndef findMinDifference(timePoints):\n    timePoints.sort()\n    min_difference = float('inf')\n\n    for i in range(len(timePoints)):\n        h1, m1 = map(int, timePoints[i].split(':'))\n        h2, m2 = map(int, timePoints[(i+1)%len(timePoints)].split(':'))\n        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))\n        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)\n\n    return min_difference\n```\n    \n    1. Sort the given timePoints list.\n2. Initialize variable minDifference with the maximum value possible to keep track of the minimum difference.\n3. Loop through the timePoints list and for each pair of consecutive times (including the last time and the first time in the list):\n    - Calculate the absolute difference between the time in minutes.\n    - If the difference is greater than 720 (half of 1440 minutes in a day), take the complementary difference (i.e., 1440 - curDifference).\n    - Update the minDifference variable with the minimum of the previous minDifference and the calculated difference.\n4. After the loop, the minDifference variable will hold the minimum minutes difference between any two time-points in the list. Return it.\n    ",
        "tag": [
            "Array",
            "Math",
            "String",
            "Sorting"
        ]
    },
    {
        "thought_name": "Single Element in a Sorted Array",
        "thought_question": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn _the single element that appears only once_.\n\nYour solution must run in `O(log n)` time and `O(1)` space.",
        "thought_answer": "\n    ```python\ndef singleNonDuplicate(nums):\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]\n```\n    \n    The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Output Contest Matches",
        "thought_question": "During the NBA playoffs, we always set the rather strong team to play with the rather weak team, like make the rank `1` team play with the rank `nth` team, which is a good strategy to make the contest more interesting.\n\nGiven `n` teams, return _their final contest matches in the form of a string_.\n\nThe `n` teams are labeled from `1` to `n`, which represents their initial rank (i.e., Rank `1` is the strongest team and Rank `n` is the weakest team).\n\nWe will use parentheses `'('`, and `')'` and commas `','` to represent the contest team pairing. We use the parentheses for pairing and the commas for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one.",
        "thought_answer": "\n    ```python\ndef findContestMatch(n):\n    matches = [str(i) for i in range(1, n + 1)]\n\n    while n > 1:\n        for i in range(n // 2):\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\"\n        n //= 2\n\n    return matches[0]\n```\n\n    \n    This algorithm initializes an array of matches with `n` elements, each representing a team. It then generates one half of the final contest matches using a while loop. During each iteration of the while loop, for every pair of teams `i` and `n - 1 - i`, we form a new match by creating a string with the format `(team1,team2)` and store it in the matches array. With each iteration, we divide the number of matches by 2, which eventually gives us the final contest match at the first index of the matches array.\n    ",
        "tag": []
    },
    {
        "thought_name": "Number of Provinces",
        "thought_question": "There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.\n\nA **province** is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.\n\nReturn _the total number of **provinces**_.",
        "thought_answer": "\n    ```python\ndef findCircleNum(isConnected):\n    def dfs(isConnected, visited, i):\n        visited[i] = True\n        for j in range(len(isConnected)):\n            if isConnected[i][j] == 1 and not visited[j]:\n                dfs(isConnected, visited, j)\n\n    provinces = 0\n    visited = [False] * len(isConnected)\n    for i in range(len(isConnected)):\n        if not visited[i]:\n            dfs(isConnected, visited, i)\n            provinces += 1\n    return provinces\n```\n    \n    We can solve this problem by using Depth First Search (DFS) to traverse the graph of cities:\n\n1. Create a boolean array `visited` of size n (the number of cities) initialized with `false` values.\n2. Initialize a counter variable `provinces` to count the number of provinces and set it to 0.\n3. Iterate through each city from 0 to n-1.\n   - If the city has not been visited, call a DFS helper function to traverse the connected components.\n   - Increment the `provinces` counter for every new group of connected cities.\n4. In the DFS helper function, mark the given city `i` as visited.\n5. Iterate through all other cities from 0 to n-1.\n   - If the cities `i` and `j` are directly connected (isConnected[i][j] == 1) and city `j` has not been visited, call the DFS helper function with city `j`.\n6. Return the total number of provinces.\n\nThis algorithm ensures that all directly and indirectly connected cities are visited, and their connected components are counted as provinces. The time complexity of this algorithm is O(n^2) as in the worst case, we might have to visit all possible edge connections between cities.\n    ",
        "tag": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ]
    },
    {
        "thought_name": "Optimal Division",
        "thought_question": "You are given an integer array `nums`. The adjacent integers in `nums` will perform the float division.\n\n*   For example, for `nums = [2,3,4]`, we will evaluate the expression `\"2/3/4 \"`.\n\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n\nReturn _the corresponding expression that has the maximum value in string format_.\n\n**Note:** your expression should not contain redundant parenthesis.",
        "thought_answer": "\n    ```python\ndef optimal_division(nums):\n    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n    return res\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ",
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Subarray Sum Equals K",
        "thought_question": "Given an array of integers `nums` and an integer `k`, return _the total number of subarrays whose sum equals to_ `k`.\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.",
        "thought_answer": "\n    ```python\ndef subarraySum(nums, k):\n    prefix_sum_frequency = {0: 1}\n    prefix_sum, result = 0, 0\n    \n    for num in nums:\n        prefix_sum += num\n        result += prefix_sum_frequency.get(prefix_sum - k, 0)\n        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1\n\n    return result\n```\n    \n    The algorithm utilizes a hash map to store the frequency of the prefix sum up to the current element in the array. We start by initializing the hash map with a key-value pair (0, 1), which represents the empty subarray sum. Then we iterate through the input array, updating the prefix sum and result.\n\nFor each element in the array, we increment the prefix sum by the value of the element. We then increment the result by the value of the key (prefix sum - k) in the hash map, using a default value of 0 if the key is not found. This represents the number of subarrays ending at the current index with the sum equal to k. Finally, we increment the value of the prefix sum key in the hash map.\n\nThe time complexity of the algorithm is O(n), where n is the length of the input array. This is because we iterate through the array once and perform constant time operations for each element. The space complexity is O(n), which comes from using the hash map to store frequency of prefix sums.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Longest Line of Consecutive One in Matrix",
        "thought_question": "Given an `m x n` binary matrix `mat`, return _the length of the longest line of consecutive one in the matrix_.\n\nThe line could be horizontal, vertical, diagonal, or anti-diagonal.",
        "thought_answer": "\n    ```python\ndef longestLine(mat):\n    rows, cols = len(mat), len(mat[0])\n    max_length = 0\n    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if mat[r][c] == 1:\n                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1\n                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1\n                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1\n                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1\n                max_length = max(max_length, max(dp[r][c]))\n\n    return max_length\n```\n\n    \n    The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array.\n    ",
        "tag": []
    },
    {
        "thought_name": "Array Nesting",
        "thought_question": "You are given an integer array `nums` of length `n` where `nums` is a permutation of the numbers in the range `[0, n - 1]`.\n\nYou should build a set `s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }` subjected to the following rule:\n\n*   The first element in `s[k]` starts with the selection of the element `nums[k]` of `index = k`.\n*   The next element in `s[k]` should be `nums[nums[k]]`, and then `nums[nums[nums[k]]]`, and so on.\n*   We stop adding right before a duplicate element occurs in `s[k]`.\n\nReturn _the longest length of a set_ `s[k]`.",
        "thought_answer": "\n    ```python\ndef arrayNesting(nums):\n    n = len(nums)\n    max_len = 0\n    for i in range(n):\n        if nums[i] != -1:\n            start = nums[i]\n            count = 0\n            while nums[start] != -1:\n                temp = start\n                start = nums[start]\n                count += 1\n                nums[temp] = -1\n            max_len = max(max_len, count)\n    return max_len\n```\n    \n    This algorithm iterates through the given `nums` array. During the iteration, when the current element `nums[i]` is not equal to -1, it initializes a new set by setting `start` to `nums[i]` and sets the `count` to 0. Then, in the inner while loop, it keeps following the chain as described in the problem statement and sets the visited element to -1. After completing the chain for the current element, it calculates the maximum length found so far and assigns it to `max_len`. This process is repeated for all elements in the `nums` array. Finally, the algorithm returns the longest length of a set `s[k]` found.\n    ",
        "tag": [
            "Array",
            "Depth-First Search"
        ]
    },
    {
        "thought_name": "Squirrel Simulation",
        "thought_question": "You are given two integers `height` and `width` representing a garden of size `height x width`. You are also given:\n\n*   an array `tree` where `tree = [treer, treec]` is the position of the tree in the garden,\n*   an array `squirrel` where `squirrel = [squirrelr, squirrelc]` is the position of the squirrel in the garden,\n*   and an array `nuts` where `nuts[i] = [nutir, nutic]` is the position of the `ith` nut in the garden.\n\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn _the **minimal distance** for the squirrel to collect all the nuts and put them under the tree one by one_.\n\nThe **distance** is the number of moves.",
        "thought_answer": "\n    ```python\ndef minDistance(height, width, tree, squirrel, nuts):\n    totalDist = 0\n    minDiff = float(\"inf\")\n    \n    for nut in nuts:\n        treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1])\n        squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1])\n        \n        totalDist += 2 * treeDist\n        minDiff = min(minDiff, squirrelDist - treeDist)\n    \n    return totalDist + minDiff\n```\n\n    \n    Our main goal in this problem is to minimize the total distance. We will loop through all the nuts and calculate the distance between the squirrel and the nut, and the distance between the tree and the nut. We have to double the tree distance due to the squirrel having to come back to the tree. After calculating the distances, we subtract the tree distance from the squirrel distance and find the minimum difference. The total distance is the sum of all the doubled tree distances and the minimum difference.\n    ",
        "tag": []
    },
    {
        "thought_name": "Out of Boundary Paths",
        "thought_question": "There is an `m x n` grid with a ball. The ball is initially at the position `[startRow, startColumn]`. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply **at most** `maxMove` moves to the ball.\n\nGiven the five integers `m`, `n`, `maxMove`, `startRow`, `startColumn`, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef findPaths(m, n, maxMove, startRow, startColumn):               \n    MOD = 10**9 + 7                     \n    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):                                \n        for i in range(m):                                         \n            for j in range(n):                                           \n                for move in moves:              \n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 \n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          \n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]\n```\n    \n    We use dynamic programming to accumulate the ways to move the ball up to the maximum allowed moves. The `dp` array has dimensions `maxMove + 1` by `m` by `n`, where `dp[k][i][j]` represents the number of ways the ball can reach position `(i, j)` in exactly `k` moves.\n\nWe loop through moves from `1` to `maxMove`, and then loop through each cell of the grid. For each cell, we check each possible move direction. If moving in that direction causes the ball to cross the grid boundary (i.e., the new coordinates are outside of the grid), we increment the number of ways to move in exactly `k` moves by `1`. If the new coordinates are inside the grid, we add the number of ways to move to the new position in exactly `k - 1` moves to our current ways. We do this modulo `10^9 + 7` to prevent integer overflow.\n\nFinally, we return the number of ways to move the ball out of the grid boundary in exactly `maxMove` moves, which is stored at `dp[maxMove][startRow][startColumn]`.\n    ",
        "tag": [
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Shortest Unsorted Continuous Subarray",
        "thought_question": "Given an integer array `nums`, you need to find one **continuous subarray** that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\n\nReturn _the shortest such subarray and output its length_.",
        "thought_answer": "\n    ```python\ndef findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    start, end = 0, len(nums) - 1\n    while start < len(nums) and nums[start] == sorted_nums[start]:\n        start += 1\n    while end > start and nums[end] == sorted_nums[end]:\n        end -= 1\n    return end - start + 1\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Stack",
            "Greedy",
            "Sorting",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Delete Operation for Two Strings",
        "thought_question": "Given two strings `word1` and `word2`, return _the minimum number of **steps** required to make_ `word1` _and_ `word2` _the same_.\n\nIn one **step**, you can delete exactly one character in either string.",
        "thought_answer": "\n    ```python\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            elif word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Valid Triangle Number",
        "thought_question": "Given an integer array `nums`, return _the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle_.",
        "thought_answer": "\n    ```python\ndef triangleNumber(nums: list) -> int:\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count\n```\n    \n    1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximum Distance in Arrays",
        "thought_question": "You are given `m` `arrays`, where each array is sorted in **ascending order**.\n\nYou can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers `a` and `b` to be their absolute difference `|a - b|`.\n\nReturn _the maximum distance_.",
        "thought_answer": "\n    ```python\ndef maxDistance(arrays: List[List[int]]) -> int:\n    max_dist = 0\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    \n    for arr in arrays[1:]:\n        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n        \n    return max_dist\n```\n    \n    We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Minimum Factorization",
        "thought_question": "Given a positive integer num, return _the smallest positive integer_ `x` _whose multiplication of each digit equals_ `num`. If there is no answer or the answer is not fit in **32-bit** signed integer, return `0`.",
        "thought_answer": "\n    ```python\ndef smallestFactorization(num: int) -> int:\n    if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find the Derangement of An Array",
        "thought_question": "In combinatorial mathematics, a **derangement** is a permutation of the elements of a set, such that no element appears in its original position.\n\nYou are given an integer `n`. There is originally an array consisting of `n` integers from `1` to `n` in ascending order, return _the number of **derangements** it can generate_. Since the answer may be huge, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef findDerangement(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n```\n    \n    To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n.\n    ",
        "tag": []
    },
    {
        "thought_name": "Exclusive Time of Functions",
        "thought_question": "On a **single-threaded** CPU, we execute a program containing `n` functions. Each function has a unique ID between `0` and `n-1`.\n\nFunction calls are **stored in a [call stack](https://en.wikipedia.org/wiki/Call_stack)**: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is **the current function being executed**. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n\nYou are given a list `logs`, where `logs[i]` represents the `ith` log message formatted as a string `\"{function_id}:{ \"start \" | \"end \"}:{timestamp} \"`. For example, `\"0:start:3 \"` means a function call with function ID `0` **started at the beginning** of timestamp `3`, and `\"1:end:2 \"` means a function call with function ID `1` **ended at the end** of timestamp `2`. Note that a function can be called **multiple times, possibly recursively**.\n\nA function's **exclusive time** is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for `2` time units and another call executing for `1` time unit, the **exclusive time** is `2 + 1 = 3`.\n\nReturn _the **exclusive time** of each function in an array, where the value at the_ `ith` _index represents the exclusive time for the function with ID_ `i`.",
        "thought_answer": "\n    ```python\ndef exclusiveTime(n, logs):\n    res = [0] * n\n    stack = []\n    prev_time = 0\n\n    for log in logs:\n        parts = log.split(':')\n        id = int(parts[0])\n        type = parts[1]\n        time = int(parts[2])\n\n        if type == \"start\":\n            if stack:\n                res[stack[-1]] += time - prev_time\n            stack.append(id)\n            prev_time = time\n        else:\n            res[stack.pop()] += time - prev_time + 1\n            prev_time = time + 1\n\n    return res\n```\n    \n    The algorithm uses a stack to keep track of the active function calls. We iterate through the logs and parse each log to obtain the `id`, `type`, and `timestamp`. \n\nIf the current log type is \"start\", we check if the stack is not empty, and if so, we update the result entry for the function at the top of the stack by adding the time elapsed since the previous timestamp, `time - prev_time`. Then we push the new function's ID onto the stack and update the `prev_time` to the current `time`.\n\nIf the current log type is \"end\", we update the result entry for the function at the top of the stack by adding the time elapsed plus one, `time - prev_time + 1`. Then we pop the function's ID off the stack and update the `prev_time` to `time + 1`.\n\nAfter processing all logs, the result array contains the exclusive time for each function.\n    ",
        "tag": [
            "Array",
            "Stack"
        ]
    },
    {
        "thought_name": "Maximum Length of Pair Chain",
        "thought_question": "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.",
        "thought_answer": "\n    ```python\ndef findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Palindromic Substrings",
        "thought_question": "Given a string `s`, return _the number of **palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.",
        "thought_answer": "\n    ```python\ndef countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ",
        "tag": [
            "String",
            "Rolling Hash",
            "Hash Function"
        ]
    },
    {
        "thought_name": "2 Keys Keyboard",
        "thought_question": "There is only one character `'A'` on the screen of a notepad. You can perform one of two operations on this notepad for each step:\n\n*   Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n*   Paste: You can paste the characters which are copied last time.\n\nGiven an integer `n`, return _the minimum number of operations to get the character_ `'A'` _exactly_ `n` _times on the screen_.",
        "thought_answer": "\n    ```python\ndef min_steps(n):\n    result = 0\n    i = 2\n    while i <= n:\n        while n % i == 0:\n            result += i\n            n //= i\n        i += 1\n    return result\n```\n    \n    We need to find the minimum number of operations to get the character 'A' exactly n times on the screen. The operations are copying all (useful when having a large number of 'A's) and pasting.\n\nWe can think about this problem in terms of prime factorization. We are trying to break down n into the sum of various prime factors. The prime factors represent the number of operations needed at each step. \n\nIn our algorithm, we initialize the variable `result` to 0, which will store the minimum number of operations. We then start with i = 2 (smallest prime number) and iterate through all values less than or equal to n. Inside the loop, we check if n is divisible by i (i.e., n % i == 0). If yes, we add i to `result` and divide n by i. We keep doing this while n is divisible by i. Once n is no longer divisible by i, move on to the next value of i.\n\nAt the end of the algorithm, the `result` variable will contain the minimum number of operations to get n 'A's on the screen.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "4 Keys Keyboard",
        "thought_question": "Imagine you have a special keyboard with the following keys:\n\n*   A: Print one `'A'` on the screen.\n*   Ctrl-A: Select the whole screen.\n*   Ctrl-C: Copy selection to buffer.\n*   Ctrl-V: Print buffer on screen appending it after what has already been printed.\n\nGiven an integer n, return _the maximum number of_ `'A'` _you can print on the screen with **at most**_ `n` _presses on the keys_.",
        "thought_answer": "\n    ```python\ndef maxA(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i - 2):\n            dp[i] = max(dp[i], dp[j] * (i - j - 1))\n    return dp[n]\n```\n    \n    The problem can be solved using dynamic programming. We can create a dp array of size `n + 1` to store the maximum number of 'A's that can be printed with a maximum of `i` presses.\n\nFor each position `i` in the dp array, we initialize it with the value of `i`, as the minimum number of 'A's that can be printed is pressing the 'A' key `i` times. Next, we iterate through the previous positions, from `j = 1` to `i - 3`, and calculate the maximum number of 'A's we can obtain by copying the string of 'A's with `(i - j - 1)` Ctrl-V presses right after a Ctrl A and Ctrl C.\n\nTo calculate the maximum, we take the maximum between the current value of `dp[i]` and `dp[j] * (i - j - 1)`. Finally, return the value of `dp[n]`, as it represents the maximum number of 'A's that can be printed with a maximum of `n` presses.\n    ",
        "tag": []
    },
    {
        "thought_name": "Maximum Swap",
        "thought_question": "You are given an integer `num`. You can swap two digits at most once to get the maximum valued number.\n\nReturn _the maximum valued number you can get_.",
        "thought_answer": "\n    ```python\ndef maximumSwap(num):\n    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]\n                return int(\"\".join(num_str))\n\n    return num\n```\n    \n    1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input.\n    ",
        "tag": [
            "Math",
            "Greedy"
        ]
    },
    {
        "thought_name": "Number of Longest Increasing Subsequence",
        "thought_question": "Given an integer array `nums`, return _the number of longest increasing subsequences._\n\n**Notice** that the sequence has to be **strictly** increasing.",
        "thought_answer": "\n    ```python\ndef findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Binary Indexed Tree",
            "Segment Tree"
        ]
    },
    {
        "thought_name": "Repeated String Match",
        "thought_question": "Given two strings `a` and `b`, return _the minimum number of times you should repeat string_ `a` _so that string_ `b` _is a substring of it_. If it is impossible for `b`​​​​​​ to be a substring of `a` after repeating it, return `-1`.\n\n**Notice:** string `\"abc \"` repeated 0 times is `\" \"`, repeated 1 time is `\"abc \"` and repeated 2 times is `\"abcabc \"`.",
        "thought_answer": "\n    ```python\ndef min_repeats_to_substring(a: str, b: str) -> int:\n    times = (len(b) + len(a) - 1) // len(a)\n\n    for i in range(2):\n        repeated_a = a * (times + i)\n        if b in repeated_a:\n            return times + i\n\n    return -1\n```\n    \n    The algorithm calculates the minimum number of times string `a` must be repeated to have a length >= length of string `b`, which is done by `times = (b.length() + a.length() - 1) / a.length()`. Then, the algorithm checks if `b` is a substring of the concatenated string `a` after repeating it n number of times (n being `times` and `times+1`). If it finds `b` as a substring in any of the two cases, it returns the number of times `a` is repeated. If not found, it returns -1.\n    ",
        "tag": [
            "String",
            "String Matching"
        ]
    },
    {
        "thought_name": "Number of Distinct Islands",
        "thought_question": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nAn island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.\n\nReturn _the number of **distinct** islands_.",
        "thought_answer": "\n    ```python\ndef numDistinctIslands(grid):\n    unique_islands = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                island_shape = []\n                dfs(grid, i, j, i, j, island_shape)\n                island_shape.sort()\n                unique_islands.add(tuple(island_shape))\n    return len(unique_islands)\n\ndef dfs(grid, i, j, i0, j0, shape):\n    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:\n        grid[i][j] = 2\n        shape.append((i - i0, j - j0))\n        dfs(grid, i - 1, j, i0, j0, shape)\n        dfs(grid, i + 1, j, i0, j0, shape)\n        dfs(grid, i, j - 1, i0, j0, shape)\n        dfs(grid, i, j + 1, i0, j0, shape)\n```\n    \n    The algorithm behind this code is as follows:\n\n1. Initialize the set called `unique_islands` to store the shapes of different islands that are found.\n2. Iterate through the rows and columns of the grid.\n3. When a land cell (grid[i][j] == 1) is found, we've discovered a new island. To find the shape of this island:\n    - Call the `dfs` function (Depth First Search) starting from the current cell.\n    - `dfs` pushes visited cells' relative position to the island_shape list.\n    - Visited cells will have their value changed from 1 to 2 to avoid revisiting.\n4. After exploring the island, the list of relative positions representing the island_shape needs to be sorted to ensure uniqueness.\n5. Add the sorted island_shape to the set of unique_islands.\n6. After traversing the grid, return the number of islands in the unique_islands set.\n\nThe algorithm is similar across all languages, with small syntax differences. Note that JavaScript serializes the island_shape list to a JSON string before adding to the Set, as native Sets don't have deep equality comparison.\n    ",
        "tag": []
    },
    {
        "thought_name": "Max Area of Island",
        "thought_question": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.",
        "thought_answer": "\n    ```python\ndef maxAreaOfIsland(grid):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area\n```\n    \n    The algorithm uses DFS (Depth-First Search) to iterate through each cell of the given matrix.\n1. Initialize a variable, max_area, to store the maximum area found.\n2. Define a DFS function, which receives coordinates (i, j) as arguments. \n   - If the cell at (i, j) is out of bounds or has a value of 0, return 0.\n   - Otherwise, mark the cell at (i, j) as visited by setting its value to 0.\n   - Recursively call the DFS function for the adjacent cells (above, below, left, and right) and sum their returned values. Add 1 (for the current cell) and return the result.\n3. Iterate through each cell in the matrix. If the cell contains a 1 (land), invoke the DFS function with the current coordinates.\n   - Update max_area with the maximum of its current value and the value returned by the DFS function.\n4. After the loop, return max_area as the maximum area of an island in the grid.\n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ]
    },
    {
        "thought_name": "Minimum ASCII Delete Sum for Two Strings",
        "thought_question": "Given two strings `s1` and `s2`, return _the lowest **ASCII** sum of deleted characters to make two strings equal_.",
        "thought_answer": "\n    ```python\ndef minimumDeleteSum(s1: str, s2: str) -> int:\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Subarray Product Less Than K",
        "thought_question": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.",
        "thought_answer": "\n    ```python\ndef numSubarrayProductLessThanK(nums, k):\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count\n```\n    \n    The algorithm uses a sliding window approach to find the contiguous subarrays with the product less than k. It initializes a product variable to 1, and count variable to 0.  We also have left and right pointers for our sliding window.\n\nFor each number in the array, we multiply the product by the current number. Inside a loop, we check if the product is greater than or equal to k; if it is, we divide the product by the number at the left pointer and move the left pointer to the right.\n\nAfter adjusting the product and the left pointer, we can calculate the length of the current window. We increment the count by the length of the window.\n\nAt the end, we return the total count of subarrays with product less than k.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Best Time to Buy and Sell Stock with Transaction Fee",
        "thought_question": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "thought_answer": "\n    ```python\ndef maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Maximum Length of Repeated Subarray",
        "thought_question": "Given two integer arrays `nums1` and `nums2`, return _the maximum length of a subarray that appears in **both** arrays_.",
        "thought_answer": "\n    ```python\ndef findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sliding Window",
            "Rolling Hash",
            "Hash Function"
        ]
    },
    {
        "thought_name": "Longest Word in Dictionary",
        "thought_question": "Given an array of strings `words` representing an English Dictionary, return _the longest word in_ `words` _that can be built one character at a time by other words in_ `words`.\n\nIf there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n\nNote that the word should be built from left to right with each additional character being added to the end of a previous word.",
        "thought_answer": "\n    ```python\ndef longest_word(words):\n    built_words = set()\n    result = ''\n\n    for word in sorted(words):\n        if len(word) == 1 or word[:-1] in built_words:\n            if len(word) > len(result):\n                result = word\n            built_words.add(word)\n\n    return result\n```\n\n    \n    The algorithm starts by sorting the input list of words. Then, it initializes an empty set `built_words` to store the \"buildable\" words and an empty string `result` to keep track of the longest word found.\n\nFor each word in the sorted list, it checks if the word is buildable by having the length of 1 or its substring without the last character is in the set `built_words`. If the word is buildable, it compares its length with the current `result` and updates the `result` if the word is longer. It also adds the buildable word to the set `built_words`.\n\nAfter iterating through all the words in the list, it returns the longest buildable word found.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Trie",
            "Sorting"
        ]
    },
    {
        "thought_name": "Candy Crush",
        "thought_question": "This question is about implementing a basic elimination algorithm for Candy Crush.\n\nGiven an `m x n` integer array `board` representing the grid of candy where `board[i][j]` represents the type of candy. A value of `board[i][j] == 0` represents that the cell is empty.\n\nThe given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:\n\n*   If three or more candies of the same type are adjacent vertically or horizontally, crush them all at the same time - these positions become empty.\n*   After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. No new candies will drop outside the top boundary.\n*   After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.\n*   If there does not exist more candies that can be crushed (i.e., the board is stable), then return the current board.\n\nYou need to perform the above rules until the board becomes stable, then return _the stable board_.",
        "thought_answer": "\n    ```python\ndef candyCrush(board):\n    rows = len(board)\n    cols = len(board[0])\n    toDo = False\n    \n    for r in range(rows):\n        for c in range(cols - 2):\n            val = abs(board[r][c])\n            if val and val == abs(board[r][c + 1]) and val == abs(board[r][c + 2]):\n                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val\n                toDo = True\n                \n    for r in range(rows - 2):\n        for c in range(cols):\n            val = abs(board[r][c])\n            if val and val == abs(board[r + 1][c]) and val == abs(board[r + 2][c]):\n                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val\n                toDo = True\n                \n    for c in range(cols):\n        wr = rows - 1\n        for r in range(rows - 1, -1, -1):\n            if board[r][c] > 0:\n                board[wr][c] = board[r][c]\n                wr -= 1\n                \n        for r in range(wr, -1, -1):\n            board[r][c] = 0\n                \n    return candyCrush(board) if toDo else board\n```\n    \n    The algorithm iterates over `board`, checking for matching candies both horizontally and vertically. If matching candies are found, their signs are inverted to mark them as crushed. After marking all matching candies, the empty cells are filled by dropping candies from above in the same column. Finally, the function is called recursively until no more matching candies are found.\n    ",
        "tag": []
    },
    {
        "thought_name": "Monotone Increasing Digits",
        "thought_question": "An integer has **monotone increasing digits** if and only if each pair of adjacent digits `x` and `y` satisfy `x <= y`.\n\nGiven an integer `n`, return _the largest number that is less than or equal to_ `n` _with **monotone increasing digits**_.",
        "thought_answer": "\n    ```python\ndef monotoneIncreasingDigits(n: int) -> int:\n    n_str = [c for c in str(n)]\n\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n\n    return int(''.join(n_str))\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ",
        "tag": [
            "Math",
            "Greedy"
        ]
    },
    {
        "thought_name": "Daily Temperatures",
        "thought_question": "Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.",
        "thought_answer": "\n    ```python\ndef daily_temperatures(temperatures):\n    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    return result\n```\n    \n    The algorithm uses a stack that stores indices of the temperatures array. We iterate through the temperatures checking if the current temperature is greater than the temperature at the top of the stack. If it is, we pop the stack, and update the result array with the difference of the current index and the popped index, which represents the number of days to wait.\n\nIf the current temperature is not greater than the top of the stack, or the stack is empty, we push the current index onto the stack.\n\nAt the end, any remaining indices in the stack represent days without a warmer day, and their values in the result array will remain as 0 (initialized earlier).\n\nThe time complexity of the algorithm is O(N), since each index will be pushed and popped only once throughout the entire loop.\n    ",
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Delete and Earn",
        "thought_question": "You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:\n\n*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the **maximum number of points** you can earn by applying the above operation some number of times_.",
        "thought_answer": "\n    ```python\ndef max_points(nums):\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points\n```\n    \n    The algorithm uses dynamic programming to determine the maximum number of points earned from the input integer array. We create a `dp` array to store counts of integer occurrences in `nums`. We then iterate through the `dp` array, and for each index `i`, calculate the maximum number of points earned by choosing to either keep or skip the current value (represented by the index). The final answer (max points) is obtained from the last index of the `dp` array.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Number Of Corner Rectangles",
        "thought_question": "Given an `m x n` integer matrix `grid` where each entry is only `0` or `1`, return _the number of **corner rectangles**_.\n\nA **corner rectangle** is four distinct `1`'s on the grid that forms an axis-aligned rectangle. Note that only the corners need to have the value `1`. Also, all four `1`'s used must be distinct.",
        "thought_answer": "\n    ```python\ndef countCornerRectangles(grid):\n    count = 0\n    m = len(grid)\n    n = len(grid[0])\n    \n    for i in range(m - 1):\n        for j in range(n - 1):\n            if grid[i][j] == 1:\n                for k in range(i + 1, m):\n                    for l in range(j + 1, n):\n                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:\n                            count += 1\n    return count\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ",
        "tag": []
    },
    {
        "thought_name": "Reach a Number",
        "thought_question": "You are standing at position `0` on an infinite number line. There is a destination at position `target`.\n\nYou can make some number of moves `numMoves` so that:\n\n*   On each move, you can either go left or right.\n*   During the `ith` move (starting from `i == 1` to `i == numMoves`), you take `i` steps in the chosen direction.\n\nGiven the integer `target`, return _the **minimum** number of moves required (i.e., the minimum_ `numMoves`_) to reach the destination_.",
        "thought_answer": "\n    ```python\ndef reachNumber(target: int) -> int:\n    target = abs(target)\n    step = 0\n    sum = 0\n    while sum < target:\n        step += 1\n        sum += step\n    while (sum - target) % 2 != 0:\n        step += 1\n        sum += step\n    return step\n```\n\n    \n    1. Calculate the absolute value of `target` since reaching a negative target can be achieved similarly to reaching a positive target.\n2. Initialize the steps count `step` and a variable `sum` to store the sum of steps.\n3. Keep adding steps to `sum` until the `sum` is greater than or equal to the target.\n4. If the difference between the `sum` and the `target` is not divisible by 2, it means we haven't reached an even-numbered position or an odd-numbered position according to the parity of the `target`. If that's the case, increment `step` and add the new `step` to the `sum`.\n5. Repeat step 4 until the difference between the `sum` and the `target` is divisible by 2.\n6. Return the value of `step`.\n    ",
        "tag": [
            "Math",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Partition Labels",
        "thought_question": "You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn _a list of integers representing the size of these parts_.",
        "thought_answer": "\n    ```python\ndef partition_labels(s):\n    last = {c:i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n    return ans\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ",
        "tag": [
            "Hash Table",
            "Two Pointers",
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Rotated Digits",
        "thought_question": "An integer `x` is a **good** if after rotating each digit individually by 180 degrees, we get a valid number that is different from `x`. Each digit must be rotated - we cannot choose to leave it alone.\n\nA number is valid if each digit remains a digit after rotation. For example:\n\n*   `0`, `1`, and `8` rotate to themselves,\n*   `2` and `5` rotate to each other (in this case they are rotated in a different direction, in other words, `2` or `5` gets mirrored),\n*   `6` and `9` rotate to each other, and\n*   the rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer `n`, return _the number of **good** integers in the range_ `[1, n]`.",
        "thought_answer": "\n    ```python\ndef rotatedDigits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if isGood(i):\n            count += 1\n    return count\n\ndef isGood(num: int) -> bool:\n    changed = False\n    while num:\n        digit = num % 10\n        if digit in (3, 4, 7):\n            return False\n        if digit in (2, 5, 6, 9):\n            changed = True\n        num //= 10\n    return changed\n```\n    \n    The algorithm will use two main functions, one to check if a number is a good number (`isGood`) and the main one to count such numbers (`rotatedDigits`).\n\n1. Create a variable called `count` to store the count of good numbers.\n2. Iterate from 1 to the given number `n`.\n3. For each number, call the `isGood` function to check if it's a good number.\n4. If it is a good number, increment the `count`.\n5. The `isGood` function takes an integer as input and checks if it's a good number:\n    - Check each digit of the number while the number is greater than 0.\n    - If the digit is 3, 4 or 7, then the number is not a good number (return false).\n    - If the digit is 2, 5, 6 or 9, then the number is changed after rotation, set the `changed` flag as true.\n    - Remove the last digit of the number by dividing it by 10.\n    - If the `changed` flag is true, then the number is a good number (return true), otherwise return false.\n6. Return the `count`.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Most Profit Assigning Work",
        "thought_question": "You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.",
        "thought_answer": "\n    ```python\ndef maxProfitAssignment(difficulty, profit, worker):\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit\n```\n    \n    1. Combine the difficulty and profit arrays into one array, called jobs, containing pairs of the values (in JavaScript, arrays of arrays), and sort it based on the difficulty values.\n2. Sort the worker array in ascending order.\n3. Initially, set the max_profit and total_profit to 0, and job_idx to 0.\n4. Iterate over the worker array.\n   a. Inside the loop, while job_idx is less than n (number of jobs) and the current worker's ability is greater than or equal to the current job's difficulty, update the max_profit to be the maximum of the current max_profit and the current job's profit, and increment job_idx.\n   b. After the inner loop, add max_profit to the total_profit.\n5. Return the total_profit.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Push Dominoes",
        "thought_question": "There are `n` dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n\nYou are given a string `dominoes` representing the initial state where:\n\n*   `dominoes[i] = 'L'`, if the `ith` domino has been pushed to the left,\n*   `dominoes[i] = 'R'`, if the `ith` domino has been pushed to the right, and\n*   `dominoes[i] = '.'`, if the `ith` domino has not been pushed.\n\nReturn _a string representing the final state_.",
        "thought_answer": "\n    ```python\ndef pushDominoes(dominoes: str) -> str:\n    n = len(dominoes)\n    forces = [0] * n\n    \n    force = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            force = n\n        elif dominoes[i] == 'L':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] += force\n    \n    force = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            force = n\n        elif dominoes[i] == 'R':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] -= force\n    \n    return \"\".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])\n```\n\n    \n    We will use two-pass mechanism:\n1. Pass from left to right - calculate the force exerted by 'R' dominoes to 'L' dominoes.\n2. Pass from right to left - calculate the force exerted by 'L' dominoes to 'R' dominoes and subtract it from the previous force (from pass 1)\n3. Use the final force information to output the final state of dominoes:\n    - if force > 0, it's 'R'\n    - if force < 0, it's 'L'\n    - if force == 0, it's '.'\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Magic Squares In Grid",
        "thought_question": "A `3 x 3` magic square is a `3 x 3` grid filled with distinct numbers **from** `1` **to** `9` such that each row, column, and both diagonals all have the same sum.\n\nGiven a `row x col` `grid` of integers, how many `3 x 3` \"magic square \" subgrids are there? (Each subgrid is contiguous).",
        "thought_answer": "\n    ```python\ndef numMagicSquaresInside(grid):\n    count = 0\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            if grid[i][j] <= 9 and grid[i + 1][j + 1] == 5 and isMagic(grid, i, j):\n                count += 1\n    return count\n\n\ndef isMagic(grid, x, y):\n    temp = [0] * 16\n    for i in range(3):\n        for j in range(3):\n            num = grid[x + i][y + j]\n            temp[num] += 1\n            if num > 9 or temp[num] > 1:\n                return False\n\n    _sum = grid[x][y] + grid[x][y+1] + grid[x][y+2]\n    for i in range(3):\n        row_sum, col_sum = 0, 0\n        for j in range(3):\n            row_sum += grid[x + i][y + j]\n            col_sum += grid[x + j][y + i]\n        if row_sum != _sum or col_sum != _sum:\n            return False\n\n    if grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] != _sum:\n        return False\n    if grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] != _sum:\n        return False\n\n    return True\n```\n\n    \n    1. Traverse the grid using nested loops, make sure the iterations will end before the boundaries.\n2. Check the cell value at each position, if it satisfies the constraints and has a center of 5, otherwise it can't be the magic square.\n3. Create a function to check if the subgrid is a magic square, it will check the sum of each row, col, and diagonal.\n4. In the checking magic function, it will maintain a count array initialized with 16 zeros. Count and check the values for each cell in subgrid, if the value is less than or equal to 9 and count of the value is less than 2, otherwise return false.\n5. Calculate the sum of each row and column and compare it with the pre-calculated sum. If any sum is not matching, return false.\n6. Check the sums of both diagonals; if they don't match the pre-calculated sum, return false.\n7. If all checks pass, return true.\n8. For each subgrid, if it's a magic square, increment the count.\n9. Return the count after traversing all subgrids.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Matrix"
        ]
    },
    {
        "thought_name": "Longest Mountain in Array",
        "thought_question": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.",
        "thought_answer": "\n    ```python\ndef longestMountain(arr):\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res\n```\n    \n    The algorithm uses one pass with two pointers and maintains two counters, \"up\" and \"down\". It begins at the 1st index, iterating through the array. If the current element is greater than the previous, it increases the \"up\" counter; otherwise, if it's less than the previous, it increases the \"down\" counter. Every time a mountain is identified (when both \"up\" and \"down\" are non-zero), the maximum length is updated. If some conditions are met, such as a new ascending sequence interruption or equal adjacent elements, reset the \"up\" and \"down\" counters to zero. Finally, return the maximum length of a mountain subarray found.\n\nThis solution executes in O(n) time with O(1) space complexity.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Enumeration"
        ]
    },
    {
        "thought_name": "Shifting Letters",
        "thought_question": "You are given a string `s` of lowercase English letters and an integer array `shifts` of the same length.\n\nCall the `shift()` of a letter, the next letter in the alphabet, (wrapping around so that `'z'` becomes `'a'`).\n\n*   For example, `shift('a') = 'b'`, `shift('t') = 'u'`, and `shift('z') = 'a'`.\n\nNow for each `shifts[i] = x`, we want to shift the first `i + 1` letters of `s`, `x` times.\n\nReturn _the final string after all such shifts to s are applied_.",
        "thought_answer": "\n    ```python\ndef shiftingLetters(s: str, shifts) -> str:\n    for i in range(len(shifts) - 2, -1, -1):\n        shifts[i] += shifts[i + 1] % 26\n\n    result = list(s)\n    for i in range(len(s)):\n        result[i] = chr((ord(result[i]) - ord('a') + shifts[i] % 26) % 26 + ord('a'))\n        \n    return \"\".join(result)\n```\n    \n    For this problem, we first need to retrieve the total shifts needed for each character. To achieve this, we start from the last character's shift value and go backwards through the `shifts` array, summing the shifts and taking the modulo 26 to avoid loops in the alphabet.\n\nOnce we have the total shifts needed for each character, we iterate through the given string `s`, and for each character, we calculate its new position in the alphabet by adding the character's total shift modulo 26, and updating its value in the result string or array.\n\nFinally, we return the result string/array, which holds the final string after all of the shifts have been applied.\n    ",
        "tag": [
            "Array",
            "String",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Maximize Distance to Closest Person",
        "thought_question": "You are given an array representing a row of `seats` where `seats[i] = 1` represents a person sitting in the `ith` seat, and `seats[i] = 0` represents that the `ith` seat is empty **(0-indexed)**.\n\nThere is at least one empty seat, and at least one person sitting.\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\n\nReturn _that maximum distance to the closest person_.",
        "thought_answer": "\n    ```python\ndef maxDistToClosest(seats):\n    n = len(seats)\n    maxDist = 0\n    lastPerson = -1\n\n    for i in range(n):\n        if seats[i] == 1:\n            if lastPerson == -1:\n                maxDist = i\n            else:\n                maxDist = max(maxDist, (i - lastPerson) // 2)\n            lastPerson = i\n\n    maxDist = max(maxDist, n - 1 - lastPerson)\n    return maxDist\n```\n    \n    1. Initialize `maxDist` to 0 and `lastPerson` to -1.\n2. Loop through the array with the index `i`.\n3. If a person is found sitting in the current seat, calculate the distance.\n   - If this is the first person found (`lastPerson == -1`), set the maximum distance as their index `i`.\n   - If not, calculate and update the maximum distance as `(i - lastPerson) / 2`.\n4. Update `lastPerson` to the index of the current person (`lastPerson = i`).\n5. After the loop, compare the maximum distance to the distance between the last person and the end of the array (`n - 1 - lastPerson`). Update `maxDist` to the larger value.\n6. Return `maxDist` as the maximum distance to the closest person.\n    ",
        "tag": [
            "Array"
        ]
    },
    {
        "thought_name": "Subarray Sums Divisible by K",
        "thought_question": "Given an integer array `nums` and an integer `k`, return _the number of non-empty **subarrays** that have a sum divisible by_ `k`.\n\nA **subarray** is a **contiguous** part of an array.",
        "thought_answer": "\n    ```python\ndef subarraysDivByK(nums, k):\n    prefix_sums_mod_k = [0] * k\n    prefix_sums_mod_k[0] = 1\n    running_sum = 0\n    count = 0\n    \n    for num in nums:\n        running_sum += num\n        mod = (running_sum % k + k) % k\n        count += prefix_sums_mod_k[mod]\n        prefix_sums_mod_k[mod] += 1\n    \n    return count\n```\n    \n    1. Initialize a list (or array) called `prefixSumsModK` with a size `k` and value 0. Set the first element of `prefixSumsModK` to 1.\n2. Initialize variables `runningSum` and `count` both equal to 0.\n3. Iterate through the input array `nums`.\n4. For each element, add it to `runningSum`.\n5. Calculate the modulus of `runningSum` divided by `k`. To ensure the result is positive, add `k` to the result and calculate the modulus again.\n6. Increment the count by the value at the index `mod` in the `prefixSumsModK` list.\n7. Increment the value at the index `mod` in the `prefixSumsModK` list.\n8. Return `count` after the loop.\n\nThis algorithm uses the prefix sum with mod k to efficiently count the subarrays with a sum divisible by k.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Smallest Integer Divisible by K",
        "thought_question": "Given a positive integer `k`, you need to find the **length** of the **smallest** positive integer `n` such that `n` is divisible by `k`, and `n` only contains the digit `1`.\n\nReturn _the **length** of_ `n`. If there is no such `n`, return -1.\n\n**Note:** `n` may not fit in a 64-bit signed integer.",
        "thought_answer": "\n    ```python\ndef smallestRepunitDivByK(k: int) -> int:\n    if k % 2 == 0 or k % 5 == 0:\n        return -1\n    n = 0\n    for i in range(1, k + 1):\n        n = (n * 10 + 1) % k\n        if n == 0:\n            return i\n    return -1\n```\n    \n    The algorithm starts by checking if k is divisible by 2 or 5. If it is, we return -1, because no number consisting of only the digit 1 can be divisible by 2 or 5. Then, we initialize a variable `n` to 0. We loop from 1 to k, and at each iteration, we multiply the current `n` by 10, add 1, and take the remainder when divided by k. If the remainder becomes 0, we return the current iteration index, since this indicates that we've found the smallest number consisting of only the digit 1 that is divisible by k. If after the loop, we haven't found such a number, we return -1.\n    ",
        "tag": [
            "Hash Table",
            "Math"
        ]
    },
    {
        "thought_name": "Grumpy Bookstore Owner",
        "thought_question": "There is a bookstore owner that has a store open for `n` minutes. Every minute, some number of customers enter the store. You are given an integer array `customers` of length `n` where `customers[i]` is the number of the customer that enters the store at the start of the `ith` minute and all those customers leave after the end of that minute.\n\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where `grumpy[i]` is `1` if the bookstore owner is grumpy during the `ith` minute, and is `0` otherwise.\n\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n\nThe bookstore owner knows a secret technique to keep themselves not grumpy for `minutes` consecutive minutes, but can only use it once.\n\nReturn _the maximum number of customers that can be satisfied throughout the day_.",
        "thought_answer": "\n    ```python\ndef maxSatisfied(customers, grumpy, minutes):\n    total_customers = 0\n    max_extra_customers = 0\n    extra_customers = 0\n    for i in range(len(customers)):\n        if grumpy[i] == 0:\n            total_customers += customers[i]\n        if i < minutes:\n            extra_customers += customers[i] * grumpy[i]\n        else:\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])\n        max_extra_customers = max(max_extra_customers, extra_customers)\n    return total_customers + max_extra_customers\n```\n\n    \n    First, we need to calculate the initial sum of satisfied customers which we do by looping through the `customers` array and checking if the bookstore owner is grumpy at that minute, i.e., `grumpy[i] == 0`. If the bookstore owner is not grumpy, we add the customers at that minute to `total_customers`. \n\nThen, we need to find the maximum possible number of extra customers that can be satisfied by using the secret technique for `minutes` minutes. Initialise two variables, `max_extra_customers` and `extra_customers`, to 0. Iterate through the `customers` array again. If the current minute, `i`, is less than `minutes`, increment `extra_customers` by the product of `customers[i]` and `grumpy[i]`. Otherwise, increment `extra_customers` by adding the product of `customers[i]` and `grumpy[i]` and subtracting the product of `customers[i - minutes]` and `grumpy[i - minutes]`. \n\nUpdate `max_extra_customers` with the maximum of its current value and `extra_customers`. After the iteration, return the sum of `total_customers` and `max_extra_customers` as the maximum number of satisfied customers throughout the day.\n    ",
        "tag": [
            "Array",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Previous Permutation With One Swap",
        "thought_question": "Given an array of positive integers `arr` (not necessarily distinct), return _the_ _lexicographically_ _largest permutation that is smaller than_ `arr`, that can be **made with exactly one swap**. If it cannot be done, then return the same array.\n\n**Note** that a _swap_ exchanges the positions of two numbers `arr[i]` and `arr[j]`",
        "thought_answer": "\n    ```python\ndef prevPermOpt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            break\n    return arr\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Find K-Length Substrings With No Repeated Characters",
        "thought_question": "Given a string `s` and an integer `k`, return _the number of substrings in_ `s` _of length_ `k` _with no repeated characters_.",
        "thought_answer": "\n    ```python\ndef num_k_len_substr_no_repeats(s: str, k: int) -> int:\n    n = len(s)\n    if k > n:\n        return 0\n\n    result = 0\n    window = set()\n\n    i = 0\n    for j in range(n):\n        while s[j] in window:\n            window.remove(s[i])\n            i += 1\n        window.add(s[j])\n        if j - i + 1 == k:\n            result += 1\n            window.remove(s[i])\n            i += 1\n\n    return result\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "tag": []
    },
    {
        "thought_name": "The Earliest Moment When Everyone Become Friends",
        "thought_question": "There are n people in a social group labeled from `0` to `n - 1`. You are given an array `logs` where `logs[i] = [timestampi, xi, yi]` indicates that `xi` and `yi` will be friends at the time `timestampi`.\n\nFriendship is **symmetric**. That means if `a` is friends with `b`, then `b` is friends with `a`. Also, person `a` is acquainted with a person `b` if `a` is friends with `b`, or `a` is a friend of someone acquainted with `b`.\n\nReturn _the earliest time for which every person became acquainted with every other person_. If there is no such earliest time, return `-1`.",
        "thought_answer": "\n    ```python\ndef earliestAcq(logs, n):\n    def find(x):\n        if x != parents[x]:\n            parents[x] = find(parents[x])\n        return parents[x]\n\n    parents = list(range(n))\n    logs.sort()\n\n    group_count = n\n    for timestamp, x, y in logs:\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parents[root_x] = root_y\n            group_count -= 1\n        if group_count == 1:\n            return timestamp\n    return -1\n```\n    \n    All the implemented algorithms are based on the Union-Find data structure.\n\nWe initialize a parents array to keep track of the parent of each node. We sort the logs based on timestamps. We iterate through each log and for each pair of friends, x and y, we find their root using the `find` function. If the roots are not equal, we merge their roots and decrement the group count. This means they are now part of the same group, and there is one less separate group. We return the current timestamp when we reach to only one group left.\n    ",
        "tag": []
    },
    {
        "thought_name": "Corporate Flight Bookings",
        "thought_question": "There are `n` flights that are labeled from `1` to `n`.\n\nYou are given an array of flight bookings `bookings`, where `bookings[i] = [firsti, lasti, seatsi]` represents a booking for flights `firsti` through `lasti` (**inclusive**) with `seatsi` seats reserved for **each flight** in the range.\n\nReturn _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the total number of seats reserved for flight_ `i`.",
        "thought_answer": "\n    ```python\ndef corpFlightBookings(bookings, n):\n    seats = [0] * n\n    for booking in bookings:\n        seats[booking[0] - 1] += booking[2]\n        if booking[1] < n:\n            seats[booking[1]] -= booking[2]\n    for i in range(1, n):\n        seats[i] += seats[i - 1]\n    return seats\n```\n    \n    The algorithm initializes an array of `n` elements with all elements set to `0`. Then it iterates through the `bookings` array and for each booking, it adds the `seats` at the position `first_i - 1` and subtracts the `seats` at `last_i` if `last_i` is within the range of the array. This process gives us an initial array representing the change in seats for each flight. Finally, it iterates through the array adjusting the count for each flight by summing the previous flight count to get the total count. This gives the desired output with a time complexity of `O(n)` where `n` is the number of flights.\n    ",
        "tag": [
            "Array",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Longest Well-Performing Interval",
        "thought_question": "We are given `hours`, a list of the number of hours worked per day for a given employee.\n\nA day is considered to be a _tiring day_ if and only if the number of hours worked is (strictly) greater than `8`.\n\nA _well-performing interval_ is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\n\nReturn the length of the longest well-performing interval.",
        "thought_answer": "\n    ```python\ndef longestWellPerformingInterval(hours):\n    sum = 0\n    longest = 0\n    first_sum_index = {}\n\n    for i, hour in enumerate(hours):\n        sum += 1 if hour > 8 else -1\n        if sum > 0:\n            longest = i + 1\n        else:\n            if sum - 1 in first_sum_index:\n                longest = max(longest, i - first_sum_index[sum - 1])\n            if sum not in first_sum_index:\n                first_sum_index[sum] = i\n\n    return longest\n```\n\n    \n    The algorithm iterates through the input list, representing the hours worked. It keeps track of the cumulative sum of tiring and non-tiring days, incrementing the sum by 1 for a tiring day, and decrementing by 1 for a non-tiring day.\n\nDuring the iteration, it checks if the sum is greater than 0, meaning there are more tiring days than non-tiring days up to the current index. If that's the case, the length of the well-performing interval is updated as the current index plus 1. If the sum is less than or equal to 0, the algorithm checks if the sum minus 1 exists in the dictionary of first sum occurrence indices; if it does, it updates the length of the well-performing interval according to this first occurrence index.\n\nFinally, if the current sum hasn't been encountered before, the algorithm adds the current index as the first occurrence of the sum in the `first_sum_index` dictionary.\n\nBy the end of the iteration, the maximum length of a well-performing interval is found.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Stack",
            "Monotonic Stack",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Maximum of Absolute Value Expression",
        "thought_question": "Given two arrays of integers with equal lengths, return the maximum value of:\n\n`|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|`\n\nwhere the maximum is taken over all `0 <= i, j < arr1.length`.",
        "thought_answer": "\n    ```python\ndef maxAbsValExpr(arr1, arr2):\n    result = 0\n    max_sum = [float('-inf')] * 4\n\n    for i in range(len(arr1)):\n        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i)\n        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i)\n        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i)\n        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i)\n\n    for i in range(len(arr1)):\n        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i)\n        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i)\n\n    return result\n```\n    \n    The problem asks to find the maximum value of the given expression, and since we have the absolute values involved, we can simplify this expression using 4 different combinations. These combinations are formed by considering both positive and negative variations of `arr1` and `arr2` components in the expression. So, we calculate the maximum values of these 4 expressions for the whole range of indices.\n\nNow, for each index, we take the difference of the calculated max values and the newly calculated expressions. After this step, we find the maximum of these 4 differences and update the result variable, which ultimately gives the required result after iterating through the entire index range.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Parallel Courses",
        "thought_question": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`.\n\nIn one semester, you can take **any number** of courses as long as you have taken all the prerequisites in the **previous** semester for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. If there is no way to take all the courses, return `-1`.",
        "thought_answer": "\n    ```python\ndef minimum_semesters(n: int, relations: List[List[int]]) -> int:\n    in_degree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev, next in relations:\n        graph[prev].append(next)\n        in_degree[next] += 1\n\n    q = [i for i in range(1, n + 1) if in_degree[i] == 0]\n    semesters = 0\n\n    while q:\n        next_q = []\n        semesters += 1\n        for course in q:\n            n -= 1\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    next_q.append(next_course)\n        q = next_q\n\n    return semesters if n == 0 else -1\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "tag": []
    },
    {
        "thought_name": "Longest Common Subsequence",
        "thought_question": "Given two strings `text1` and `text2`, return _the length of their longest **common subsequence**._ If there is no **common subsequence**, return `0`.\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n*   For example, `\"ace \"` is a subsequence of `\"abcde \"`.\n\nA **common subsequence** of two strings is a subsequence that is common to both strings.",
        "thought_answer": "\n    ```python\ndef longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n```\n    \n    We will use dynamic programming to solve this problem. The idea is to create a 2D array `dp` with dimensions `text1.length + 1` and `text2.length + 1`. The indices `(i, j)` of the array will store the length of the longest common subsequence of the substrings `text1` and `text2` until index `i` and `j` respectively.\n\nWe loop through the two strings and compare their characters at positions `i - 1` and `j - 1` (since indices are 0-based). If the characters are the same, the value of `dp[i][j]` will be equal to the `dp[i - 1][j - 1]` + 1; otherwise, we set `dp[i][j]` equal to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n\nAfter iterating through both strings, the result will be stored at `dp[m][n]` where `m` and `n` are the lengths of `text1` and `text2`.\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Decrease Elements To Make Array Zigzag",
        "thought_question": "Given an array `nums` of integers, a _move_ consists of choosing any element and **decreasing it by 1**.\n\nAn array `A` is a _zigzag array_ if either:\n\n*   Every even-indexed element is greater than adjacent elements, ie. `A[0] > A[1] < A[2] > A[3] < A[4] > ...`\n*   OR, every odd-indexed element is greater than adjacent elements, ie. `A[0] < A[1] > A[2] < A[3] > A[4] < ...`\n\nReturn the minimum number of moves to transform the given array `nums` into a zigzag array.",
        "thought_answer": "\n    ```python\ndef movesToMakeZigzag(nums):\n    even_moves, odd_moves = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else 1001\n        right = nums[i + 1] if i < len(nums) - 1 else 1001\n        min_value = min(left, right)\n        if nums[i] >= min_value:\n            if i % 2 == 0:\n                even_moves += nums[i] - min_value + 1\n            else:\n                odd_moves += nums[i] - min_value + 1\n    return min(even_moves, odd_moves)\n```\n    \n    The algorithm first initializes two counters: one for the number of moves for making a zigzag array starting at an even position, and another for starting at an odd position. Then, we iterate through the array and check the left and right neighbours of each element. If the current element is larger than or equal to any of its neighbours, we need to decrease it. The number of moves needed is the difference between the current element and the minimum adjacent value, plus one. Depending on the index of the element, we add the number of moves to the corresponding counter (even or odd). Finally, we return the minimum between the two counters.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Minimum Swaps to Group All 1's Together",
        "thought_question": "Given a binary array `data`, return the minimum number of swaps required to group all `1`'s present in the array together in **any place** in the array.",
        "thought_answer": "\n    ```python\ndef minSwaps(data):\n    ones = sum(data)\n    cur_ones, max_ones = 0, 0\n    for i, d in enumerate(data):\n        cur_ones += d\n        if i >= ones:\n            cur_ones -= data[i - ones]\n        max_ones = max(max_ones, cur_ones)\n    return ones - max_ones\n```\n\n    \n    First, count the number of ones in the data array. Then, use a sliding window of length equal to the count of ones to keep a running sum of ones in the window. Keep track of the maximum number of ones found in any window. The minimum number of swaps required to group all ones together equals the total number of ones minus the maximum number of ones found in any window.\n    ",
        "tag": []
    },
    {
        "thought_name": "Number of Dice Rolls With Target Sum",
        "thought_question": "You have `n` dice, and each die has `k` faces numbered from `1` to `k`.\n\nGiven three integers `n`, `k`, and `target`, return _the number of possible ways (out of the_ `kn` _total ways)_ _to roll the dice, so the sum of the face-up numbers equals_ `target`. Since the answer may be too large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef numRollsToTarget(n, k, target):\n    MOD = 1000000007\n    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, target + 1):\n            for d in range(1, k + 1):\n                if j - d >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD\n    return dp[n][target]\n```\n    \n    The problem can be solved using dynamic programming. We first initialize a `n+1`by `target+1` matrix `dp` where `dp[i][j]` represents the number of ways to get a sum `j` using `i` dice. The matrix is initialized with 0s, and the base case (no dice and no target) is set as 1 (`dp[0][0]=1`).\n\nWe iterate through the matrix with two nested loops over the number of dice `i` and the target sum `j`. In each iteration, we also have another loop iterating through the possible numbers on a die, from `1` to `k`. This checks if the target has not been exceeded and, if possible, calculates the cumulative sum of the possible ways to get a sum equal to the current target using one less die (`dp[i - 1][j - d]`). This sum is then taken modulo `1e9 + 7`.\n\nFinally, we return the number of ways found in the last cell of the matrix, `dp[n][target]`.\n    ",
        "tag": [
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Shortest Distance to Target Color",
        "thought_question": "You are given an array `colors`, in which there are three colors: `1`, `2` and `3`.\n\nYou are also given some queries. Each query consists of two integers `i` and `c`, return the shortest distance between the given index `i` and the target color `c`. If there is no solution return `-1`.",
        "thought_answer": "\n    ```python\ndef shortestDistance(colors, queries):\n    result = []\n    positions = [[] for _ in range(3)]\n\n    for i, color in enumerate(colors):\n        positions[color - 1].append(i)\n\n    for query in queries:\n        index_positions = positions[query[1] - 1]\n\n        if not index_positions:\n            result.append(-1)\n        else:\n            dist = float('inf')\n\n            for pos in index_positions:\n                dist = min(dist, abs(pos - query[0]))\n\n            result.append(dist)\n\n    return result\n```\n    \n    The algorithm maintains a list with 3 inner lists (named `positions`), representing the positions where each color (`1`, `2`, or `3`) appear in the input list `colors`. \n\nFor each query, we get the index positions of the target color (query[1]) from the `positions` list. If there are no index positions, we append `-1` to our `result` list. Otherwise, we calculate the distance between each target color position and the index `i` given in the query by finding the absolute difference of their indices. We keep the minimum distance found, and append it to our `result` list.\n\nFinally, we return the `result` list containing the shortest distances for each query.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find Smallest Common Element in All Rows",
        "thought_question": "Given an `m x n` matrix `mat` where every row is sorted in **strictly** **increasing** order, return _the **smallest common element** in all rows_.\n\nIf there is no common element, return `-1`.",
        "thought_answer": "\n    ```python\ndef smallest_common_element(mat):\n    counts = {}\n    for row in mat:\n        for num in row:\n            counts[num] = counts.get(num, 0) + 1\n            if counts[num] == len(mat):\n                return num\n    return -1\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "tag": []
    },
    {
        "thought_name": "Remove All Adjacent Duplicates in String II",
        "thought_question": "You are given a string `s` and an integer `k`, a `k` **duplicate removal** consists of choosing `k` adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together.\n\nWe repeatedly make `k` **duplicate removals** on `s` until we no longer can.\n\nReturn _the final string after all such duplicate removals have been made_. It is guaranteed that the answer is **unique**.",
        "thought_answer": "\n    ```python\ndef removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if not stack or stack[-1][0] != c:\n            stack.append((c, 1))\n        elif stack[-1][1] + 1 != k:\n            stack[-1] = (c, stack[-1][1] + 1)\n        else:\n            stack.pop()\n    return ''.join(c * count for c, count in stack)\n```\n\n    \n    The algorithm makes use of a stack that stores the characters and their counts. For each character in the input string `s`, we check if the stack is empty or if the top of the stack has a different character. If either of these cases is true, we push the new character onto the stack along with a count of 1.\n\nIf the character is the same as the one on the top of the stack, we increment the count of that character. If the count reaches the value of `k`, we remove the character from the stack (its count is reset). We repeat this process for each character in the input string.\n\nAfter iteration, we construct the final result string from the stack contents. Each character is repeated as many times as the count associated with it on the stack. This string is the result after all of the `k`-duplicate removals have been made.\n    ",
        "tag": [
            "String",
            "Stack"
        ]
    },
    {
        "thought_name": "Stepping Numbers",
        "thought_question": "A **stepping number** is an integer such that all of its adjacent digits have an absolute difference of exactly `1`.\n\n*   For example, `321` is a **stepping number** while `421` is not.\n\nGiven two integers `low` and `high`, return _a sorted list of all the **stepping numbers** in the inclusive range_ `[low, high]`.",
        "thought_answer": "\n    ```python\ndef countSteppingNumbers(low, high):\n    results = []\n    for i in range(low, high+1):\n        prev = -1\n        j = i\n        is_stepping = True\n        while j > 0:\n            digit = j % 10\n            if prev != -1 and abs(prev - digit) != 1:\n                is_stepping = False\n                break\n            prev = digit\n            j //= 10\n        if is_stepping:\n            results.append(i)\n    return results\n```\n    \n    The algorithm starts by initializing an empty list for the final result. Then it iterates from `low` to `high` inclusive. For each integer `i` in the range, it checks whether it's a stepping number or not. To do so:\n1. Initialize a `prev` variable to store the previous digit and set it initially to -1.\n2. Initialize a variable `j` with the value of `i`.\n3. Initialize an `is_stepping` flag and set it to true.\n4. Create a while loop that continues until `j` is greater than 0.\n    - Calculate the current digit by taking the modulus of `j` and 10.\n    - If `prev` is not equal to -1 and the absolute difference between the current digit and the previous digit is not equal to 1, set the `is_stepping` flag to false and break the loop.\n    - Otherwise, set the `prev` variable to the current digit and divide `j` by 10 (using integer division).\n5. After the loop, if the `is_stepping` flag is still true, it means the number `i` is a stepping number, so add it to the result list.\n6. Finally, return the result list.\n    ",
        "tag": []
    },
    {
        "thought_name": "Number of Closed Islands",
        "thought_question": "Given a 2D `grid` consists of `0s` (land) and `1s` (water). An _island_ is a maximal 4-directionally connected group of `0s` and a _closed island_ is an island **totally** (all left, top, right, bottom) surrounded by `1s.`\n\nReturn the number of _closed islands_.",
        "thought_answer": "\n    ```python\ndef closedIsland(grid):\n    def dfs(grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return False\n\n        if grid[i][j] == 1:\n            return True\n\n        grid[i][j] = 1\n\n        up = dfs(grid, i - 1, j)\n        down = dfs(grid, i + 1, j)\n        left = dfs(grid, i, j - 1)\n        right = dfs(grid, i, j + 1)\n\n        return up and down and left and right\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0 and dfs(grid, i, j):\n                count += 1\n\n    return count\n```\n\n    \n    The algorithm uses Depth-first Search (DFS) to traverse islands of 0s (land). If the DFS function returns false, then the current cell is on the edge and it is not a closed island. If the DFS function returns true, then the current cell is surrounded by 1s (water), and the current island is a closed island.\n\nFor each cell that contains a 0 (land), we call the DFS function to explore the island. If the DFS function returns true for all directions (up, down, left, and right), then it is a closed island. We increment the count for each closed island found.\n\nFinally, we return the total count of closed islands.\n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ]
    },
    {
        "thought_name": "Search Suggestions System",
        "thought_question": "You are given an array of strings `products` and a string `searchWord`.\n\nDesign a system that suggests at most three product names from `products` after each character of `searchWord` is typed. Suggested products should have common prefix with `searchWord`. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\nReturn _a list of lists of the suggested products after each character of_ `searchWord` _is typed_.",
        "thought_answer": "\n    ```python\ndef suggestedProducts(products, searchWord):\n    result = []\n    products.sort()\n    \n    for i in range(len(searchWord)):\n        suggestions = []\n        for product in products:\n            if len(product) > i and product[i] == searchWord[i]:\n                suggestions.append(product)\n                if len(suggestions) == 3:\n                    break\n        result.append(suggestions)\n    \n    return result\n```\n\n    \n    The given problem can be solved with a simple sorting and iteration approach. The algorithm works as follows:\n\n1. Sort the `products` list lexicographically.\n2. Iterate through each character in the `searchWord`.\n3. For each character, initialize an empty list `suggestions` to store the suggested products.\n4. Iterate through each product in the `products` list.\n5. If the product has the same character at the current position as the `searchWord`, add the product to the `suggestions` list.\n6. Break the loop if the `suggestions` list has 3 elements, as we need at most 3 product suggestions at a time.\n7. After iterating through all products, add the `suggestions` list to the `result` list.\n8. Repeat steps 3-7 for each character in the `searchWord`.\n9. Return the `result` list containing lists of suggested products after each character of `searchWord`.\n\nThis algorithm solves the problem with a simple traversal approach and doesn't require any complex data structures or techniques.\n    ",
        "tag": [
            "Array",
            "String",
            "Binary Search",
            "Trie",
            "Sorting",
            "Heap (Priority Queue)"
        ]
    },
    {
        "thought_name": "Sequential Digits",
        "thought_question": "An integer has _sequential digits_ if and only if each digit in the number is one more than the previous digit.\n\nReturn a **sorted** list of all the integers in the range `[low, high]` inclusive that have sequential digits.",
        "thought_answer": "\n    ```python\ndef sequential_digits(low, high):\n    result = []\n    for i in range(1, 10):\n        number = i\n        for j in range(i + 1, 10):\n            number = number * 10 + j\n            if low <= number <= high:\n                result.append(number)\n    return sorted(result)\n```\n    \n    The algorithm starts iterating from 1 to 9, representing the first digit of the possible sequential digits. Inside the outer loop, we initialize a new loop that starts at the next digit (i + 1). We keep adding the next digit to the number by multiplying it by 10 and then adding the digit. After each addition, we check if the number falls within the range [low, high]. If it does, we add it to our result list. Finally, we sort the resultant list and return it. The time complexity of the algorithm is O(n) where n is the range of [low, high]. The space complexity of the algorithm is O(1) as we are using a constant amount of additional space.\n    ",
        "tag": [
            "Enumeration"
        ]
    },
    {
        "thought_name": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
        "thought_question": "Given a `m x n` matrix `mat` and an integer `threshold`, return _the maximum side-length of a square with a sum less than or equal to_ `threshold` _or return_ `0` _if there is no such square_.",
        "thought_answer": "\n    ```python\ndef maxSideLength(mat: List[List[int]], threshold: int) -> int:\n    m, n = len(mat), len(mat[0])\n    preSum = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]\n\n    maxSide = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, min(m, n) + 1):\n                endX, endY = i + k - 1, j + k - 1\n                if endX <= m and endY <= n:\n                    sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1]\n                    if sum <= threshold:\n                        maxSide = max(maxSide, k)\n                else:\n                    break\n    return maxSide\n```\n\n    \n    The goal is to find the maximum side-length of a square with a sum less than or equal to threshold. We first calculate a prefix sum array of size (m+1) x (n+1) where preSum[i][j] stores the sum of all elements in the matrix up to mat[i-1][j-1]. This allows us to calculate the sum of any square in the matrix in constant time.\n\nThen, we iterate through each cell in the matrix and try to find a square with maximum side-length whose sum is less than or equal to threshold. We check this for each possible side-length (1 to min(m, n)) by using the prefix sum array.\n\nThroughout the iteration, we keep track of the maximum side-length that satisfies the condition sum <= threshold. We return this maximum side-length as the final result. If no square satisfies the condition, the result will be 0.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Matrix",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Matrix Block Sum",
        "thought_question": "Given a `m x n` matrix `mat` and an integer `k`, return _a matrix_ `answer` _where each_ `answer[i][j]` _is the sum of all elements_ `mat[r][c]` _for_:\n\n*   `i - k <= r <= i + k,`\n*   `j - k <= c <= j + k`, and\n*   `(r, c)` is a valid position in the matrix.",
        "thought_answer": "\n    ```python\ndef matrix_block_sum(mat, k):\n    m, n = len(mat), len(mat[0])\n    answer = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for r in range(max(0, i - k), min(m, i + k + 1)):\n                for c in range(max(0, j - k), min(n, j + k + 1)):\n                    answer[i][j] += mat[r][c]\n                    \n    return answer\n```\n    \n    This algorithm iterates through each cell of the input matrix `mat`. For each cell, it calculates the sum of all elements in the given sub-matrix range. The sub-matrix `mat[r][c]` is represented by the conditions `i - k <= r <= i + k` and `j - k <= c <= j + k`. It checks if `(r, c)` is a valid position. If it's valid, the sum will be stored in the `answer` matrix at the same index (i, j). The complexity of this algorithm is O(m * n * k^2), where m is the number of rows, n is the number of columns, and k is the range.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Minimum Flips to Make a OR b Equal to c",
        "thought_question": "Given 3 positives numbers `a`, `b` and `c`. Return the minimum flips required in some bits of `a` and `b` to make ( `a` OR `b` == `c` ). (bitwise OR operation).  \nFlip operation consists of change **any** single bit 1 to 0 or change the bit 0 to 1 in their binary representation.",
        "thought_answer": "\n    ```python\ndef minFlips(a: int, b: int, c: int) -> int:\n    count = 0\n    for i in range(32):\n        bitA = (a >> i) & 1\n        bitB = (b >> i) & 1\n        bitC = (c >> i) & 1\n        if bitC == 0:\n            count += bitA + bitB\n        else:\n            count += 1 - (bitA | bitB)\n    return count\n```\n    \n    We iterate through all 32 bits since the maximum number is 10^9, which requires 30 bits to represent in binary. For each bit, we determine the bits for `a`, `b`, and `c`, at the current position. If the bit in `c` is 0, we increment the counter by the sum of the bits of `a` and `b` at that position. This is because we need to flip any 1s in `a` and `b` to make the OR result 0. If the bit in `c` is 1, we increment the counter by 1 minus the OR result of `a` and `b`. This is because either `a` or `b` (or both) need to have a 1 at this position, so 1 minus the OR result gives us the necessary flips.\n    ",
        "tag": [
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Break a Palindrome",
        "thought_question": "Given a palindromic string of lowercase English letters `palindrome`, replace **exactly one** character with any lowercase English letter so that the resulting string is **not** a palindrome and that it is the **lexicographically smallest** one possible.\n\nReturn _the resulting string. If there is no way to replace a character to make it not a palindrome, return an **empty string**._\n\nA string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly smaller than the corresponding character in `b`. For example, `\"abcc \"` is lexicographically smaller than `\"abcd \"` because the first position they differ is at the fourth character, and `'c'` is smaller than `'d'`.",
        "thought_answer": "\n    ```python\ndef breakPalindrome(palindrome: str) -> str:\n    length = len(palindrome)\n    if length == 1:\n        return \"\"\n    \n    chars = list(palindrome)\n    for i in range(length // 2):\n        if chars[i] != 'a':\n            chars[i] = 'a'\n            return \"\".join(chars)\n    \n    chars[length - 1] = 'b'\n    return \"\".join(chars)\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ",
        "tag": [
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "thought_question": "There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.",
        "thought_answer": "\n    ```python\ndef findTheCity(n, edges, distanceThreshold):\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res\n```\n\n    \n    The problem can be solved using Floyd-Warshall algorithm for finding shortest paths between all pairs of cities. First, we initialize an `n x n` distance matrix with a value larger than the maximum distance, and set the distance of each edge given in the input. The initial distance from each city to themselves is set to 0.\n\nThen we iteratively update the distance matrix using the Floyd-Warshall algorithm. To do this, we iterate over all pairs of cities (i, j), and for each pair, check if the distance through an additional city k is shorter than the current distance between i and j. If yes, we update the distance matrix entry to the shorter distance.\n\nAfter the algorithm is done, we iterate through each city and count the number of cities that are reachable within the distance threshold. If the number of reachable cities is smaller than or equal to the current smallest count, we update the smallest count and set the resulting city index to the current city index.\n\nFinally, we return the result city index.\n    ",
        "tag": [
            "Dynamic Programming",
            "Graph",
            "Shortest Path"
        ]
    },
    {
        "thought_name": "Minimum Number of Steps to Make Two Strings Anagram",
        "thought_question": "You are given two strings of the same length `s` and `t`. In one step you can choose **any character** of `t` and replace it with **another character**.\n\nReturn _the minimum number of steps_ to make `t` an anagram of `s`.\n\nAn **Anagram** of a string is a string that contains the same characters with a different (or the same) ordering.",
        "thought_answer": "\n    ```python\ndef minSteps(s, t):\n    s_Count = [0] * 26\n    t_Count = [0] * 26\n    for c in s: s_Count[ord(c) - ord('a')] += 1\n    for c in t: t_Count[ord(c) - ord('a')] += 1\n    res = 0\n    for i in range(26):\n        res += abs(s_Count[i] - t_Count[i])\n    return res // 2\n```\n    \n    1. Initialize two arrays, `s_Count` and `t_Count`, of length 26, both filled with zeros. These arrays will represent the character counts in strings `s` and `t`. The index represents the respective character number and the value at that index represents the count of the character.\n2. Iterate through both strings `s` and `t` and increase the count of characters in their respective count arrays.\n3. Initialize a counter `res` to zero.\n4. Iterate through the arrays `s_Count` and `t_Count` and calculate the absolute difference between the counts for each character. Add the difference to the counter variable `res`.\n5. Return half of the `res` variable (since we counted the difference two times, i.e., in both `s` and `t`).\n\nThis algorithm has a time complexity of O(n) since we iterate through both strings once and the count arrays once.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ]
    },
    {
        "thought_name": "Time Needed to Inform All Employees",
        "thought_question": "A company has `n` employees with a unique ID for each employee from `0` to `n - 1`. The head of the company is the one with `headID`.\n\nEach employee has one direct manager given in the `manager` array where `manager[i]` is the direct manager of the `i-th` employee, `manager[headID] = -1`. Also, it is guaranteed that the subordination relationships have a tree structure.\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\nThe `i-th` employee needs `informTime[i]` minutes to inform all of his direct subordinates (i.e., After informTime\\[i\\] minutes, all his direct subordinates can start spreading the news).\n\nReturn _the number of minutes_ needed to inform all the employees about the urgent news.",
        "thought_answer": "\n    ```python\ndef numOfMinutes(n, headID, manager, informTime):\n    subordinates = [[] for _ in range(n)]\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n    return dfs(headID, subordinates, informTime)\n\ndef dfs(employee, subordinates, informTime):\n    if informTime[employee] == 0:\n        return 0\n    max_time = 0\n    for i in subordinates[employee]:\n        max_time = max(max_time, dfs(i, subordinates, informTime))\n    return max_time + informTime[employee]\n```\n\n    \n    The algorithm first builds a data structure (adjacency list) to represent the tree of subordinates, and then performs a depth-first search from the headID to find the maximum time taken to inform all employees. In each step of the DFS, it iterates through the direct subordinates of the current employee and calculates the time required for that employee to inform everyone. The maximum time from all possible subordinates is added to the current employee's informTime and returned. This continues recursively until the entire organization is processed.\n    ",
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search"
        ]
    },
    {
        "thought_name": "Four Divisors",
        "thought_question": "Given an integer array `nums`, return _the sum of divisors of the integers in that array that have exactly four divisors_. If there is no such integer in the array, return `0`.",
        "thought_answer": "\n    ```python\ndef sum_of_four_divisors(nums):\n    total_sum = 0\n    for num in nums:\n        count = 0\n        div_sum = 0\n        i = 1\n        while i * i <= num:\n            if num % i == 0:\n                count += 1 if i * i == num else 2\n                div_sum += i + (num // i)\n                if count > 4:\n                    break\n            i += 1\n        if count == 4:\n            total_sum += div_sum\n    return total_sum\n```\n    \n    The algorithm iterates through each number in the `nums` array. For each number, it calculates the number of divisors and their sum. If a number has a square root, the count of divisors is incremented once, instead of twice, and the divisor sum is incremented by that number and its corresponding divisor, except when the loop finds a square root divisor. When the count of divisors exceeds 4, the loop breaks. If a number has exactly 4 divisors, the sum of its divisors is added to the final answer. The result is returned after processing all the numbers in the input array.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Count Submatrices With All Ones",
        "thought_question": "Given an `m x n` binary matrix `mat`, _return the number of **submatrices** that have all ones_.",
        "thought_answer": "\n    ```python\ndef numSubmat(mat: List[List[int]]) -> int:\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    ans = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if mat[i][j]:\n                dp[i][j] = 1 if j == 0 else dp[i][j-1] + 1\n                width = dp[i][j]\n                for k in range(i, -1, -1):\n                    width = min(width, dp[k][j])\n                    ans += width\n    \n    return ans\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We first create a 2D array `dp` of the same size as `mat`. Then, we iterate through each element `mat[i][j]`. If `mat[i][j]` is 1, we calculate the value of `dp[i][j]`. The value `dp[i][j]` represents the number of continuous 1s in the row from the current position to the left. Thus, `dp[i][j] = 1` if `j == 0` (i.e., this is the first element in the row), otherwise `dp[i][j] = dp[i][j-1] + 1`.\n\nThen, we iterate from the current row `i` to the first row (0) and calculate the minimum width of the continuous 1s in the columns at position `j` for each row. The sum of these minimum widths gives the total number of submatrices containing all 1s.\n\nFinally, the function returns the sum of all submatrices.\n\nTime complexity: O(m * n * m) since we have to iterate through all the elements in the matrix and then again for each row from the current row to the first.\nSpace complexity: O(m * n) for the `dp` array.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Stack",
            "Matrix",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Minimum Difference Between Largest and Smallest Value in Three Moves",
        "thought_question": "You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.",
        "thought_answer": "\n    ```python\ndef minDifference(nums):\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "thought_question": "Given an array `nums` and an integer `target`, return _the maximum number of **non-empty** **non-overlapping** subarrays such that the sum of values in each subarray is equal to_ `target`.",
        "thought_answer": "\n    ```python\ndef maxNonOverlapping(nums, target):\n    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n    return count\n```\n    \n    We use the prefix sum to cumulatively store the sum of the array until the current position. On each iteration, we calculate the sum of elements and then check if the (current sum - target) exists in the prefix sum hashmap. If it exists, it means we have a subarray that sums to the target, so we update our count. We also make sure to only consider non-overlapping subarrays by storing the current max count in the hashmap.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Greedy",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Minimum Operations to Make Array Equal",
        "thought_question": "You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e., `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e., perform `arr[x] -=1` and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array, return _the minimum number of operations_ needed to make all the elements of arr equal.",
        "thought_answer": "\n    ```python\ndef min_operations(n):\n    return n * n // 4\n```\n    \n    This problem can be solved mathematically without iterating through the array. Since the given array is of length `n` and always has the pattern `arr[i] = (2 * i) + 1`, the average value will always be the middle value when `n` is odd, and the average of two middle values when `n` is even.\n\nIn both cases, you can calculate the number of operations needed to make all elements equal by using the following formula: `n * n / 4`. The integer division (`//` in Python) and `Math.floor()` in JavaScript are used to get the integer result of the division.\n\nFor example, for `n = 3`, the array will be `[1, 3, 5]`. The average value is `3`, and you need 2 operations to turn `1` and `5` into `3`. The formula `n * n / 4` yields `3 * 3 / 4` = `2`. Similarly, for `n = 6`, the array will be `[1, 3, 5, 7, 9, 11]`, and you need 9 operations to make all elements equal. The formula gives `6 * 6 / 4` = `9`.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Shortest Subarray to be Removed to Make Array Sorted",
        "thought_question": "Given an integer array `arr`, remove a subarray (can be empty) from `arr` such that the remaining elements in `arr` are **non-decreasing**.\n\nReturn _the length of the shortest subarray to remove_.\n\nA **subarray** is a contiguous subsequence of the array.",
        "thought_answer": "\n    ```python\ndef findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    left, right = 0, n - 1\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n    if left == n - 1:\n        return 0\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n    result = min(n - left - 1, right)\n    i, j = 0, right\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n    return result\n```\n    \n    The algorithm starts by finding the longest non-decreasing subarray from both ends (left and right) of the array. If the left index reaches the end of the array, it means the array is already non-decreasing and we can return 0.\n\nThen, we initialize the result as the minimum of the remaining subarray lengths on the left side and the right side. We use two pointers i and j starting from the left index and the right index, respectively.\n\nWe iterate through the array and compare the values of arr[i] and arr[j]. If arr[i] <= arr[j], it means the subarray from i to j can be non-decreasing, so we update the result with the minimum length of this subarray. If arr[i] > arr[j], we increment j.\n\nWhen the loop finishes, the result is the length of the shortest subarray to remove to make the remaining elements non-decreasing.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Stack",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Minimum Time to Make Rope Colorful",
        "thought_question": "Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.\n\nAlice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.\n\nReturn _the **minimum time** Bob needs to make the rope **colorful**_.",
        "thought_answer": "\n    ```python\ndef minTime(colors: str, neededTime: List[int]) -> int:\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ",
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Maximum Sum Obtained of Any Permutation",
        "thought_question": "We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both `starti` and `endi` are _0-indexed_.\n\nReturn _the maximum total sum of all requests **among all permutations** of_ `nums`.\n\nSince the answer may be too large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef maxSumRangeQuery(nums, requests):\n    n = len(nums)\n    count = [0] * n\n    for request in requests:\n        count[request[0]] += 1\n        if request[1] + 1 < n:\n            count[request[1] + 1] -= 1\n    for i in range(1, n):\n        count[i] += count[i - 1]\n\n    nums.sort()\n    count.sort()\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + nums[i] * count[i]) % 1000000007\n    return ans\n```\n    \n    1. Create an empty frequency count array, `count`, of the same size as `nums`.\n2. Loop through the `requests` array to update our `count` array: increment the count value on the `start` index and decrement it on the `end + 1` index, if it is less than `n`.\n3. Starting from the second index of the `count` array, update each `count` element with the sum of the current element and the previous element, i.e., compute the prefix sum.\n4. Sort both the `nums` and `count` arrays in non-decreasing order.\n5. Calculate the summation of the product of pairwise elements of two sorted arrays, modulo 1e9+7, and store it in a variable called `ans`.\n6. Return the `ans` value.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Make Sum Divisible by P",
        "thought_question": "Given an array of positive integers `nums`, remove the **smallest** subarray (possibly **empty**) such that the **sum** of the remaining elements is divisible by `p`. It is **not** allowed to remove the whole array.\n\nReturn _the length of the smallest subarray that you need to remove, or_ `-1` _if it's impossible_.\n\nA **subarray** is defined as a contiguous block of elements in the array.",
        "thought_answer": "\n    ```python\ndef minSubarray(nums, p):\n    n, res, need, cur = len(nums), len(nums), 0, 0\n    for num in nums:\n        need = (need + num) % p\n    if need == 0:\n        return 0\n    last_seen = {0: -1}\n    for i, num in enumerate(nums):\n        cur = (cur + num) % p\n        last_seen[cur] = i\n        res = min(res, i - last_seen.get((cur - need + p) % p, -n))\n    return res if res < n else -1\n```\n    \n    1. First, find the remainder `need` when the sum of the array is divided by `p`.\n2. If `need` is 0, the sum is already divisible by `p`, so return 0.\n3. Otherwise, create a hashmap `last_seen` to store the last seen index of each remainder when the sum from the start of the array is divided by `p`. Initialize with 0 mapped to `-1`.\n4. Iterate through the array, updating the current remainder `cur`.\n5. For each remainder, update the last seen index in `last_seen` hashmap and calculate the minimum length subarray to remove by finding the difference between the current index and the last seen index of `cur-need+p` modulo `p`. Update the result if the calculated length is smaller.\n6. If the final result is smaller than the array length, return the result, otherwise, return -1.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Split a String Into the Max Number of Unique Substrings",
        "thought_question": "Given a string `s`, return _the maximum number of unique substrings that the given string can be split into_.\n\nYou can split string `s` into any list of **non-empty substrings**, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are **unique**.\n\nA **substring** is a contiguous sequence of characters within a string.",
        "thought_answer": "\n    ```python\ndef maxUniqueSplit(s, start=0, seen=None):\n    if seen is None:\n        seen = set()\n    if start == len(s):\n        return 0\n    maxUnique = -1\n    for i in range(start + 1, len(s) + 1):\n        sub = s[start:i]\n        if sub not in seen:\n            seen.add(sub)\n            unique = maxUniqueSplit(s, i, seen)\n            if unique != -1:\n                maxUnique = max(maxUnique, unique + 1)\n            seen.remove(sub)\n    return maxUnique\n```\n    \n    The algorithm is a recursive backtracking algorithm. We start at the beginning of the string and iteratively build substrings from the current starting position. If the substring is not already in the set of seen substrings, we add it to the set and continue the split process for the remaining part of the string. Then we remove the substring from the set of seen substrings and continue with the next possible substring. The base case is reached when we processed the entire string, in which case we return 0 as the initial value for the split count. The final result will be the maximum number of unique substrings found during the recursive process.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Maximum Profit of Operating a Centennial Wheel",
        "thought_question": "You are the operator of a Centennial Wheel that has **four gondolas**, and each gondola has room for **up** **to** **four people**. You have the ability to rotate the gondolas **counterclockwise**, which costs you `runningCost` dollars.\n\nYou are given an array `customers` of length `n` where `customers[i]` is the number of new customers arriving just before the `ith` rotation (0-indexed). This means you **must rotate the wheel** `i` **times before the** `customers[i]` **customers arrive**. **You cannot make customers wait if there is room in the gondola**. Each customer pays `boardingCost` dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\n\nYou can stop the wheel at any time, including **before** **serving** **all** **customers**. If you decide to stop serving customers, **all subsequent rotations are free** in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait **for the next rotation**.\n\nReturn _the minimum number of rotations you need to perform to maximize your profit._ If there is **no scenario** where the profit is positive, return `-1`.",
        "thought_answer": "\n    ```python\ndef minOperationsMaxProfit(customers, boardingCost, runningCost):\n    waiting = 0\n    profit = 0\n    max_profit = 0\n    rotations = 0\n    result = -1\n\n    for i in range(len(customers) + sum(customers)):\n        if i < len(customers):\n            waiting += customers[i]\n        boarding = min(waiting, 4)\n        waiting -= boarding\n        profit += boarding * boardingCost - runningCost\n\n        if profit > max_profit:\n            max_profit = profit\n            result = rotations + 1\n        rotations += 1\n    \n    return result\n```\n\n    \n    We will iterate through each rotation until there is no customer left in the customers array or no one waiting in line. In each iteration, we will first check if there are any customers arriving and update the waiting status accordingly. Then, decide how many customers to board and update the waiting status again. Afterward, we update the profit based on the number of customers boarded and runningCost. If the updated profit is greater than the current max_profit, we update the max_profit and result (number of rotations). Finally, we increment the rotation counter.\n    ",
        "tag": [
            "Array",
            "Simulation"
        ]
    },
    {
        "thought_name": "Count Sorted Vowel Strings",
        "thought_question": "Given an integer `n`, return _the number of strings of length_ `n` _that consist only of vowels (_`a`_,_ `e`_,_ `i`_,_ `o`_,_ `u`_) and are **lexicographically sorted**._\n\nA string `s` is **lexicographically sorted** if for all valid `i`, `s[i]` is the same as or comes before `s[i+1]` in the alphabet.",
        "thought_answer": "\n    ```python\ndef countVowelStrings(n: int) -> int:\n    dp = [1, 1, 1, 1, 1]\n    for i in range(2, n + 1):\n        for j in range(3, -1, -1):\n            dp[j] = dp[j] + dp[j + 1]\n    return sum(dp)\n```\n    \n    We use dynamic programming to solve this problem. Initialize an array dp of size 5 with all elements set to 1. Then, for each i in the range [2, n], iterate through the dp array starting from index 3 (denoting vowel 'o'), moving backwards. Update each dp[j] by adding dp[j + 1] (i.e., count of the next vowel) to its current value. Finally, sum up the values in the dp array and return the result as the number of lexicographically sorted strings with n characters.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ]
    },
    {
        "thought_name": "Ways to Make a Fair Array",
        "thought_question": "You are given an integer array `nums`. You can choose **exactly one** index (**0-indexed**) and remove the element. Notice that the index of the elements may change after the removal.\n\nFor example, if `nums = [6,1,7,4,1]`:\n\n*   Choosing to remove index `1` results in `nums = [6,7,4,1]`.\n*   Choosing to remove index `2` results in `nums = [6,1,4,1]`.\n*   Choosing to remove index `4` results in `nums = [6,1,7,4]`.\n\nAn array is **fair** if the sum of the odd-indexed values equals the sum of the even-indexed values.\n\nReturn the _**number** of indices that you could choose such that after the removal,_ `nums` _is **fair**._",
        "thought_answer": "\n    ```python\ndef numberOfFairs(nums):\n    even_sum = sum(nums[0::2])\n    odd_sum = sum(nums[1::2])\n    l_even = l_odd = count = 0\n    for i, num in enumerate(nums):\n        if i % 2 == 0:\n            even_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_even += num\n        else:\n            odd_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_odd += num\n    return count\n```\n    \n    1. First, find the sum of values at even indices and odd indices and store them in `even_sum` and `odd_sum` respectively.\n2. Iterate through the array with index `i`:\n   - If `i` is even, subtract the value at `i` from `even_sum`, check if `l_even` (sum of even values to the left of `i`) plus `odd_sum` equals `l_odd` (sum of odd values to the left of `i`) plus `even_sum`, and if yes, increment `count`. Then add the value at `i` to `l_even`.\n   - If `i` is odd, subtract the value at `i` from `odd_sum`, check if `l_even` plus `odd_sum` equals `l_odd` plus `even_sum`, and if yes, increment `count`. Then add the value at `i` to `l_odd`.\n3. Return `count` as the number of indices you could choose such that after the removal, nums is fair.\n    ",
        "tag": [
            "Array",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Stone Game VI",
        "thought_question": "Alice and Bob take turns playing a game, with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**.\n\nYou are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game, and:\n\n*   If Alice wins, return `1`.\n*   If Bob wins, return `-1`.\n*   If the game results in a draw, return `0`.",
        "thought_answer": "\n    ```python\ndef stoneGameVI(aliceValues, bobValues):\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)\n```\n\n    \n    Instead of looking at the stones' values separately, we can look at them by their total value (`total = aliceValue + bobValue`). We sort the stones in decreasing order of their total value. Essentially, we want both Alice and Bob to take higher value stones.\n\nThen, we iterate over the sorted stones, giving each stone i to the current player (Alice gets the stones from even indices, Bob gets the stones from odd indices). After that, we compare the sum of values obtained by both players, and return the appropriate result value (win, lose, or draw) as per the problem statement.\n    ",
        "tag": [
            "Array",
            "Math",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Game Theory"
        ]
    },
    {
        "thought_name": "Decode XORed Permutation",
        "thought_question": "There is an integer array `perm` that is a permutation of the first `n` positive integers, where `n` is always **odd**.\n\nIt was encoded into another integer array `encoded` of length `n - 1`, such that `encoded[i] = perm[i] XOR perm[i + 1]`. For example, if `perm = [1,3,2]`, then `encoded = [2,1]`.\n\nGiven the `encoded` array, return _the original array_ `perm`. It is guaranteed that the answer exists and is unique.",
        "thought_answer": "\n    ```python\ndef decode(encoded):\n    n = len(encoded) + 1\n    total_xor = 0\n    \n    for i in range(1, n + 1):\n        total_xor ^= i\n\n    non_first_xor = 0\n    for i in range(1, n - 1, 2):\n        non_first_xor ^= encoded[i]\n\n    perm = [total_xor ^ non_first_xor]\n    for i in range(1, n):\n        perm.append(perm[-1] ^ encoded[i - 1])\n    \n    return perm\n```\n\n    \n    1. Calculate the XOR of all numbers from 1 to n, which is called `totalXor`.\n2. Calculate the XOR of all even indices of `encoded` array, which is called `nonFirstXor`.\n3. The first number in `perm` can be calculated as `totalXor ^ nonFirstXor`.\n4. Iterate through the array from 1 to n-1 to fill in the rest of the `perm` array. The value of `perm[i]` is calculated as `perm[i - 1] ^ encoded[i - 1]`.\n5. Return the `perm` array.\n    ",
        "tag": [
            "Array",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Maximum Absolute Sum of Any Subarray",
        "thought_question": "You are given an integer array `nums`. The **absolute sum** of a subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is `abs(numsl + numsl+1 + ... + numsr-1 + numsr)`.\n\nReturn _the **maximum** absolute sum of any **(possibly empty)** subarray of_ `nums`.\n\nNote that `abs(x)` is defined as follows:\n\n*   If `x` is a negative integer, then `abs(x) = -x`.\n*   If `x` is a non-negative integer, then `abs(x) = x`.",
        "thought_answer": "\n    ```python\ndef maxAbsoluteSum(nums):\n    max_sum = max_end = min_sum = min_end = 0\n    for num in nums:\n        max_end = max(max_end + num, num)\n        min_end = min(min_end + num, num)\n        max_sum = max(max_sum, max_end)\n        min_sum = min(min_sum, min_end)\n    return max(max_sum, -min_sum)\n```\n    \n    We use the Kadane's algorithm to maintain both the maximum sum subarray (max_end) and the minimum sum subarray (min_end) ending at the current position.\n\n1. Iterate through the given array nums\n2. For each number in nums:\n   1. Update max_end to be the maximum of max_end + num and num\n   2. Update min_end to be the minimum of min_end + num and num\n   3. Update max_sum to be the maximum of max_sum and max_end\n   4. Update min_sum to be the minimum of min_sum and min_end\n3. Return the maximum of max_sum and -min_sum.\n\nKeep in mind that empty subarray is allowed, but in practice we won't need any additional code to handle empty subarray since the minimum absolute sum is always 0 (which can be the result of an empty subarray).\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Minimum Length of String After Deleting Similar Ends",
        "thought_question": "Given a string `s` consisting only of characters `'a'`, `'b'`, and `'c'`. You are asked to apply the following algorithm on the string any number of times:\n\n1.  Pick a **non-empty** prefix from the string `s` where all the characters in the prefix are equal.\n2.  Pick a **non-empty** suffix from the string `s` where all the characters in this suffix are equal.\n3.  The prefix and the suffix should not intersect at any index.\n4.  The characters from the prefix and suffix must be the same.\n5.  Delete both the prefix and the suffix.\n\nReturn _the **minimum length** of_ `s` _after performing the above operation any number of times (possibly zero times)_.",
        "thought_answer": "\n    ```python\ndef minimumLength(s: str) -> int:\n    if not s: return 0\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]: break\n        remove_char = s[i]\n        while i < len(s) and s[i] == remove_char: i += 1\n        while j >= 0 and s[j] == remove_char: j -= 1\n    return max(0, j - i + 1)\n```\n    \n    The algorithm involves the use of two pointers, one at the beginning and the other at the end of the string. While the characters at the positions of both pointers are the same, we increment the first pointer (i) until a different character is found in the string, and decrement the second pointer (j) until a different character is found. We then return the difference between j and i plus 1, or 0 if the result is negative, as the minimum length after performing the operations.\n    ",
        "tag": [
            "Two Pointers",
            "String"
        ]
    },
    {
        "thought_name": "Largest Merge Of Two Strings",
        "thought_question": "You are given two strings `word1` and `word2`. You want to construct a string `merge` in the following way: while either `word1` or `word2` are non-empty, choose **one** of the following options:\n\n*   If `word1` is non-empty, append the **first** character in `word1` to `merge` and delete it from `word1`.\n    *   For example, if `word1 = \"abc \"` and `merge = \"dv \"`, then after choosing this operation, `word1 = \"bc \"` and `merge = \"dva \"`.\n*   If `word2` is non-empty, append the **first** character in `word2` to `merge` and delete it from `word2`.\n    *   For example, if `word2 = \"abc \"` and `merge = \" \"`, then after choosing this operation, `word2 = \"bc \"` and `merge = \"a \"`.\n\nReturn _the lexicographically **largest**_ `merge` _you can construct_.\n\nA string `a` is lexicographically larger than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly larger than the corresponding character in `b`. For example, `\"abcd \"` is lexicographically larger than `\"abcc \"` because the first position they differ is at the fourth character, and `d` is greater than `c`.",
        "thought_answer": "\n    ```python\ndef largest_merge(word1: str, word2: str) -> str:\n    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Minimum Elements to Add to Form a Given Sum",
        "thought_question": "You are given an integer array `nums` and two integers `limit` and `goal`. The array `nums` has an interesting property that `abs(nums[i]) <= limit`.\n\nReturn _the minimum number of elements you need to add to make the sum of the array equal to_ `goal`. The array must maintain its property that `abs(nums[i]) <= limit`.\n\nNote that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise.",
        "thought_answer": "\n    ```python\ndef minElements(nums, limit, goal):\n    sum_nums = sum(nums)\n    diff = abs(goal - sum_nums)\n    \n    return (diff + limit - 1) // limit\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Queries on Number of Points Inside a Circle",
        "thought_question": "You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the `ith` point on a 2D plane. Multiple points can have the **same** coordinates.\n\nYou are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle centered at `(xj, yj)` with a radius of `rj`.\n\nFor each query `queries[j]`, compute the number of points **inside** the `jth` circle. Points **on the border** of the circle are considered **inside**.\n\nReturn _an array_ `answer`_, where_ `answer[j]` _is the answer to the_ `jth` _query_.",
        "thought_answer": "\n    ```python\ndef countPoints(points, queries):\n    answer = []\n    for query in queries:\n        inside = 0\n        for point in points:\n            dx = point[0] - query[0]\n            dy = point[1] - query[1]\n            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1\n        answer.append(inside)\n    return answer\n```\n\n    \n    For each query circle, we iterate over each point to check if it lies inside the circle. To check if a point is inside the circle, we calculate the squared distance (dx * dx + dy * dy) between the point and the center of the circle. If the squared distance is less than or equal to the squared radius of the circle, that means the point is inside the circle or on its border. We increment an `inside` counter for each point that satisfies this condition. The counter gets added to the `answer` array after iterating over all the points for the current circle. We repeat this process for all query circles and return the array of `inside` counts.\n    ",
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ]
    },
    {
        "thought_name": "Frequency of the Most Frequent Element",
        "thought_question": "The **frequency** of an element is the number of times it occurs in an array.\n\nYou are given an integer array `nums` and an integer `k`. In one operation, you can choose an index of `nums` and increment the element at that index by `1`.\n\nReturn _the **maximum possible frequency** of an element after performing **at most**_ `k` _operations_.",
        "thought_answer": "\n    ```python\ndef maxFrequency(nums: List[int], k: int) -> int:\n    nums.sort()\n    n, i, s, max_freq = len(nums), 0, 0, 0\n\n    for j in range(n):\n        s += nums[j]\n        while s + k < nums[j] * (j - i + 1):\n            s -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n\n    return max_freq\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize variables `n` as the length of `nums`, `i` as 0, `sum` as 0, and `max_freq` as 0.\n3. Iterate through the sorted array with index `j`.\n   a. Add each element to the `sum`.\n   b. In a while loop, if `sum + k` is less than `nums[j] * (j - i + 1)`, subtract `nums[i]` from `sum`, and increment `i`.\n   c. Update the `max_freq` by taking the maximum of the current `max_freq` and `j - i + 1`.\n4. Return the final `max_freq` as the answer.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sliding Window",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Maximum Element After Decreasing and Rearranging",
        "thought_question": "You are given an array of positive integers `arr`. Perform some operations (possibly none) on `arr` so that it satisfies these conditions:\n\n*   The value of the **first** element in `arr` must be `1`.\n*   The absolute difference between any 2 adjacent elements must be **less than or equal to** `1`. In other words, `abs(arr[i] - arr[i - 1]) <= 1` for each `i` where `1 <= i < arr.length` (**0-indexed**). `abs(x)` is the absolute value of `x`.\n\nThere are 2 types of operations that you can perform any number of times:\n\n*   **Decrease** the value of any element of `arr` to a **smaller positive integer**.\n*   **Rearrange** the elements of `arr` to be in any order.\n\nReturn _the **maximum** possible value of an element in_ `arr` _after performing the operations to satisfy the conditions_.",
        "thought_answer": "\n    ```python\ndef maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:\n    arr.sort()\n    arr[0] = 1\n    for i in range(1, len(arr)):\n        arr[i] = min(arr[i], arr[i - 1] + 1)\n    return arr[-1]\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Distinct Numbers in Each Subarray",
        "thought_question": "Given an integer array `nums` and an integer `k`, you are asked to construct the array `ans` of size `n-k+1` where `ans[i]` is the number of **distinct** numbers in the subarray `nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]]`.\n\nReturn _the array_ `ans`.",
        "thought_answer": "\n    ```python\ndef distinct_numbers_in_subarrays(nums, k):\n    counts = {}\n    ans = []\n    for i, num in enumerate(nums):\n        counts[num] = counts.get(num, 0) + 1\n        if i >= k:\n            counts[nums[i - k]] -= 1\n            if counts[nums[i - k]] == 0:\n                del counts[nums[i - k]]\n        if i >= k - 1:\n            ans.append(len(counts))\n    return ans\n```\n    \n    We use a sliding window approach to keep track of a subarray of the size k in the given array. To find the distinct elements in the subarray, we maintain a hash map named `counts` to store the frequency of each element in the subarray. We iterate through the given array and perform the following steps for each element:\n\n1. Increment the frequency count of the element in the `counts` hash map.\n2. If the index `i` is larger or equal to `k`, we know the subarray of size k has moved to the next index. We decrement the frequency count of the element at `nums[i - k]`. If the frequency count becomes zero, we remove this element from the hash map.\n3. If the index `i` is larger or equal to `k - 1`, we have a valid subarray of size k. In this case, we append the length of the hash map (which represents the number of distinct elements) to the `ans` array.\n\nAt the end, we return the `ans` array.\n    ",
        "tag": []
    },
    {
        "thought_name": "Maximum Distance Between a Pair of Values",
        "thought_question": "You are given two **non-increasing 0-indexed** integer arrays `nums1`​​​​​​ and `nums2`​​​​​​.\n\nA pair of indices `(i, j)`, where `0 <= i < nums1.length` and `0 <= j < nums2.length`, is **valid** if both `i <= j` and `nums1[i] <= nums2[j]`. The **distance** of the pair is `j - i`​​​​.\n\nReturn _the **maximum distance** of any **valid** pair_ `(i, j)`_. If there are no valid pairs, return_ `0`.\n\nAn array `arr` is **non-increasing** if `arr[i-1] >= arr[i]` for every `1 <= i < arr.length`.",
        "thought_answer": "\n    ```python\ndef maxDistance(nums1, nums2):\n    i, j, maxDist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] > nums2[j]:\n            i += 1\n        else:\n            maxDist = max(maxDist, j - i)\n            j += 1\n    return maxDist\n```\n    \n    The algorithm starts with setting both indices `i` and `j` to zero. A `maxDist` variable is initialized as zero as well. It uses a while loop to navigate through both arrays (nums1 and nums2) as long as the indices are within their respective array boundaries. It then checks whether the element at `nums1[i]` is greater than the element at `nums2[j]`, if true, it increments the index `i`. Otherwise, it updates the `maxDist` variable as the maximum between the existing maximum distance and the new distance (`j - i`), and increments the index `j`.\n\nThis algorithm works because it takes advantage of the non-increasing property of both arrays. It moves through the arrays checking each possible valid pair `(i, j)`. It moves index `i` right when the current pair is invalid and moves `j` right when a valid pair is found, updating the maximum distance when necessary.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Maximum Subarray Min-Product",
        "thought_question": "The **min-product** of an array is equal to the **minimum value** in the array **multiplied by** the array's **sum**.\n\n*   For example, the array `[3,2,5]` (minimum value is `2`) has a min-product of `2 * (3+2+5) = 2 * 10 = 20`.\n\nGiven an array of integers `nums`, return _the **maximum min-product** of any **non-empty subarray** of_ `nums`. Since the answer may be large, return it **modulo** `109 + 7`.\n\nNote that the min-product should be maximized **before** performing the modulo operation. Testcases are generated such that the maximum min-product **without** modulo will fit in a **64-bit signed integer**.\n\nA **subarray** is a **contiguous** part of an array.",
        "thought_answer": "\n    ```python\ndef maxSumMinProduct(nums: list[int]) -> int:\n    MOD = int(1e9 + 7)\n    max_product = 0\n    stk = []\n    prefix_sum = [0] * (len(nums) + 1)\n\n    for i in range(len(nums)):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    for i in range(len(nums)):\n        while stk and nums[stk[-1]] > nums[i]:\n            min_val = nums[stk.pop()]\n            max_product = max(max_product, min_val * (prefix_sum[i] - prefix_sum[stk[-1] + 1 if stk else 0]))\n        stk.append(i)\n       \n    while stk:\n        min_val = nums[stk.pop()]\n        max_product = max(max_product, min_val * (prefix_sum[len(nums)] - prefix_sum[stk[-1] + 1 if stk else 0]))\n\n    return max_product % MOD\n```\n\n    \n    1. Calculate the prefix sums for every element in the input array.\n2. Then, we iterate through the input array and maintain a decreasing monotonic stack.\n3. If the current element is lower than the top element of the stack, we calculate the maximum min-product for the top element by popping it from the stack.\n4. After processing all elements, we calculate the maximum min-product for the remaining elements in the stack.\n5. The time complexity is O(n) as we push and pop each element exactly once.\n    ",
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Product of Two Run-Length Encoded Arrays",
        "thought_question": "**Run-length encoding** is a compression algorithm that allows for an integer array `nums` with many segments of **consecutive repeated** numbers to be represented by a (generally smaller) 2D array `encoded`. Each `encoded[i] = [vali, freqi]` describes the `ith` segment of repeated numbers in `nums` where `vali` is the value that is repeated `freqi` times.\n\n*   For example, `nums = [1,1,1,2,2,2,2,2]` is represented by the **run-length encoded** array `encoded = [[1,3],[2,5]]`. Another way to read this is \"three `1`'s followed by five `2`'s \".\n\nThe **product** of two run-length encoded arrays `encoded1` and `encoded2` can be calculated using the following steps:\n\n1.  **Expand** both `encoded1` and `encoded2` into the full arrays `nums1` and `nums2` respectively.\n2.  Create a new array `prodNums` of length `nums1.length` and set `prodNums[i] = nums1[i] * nums2[i]`.\n3.  **Compress** `prodNums` into a run-length encoded array and return it.\n\nYou are given two **run-length encoded** arrays `encoded1` and `encoded2` representing full arrays `nums1` and `nums2` respectively. Both `nums1` and `nums2` have the **same length**. Each `encoded1[i] = [vali, freqi]` describes the `ith` segment of `nums1`, and each `encoded2[j] = [valj, freqj]` describes the `jth` segment of `nums2`.\n\nReturn _the **product** of_ `encoded1` _and_ `encoded2`.\n\n**Note:** Compression should be done such that the run-length encoded array has the **minimum** possible length.",
        "thought_answer": "\n    ```python\ndef findRLEProduct(encoded1, encoded2):\n    result = []\n    i, j, count1, count2 = 0, 0, 0, 0\n\n    while i < len(encoded1) and j < len(encoded2):\n        product = encoded1[i][0] * encoded2[j][0]\n        count = min(encoded1[i][1] - count1, encoded2[j][1] - count2)\n        count1 += count\n        count2 += count\n\n        if result and result[-1][0] == product:\n            result[-1][1] += count\n        else:\n            result.append([product, count])\n\n        if count1 == encoded1[i][1]:\n            i += 1\n            count1 = 0\n\n        if count2 == encoded2[j][1]:\n            j += 1\n            count2 = 0\n\n    return result\n```\n    \n    The algorithm simply iterate through both `encoded1` and `encoded2` arrays, calculating the products at every segment, compressing it into a formatted run-length encoded array in the form of [val, freq], and appending the compressed parts to the `result` list. I utilize two pointers `i` and `j` to iterate through `encoded1` and `encoded2` respectively, and two additional counters `count1` and `count2` to keep track of the elements consumed in the respective arrays. At every iteration, I calculate the minimum count of consecutive elements to consume and update the result.\n\nThis way, the algorithm does not need to expand the entire `encoded1` and `encoded2` arrays, thus improving the time complexity from O(n) to O(len(encoded1) + len(encoded2)). Each segment is calculated and compressed on-the-fly, and stored in `result`. Finally, after both arrays are consumed, just return the `result`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Minimize Maximum Pair Sum in Array",
        "thought_question": "The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs.\n\n*   For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.\n\nGiven an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:\n\n*   Each element of `nums` is in **exactly one** pair, and\n*   The **maximum pair sum** is **minimized**.\n\nReturn _the minimized **maximum pair sum** after optimally pairing up the elements_.",
        "thought_answer": "\n    ```python\ndef minPairSum(nums):\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximum Number of Removable Characters",
        "thought_question": "You are given two strings `s` and `p` where `p` is a **subsequence** of `s`. You are also given a **distinct 0-indexed** integer array `removable` containing a subset of indices of `s` (`s` is also **0-indexed**).\n\nYou want to choose an integer `k` (`0 <= k <= removable.length`) such that, after removing `k` characters from `s` using the **first** `k` indices in `removable`, `p` is still a **subsequence** of `s`. More formally, you will mark the character at `s[removable[i]]` for each `0 <= i < k`, then remove all marked characters and check if `p` is still a subsequence.\n\nReturn _the **maximum**_ `k` _you can choose such that_ `p` _is still a **subsequence** of_ `s` _after the removals_.\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
        "thought_answer": "\n    ```python\ndef maximumRemovals(s: str, p: str, removable: List[int]) -> int:\n    low, high = 0, len(removable)\n    while low < high:\n        mid = (low + high + 1) // 2\n        temp_s = list(s)\n        for i in range(mid):\n            temp_s[removable[i]] = '-'\n        i, j = 0, 0\n        while i < len(temp_s) and j < len(p):\n            if temp_s[i] == p[j]:\n                j += 1\n            i += 1\n        if j == len(p):\n            low = mid\n        else:\n            high = mid - 1\n    return low\n```\n\n    \n    We first initialize two variables low and high with values 0 and the length of the removable array.\n\nWe then enter a while loop. In that loop:\n1. Calculate the mid using low and high.\n2. Create a temporary string \"temp_s\" based on \"s\" for testing purposes.\n3. Mark the character at the index in \"temp_s\" that's stored in the removable array for the first k indices.\n4. Initialize two variables i and j with value 0.\n5. Enter a while loop:\n   a. Check if the character at index i in \"temp_s\" is equal to the character at index j in \"p\".\n   b. If they are equal, increment the variable j.\n   c. Increment the variable i.\n6. Check if j is equal to the length of \"p\".\n   a. If true, we set low = mid.\n   b. If false, we set high = mid - 1.\n\nAfter the loop, return the value of low which will be the maximum k such that p is still a subsequence of s after the removals.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "String",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Eliminate Maximum Number of Monsters",
        "thought_question": "You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._",
        "thought_answer": "\n    ```python\ndef eliminate_maximum(dist, speed):\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated\n```\n    \n    1. Calculate the time it takes for each monster to reach the city, and store these times in an array `time_to_reach_city`.\n2. Sort the `time_to_reach_city` array in ascending order.\n3. Iterate through the array and check if the time it takes for the monster to reach the city is greater than the current time (index `i`). If it is, eliminate the monster and increment the `eliminated` counter.\n4. If the time it takes for any remaining monster to reach the city is less than or equal to the current time, break out of the loop.\n5. Return the number of eliminated monsters.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Count Good Numbers",
        "thought_question": "A digit string is **good** if the digits **(0-indexed)** at **even** indices are **even** and the digits at **odd** indices are **prime** (`2`, `3`, `5`, or `7`).\n\n*   For example, `\"2582 \"` is good because the digits (`2` and `8`) at even positions are even and the digits (`5` and `2`) at odd positions are prime. However, `\"3245 \"` is **not** good because `3` is at an even index but is not even.\n\nGiven an integer `n`, return _the **total** number of good digit strings of length_ `n`. Since the answer may be large, **return it modulo** `109 + 7`.\n\nA **digit string** is a string consisting of digits `0` through `9` that may contain leading zeros.",
        "thought_answer": "\n    ```python\ndef goodDigitStrings(n: int) -> int:\n    MOD = 1000000007\n    even_count, prime_count = 1, 1\n    for i in range(n):\n        if i % 2 == 0:\n            even_count = (even_count * 5) % MOD\n        else:\n            prime_count = (prime_count * 4) % MOD\n    return (even_count * prime_count) % MOD\n```\n    \n    The provided algorithm works by noticing that in a good digit string, the even indices need to have the values {0, 2, 4, 6, 8} (5 elements), and odd indices must have {2, 3, 5, 7} (4 elements). For each pair of adjacent indices (i.e., an even index i and an odd index i+1), there are 5 * 4 = 20 combinations, so the result can be calculated as the product of the number of even indices and the number of odd indices modulo the given value (10^9 + 7).\n    ",
        "tag": [
            "Math",
            "Recursion"
        ]
    },
    {
        "thought_name": "Describe the Painting",
        "thought_question": "There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **half-closed segment** `[starti, endi)` with `colori` as the color.\n\nThe colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors.\n\n*   For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`.\n\nFor the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set.\n\nYou want to **describe** the painting with the **minimum** number of non-overlapping **half-closed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **half-closed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`.\n\n*   For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because:\n    *   `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments.\n    *   `[4,7)` is colored `{7}` from only the second segment.\n\nReturn _the 2D array_ `painting` _describing the finished painting (excluding any parts that are **not** painted). You may return the segments in **any order**_.\n\nA **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`.",
        "thought_answer": "\n    ```python\ndef splitPainting(segments):\n    line = {}\n    for s in segments:\n        start, end, color = s\n        if start not in line:\n            line[start] = 0\n        if end not in line:\n            line[end] = 0\n        line[start] += color\n        line[end] -= color\n    res = []\n    pre = 0\n    sum = 0\n    for key in sorted(line.keys()):\n        if pre > 0:\n            if sum > 0:\n                res.append([pre, key, sum])\n        pre = key\n        sum += line[key]\n    return res\n```\n    \n    The algorithm uses a sweep line approach to solve the problem. First, we traverse through the input segments, and maintain a map `line` that stores the sum of the colors at each starting and ending point of the segments. The starting points will have positive values, and the ending points will have negative values.\n\nNext, we iterate through the sorted keys (i.e., the points) of the map, and for each key, we update the sum of colors until we reach the next point. During this process, we construct the non-overlapping segments with their respective mixed color sums and add them to the result.\n\nFinally, we return the resulting 2D array containing the non-overlapping segments describing the painting. Note that the segments can be returned in any order since there is no specific requirement about the order in which they appear in the output.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Find All Groups of Farmland",
        "thought_question": "You are given a **0-indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland.\n\nTo keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** four-directionally adjacent to another farmland in a different group.\n\n`land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m-1, n-1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4-length array `[r1, c1, r2, c2].`\n\nReturn _a 2D array containing the 4-length arrays described above for each **group** of farmland in_ `land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_.",
        "thought_answer": "\n    ```python\ndef findFarmland(land):\n    m, n = len(land), len(land[0])\n    groups = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups\n```\n    \n    The algorithm iterates through each cell of the binary `land` matrix. When a farmland (value `1`) is found, it starts in the top-left corner of the potential group and expands to the right to find the bottom-right corner along the same row. Then, it expands downwards to find the true bottom-right corner of the group. Afterward, the group's farmland cells are converted to `0` to avoid counting the group again, and the coordinates of the top-left and bottom-right corners are added to the result list.\n\nThis algorithm is efficient because it exploits the rectangular shape and the adjacency constraints of farmland groups. By using a nested loop from the top-left cell, it avoids recalculating groups or considering partial groups. In addition, the loop iterations are limited by incrementing `j` when appropriate, reducing the number of iterations.\n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ]
    },
    {
        "thought_name": "First Day Where You Have Been in All the Rooms",
        "thought_question": "There are `n` rooms you need to visit, labeled from `0` to `n - 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day.\n\nInitially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0-indexed** array `nextVisit` of length `n`:\n\n*   Assuming that on a day, you visit room `i`,\n*   if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`;\n*   if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`.\n\nReturn _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef firstDayBeenInAllRooms(nextVisit):\n    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]\n```\n    \n    The algorithm can be solved using Dynamic Programming - specifically, by keeping track of the first day when the room `i` is visited in a `dp` array.\n\nWe can calculate the value of `dp[i]` based on `dp[i-1]` and `dp[nextVisit[i-1]]`._visit[i-1]]. RootStateRoomTime - startTime[nextVisit[i - 1]]+2[DP[i++]=dp[i-1]*2-DP[nextVisit[i-1]]+2%MOD.\n\nThe result will be the value in `dp` at index `n-1`\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Maximize the Confusion of an Exam",
        "thought_question": "A teacher is writing a test with `n` true/false questions, with `'T'` denoting true and `'F'` denoting false. He wants to confuse the students by **maximizing** the number of **consecutive** questions with the **same** answer (multiple trues or multiple falses in a row).\n\nYou are given a string `answerKey`, where `answerKey[i]` is the original answer to the `ith` question. In addition, you are given an integer `k`, the maximum number of times you may perform the following operation:\n\n*   Change the answer key for any question to `'T'` or `'F'` (i.e., set `answerKey[i]` to `'T'` or `'F'`).\n\nReturn _the **maximum** number of consecutive_ `'T'`s or `'F'`s _in the answer key after performing the operation at most_ `k` _times_.",
        "thought_answer": "\n    ```python\ndef max_consecutive_answers(answer_key: str, k: int) -> int:\n    max_len, left, T_cnt, F_cnt = 0, 0, 0, 0\n\n    for right, c in enumerate(answer_key):\n        if c == 'T':\n            T_cnt += 1\n        else:\n            F_cnt += 1\n\n        if min(T_cnt, F_cnt) > k:\n            if answer_key[left] == 'T':\n                T_cnt -= 1\n            else:\n                F_cnt -= 1\n            left += 1\n        else:\n            max_len = max(max_len, T_cnt + F_cnt)\n\n    return max_len\n```\n\n    \n    We can use a sliding window algorithm to find the maximum number of consecutive T's or F's. Initialize two counters: `T_cnt` and `F_cnt` to count the number of T's and F's in the current window. Initialize two pointers, `left` and `right`, to the beginning of the window. Iterate over `answerKey` with the `right` pointer, incrementing the appropriate counter for each character encountered.\n\nAfter incrementing a counter, check if the minimum of `T_cnt` and `F_cnt` is greater than k. If it is, we must shrink the window, so decrement the counter of the character at the `left` pointer and increment the `left` pointer. If the minimum is not greater than k, update `max_len` with the current length of the window (i.e., the sum of `T_cnt` and `F_cnt`).\n\nContinue iterating until the end of `answerKey` and return `max_len`.\n    ",
        "tag": [
            "String",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Minimized Maximum of Products Distributed to Any Store",
        "thought_question": "You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type.\n\nYou need to distribute **all products** to the retail stores following these rules:\n\n*   A store can only be given **at most one product type** but can be given **any** amount of it.\n*   After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store.\n\nReturn _the minimum possible_ `x`.",
        "thought_answer": "\n    ```python\ndef minimum_maximum(n, quantities):\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x\n```\n\n    \n    - Calculate the sum of all products to be distributed.\n- Calculate an initial estimate for x by dividing the total number of products by the number of stores.\n- Initialize a remaining_stores variable to store the stores that have not been assigned products yet.\n- Iterate through each product type:\n  - Decrease remaining_stores by the number of stores needed to distribute the current product type with the current value of x.\n  - If remaining_stores becomes negative, it means x is too small. Recalculate x using the current remaining_stores and start over with remaining_stores equal to the number of stores.\n- Return x when there's no need for further adjustment.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Greedy"
        ]
    },
    {
        "thought_name": "Number of Smooth Descent Periods of a Stock",
        "thought_question": "You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.\n\nA **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.\n\nReturn _the number of **smooth descent periods**_.",
        "thought_answer": "\n    ```python\ndef num_smooth_descent_periods(prices):\n    result = 0\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] == prices[i - 1] - 1:\n            count += 1\n        else:\n            count = 0\n        result += count + 1\n    return result + 1\n```\n    \n    This algorithm iterates through the `prices` array, starting at index 1. At each index `i`, it checks if the current price is equal to the previous price minus 1. If this condition is true, it means that the two prices form a smooth descent pair and `count` is incremented. If the condition is not met, it means that the path is broken, so `count` is reset to 0. The result is incremented by `count + 1` at each step, and finally incremented by 1 at the end to account for the first day in the period. The time complexity is O(n), where n is the length of the prices array.\n    ",
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Execution of All Suffix Instructions Staying in a Grid",
        "thought_question": "There is an `n x n` grid, with the top-left cell at `(0, 0)` and the bottom-right cell at `(n - 1, n - 1)`. You are given the integer `n` and an integer array `startPos` where `startPos = [startrow, startcol]` indicates that a robot is initially at cell `(startrow, startcol)`.\n\nYou are also given a **0-indexed** string `s` of length `m` where `s[i]` is the `ith` instruction for the robot: `'L'` (move left), `'R'` (move right), `'U'` (move up), and `'D'` (move down).\n\nThe robot can begin executing from any `ith` instruction in `s`. It executes the instructions one by one towards the end of `s` but it stops if either of these conditions is met:\n\n*   The next instruction will move the robot off the grid.\n*   There are no more instructions left to execute.\n\nReturn _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is **the number of instructions** the robot can execute if the robot **begins executing from** the_ `ith` _instruction in_ `s`.",
        "thought_answer": "\n    ```python\ndef findNoOfInstructions(n: int, startPos: List[int], s: str) -> List[int]:\n    answer = [0] * len(s)\n    x, y = startPos\n\n    for i in range(len(s)):\n        cnt = 0\n        cx, cy = x, y\n        for j in range(i, len(s)):\n            step = s[j]\n            if step == 'L':\n                if cy == 0: break\n                cy -= 1\n            elif step == 'R':\n                if cy == n - 1: break\n                cy += 1\n            elif step == 'U':\n                if cx == 0: break\n                cx -= 1\n            else:\n                if cx == n - 1: break\n                cx += 1\n            cnt += 1\n            if j == len(s) - 1: break\n        answer[i] = cnt\n\n    return answer\n```\n\n    \n    Iterate through the string `s` considering each index as the starting point for execution. In each step, try executing instructions without going out of the grid boundary from that starting point.\n\nIn a nested loop, keep track of the robot position `cx` and `cy`, and for each step, check if the robot would go out-of-bounds on executing the instruction. If it goes out-of-bounds, break out of the loop for that starting point.\n\nFinally, the count of instructions executed for each starting point is stored in the `answer` array.\n    ",
        "tag": [
            "String",
            "Simulation"
        ]
    },
    {
        "thought_name": "Max Sum of a Pair With Equal Sum of Digits",
        "thought_question": "You are given a **0-indexed** array `nums` consisting of **positive** integers. You can choose two indices `i` and `j`, such that `i != j`, and the sum of digits of the number `nums[i]` is equal to that of `nums[j]`.\n\nReturn _the **maximum** value of_ `nums[i] + nums[j]` _that you can obtain over all possible indices_ `i` _and_ `j` _that satisfy the conditions._",
        "thought_answer": "\n    ```python\ndef max_sum_numbers_with_equal_sum_of_digits(nums):\n    digit_sum_to_max = {}\n    ans = -1\n\n    for num in nums:\n        sum_of_digits = sum(map(int, str(num)))\n        \n        prev_max = digit_sum_to_max.get(sum_of_digits, 0)\n        if prev_max:\n            ans = max(ans, num + prev_max)\n        \n        digit_sum_to_max[sum_of_digits] = max(num, prev_max)\n\n    return ans\n```\n    \n    For each number in the input array, calculate the sum of its digits. Store the maximum value of the numbers with the same digit sum in a hashmap. For each number, check if there is a number in the hashmap with the same digit sum. If there is, calculate their sum and update the answer if their sum is greater than the current answer.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Heap (Priority Queue)"
        ]
    },
    {
        "thought_name": "Number of Zero-Filled Subarrays",
        "thought_question": "Given an integer array `nums`, return _the number of **subarrays** filled with_ `0`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.",
        "thought_answer": "\n    ```python\ndef numberOfSubarraysWithZeroes(nums):\n    count = 0\n    zero_count = 0\n\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n            count += zero_count\n        else:\n            zero_count = 0\n\n    return count\n```\n\n    \n    For this problem, we iterate through the given `nums` array. If we encounter a zero, we increment `zeroCount`, which keeps track of consecutive zeroes. We then add `zeroCount` to our total `count`, which represents the number of subarrays filled with zeroes.\n\nIf we encounter a non-zero number, we reset `zeroCount` to 0.\n\nFinally, we return the total `count` as the result.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Equal Row and Column Pairs",
        "thought_question": "Given a **0-indexed** `n x n` integer matrix `grid`, _return the number of pairs_ `(ri, cj)` _such that row_ `ri` _and column_ `cj` _are equal_.\n\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).",
        "thought_answer": "\n    ```python\ndef countEqualRowColumnPairs(grid: List[List[int]]) -> int:\n   n = len(grid)\n   ans = 0\n\n   for i in range(n):\n      for j in range(n):\n         equal = True\n         for k in range(n):\n             if grid[i][k] != grid[k][j]:\n                 equal = False\n                 break\n         if equal:\n             ans += 1\n\n   return ans\n```\n    \n    We use three nested loops to find the equal row and column pairs. For each row `i` and column `j`, we iterate through elements `k` from `0` to `n` checking if `grid[i][k]` equals `grid[k][j]`. If all elements match for a row and column pair, we increment the answer counter `ans`. Finally, return the value of `ans`.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Find Closest Node to Given Two Nodes",
        "thought_question": "You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`.\n\nYou are also given two integers `node1` and `node2`.\n\nReturn _the **index** of the node that can be reached from both_ `node1` _and_ `node2`_, such that the **maximum** between the distance from_ `node1` _to that node, and from_ `node2` _to that node is **minimized**_. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`.\n\nNote that `edges` may contain cycles.",
        "thought_answer": "\n    ```python\ndef get_index_with_min_max_distance(edges, node1, node2):\n    dist1 = [-1] * len(edges)\n    dist2 = [-1] * len(edges)\n\n    dist1[node1] = 0\n    dist2[node2] = 0\n    for i in range(len(edges)):\n        if dist1[i] != -1 and edges[i] != -1:\n            if dist1[edges[i]] == -1:\n                dist1[edges[i]] = dist1[i] + 1\n            else:\n                dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1)\n\n        if dist2[i] != -1 and edges[i] != -1:\n            if dist2[edges[i]] == -1:\n                dist2[edges[i]] = dist2[i] + 1\n            else:\n                dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1)\n\n    ans = -1\n    min_max_dist = float(\"inf\")\n    for i in range(len(edges)):\n        if dist1[i] != -1 and dist2[i] != -1:\n            max_dist = max(dist1[i], dist2[i])\n            if max_dist < min_max_dist:\n                min_max_dist = max_dist\n                ans = i\n\n    return ans\n```\n    \n    We first create arrays `dist1` and `dist2` of the same size as `edges`, initialize them with `-1`, and set `dist[node1] = 0` and `dist[node2] = 0`. These arrays keep track of the shortest distances from `node1` and `node2`, respectively. Then, we iterate through the nodes in the graph, and for each node `i` that has an outgoing edge and is reachable from `node1` or `node2`, we update `dist1[edges[i]]` and `dist2[edges[i]]` to be the minimum of their current value and the distance from the previous node plus 1.\n\nFinally, we iterate through the nodes again to find the node with the minimum maximum distance from `node1` and `node2`. For each node `i` that has a valid distance from both `node1` and `node2`, we compute the maximum distance `max_dist1 = max(dist1[i], dist2[i])`. If this maximum distance is smaller than the minimum maximum distance seen so far, we update the answer to be node `i`.\n    ",
        "tag": [
            "Depth-First Search",
            "Graph"
        ]
    },
    {
        "thought_name": "Count Number of Bad Pairs",
        "thought_question": "You are given a **0-indexed** integer array `nums`. A pair of indices `(i, j)` is a **bad pair** if `i < j` and `j - i != nums[j] - nums[i]`.\n\nReturn _the total number of **bad pairs** in_ `nums`.",
        "thought_answer": "\n    ```python\ndef bad_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if j - i != nums[j] - nums[i]:\n                count += 1\n    return count\n```\n    \n    The algorithm iterates through all possible pairs of indices (i, j) in the given array `nums`, where i < j. For each pair, it checks if the condition `(j - i) != (nums[j] - nums[i])` is true. If it is, it increments the counter `count`. The algorithm has a nested loop structure and its time complexity is O(n^2). Finally, it returns the total count of bad pairs found.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Counting"
        ]
    },
    {
        "thought_name": "Task Scheduler II",
        "thought_question": "You are given a **0-indexed** array of positive integers `tasks`, representing tasks that need to be completed **in order**, where `tasks[i]` represents the **type** of the `ith` task.\n\nYou are also given a positive integer `space`, which represents the **minimum** number of days that must pass **after** the completion of a task before another task of the **same** type can be performed.\n\nEach day, until all tasks have been completed, you must either:\n\n*   Complete the next task from `tasks`, or\n*   Take a break.\n\nReturn _the **minimum** number of days needed to complete all tasks_.",
        "thought_answer": "\n    ```python\ndef min_days_to_complete_tasks(tasks, space):\n    task_last_complete = {}\n    days = 0\n\n    for task in tasks:\n        if task in task_last_complete:\n            passed_days = days - task_last_complete[task]\n            if passed_days < space:\n                days += space - passed_days\n        days += 1\n        task_last_complete[task] = days\n\n    return days\n```\n    \n    The algorithm uses a hash table to keep track of the last completed day for each task type. It iterates through the given `tasks`, and for each task, it calculates the number of days passed since the last completion of the same task type. If the passed days are less than the required `space`, we add the difference to the current `days` count, simulating taking breaks until the task can be performed again. Finally, we increment the days count, as well as updating the last completed day of the task type in the hash table. The algorithm returns the total number of days needed to complete all tasks.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Simulation"
        ]
    },
    {
        "thought_name": "Longest Ideal Subsequence",
        "thought_question": "You are given a string `s` consisting of lowercase letters and an integer `k`. We call a string `t` **ideal** if the following conditions are satisfied:\n\n*   `t` is a **subsequence** of the string `s`.\n*   The absolute difference in the alphabet order of every two **adjacent** letters in `t` is less than or equal to `k`.\n\nReturn _the length of the **longest** ideal string_.\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n**Note** that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of `'a'` and `'z'` is `25`, not `1`.",
        "thought_answer": "\n    ```python\ndef longest_ideal_string(s: str, k: int) -> int:\n    dp = [0] * 26\n\n    for c in s:\n        current = 1\n        for i in range(26):\n            if abs(i - (ord(c) - ord('a'))) <= k:\n                current = max(current, dp[i] + 1)\n        dp[ord(c) - ord('a')] = max(dp[ord(c) - ord('a')], current)\n\n    return max(dp)\n```\n    \n    The algorithm for this problem is dynamic programming. For each character in the input string `s`, check whether the difference of the alphabet order is within `k`. Then, update a memoization array `dp` that stores the longest ideal subsequence ending with each lowercase letter. The final solution is max of all the values in `dp`.\n\n1. Initialize a memoization array `dp` of length 26 with all elements initially set to 0.\n2. Iterate through every character `c` in the input string `s`.\n3. For each character `c`, initialize a variable `current` to store the maximum length for the current character.\n4. Iterate through all possible lowercase characters (from 'a' to 'z'), denoted as index `i`.\n   - If the absolute difference between the index `i` and the position of character `c` in the alphabet is less than or equal to `k`, update `current` to the maximum between `current` and `dp[i] + 1`.\n5. Update the value of `dp` at the position of character `c` based on `current`.\n6. At the end, the longest ideal string length is the maximum value in the `dp` array. Return the max value found in `dp`.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Node With Highest Edge Score",
        "thought_question": "You are given a directed graph with `n` nodes labeled from `0` to `n - 1`, where each node has **exactly one** outgoing edge.\n\nThe graph is represented by a given **0-indexed** integer array `edges` of length `n`, where `edges[i]` indicates that there is a **directed** edge from node `i` to node `edges[i]`.\n\nThe **edge score** of a node `i` is defined as the sum of the **labels** of all the nodes that have an edge pointing to `i`.\n\nReturn _the node with the highest **edge score**_. If multiple nodes have the same **edge score**, return the node with the **smallest** index.",
        "thought_answer": "\n    ```python\ndef highest_edge_score_node(edges: List[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n        scores[edge] += i\n    return scores.index(max(scores))\n```\n    \n    1. Create an array \"scores\" with the same length as \"edges\" and fill it with zeros.\n2. Iterate through the \"edges\" array. For each index i, increment the score array value at the position of edges[i] by i.\n3. Find the index of the maximum value in the \"scores\" array and return it. In the case of a tie, the smallest index will be returned first, as required.\n    ",
        "tag": [
            "Hash Table",
            "Graph"
        ]
    },
    {
        "thought_name": "Construct Smallest Number From DI String",
        "thought_question": "You are given a **0-indexed** string `pattern` of length `n` consisting of the characters `'I'` meaning **increasing** and `'D'` meaning **decreasing**.\n\nA **0-indexed** string `num` of length `n + 1` is created using the following conditions:\n\n*   `num` consists of the digits `'1'` to `'9'`, where each digit is used **at most** once.\n*   If `pattern[i] == 'I'`, then `num[i] < num[i + 1]`.\n*   If `pattern[i] == 'D'`, then `num[i] > num[i + 1]`.\n\nReturn _the lexicographically **smallest** possible string_ `num` _that meets the conditions._",
        "thought_answer": "\n    ```python\ndef findSmallestNum(pattern: str) -> str:\n    num = \"123456789\"\n    i = 0\n    while i < len(pattern):\n        if pattern[i] == 'D':\n            j = i\n            while j < len(pattern) and pattern[j] == 'D':\n                j += 1\n            num = num[:i] + num[i:j+1][::-1] + num[j+1:]\n            i = j\n        else:\n            i += 1\n    return num[:len(pattern) + 1]\n```\n    \n    The algorithm first initializes the `num` string to contain digits from 1 to 9. It then iterates through the `pattern` string. If it encounters a `'D'` character, it finds the stretch of consecutive `'D'` characters and reverses the corresponding stretch of numbers in `num`. If the character is `'I'`, it does nothing and moves to the next index. Finally, it returns the substring of `num` from index 0 to index `pattern.length()`, which is the result according to the provided conditions.\n    ",
        "tag": [
            "String",
            "Backtracking",
            "Stack",
            "Greedy"
        ]
    },
    {
        "thought_name": "Shifting Letters II",
        "thought_question": "You are given a string `s` of lowercase English letters and a 2D integer array `shifts` where `shifts[i] = [starti, endi, directioni]`. For every `i`, **shift** the characters in `s` from the index `starti` to the index `endi` (**inclusive**) forward if `directioni = 1`, or shift the characters backward if `directioni = 0`.\n\nShifting a character **forward** means replacing it with the **next** letter in the alphabet (wrapping around so that `'z'` becomes `'a'`). Similarly, shifting a character **backward** means replacing it with the **previous** letter in the alphabet (wrapping around so that `'a'` becomes `'z'`).\n\nReturn _the final string after all such shifts to_ `s` _are applied_.",
        "thought_answer": "\n    ```python\ndef shiftCharacters(s: str, shifts: List[List[int]]) -> str:\n    shift_values = [0] * len(s)\n    for shift in shifts:\n        start, end, direction = shift\n        value = 1 if direction == 1 else -1\n        shift_values[start] += value\n        if end + 1 < len(s):\n            shift_values[end + 1] -= value\n\n    for i in range(1, len(s)):\n        shift_values[i] += shift_values[i - 1]\n\n    return ''.join(chr((ord(s[i]) - ord('a') + shift_values[i]) % 26 + ord('a')) for i in range(len(s)))\n```\n    \n    The algorithm works by first computing the total shift value for each character in the string by iterating over the shifts array. We use a separate `shiftValues` array, initialized with zeros, to store the computed shift value for each character. For each shift [start, end, direction], we increment the shift value at index 'start' by 1 or -1 depending on the direction, and decrement the shift value for the index 'end + 1' by the same amount, considering it is a valid index.\n\nOnce we have calculated the shift value increments for each character, we loop through the `shiftValues` array from the second element and add the shift value of the previous element to the current element. This way, we accumulate the shift values for each character.\n\nFinally, we iterate through the string and update each character by applying its corresponding shift value using modular arithmetic. We add the computed shift value for each character to the distance from 'a' and take the remainder when dividing by 26, then map back to the actual character by adding the ASCII code of the letter 'a'.\n\nOnce we have iterated through the entire string, we return the updated string.\n    ",
        "tag": [
            "Array",
            "String",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Removing Stars From a String",
        "thought_question": "You are given a string `s`, which contains stars `*`.\n\nIn one operation, you can:\n\n*   Choose a star in `s`.\n*   Remove the closest **non-star** character to its **left**, as well as remove the star itself.\n\nReturn _the string after **all** stars have been removed_.\n\n**Note:**\n\n*   The input will be generated such that the operation is always possible.\n*   It can be shown that the resulting string will always be unique.",
        "thought_answer": "\n    ```python\ndef remove_stars(s: str) -> str:\n    result = []\n    for c in s:\n        if c == '*':\n            if result:\n                result.pop()\n        else:\n            result.append(c)\n    return ''.join(result)\n```\n\n    \n    For each character in the given string `s`, we iterate through the characters. If the character is a star, we remove the last character of the `result` only if `result` is not empty. Otherwise, we append the character to the `result`. Finally, we return the `result` as a string. This algorithm simulates the removal operation described in the question. Since we always remove characters that are closest to the stars, the order of operations does not matter, and the algorithm produces the unique possible output.\n    ",
        "tag": [
            "String",
            "Stack",
            "Simulation"
        ]
    },
    {
        "thought_name": "Count Strictly Increasing Subarrays",
        "thought_question": "You are given an array `nums` consisting of **positive** integers.\n\nReturn _the number of **subarrays** of_ `nums` _that are in **strictly increasing** order._\n\nA **subarray** is a **contiguous** part of an array.",
        "thought_answer": "\n    ```python\ndef num_strictly_increasing_subarrays(nums):\n    n = len(nums)\n    count = 0\n    sum = 0\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            count += 1\n        else:\n            count = 0\n        sum += count\n    return sum + n\n```\n    \n    In this solution, we iterate through the array once, whereas we maintain two variables: `count` and `sum`. `count` is the length of the current increasing subarray, and `sum` keeps the sum of all lengths.\nFor each element, starting with the second one, we check whether it is greater than the previous element. If so, we increment the `count`, otherwise we reset the `count` to zero. We add the `count` to the `sum` at each iteration.\nWhen the loop finishes, we have the total number of strictly increasing subarrays of length 2 or more. We finally add the length of the original array `n` to the result to include the length 1 subarrays, and return the final result.\n    ",
        "tag": []
    },
    {
        "thought_name": "Optimal Partition of String",
        "thought_question": "Given a string `s`, partition the string into one or more **substrings** such that the characters in each substring are **unique**. That is, no letter appears in a single substring more than **once**.\n\nReturn _the **minimum** number of substrings in such a partition._\n\nNote that each character should belong to exactly one substring in a partition.",
        "thought_answer": "\n    ```python\ndef min_substrs(s: str) -> int:\n    seen = set()\n    count = 0\n    for c in s:\n        if c in seen:\n            count += 1\n            seen.clear()\n        seen.add(c)\n    return count + int(bool(seen))\n```\n    \n    The algorithm iterates through the characters of the input string `s`. It uses a set `seen` to store the unique characters encountered so far in the current substring. When a character is found that already exists in the set, we increment the `count` and clear the set. This indicates that a new unique substring should start. \n\nAt the end, if there are still characters left in the `seen` set, it means there is one last unique substring, so we add 1 to the count.\n\nThe time complexity of this algorithm is O(N) where N is the length of the input string, since we iterate through the input string once, and set operations (add, clear, etc.) take constant time on average.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Maximum Matching of Players With Trainers",
        "thought_question": "You are given a **0-indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0-indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer.\n\nThe `ith` player can **match** with the `jth` trainer if the player's ability is **less than or equal to** the trainer's training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player.\n\nReturn _the **maximum** number of matchings between_ `players` _and_ `trainers` _that satisfy these conditions._",
        "thought_answer": "\n    ```python\ndef max_matchings(players, trainers):\n    players.sort()\n    trainers.sort()\n\n    player_index, trainer_index, match_count = 0, 0, 0\n    while (player_index < len(players)) and (trainer_index < len(trainers)):\n        if players[player_index] <= trainers[trainer_index]:\n            match_count += 1\n            player_index += 1\n            trainer_index += 1\n        else:\n            trainer_index += 1\n\n    return match_count\n```\n\n    \n    1. Sort the `players` and `trainers` arrays in ascending order.\n2. Initialize variables `playerIndex`, `trainerIndex`, and `matchCount` to 0.\n3. Loop through the `players` and `trainers` arrays while `playerIndex` is less than the `players` length and `trainerIndex` is less than the `trainers` length.\n   a. If the current `player`'s ability is less than or equal to the current `trainer`'s training capacity, increase the `matchCount`, increment both `playerIndex` and `trainerIndex`.\n   b. If not, increment `trainerIndex` only.\n4. After the loop, the final `matchCount` value is the maximum number of matchings that satisfy the conditions.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Length of the Longest Alphabetical Continuous Substring",
        "thought_question": "An **alphabetical continuous string** is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string `\"abcdefghijklmnopqrstuvwxyz \"`.\n\n*   For example, `\"abc \"` is an alphabetical continuous string, while `\"acb \"` and `\"za \"` are not.\n\nGiven a string `s` consisting of lowercase letters only, return the _length of the **longest** alphabetical continuous substring._",
        "thought_answer": "\n    ```python\ndef longest_alphabetical_continuous_substring(s: str) -> int:\n    max_length = current_length = 1\n    for i in range(1, len(s)):\n        if ord(s[i]) == ord(s[i - 1]) + 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    return max(max_length, current_length)\n```\n    \n    1. Initialize two variables, `max_length` and `current_length` to keep track of the longest alphabetical continuous substring's length and the current alphabetical substring's length, respectively. Both are initially set to 1, as there is at least one character in the string.\n2. Iterate through the string from the second character to the end.\n3. Compare the current character and the previous character. If they are consecutive in the alphabet (i.e., the current character's Unicode code point is one greater than the previous character's code point), increment the current length.\n4. If they are not consecutive, update the maximum length by comparing it with the current length and reset the current length to 1.\n5. After finishing the loop, we need to compare the maximum length and the current length once more to make sure the last continuous substring is accounted for.\n6. Return the largest value between the two as the answer.\n    ",
        "tag": [
            "String"
        ]
    },
    {
        "thought_name": "Closest Fair Integer",
        "thought_question": "You are given a **positive** integer `n`.\n\nWe call an integer `k` fair if the number of **even** digits in `k` is equal to the number of **odd** digits in it.\n\nReturn _the **smallest** fair integer that is **greater than or equal** to_ `n`.",
        "thought_answer": "\n    ```python\ndef smallest_fair_number(n):\n    while True:\n        k = n\n        even = 0\n        odd = 0\n        while k > 0:\n            if k % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n            k //= 10\n        if even == odd:\n            return n\n        n += 1\n```\n    \n    The algorithm starts from the given number `n` and check if it is fair or not. A fair number `k` is the one where the count of even digits is equal to the count of odd digits.\n\nTo check if a number is fair, we count the even and odd digits of the number `k` using a while loop. In each iteration, we check if the last digit of `k` is even or odd, increment the respective counter, and update `k` by removing the last digit. If the count of even and odd digits is equal, return the number `n`.\n\nIf the given number `n` is not fair, we increment `n` and repeat the process until we find a fair number.\n\nThis algorithm has a linear time complexity (in the worst case) as we need to find the subsequent fair numbers one by one until we find the smallest fair number satisfying the constraints.\n    ",
        "tag": []
    },
    {
        "thought_name": "Merge Operations to Turn Array Into a Palindrome",
        "thought_question": "You are given an array `nums` consisting of **positive** integers.\n\nYou can perform the following operation on the array **any** number of times:\n\n*   Choose any two **adjacent** elements and **replace** them with their **sum**.\n    *   For example, if `nums = [1,2,3,1]`, you can apply one operation to make it `[1,5,1]`.\n\nReturn _the **minimum** number of operations needed to turn the array into a **palindrome**_.",
        "thought_answer": "\n    ```python\ndef minOperations(nums):\n    n = len(nums)\n    i, j = 0, n - 1\n    operations = 0\n\n    while i < j:\n        if nums[i] == nums[j]:\n            i += 1\n            j -= 1\n        elif nums[i] < nums[j]:\n            nums[i + 1] += nums[i]\n            i += 1\n            operations += 1\n        else:\n            nums[j - 1] += nums[j]\n            j -= 1\n            operations += 1\n\n    return operations\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "tag": []
    },
    {
        "thought_name": "Bitwise XOR of All Pairings",
        "thought_question": "You are given two **0-indexed** arrays, `nums1` and `nums2`, consisting of non-negative integers. There exists another array, `nums3`, which contains the bitwise XOR of **all pairings** of integers between `nums1` and `nums2` (every integer in `nums1` is paired with every integer in `nums2` **exactly once**).\n\nReturn _the **bitwise XOR** of all integers in_ `nums3`.",
        "thought_answer": "\n    ```python\ndef get_xor(nums1, nums2):\n    xor_result = 0\n    for num1 in nums1:\n        for num2 in nums2:\n            xor_result ^= (num1 ^ num2)\n    return xor_result\n```\n    \n    The algorithm iterates over each integer in `nums1` and each integer in `nums2`, and computes the XOR of their pair. The XOR result of this pair is then XORed with the overall XOR result variable `xor_result`. This loop computes the XOR result of all pairs at the end. Since the XOR operation is commutative and associative, the order of the operations and pairs does not matter.\n    ",
        "tag": [
            "Array",
            "Bit Manipulation",
            "Brainteaser"
        ]
    },
    {
        "thought_name": "Maximum Sum of an Hourglass",
        "thought_question": "You are given an `m x n` integer matrix `grid`.\n\nWe define an **hourglass** as a part of the matrix with the following form:\n\nReturn _the **maximum** sum of the elements of an hourglass_.\n\n**Note** that an hourglass cannot be rotated and must be entirely contained within the matrix.",
        "thought_answer": "\n    ```python\ndef max_hourglass_sum(grid):\n    m, n = len(grid), len(grid[0])\n    max_sum = float('-inf')\n    for i in range(1, m - 1):\n        for j in range(1, n - 1):\n            sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] \\\n                  + grid[i][j] \\\n                  + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, sum)\n    return max_sum\n```\n\n    \n    The problem requires us to find the maximum sum of hourglasses in the given grid.\n\nWe first find the dimensions of the grid, m and n. We initialize maxSum as the smallest integer value possible (-inf for Python).\n\nSince the hourglass shape should be entirely contained within the grid, we start our traversal from (1,1), i.e., one cell shifted right and down from the top-left corner of the grid, continuing until (m-2, n-2). Both these indices are included in the traversal.\n\nIn the nested for loop, we calculate the hourglass sum for each cell by adding the values of its hourglass pattern: three cells horizontally from the cell above it, the cell itself, and three cells horizontally from the cell below it. We then compare the calculated sum with the current maxSum, keeping the larger value as the new maxSum.\n\nFinally, we return the maxSum after traversing the entire grid.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Maximize Total Tastiness of Purchased Fruits",
        "thought_question": "You are given two non-negative integer arrays `price` and `tastiness`, both arrays have the same length `n`. You are also given two non-negative integers `maxAmount` and `maxCoupons`.\n\nFor every integer `i` in range `[0, n - 1]`:\n\n*   `price[i]` describes the price of `ith` fruit.\n*   `tastiness[i]` describes the tastiness of `ith` fruit.\n\nYou want to purchase some fruits such that total tastiness is maximized and the total price does not exceed `maxAmount`.\n\nAdditionally, you can use a coupon to purchase fruit for **half of its price** (rounded down to the closest integer). You can use at most `maxCoupons` of such coupons.\n\nReturn _the maximum total tastiness that can be purchased_.\n\n**Note that:**\n\n*   You can purchase each fruit at most once.\n*   You can use coupons on some fruit at most once.",
        "thought_answer": "\n    ```python\ndef maxTastiness(price, tastiness, maxAmount, maxCoupons):\n    n = len(price)\n    dp = [[[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        fruit_price = price[i - 1]\n        fruit_tastiness = tastiness[i - 1]\n        half_fruit_price = fruit_price // 2\n        \n        for j in range(maxAmount + 1):\n            for k in range(maxCoupons + 1):\n                dp[i][j][k] = dp[i - 1][j][k]\n                if j >= fruit_price:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)\n                if k > 0 and j >= half_fruit_price:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)\n\n    return dp[n][maxAmount][maxCoupons]\n```\n\n    \n    We solve the problem using dynamic programming. Our state is represented by three dimensions:\n\n1. The index of the current fruit (0-based)\n2. The current amount spent\n3. The number of coupons used\n\nThe dp array is initialized as a 3D array filled with zeros. Then, we iterate through the fruits, updating the dp array based on whether we buy the current fruit or not, and whether we use a coupon to buy it.\n\nFor each fruit, we iterate through all possible amounts spent and all possible numbers of coupons used. We have three cases to consider when updating the dp array:\n\n1. We do not buy the current fruit: `dp[i][j][k] = dp[i - 1][j][k]`\n2. We buy the current fruit without a coupon: If `j >= fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)`\n3. We buy the current fruit with a coupon: If `k > 0 && j >= half_fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)`\n   \nAfter iterating through all the fruits, amounts, and coupons, the maximum tastiness that can be obtained is stored in `dp[n][maxAmount][maxCoupons]`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find The Original Array of Prefix Xor",
        "thought_question": "You are given an **integer** array `pref` of size `n`. Find and return _the array_ `arr` _of size_ `n` _that satisfies_:\n\n*   `pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]`.\n\nNote that `^` denotes the **bitwise-xor** operation.\n\nIt can be proven that the answer is **unique**.",
        "thought_answer": "\n    ```python\ndef findArray(pref):\n    arr = [pref[0]]\n    for i in range(1, len(pref)):\n        arr.append(pref[i] ^ pref[i - 1])\n    return arr\n```\n    \n    The function first initializes the first element of the `arr` array to the first element of the input `pref` array. Then, for each remaining element in the `pref` array, the function calculates the corresponding `arr` element by XORing the current `pref` element with the previous `pref` element. This is based on the property of XOR, where `(a ^ b) ^ b == a`. After all elements in the `arr` array are calculated, the function returns the `arr` array.\n    ",
        "tag": [
            "Array",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Minimum Split Into Subarrays With GCD Greater Than One",
        "thought_question": "You are given an array `nums` consisting of positive integers.\n\nSplit the array into **one or more** disjoint subarrays such that:\n\n*   Each element of the array belongs to **exactly one** subarray, and\n*   The **GCD** of the elements of each subarray is strictly greater than `1`.\n\nReturn _the minimum number of subarrays that can be obtained after the split_.\n\n**Note** that:\n\n*   The **GCD** of a subarray is the largest positive integer that evenly divides all the elements of the subarray.\n*   A **subarray** is a contiguous part of the array.",
        "thought_answer": "\n    ```python\ndef min_arrays(nums):\n    def gcd(a, b):\n        return a if b == 0 else gcd(b, a % b)\n\n    total_gcd = nums[0]\n    for num in nums[1:]:\n        total_gcd = gcd(total_gcd, num)\n    \n    return 2 if total_gcd == 1 else 1\n```\n    \n    The algorithm first finds the total GCD (greatest common divisor) of all the elements in the array. If the total GCD is 1, that means the array can't be split into a single subarray and satisfy the condition of having a GCD greater than 1. In this case, the minimum number of subarrays required is 2. Otherwise, if the total GCD is greater than 1, the entire array can be considered as a single subarray meeting the condition, so the answer is 1. The gcd function is a helper function that computes the GCD of two integers using the Euclidean algorithm.\n    ",
        "tag": []
    },
    {
        "thought_name": "Minimize Maximum of Array",
        "thought_question": "You are given a **0-indexed** array `nums` comprising of `n` non-negative integers.\n\nIn one operation, you must:\n\n*   Choose an integer `i` such that `1 <= i < n` and `nums[i] > 0`.\n*   Decrease `nums[i]` by 1.\n*   Increase `nums[i - 1]` by 1.\n\nReturn _the **minimum** possible value of the **maximum** integer of_ `nums` _after performing **any** number of operations_.",
        "thought_answer": "\n    ```python\ndef find_min_maximum_value(nums):\n    result = nums[0]\n    total_sum = nums[0]\n    for i in range(1, len(nums)):\n        total_sum += nums[i]\n        result = max(result, (total_sum + i) // (i + 1))\n    return result\n```\n    \n    The algorithm iterates through the array and maintains a running sum of the elements `sum`, and the maximum value found so far `result`. For each `i`, the maximum value for any prefix array ending at `i` is calculated by taking the ceiling of the division of the running sum plus `i` by `i+1`, which represents distributing the sum among the elements up to `i+1`. This maximum value is then compared with the current `result`, and the larger one is kept. The loop ends after iterating through the whole array.\n\nFinally, the algorithm returns the calculated minimum possible maximum value `result`.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Count Number of Distinct Integers After Reverse Operations",
        "thought_question": "You are given an array `nums` consisting of **positive** integers.\n\nYou have to take each integer in the array, **reverse its digits**, and add it to the end of the array. You should apply this operation to the original integers in `nums`.\n\nReturn _the number of **distinct** integers in the final array_.",
        "thought_answer": "\n    ```python\ndef distinct_integers_after_reversing_and_adding(nums):\n    distinct = set(nums)\n    for num in nums:\n        reversed_num = int(str(num)[::-1])\n        distinct.add(reversed_num)\n    return len(distinct)\n```\n    \n    The algorithm first initializes a set `distinct` to keep track of distinct integers in the final array. It then iterates through each integer `num` in the `nums` array, adds the integer `num` to the `distinct` set, and calculates the reversed integer by reversing the digits of `num`. The reversed integer is also added to the `distinct` set. Finally, the algorithm returns the size of the `distinct` set, which represents the number of distinct integers in the final array. The time complexity is O(n) where n is the size of the `nums` array.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Counting"
        ]
    },
    {
        "thought_name": "Number of Subarrays With LCM Equal to K",
        "thought_question": "Given an integer array `nums` and an integer `k`, return _the number of **subarrays** of_ `nums` _where the least common multiple of the subarray's elements is_ `k`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\nThe **least common multiple of an array** is the smallest positive integer that is divisible by all the array elements.",
        "thought_answer": "\n    ```python\ndef count_lcm_subarrays(nums: List[int], k: int) -> int:\n    def lcm(a, b):\n        temp = a\n        while temp % b != 0:\n            temp += a\n        return temp\n\n    count = 0\n    for i in range(len(nums)):\n        curr_lcm = nums[i]\n        for j in range(i, len(nums)):\n            curr_lcm = lcm(curr_lcm, nums[j])\n            if curr_lcm == k:\n                count += 1\n\n    return count\n```\n    \n    1. Create a function `lcm` that takes two arguments, `a` and `b`, and returns the Least Common Multiple of both.\n2. Initialize a counter `count` to zero.\n3. Iterate through the input array `nums`. For each element, set the current element as the current Least Common Multiple `curr_lcm`.\n4. Iterate from the current element to the end of the array.\n   - Update the current LCM using the `lcm` function, providing the current LCM and the current element from the inner iteration as arguments.\n   - If the LCM is equal to `k`, increment the counter `count`.\n5. Return the counter `count`.\n    ",
        "tag": [
            "Array",
            "Math",
            "Number Theory"
        ]
    },
    {
        "thought_name": "Difference Between Ones and Zeros in Row and Column",
        "thought_question": "You are given a **0-indexed** `m x n` binary matrix `grid`.\n\nA **0-indexed** `m x n` difference matrix `diff` is created with the following procedure:\n\n*   Let the number of ones in the `ith` row be `onesRowi`.\n*   Let the number of ones in the `jth` column be `onesColj`.\n*   Let the number of zeros in the `ith` row be `zerosRowi`.\n*   Let the number of zeros in the `jth` column be `zerosColj`.\n*   `diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj`\n\nReturn _the difference matrix_ `diff`.",
        "thought_answer": "\n    ```python\ndef create_difference_matrix(grid):\n    m, n = len(grid), len(grid[0])\n    ones_row, ones_col = [0] * m, [0] * n\n    diff = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            ones_row[i] += grid[i][j]\n            ones_col[j] += grid[i][j]\n\n    for i in range(m):\n        for j in range(n):\n            diff[i][j] = ones_row[i] + ones_col[j] - (n - ones_row[i]) - (m - ones_col[j])\n\n    return diff\n```\n    \n    The algorithm consists of three main steps:\n\n1. Iterate through each cell in the input `grid`, and count the number of ones in each row and column. Store these counts in respective arrays `onesRow` and `onesCol`.\n\n2. Calculate the difference matrix `diff` by iterating through each cell in the input `grid`, and applying the formula `diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])`. \n\n3. Return the `diff` matrix.\n\nThe algorithm iterates through the input grid twice, and has O(m * n) time complexity. It requires additional storage for the `diff` matrix, `onesRow`, and `onesCol`, making the space complexity O(m + n + m * n).\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Append Characters to String to Make Subsequence",
        "thought_question": "You are given two strings `s` and `t` consisting of only lowercase English letters.\n\nReturn _the minimum number of characters that need to be appended to the end of_ `s` _so that_ `t` _becomes a **subsequence** of_ `s`.\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.",
        "thought_answer": "\n    ```python\ndef min_addition(s: str, t: str) -> int:\n    s_len = len(s)\n    t_len = len(t)\n    i, j = 0, 0\n    while i < s_len and j < t_len:\n        if s[i] == t[j]:\n            j += 1\n        i += 1\n    return t_len - j\n```\n    \n    The algorithm maintains two pointers, `i` and `j`, to iterate through the given strings `s` and `t`. The pointer `i` iterates through the string `s` and the pointer `j` iterates through the string `t`. While iterating through `s`, if we find a character that matches the current character in `t`, we increment the `j` pointer. This is because the matched character can be a part of the subsequence we are looking for. The iteration stops when either `i` reaches the end of `s` or `j` reaches the end of `t`.\n\nAt the end, we subtract the index `j` from the length of `t`. This gives us the minimum number of characters that need to be appended to the end of `s` so that `t` becomes a subsequence of `s`.\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Number of Substrings With Fixed Ratio",
        "thought_question": "You are given a binary string `s`, and two integers `num1` and `num2`. `num1` and `num2` are coprime numbers.\n\nA **ratio substring** is a substring of s where the ratio between the number of `0`'s and the number of `1`'s in the substring is exactly `num1 : num2`.\n\n*   For example, if `num1 = 2` and `num2 = 3`, then `\"01011 \"` and `\"1110000111 \"` are ratio substrings, while `\"11000 \"` is not.\n\nReturn _the number of **non-empty** ratio substrings of_ `s`.\n\n**Note** that:\n\n*   A **substring** is a contiguous sequence of characters within a string.\n*   Two values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the greatest common divisor of `x` and `y`.",
        "thought_answer": "\n    ```python\ndef ratio_substring_count(s: str, num1: int, num2: int) -> int:\n    count0, count1 = 0, 0\n    frequency = {0: 1}\n    result = 0\n\n    for c in s:\n        if c == '0':\n            count0 += 1\n        else:\n            count1 += 1\n\n        curr_diff = count0 * num2 - count1 * num1\n        result += frequency.get(curr_diff, 0)\n        frequency[curr_diff] = frequency.get(curr_diff, 0) + 1\n\n    return result\n```\n\n    \n    1. Initialize the counters `count0` and `count1` for counting the number of '0's and '1's, respectively, in the continuous subsequence.\n2. Initialize a hashmap `frequency` to track the difference between the number of '0's and '1's multiplied by the coefficients.\n3. For each character in the string, increment the counters based on the character being '0' or '1'.\n4. Calculate the difference between the number of '0's and '1's multiplied by the coefficients.\n5. Increment the result by the value of frequency hashmap (count of diff occurrences) at key `curr_diff`.\n6. Increment the frequency hashmap value (count of diff occurrences) at key `curr_diff`.\n7. Return the result.\n    ",
        "tag": []
    },
    {
        "thought_name": "Maximum Star Sum of a Graph",
        "thought_question": "There is an undirected graph consisting of `n` nodes numbered from `0` to `n - 1`. You are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi.`\n\nA **star graph** is a subgraph of the given graph having a center node containing `0` or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\n\nThe image below shows star graphs with `3` and `4` neighbors respectively, centered at the blue node.\n\nThe **star sum** is the sum of the values of all the nodes present in the star graph.\n\nGiven an integer `k`, return _the **maximum star sum** of a star graph containing **at most**_ `k` _edges._",
        "thought_answer": "\n    ```python\ndef max_star_sum(vals, edges, k):\n    adj = [[] for _ in range(len(vals))]\n\n    for edge in edges:\n        adj[edge[0]].append(vals[edge[1]])\n        adj[edge[1]].append(vals[edge[0]])\n\n    ans = float(\"-inf\")\n    for i in range(len(vals)):\n        adj[i].sort(reverse=True)\n        ans = max(ans, vals[i] + sum(adj[i][:k]))\n\n    return ans\n```\n    \n    The basic idea of the algorithm is to find the center node and its neighbors that maximize the star sum with the given constraints. For every node, we calculate the sum of its neighbors' values sorted in decreasing order, up to `k` neighbors. We keep track of the maximum sum found for any node so far.\n\n1. Create an adjacency list `adj` to store the values of neighbors of each node.\n\n2. Iterate through the `edges` array and populate the adjacency list `adj` such that `adj[a]` contains the values of the neighbors of the node `a`.\n\n3. For each node `i`, we sort the values of its neighbors in decreasing order to process the maximum values first.\n\n4. Initiate the maximum sum variable `ans` as the minimum value possible.\n\n5. For each node `i`, calculate the sum `sum` of its value and the sum of `k` maximum neighbors' values (if any). Update the `ans` variable to the maximum of the current sum and the previously stored maximum sum.\n\n6. Return the maximum star sum, `ans`.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Graph",
            "Sorting",
            "Heap (Priority Queue)"
        ]
    },
    {
        "thought_name": "Reward Top K Students",
        "thought_question": "You are given two string arrays `positive_feedback` and `negative_feedback`, containing the words denoting positive and negative feedback, respectively. Note that **no** word is both positive and negative.\n\nInitially every student has `0` points. Each positive word in a feedback report **increases** the points of a student by `3`, whereas each negative word **decreases** the points by `1`.\n\nYou are given `n` feedback reports, represented by a **0-indexed** string array `report` and a **0-indexed** integer array `student_id`, where `student_id[i]` represents the ID of the student who has received the feedback report `report[i]`. The ID of each student is **unique**.\n\nGiven an integer `k`, return _the top_ `k` _students after ranking them in **non-increasing** order by their points_. In case more than one student has the same points, the one with the lower ID ranks higher.",
        "thought_answer": "\n    ```python\ndef top_k_students(positive_feedback, negative_feedback, report, student_id, k):\n    points = {}\n    for i in range(len(report)):\n        pos_count, neg_count = 0, 0\n        for pos in positive_feedback:\n            pos_index = report[i].find(pos)\n            while pos_index != -1:\n                pos_count += 1\n                pos_index = report[i].find(pos, pos_index + len(pos))\n        for neg in negative_feedback:\n            neg_index = report[i].find(neg)\n            while neg_index != -1:\n                neg_count += 1\n                neg_index = report[i].find(neg, neg_index + len(neg))\n        \n        points[student_id[i]] = points.get(student_id[i], 0) + 3 * pos_count - neg_count\n\n    students = sorted(student_id, key=lambda x: (-points[x], x))\n    return students[:k]\n```\n\n    \n    1. Initialize an empty dictionary (unordered_map in C++, HashMap in Java) to store a student's points based on their ID.\n2. Iterate through the given reports using index i.\n3. For each report, initialize positive and negative count to 0.\n4. Iterate through positive_feedback words and find occurrences of each positive word in the report. Increment positive count for each occurrence.\n5. Iterate through negative_feedback words and find occurrences of each negative word in the report. Increment negative count for each occurrence.\n6. Update the student's points in the dictionary based on their ID: add 3 times positive count minus negative count to their existing points.\n7. Sort the student_id array/vector in descending order according to points and break ties by ascending student ID.\n8. Return the top k elements of the sorted `student_id` array/vector.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Sorting",
            "Heap (Priority Queue)"
        ]
    },
    {
        "thought_name": "Partition String Into Substrings With Values at Most K",
        "thought_question": "You are given a string `s` consisting of digits from `1` to `9` and an integer `k`.\n\nA partition of a string `s` is called **good** if:\n\n*   Each digit of `s` is part of **exactly** one substring.\n*   The value of each substring is less than or equal to `k`.\n\nReturn _the **minimum** number of substrings in a **good** partition of_ `s`. If no **good** partition of `s` exists, return `-1`.\n\n**Note** that:\n\n*   The **value** of a string is its result when interpreted as an integer. For example, the value of `\"123 \"` is `123` and the value of `\"1 \"` is `1`.\n*   A **substring** is a contiguous sequence of characters within a string.",
        "thought_answer": "\n    ```python\ndef min_partitions(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    idx = 0\n\n    while idx < n:\n        currentValue = 0\n        while idx < n and currentValue * 10 + int(s[idx]) <= k:\n            currentValue = currentValue * 10 + int(s[idx])\n            idx += 1\n\n        if currentValue == 0:\n            return -1\n        count += 1\n\n    return count\n```\n    \n    The algorithm goes through the input string `s` from left to right. We maintain a `currentValue` variable that will store the value of the substring we're currently generating. We also maintain an index `idx` variable to track the current position in the string `s`. \n\nWe loop through the string `s` with a while loop. In the inner while loop, we accumulate digits into `currentValue` until the combined value becomes larger than `k`. Once we reach the limit, we increment the `count` variable to represent a new partition and reset `currentValue`. If at any point we have `currentValue` as 0, it means that even a single digit is larger than `k`, so we return -1.\n\nOur algorithm continues in this manner, partitioning the string into substrings until we reach the end of the string `s`. The `count` variable keeps track of the minimum number of partitions in a good partition.\n    ",
        "tag": [
            "String",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Increment Submatrices by One",
        "thought_question": "You are given a positive integer `n`, indicating that we initially have an `n x n` **0-indexed** integer matrix `mat` filled with zeroes.\n\nYou are also given a 2D integer array `query`. For each `query[i] = [row1i, col1i, row2i, col2i]`, you should do the following operation:\n\n*   Add `1` to **every element** in the submatrix with the **top left** corner `(row1i, col1i)` and the **bottom right** corner `(row2i, col2i)`. That is, add `1` to `mat[x][y]` for all `row1i <= x <= row2i` and `col1i <= y <= col2i`.\n\nReturn _the matrix_ `mat` _after performing every query._",
        "thought_answer": "\n    ```python\ndef apply_queries(n, queries):\n    mat = [[0] * n for _ in range(n)]\n\n    for query in queries:\n        for i in range(query[0], query[2] + 1):\n            for j in range(query[1], query[3] + 1):\n                mat[i][j] += 1\n\n    return mat\n```\n    \n    The algorithm simply initializes an n x n matrix filled with zeroes, then iterates through the `queries` list, and for each query, updates the elements in the submatrix as described in the problem statement by incrementing them by 1 in a nested loop. After the updates are made to the matrix, it is returned as the output.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Sort the Students by Their Kth Score",
        "thought_question": "There is a class with `m` students and `n` exams. You are given a **0-indexed** `m x n` integer matrix `score`, where each row represents one student and `score[i][j]` denotes the score the `ith` student got in the `jth` exam. The matrix `score` contains **distinct** integers only.\n\nYou are also given an integer `k`. Sort the students (i.e., the rows of the matrix) by their scores in the `kth` (**0-indexed**) exam from the highest to the lowest.\n\nReturn _the matrix after sorting it._",
        "thought_answer": "\n    ```python\ndef sort_students(score, k):\n    score.sort(key=lambda x: x[k], reverse=True)\n    return score\n```\n\n    \n    The algorithm makes use of the given programming language's built-in sorting function (e.g., `sort` function for C++, Java, Python, and JavaScript). A custom sorting function is supplied as an argument to the built-in sort function.\n\nFor each language, the custom sorting function utilizes a lambda function that compares the `k`-th exam scores of two students (i.e., rows of the matrix). The lambda function sorts rows in descending order based on their scores in the `k`-th exam. The result is a sorted matrix where students' rows are rearranged according to their scores in the `k`-th exam.\n\nHere's an overview of the custom sorting function for each language:\n* C++: Uses lambda function `[k] (const vector<int>& a, const vector<int>& b) { return a[k] > b[k]; }`\n* Java: Uses lambda function `(a, b) -> b[k] - a[k]`\n* Python: Uses lambda function `key=lambda x: x[k], reverse=True`\n* JavaScript: Uses lambda function `(a, b) => b[k] - a[k]`\n    ",
        "tag": [
            "Array",
            "Sorting",
            "Matrix"
        ]
    },
    {
        "thought_name": "Maximum Number of Integers to Choose From a Range I",
        "thought_question": "You are given an integer array `banned` and two integers `n` and `maxSum`. You are choosing some number of integers following the below rules:\n\n*   The chosen integers have to be in the range `[1, n]`.\n*   Each integer can be chosen **at most once**.\n*   The chosen integers should not be in the array `banned`.\n*   The sum of the chosen integers should not exceed `maxSum`.\n\nReturn _the **maximum** number of integers you can choose following the mentioned rules_.",
        "thought_answer": "\n    ```python\ndef max_chosen_integers(banned, n, max_sum):\n    banned_set = set(banned)\n    count = 0\n    total_sum = 0\n    for i in range(n, 0, -1):\n        if i not in banned_set and max_sum - total_sum >= i:\n            total_sum += i\n            count += 1\n    return count\n```\n    \n    The algorithm initializes a set containing the elements from the banned list. It then iterates from `n` down to `1` and checks the following conditions:\n\n1. If the current integer `i` is not in the banned set.\n2. If the maxSum minus the current sum is greater than or equal to `i`.\n\nIf both conditions are met, it adds the integer to the sum and increments the count of chosen integers. After the loop finishes, the algorithm returns the count.\n\nThe algorithm efficiently finds the maximum number of integers that meet the conditions by iterating in decreasing order, and the usage of set ensures constant time lookup for banned elements.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Count the Number of Fair Pairs",
        "thought_question": "Given a **0-indexed** integer array `nums` of size `n` and two integers `lower` and `upper`, return _the number of fair pairs_.\n\nA pair `(i, j)` is **fair** if:\n\n*   `0 <= i < j < n`, and\n*   `lower <= nums[i] + nums[j] <= upper`",
        "thought_answer": "\n    ```python\ndef count_fair_pairs(nums, lower, upper):\n    n = len(nums)\n    fair_pairs = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lower <= nums[i] + nums[j] <= upper:\n                fair_pairs += 1\n    return fair_pairs\n```\n    \n    The algorithm iterates over each unique pair of elements in the array, with a nested loop that starts at index i+1 to avoid duplicates. For each pair, it checks if the sum of the elements is within the [lower, upper] range. If it is, it increments the fair_pairs counter. Once all pairs have been checked, the algorithm returns the total number of fair pairs found.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ]
    },
    {
        "thought_name": "Minimum Impossible OR",
        "thought_question": "You are given a **0-indexed** integer array `nums`.\n\nWe say that an integer x is **expressible** from `nums` if there exist some integers `0 <= index1 < index2 < ... < indexk < nums.length` for which `nums[index1] | nums[index2] | ... | nums[indexk] = x`. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of `nums`.\n\nReturn _the minimum **positive non-zero integer** that is not_ _expressible from_ `nums`.",
        "thought_answer": "\n    ```python\ndef min_non_expressible_integer(nums):\n    result = 1\n    nums.sort()\n    for num in nums:\n        if num > result:\n            break\n        result += num\n    return result\n```\n    \n    The algorithm first sorts the input array. Then, it initializes a \"result\" variable with a value of 1, which represents the smallest positive non-zero integer.\n\nThe algorithm then iterates through the sorted array. For each number, it checks whether the current number is greater than the \"result\" variable. If it is, the algorithm breaks out of the loop, because it has found the smallest positive number that cannot be expressed as the bitwise OR of a subsequence of the input array.\n\nIf the current number is not greater than the \"result\" variable, the algorithm updates the \"result\" variable by adding the current number to it. This is because the sorted array guarantees that the numbers are in increasing order, so the bitwise OR of any subsequence of the array will always produce a result greater than or equal to the current \"result\" variable.\n\nFinally, the algorithm returns the value of the \"result\" variable, which represents the smallest positive non-zero integer that cannot be expressed as the bitwise OR of a subsequence of the input array.\n    ",
        "tag": [
            "Array",
            "Bit Manipulation",
            "Brainteaser"
        ]
    },
    {
        "thought_name": "Find the Divisibility Array of a String",
        "thought_question": "You are given a **0-indexed** string `word` of length `n` consisting of digits, and a positive integer `m`.\n\nThe **divisibility array** `div` of `word` is an integer array of length `n` such that:\n\n*   `div[i] = 1` if the **numeric value** of `word[0,...,i]` is divisible by `m`, or\n*   `div[i] = 0` otherwise.\n\nReturn _the divisibility array of_ `word`.",
        "thought_answer": "\n    ```python\ndef divisibility_array(word: str, m: int) -> list[int]:\n    div = []\n    value = 0\n    for c in word:\n        value = (value * 10 + int(c)) % m\n        div.append(1 if value == 0 else 0)\n    return div\n```\n    \n    We initialize an empty divisibility array and a variable value to store the current numeric value. We iterate through the characters in the input string word. For each character, we multiply the value variable by 10 and add the numeric value of the character by subtracting the ASCII value of '0' from the ASCII value of the character, then taking the remainder with m. If the value is equal to 0, we push 1 in our array, and otherwise, we push 0. Finally, we return the divisibility array.\n    ",
        "tag": [
            "Array",
            "Math",
            "String"
        ]
    },
    {
        "thought_name": "Count Total Number of Colored Cells",
        "thought_question": "There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer `n`, indicating that you must do the following routine for `n` minutes:\n\n*   At the first minute, color **any** arbitrary unit cell blue.\n*   Every minute thereafter, color blue **every** uncolored cell that touches a blue cell.\n\nBelow is a pictorial representation of the state of the grid after minutes 1, 2, and 3.\n\nReturn _the number of **colored cells** at the end of_ `n` _minutes_.",
        "thought_answer": "\n    ```python\ndef number_of_colored_cells(n):\n    return n * n + (n - 1) * (n - 1)\n```\n    \n    For each minute, the boundary of colored cells expands outward in a square pattern. To get the total number of colored cells, we consider two squares - the inner square formed by the cells that were colored at minute n-1, and the outer square formed by the cells that were colored at minute n. \n\nThe inner square has dimensions (n-1)x(n-1), while the outer square has dimensions nxn. The number of colored cells is the sum of the areas of these two squares.\n\nWe compute this as `n * n + (n - 1) * (n - 1)`.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Count Ways to Group Overlapping Ranges",
        "thought_question": "You are given a 2D integer array `ranges` where `ranges[i] = [starti, endi]` denotes that all integers between `starti` and `endi` (both **inclusive**) are contained in the `ith` range.\n\nYou are to split `ranges` into **two** (possibly empty) groups such that:\n\n*   Each range belongs to exactly one group.\n*   Any two **overlapping** ranges must belong to the **same** group.\n\nTwo ranges are said to be **overlapping** if there exists at least **one** integer that is present in both ranges.\n\n*   For example, `[1, 3]` and `[2, 5]` are overlapping because `2` and `3` occur in both ranges.\n\nReturn _the **total number** of ways to split_ `ranges` _into two groups_. Since the answer may be very large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef total_ways_to_split_ranges(ranges):\n    MOD = 10**9 + 7\n    ranges.sort(key=lambda x: x[1])\n    overlapping, non_overlapping, prev_end = 0, 1, -1\n\n    for start, end in ranges:\n        if start <= prev_end:\n            overlapping += 1\n        else:\n            non_overlapping += 1\n        prev_end = max(prev_end, end)\n\n    result = 1\n    for i in range(1, overlapping + 1):\n        result = (result * 2) % MOD\n\n    return result\n```\n    \n    Firstly, sort the ranges by their end values in ascending order. Keep track of previous maximum end value (`prev_end`). Initialize the count of overlapping ranges (`overlapping`) and non-overlapping ranges (`non_overlapping`) as 0 and 1, respectively.\n\nIterate through each range, for each range, check if the start value is less than or equal to the `prev_end`. If yes, increment the count of overlapping ranges. Else, increment the count of non-overlapping ranges.\n\nUpdate the `prev_end` with the maximum value of `prev_end` and the current end value. Calculate the result by multiplying 2 to the power of the count of overlapping ranges, and return the result modulo `10^9 + 7`.\n    ",
        "tag": [
            "Array",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximize Greatness of an Array",
        "thought_question": "You are given a 0-indexed integer array `nums`. You are allowed to permute `nums` into a new array `perm` of your choosing.\n\nWe define the **greatness** of `nums` be the number of indices `0 <= i < nums.length` for which `perm[i] > nums[i]`.\n\nReturn _the **maximum** possible greatness you can achieve after permuting_ `nums`.",
        "thought_answer": "\n    ```python\ndef max_greatness(nums):\n    nums.sort()\n    greatness = 0\n    for i in range(1, len(nums)):\n        if nums[i - 1] < nums[i]:\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n            greatness += 1\n    return greatness\n```\n    \n    The algorithm consists of sorting the `nums` array in ascending order. Then, we iterate over the array from index 1 to the end. If the current element is greater than the one before it, we swap them and increase the greatness counter. This ensures that at each step, we have the maximum possible greatness for the current element. The algorithm takes advantage of the sorted array to perform permutations in a greedy manner, maximizing greatness at each step. The final result is the maximum greatness possible.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Find the Substring With Maximum Cost",
        "thought_question": "You are given a string `s`, a string `chars` of **distinct** characters and an integer array `vals` of the same length as `chars`.\n\nThe **cost of the substring** is the sum of the values of each character in the substring. The cost of an empty string is considered `0`.\n\nThe **value of the character** is defined in the following way:\n\n*   If the character is not in the string `chars`, then its value is its corresponding position **(1-indexed)** in the alphabet.\n    *   For example, the value of `'a'` is `1`, the value of `'b'` is `2`, and so on. The value of `'z'` is `26`.\n*   Otherwise, assuming `i` is the index where the character occurs in the string `chars`, then its value is `vals[i]`.\n\nReturn _the maximum cost among all substrings of the string_ `s`.",
        "thought_answer": "\n    ```python\ndef max_value_substring(s, chars, vals):\n    values = {key: val for key, val in zip(chars, vals)}\n\n    max_cost = 0\n    cost = 0\n\n    for c in s:\n        value = values.get(c) if c in values else ord(c) - ord('a') + 1\n\n        cost = max(0, cost + value)\n        max_cost = max(max_cost, cost)\n\n    return max_cost\n```\n\n    \n    1. Create a dictionary (hash_map/hash_table) to store the custom values of the characters provided in 'chars' and 'vals'.\n2. Initialize variables 'max_cost' and 'cost' to 0.\n3. Iterate through each character in the input string 's'.\n4. Inside the loop, calculate the value of the current character\n   - If it is in the custom values dictionary, use the custom value.\n   - If it is not in the custom values dictionary, use the position of the character in the alphabet (1-indexed).\n5. Update the cost by adding the value: `cost = max(0, cost + value)`. By setting it to max, we are taking into account the largest continuous substring cost.\n6. Update the max_cost with the maximum value between the current max_cost and the current cost.\n7. Return the max_cost after the loop ends.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Dynamic Programming"
        ]
    }
]
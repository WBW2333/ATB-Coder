[
    {
        "thought_name": "Burst Balloons",
        "thought_question": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.",
        "thought_answer": "\n    ```python\ndef maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Minimum Difference Between Largest and Smallest Value in Three Moves",
        "thought_question": "You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.",
        "thought_answer": "\n    ```python\ndef minDifference(nums):\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Nth Digit",
        "thought_question": "Given an integer `n`, return the `nth` digit of the infinite integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`.",
        "thought_answer": "\n    ```python\ndef findNthDigit(n):\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])\n```\n    \n    The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer.\n    ",
        "tag": [
            "Math",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Bomb Enemy",
        "thought_question": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.",
        "thought_answer": "\n    ```python\ndef maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Climbing Stairs",
        "thought_question": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
        "thought_answer": "\n    ```python\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ]
    },
    {
        "thought_name": "Missing Number",
        "thought_question": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._",
        "thought_answer": "\n    ```python\ndef missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Bit Manipulation",
            "Sorting"
        ]
    },
    {
        "thought_name": "Longest Substring with At Least K Repeating Characters",
        "thought_question": "Given a string `s` and an integer `k`, return _the length of the longest substring of_ `s` _such that the frequency of each character in this substring is greater than or equal to_ `k`.",
        "thought_answer": "\n    ```python\ndef longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    char_count = {}\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    for char, count in char_count.items():\n        if count < k:\n            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))\n    return len(s)\n```\n    \n    The algorithm starts by counting the frequency of each character in the input string `s`. If the count of any character is less than `k`, then that character cannot be part of any substring with characters having a frequency greater than or equal to `k`. Therefore, we split the input string around such characters and recursively apply the same logic on each substring. The longest substring's length across different recursive calls is returned.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Divide and Conquer",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Maximal Square",
        "thought_question": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.",
        "thought_answer": "\n    ```python\ndef maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ]
    },
    {
        "thought_name": "Longest Palindromic Substring",
        "thought_question": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.",
        "thought_answer": "\n    ```python\ndef longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "3Sum",
        "thought_question": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
        "thought_answer": "\n    ```python\ndef threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ]
    },
    {
        "thought_name": "Minimum Operations to Make Array Equal",
        "thought_question": "You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e., `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e., perform `arr[x] -=1` and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array, return _the minimum number of operations_ needed to make all the elements of arr equal.",
        "thought_answer": "\n    ```python\ndef min_operations(n):\n    return n * n // 4\n```\n    \n    This problem can be solved mathematically without iterating through the array. Since the given array is of length `n` and always has the pattern `arr[i] = (2 * i) + 1`, the average value will always be the middle value when `n` is odd, and the average of two middle values when `n` is even.\n\nIn both cases, you can calculate the number of operations needed to make all elements equal by using the following formula: `n * n / 4`. The integer division (`//` in Python) and `Math.floor()` in JavaScript are used to get the integer result of the division.\n\nFor example, for `n = 3`, the array will be `[1, 3, 5]`. The average value is `3`, and you need 2 operations to turn `1` and `5` into `3`. The formula `n * n / 4` yields `3 * 3 / 4` = `2`. Similarly, for `n = 6`, the array will be `[1, 3, 5, 7, 9, 11]`, and you need 9 operations to make all elements equal. The formula gives `6 * 6 / 4` = `9`.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Shortest Completing Word",
        "thought_question": "Given a string `licensePlate` and an array of strings `words`, find the **shortest completing** word in `words`.\n\nA **completing** word is a word that **contains all the letters** in `licensePlate`. **Ignore numbers and spaces** in `licensePlate`, and treat letters as **case insensitive**. If a letter appears more than once in `licensePlate`, then it must appear in the word the same number of times or more.\n\nFor example, if `licensePlate` `= \"aBc 12c \"`, then it contains letters `'a'`, `'b'` (ignoring case), and `'c'` twice. Possible **completing** words are `\"abccdef \"`, `\"caaacab \"`, and `\"cbca \"`.\n\nReturn _the shortest **completing** word in_ `words`_._ It is guaranteed an answer exists. If there are multiple shortest **completing** words, return the **first** one that occurs in `words`.",
        "thought_answer": "\n    ```python\ndef shortestCompletingWord(licensePlate: str, words: list[str]) -> str:\n    from collections import Counter\n\n    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n    result = \"\"\n    for word in words:\n        word_count = Counter(word)\n\n        valid = all(word_count[ch] >= count for ch, count in lp_count.items())\n\n        if valid and (not result or len(word) < len(result)):\n            result = word\n\n    return result\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ]
    },
    {
        "thought_name": "Find Closest Node to Given Two Nodes",
        "thought_question": "You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`.\n\nYou are also given two integers `node1` and `node2`.\n\nReturn _the **index** of the node that can be reached from both_ `node1` _and_ `node2`_, such that the **maximum** between the distance from_ `node1` _to that node, and from_ `node2` _to that node is **minimized**_. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`.\n\nNote that `edges` may contain cycles.",
        "thought_answer": "\n    ```python\ndef get_index_with_min_max_distance(edges, node1, node2):\n    dist1 = [-1] * len(edges)\n    dist2 = [-1] * len(edges)\n\n    dist1[node1] = 0\n    dist2[node2] = 0\n    for i in range(len(edges)):\n        if dist1[i] != -1 and edges[i] != -1:\n            if dist1[edges[i]] == -1:\n                dist1[edges[i]] = dist1[i] + 1\n            else:\n                dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1)\n\n        if dist2[i] != -1 and edges[i] != -1:\n            if dist2[edges[i]] == -1:\n                dist2[edges[i]] = dist2[i] + 1\n            else:\n                dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1)\n\n    ans = -1\n    min_max_dist = float(\"inf\")\n    for i in range(len(edges)):\n        if dist1[i] != -1 and dist2[i] != -1:\n            max_dist = max(dist1[i], dist2[i])\n            if max_dist < min_max_dist:\n                min_max_dist = max_dist\n                ans = i\n\n    return ans\n```\n    \n    We first create arrays `dist1` and `dist2` of the same size as `edges`, initialize them with `-1`, and set `dist[node1] = 0` and `dist[node2] = 0`. These arrays keep track of the shortest distances from `node1` and `node2`, respectively. Then, we iterate through the nodes in the graph, and for each node `i` that has an outgoing edge and is reachable from `node1` or `node2`, we update `dist1[edges[i]]` and `dist2[edges[i]]` to be the minimum of their current value and the distance from the previous node plus 1.\n\nFinally, we iterate through the nodes again to find the node with the minimum maximum distance from `node1` and `node2`. For each node `i` that has a valid distance from both `node1` and `node2`, we compute the maximum distance `max_dist1 = max(dist1[i], dist2[i])`. If this maximum distance is smaller than the minimum maximum distance seen so far, we update the answer to be node `i`.\n    ",
        "tag": [
            "Depth-First Search",
            "Graph"
        ]
    },
    {
        "thought_name": "Single-Row Keyboard",
        "thought_question": "There is a special keyboard with **all keys in a single row**.\n\nGiven a string `keyboard` of length `26` indicating the layout of the keyboard (indexed from `0` to `25`). Initially, your finger is at index `0`. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index `i` to index `j` is `|i - j|`.\n\nYou want to type a string `word`. Write a function to calculate how much time it takes to type it with one finger.",
        "thought_answer": "\n    ```python\ndef calculate_time(keyboard: str, word: str) -> int:\n    time = 0\n    prev_index = 0\n    char_to_index = {char: i for i, char in enumerate(keyboard)}\n\n    for c in word:\n        time += abs(char_to_index[c] - prev_index)\n        prev_index = char_to_index[c]\n\n    return time\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "tag": []
    },
    {
        "thought_name": "Rotated Digits",
        "thought_question": "An integer `x` is a **good** if after rotating each digit individually by 180 degrees, we get a valid number that is different from `x`. Each digit must be rotated - we cannot choose to leave it alone.\n\nA number is valid if each digit remains a digit after rotation. For example:\n\n*   `0`, `1`, and `8` rotate to themselves,\n*   `2` and `5` rotate to each other (in this case they are rotated in a different direction, in other words, `2` or `5` gets mirrored),\n*   `6` and `9` rotate to each other, and\n*   the rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer `n`, return _the number of **good** integers in the range_ `[1, n]`.",
        "thought_answer": "\n    ```python\ndef rotatedDigits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if isGood(i):\n            count += 1\n    return count\n\ndef isGood(num: int) -> bool:\n    changed = False\n    while num:\n        digit = num % 10\n        if digit in (3, 4, 7):\n            return False\n        if digit in (2, 5, 6, 9):\n            changed = True\n        num //= 10\n    return changed\n```\n    \n    The algorithm will use two main functions, one to check if a number is a good number (`isGood`) and the main one to count such numbers (`rotatedDigits`).\n\n1. Create a variable called `count` to store the count of good numbers.\n2. Iterate from 1 to the given number `n`.\n3. For each number, call the `isGood` function to check if it's a good number.\n4. If it is a good number, increment the `count`.\n5. The `isGood` function takes an integer as input and checks if it's a good number:\n    - Check each digit of the number while the number is greater than 0.\n    - If the digit is 3, 4 or 7, then the number is not a good number (return false).\n    - If the digit is 2, 5, 6 or 9, then the number is changed after rotation, set the `changed` flag as true.\n    - Remove the last digit of the number by dividing it by 10.\n    - If the `changed` flag is true, then the number is a good number (return true), otherwise return false.\n6. Return the `count`.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Sqrt(x)",
        "thought_question": "Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.\n\nYou **must not use** any built-in exponent function or operator.\n\n*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.",
        "thought_answer": "\n    ```python\ndef mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "tag": []
    },
    {
        "thought_name": "Second Largest Digit in a String",
        "thought_question": "Given an alphanumeric string `s`, return _the **second largest** numerical digit that appears in_ `s`_, or_ `-1` _if it does not exist_.\n\nAn **alphanumeric** string is a string consisting of lowercase English letters and digits.",
        "thought_answer": "\n    ```python\ndef second_highest(s: str) -> int:\n    largest = -1\n    second_largest = -1\n    for c in s:\n        if c.isdigit():\n            d = int(c)\n            if d > largest:\n                second_largest = largest\n                largest = d\n            elif d < largest and d > second_largest:\n                second_largest = d\n    return second_largest\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "tag": [
            "Hash Table",
            "String"
        ]
    },
    {
        "thought_name": "Generate Parentheses",
        "thought_question": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.",
        "thought_answer": "\n    ```python\ndef generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "tag": [
            "String",
            "Dynamic Programming",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Integer to Roman",
        "thought_question": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.",
        "thought_answer": "\n    ```python\ndef int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ]
    },
    {
        "thought_name": "Describe the Painting",
        "thought_question": "There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **half-closed segment** `[starti, endi)` with `colori` as the color.\n\nThe colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors.\n\n*   For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`.\n\nFor the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set.\n\nYou want to **describe** the painting with the **minimum** number of non-overlapping **half-closed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **half-closed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`.\n\n*   For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because:\n    *   `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments.\n    *   `[4,7)` is colored `{7}` from only the second segment.\n\nReturn _the 2D array_ `painting` _describing the finished painting (excluding any parts that are **not** painted). You may return the segments in **any order**_.\n\nA **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`.",
        "thought_answer": "\n    ```python\ndef splitPainting(segments):\n    line = {}\n    for s in segments:\n        start, end, color = s\n        if start not in line:\n            line[start] = 0\n        if end not in line:\n            line[end] = 0\n        line[start] += color\n        line[end] -= color\n    res = []\n    pre = 0\n    sum = 0\n    for key in sorted(line.keys()):\n        if pre > 0:\n            if sum > 0:\n                res.append([pre, key, sum])\n        pre = key\n        sum += line[key]\n    return res\n```\n    \n    The algorithm uses a sweep line approach to solve the problem. First, we traverse through the input segments, and maintain a map `line` that stores the sum of the colors at each starting and ending point of the segments. The starting points will have positive values, and the ending points will have negative values.\n\nNext, we iterate through the sorted keys (i.e., the points) of the map, and for each key, we update the sum of colors until we reach the next point. During this process, we construct the non-overlapping segments with their respective mixed color sums and add them to the result.\n\nFinally, we return the resulting 2D array containing the non-overlapping segments describing the painting. Note that the segments can be returned in any order since there is no specific requirement about the order in which they appear in the output.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Flip Game",
        "thought_question": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn all possible states of the string `currentState` after **one valid move**. You may return the answer in **any order**. If there is no valid move, return an empty list `[]`.",
        "thought_answer": "\n    ```python\ndef generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "tag": []
    },
    {
        "thought_name": "Excel Sheet Column Number",
        "thought_question": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return _its corresponding column number_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
        "thought_answer": "\n    ```python\ndef title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "tag": [
            "Math",
            "String"
        ]
    },
    {
        "thought_name": "Integer Replacement",
        "thought_question": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.",
        "thought_answer": "\n    ```python\ndef min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "tag": [
            "Dynamic Programming",
            "Greedy",
            "Bit Manipulation",
            "Memoization"
        ]
    },
    {
        "thought_name": "Minimum Time to Make Rope Colorful",
        "thought_question": "Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.\n\nAlice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.\n\nReturn _the **minimum time** Bob needs to make the rope **colorful**_.",
        "thought_answer": "\n    ```python\ndef minTime(colors: str, neededTime: List[int]) -> int:\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ",
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Remove K Digits",
        "thought_question": "Given string num representing a non-negative integer `num`, and an integer `k`, return _the smallest possible integer after removing_ `k` _digits from_ `num`.",
        "thought_answer": "\n    ```python\ndef remove_k_digits(num, k):\n    stack = []\n    for c in num:\n        while k > 0 and stack and stack[-1] > c:\n            stack.pop()\n            k -= 1\n        stack.append(c)\n    while k > 0:\n        stack.pop()\n        k -= 1\n    return ''.join(stack).lstrip('0') or '0'\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ",
        "tag": [
            "String",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Create Maximum Number",
        "thought_question": "You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n\nCreate the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the `k` digits representing the answer.",
        "thought_answer": "\n    \n```python\ndef maxNumber(nums1, nums2, k):\n    def maxArray(nums, k):\n        ans = []\n        for i, num in enumerate(nums):\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\n                ans.pop()\n            if len(ans) < k:\n                ans.append(num)\n        return ans\n\n    def merge(nums1, nums2):\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))\n```\n\n    \n    \nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "3Sum Smaller",
        "thought_question": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
        "thought_answer": "\n    ```python\ndef threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find Pivot Index",
        "thought_question": "Given an array of integers `nums`, calculate the **pivot index** of this array.\n\nThe **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn _the **leftmost pivot index**_. If no such index exists, return `-1`.",
        "thought_answer": "\n    ```python\ndef pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "tag": [
            "Array",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Count Increasing Quadruplets",
        "thought_question": "Given a **0-indexed** integer array `nums` of size `n` containing all numbers from `1` to `n`, return _the number of increasing quadruplets_.\n\nA quadruplet `(i, j, k, l)` is increasing if:\n\n*   `0 <= i < j < k < l < n`, and\n*   `nums[i] < nums[k] < nums[j] < nums[l]`.",
        "thought_answer": "\n    \n```python\ndef increasing_quadruplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n - 3):\n        for j in range(i + 1, n - 2):\n            for k in range(j + 1, n - 1):\n                if nums[i] < nums[k] and nums[k] < nums[j]:\n                    for l in range(k + 1, n):\n                        if nums[j] < nums[l]:\n                            count += 1\n    return count\n```\n\n    \n    \nWe iterate through all combinations of indices `i, j, k, l` such that `0 <= i < j < k < l < n`. For each quadruplet of indices, we check if `nums[i] < nums[k] < nums[j] < nums[l]`. If so, we increment our count of increasing quadruplets. After iterating through all possible quadruplets, we return our count.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Binary Indexed Tree",
            "Enumeration",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Maximum Average Subarray I",
        "thought_question": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
        "thought_answer": "\n    ```python\ndef findMaxAverage(nums, k):\n    n = len(nums)\n    sum_ = sum(nums[:k])\n    max_avg = sum_ / k\n    for i in range(k, n):\n        sum_ = sum_ - nums[i - k] + nums[i]\n        max_avg = max(max_avg, sum_ / k)\n    return max_avg\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "tag": [
            "Array",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Max Area of Island",
        "thought_question": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.",
        "thought_answer": "\n    ```python\ndef maxAreaOfIsland(grid):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area\n```\n    \n    The algorithm uses DFS (Depth-First Search) to iterate through each cell of the given matrix.\n1. Initialize a variable, max_area, to store the maximum area found.\n2. Define a DFS function, which receives coordinates (i, j) as arguments. \n   - If the cell at (i, j) is out of bounds or has a value of 0, return 0.\n   - Otherwise, mark the cell at (i, j) as visited by setting its value to 0.\n   - Recursively call the DFS function for the adjacent cells (above, below, left, and right) and sum their returned values. Add 1 (for the current cell) and return the result.\n3. Iterate through each cell in the matrix. If the cell contains a 1 (land), invoke the DFS function with the current coordinates.\n   - Update max_area with the maximum of its current value and the value returned by the DFS function.\n4. After the loop, return max_area as the maximum area of an island in the grid.\n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ]
    },
    {
        "thought_name": "Minimum Length of String After Deleting Similar Ends",
        "thought_question": "Given a string `s` consisting only of characters `'a'`, `'b'`, and `'c'`. You are asked to apply the following algorithm on the string any number of times:\n\n1.  Pick a **non-empty** prefix from the string `s` where all the characters in the prefix are equal.\n2.  Pick a **non-empty** suffix from the string `s` where all the characters in this suffix are equal.\n3.  The prefix and the suffix should not intersect at any index.\n4.  The characters from the prefix and suffix must be the same.\n5.  Delete both the prefix and the suffix.\n\nReturn _the **minimum length** of_ `s` _after performing the above operation any number of times (possibly zero times)_.",
        "thought_answer": "\n    ```python\ndef minimumLength(s: str) -> int:\n    if not s: return 0\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]: break\n        remove_char = s[i]\n        while i < len(s) and s[i] == remove_char: i += 1\n        while j >= 0 and s[j] == remove_char: j -= 1\n    return max(0, j - i + 1)\n```\n    \n    The algorithm involves the use of two pointers, one at the beginning and the other at the end of the string. While the characters at the positions of both pointers are the same, we increment the first pointer (i) until a different character is found in the string, and decrement the second pointer (j) until a different character is found. We then return the difference between j and i plus 1, or 0 if the result is negative, as the minimum length after performing the operations.\n    ",
        "tag": [
            "Two Pointers",
            "String"
        ]
    },
    {
        "thought_name": "Find All Duplicates in an Array",
        "thought_question": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, return _an array of all the integers that appears **twice**_.\n\nYou must write an algorithm that runs in `O(n)` time and uses only constant extra space.",
        "thought_answer": "\n    ```python\ndef find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "tag": [
            "Array",
            "Hash Table"
        ]
    },
    {
        "thought_name": "Two Sum",
        "thought_question": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.",
        "thought_answer": "\n    ```python\ndef twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "tag": [
            "Array",
            "Hash Table"
        ]
    },
    {
        "thought_name": "Sentence Screen Fitting",
        "thought_question": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.\n\nThe order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.",
        "thought_answer": "\n    ```python\ndef words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "tag": []
    },
    {
        "thought_name": "Maximum Sum of 3 Non-Overlapping Subarrays",
        "thought_question": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (**0-indexed**). If there are multiple answers, return the lexicographically smallest one.",
        "thought_answer": "\n    ```python\ndef max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Minimum Total Distance Traveled",
        "thought_question": "There are some robots and factories on the X-axis. You are given an integer array `robot` where `robot[i]` is the position of the `ith` robot. You are also given a 2D integer array `factory` where `factory[j] = [positionj, limitj]` indicates that `positionj` is the position of the `jth` factory and that the `jth` factory can repair at most `limitj` robots.\n\nThe positions of each robot are **unique**. The positions of each factory are also **unique**. Note that a robot can be **in the same position** as a factory initially.\n\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\n\n**At any moment**, you can set the initial direction of moving for **some** robot. Your target is to minimize the total distance traveled by all the robots.\n\nReturn _the minimum total distance traveled by all the robots_. The test cases are generated such that all the robots can be repaired.\n\n**Note that**\n\n*   All robots move at the same speed.\n*   If two robots move in the same direction, they will never collide.\n*   If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n*   If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n*   If the robot moved from a position `x` to a position `y`, the distance it moved is `|y - x|`.",
        "thought_answer": "\n    ```python\ndef min_total_distance(robot: List[int], factory: List[List[int]]) -> int:\n    robot.sort()\n    factory.sort()\n\n    res = 0\n    idx = 0\n    for f_pos, f_limit in factory:\n        while f_limit > 0 and idx < len(robot):\n            res += abs(f_pos - robot[idx])\n            idx += 1\n            f_limit -= 1\n    \n    return res\n```\n    \n    We sort the `robot` and `factory` arrays in ascending order. We create two variables, `res` to store the result and `idx` to keep track of the current robot index.\n\nWe loop through each factory in the sorted `factory` array. For each factory, we have a nested loop to repair the robots. We decrement the `limit` of the current factory and increment the `idx` pointer. We add the distance from the current factory to the robot to the result.\n\nFinally, we return the result `res` which represents the minimum total distance traveled by all the robots.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximum Distance Between a Pair of Values",
        "thought_question": "You are given two **non-increasing 0-indexed** integer arrays `nums1`​​​​​​ and `nums2`​​​​​​.\n\nA pair of indices `(i, j)`, where `0 <= i < nums1.length` and `0 <= j < nums2.length`, is **valid** if both `i <= j` and `nums1[i] <= nums2[j]`. The **distance** of the pair is `j - i`​​​​.\n\nReturn _the **maximum distance** of any **valid** pair_ `(i, j)`_. If there are no valid pairs, return_ `0`.\n\nAn array `arr` is **non-increasing** if `arr[i-1] >= arr[i]` for every `1 <= i < arr.length`.",
        "thought_answer": "\n    ```python\ndef maxDistance(nums1, nums2):\n    i, j, maxDist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] > nums2[j]:\n            i += 1\n        else:\n            maxDist = max(maxDist, j - i)\n            j += 1\n    return maxDist\n```\n    \n    The algorithm starts with setting both indices `i` and `j` to zero. A `maxDist` variable is initialized as zero as well. It uses a while loop to navigate through both arrays (nums1 and nums2) as long as the indices are within their respective array boundaries. It then checks whether the element at `nums1[i]` is greater than the element at `nums2[j]`, if true, it increments the index `i`. Otherwise, it updates the `maxDist` variable as the maximum between the existing maximum distance and the new distance (`j - i`), and increments the index `j`.\n\nThis algorithm works because it takes advantage of the non-increasing property of both arrays. It moves through the arrays checking each possible valid pair `(i, j)`. It moves index `i` right when the current pair is invalid and moves `j` right when a valid pair is found, updating the maximum distance when necessary.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Parallel Courses",
        "thought_question": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`.\n\nIn one semester, you can take **any number** of courses as long as you have taken all the prerequisites in the **previous** semester for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. If there is no way to take all the courses, return `-1`.",
        "thought_answer": "\n    ```python\ndef minimum_semesters(n: int, relations: List[List[int]]) -> int:\n    in_degree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev, next in relations:\n        graph[prev].append(next)\n        in_degree[next] += 1\n\n    q = [i for i in range(1, n + 1) if in_degree[i] == 0]\n    semesters = 0\n\n    while q:\n        next_q = []\n        semesters += 1\n        for course in q:\n            n -= 1\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    next_q.append(next_course)\n        q = next_q\n\n    return semesters if n == 0 else -1\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "tag": []
    },
    {
        "thought_name": "Sequential Digits",
        "thought_question": "An integer has _sequential digits_ if and only if each digit in the number is one more than the previous digit.\n\nReturn a **sorted** list of all the integers in the range `[low, high]` inclusive that have sequential digits.",
        "thought_answer": "\n    ```python\ndef sequential_digits(low, high):\n    result = []\n    for i in range(1, 10):\n        number = i\n        for j in range(i + 1, 10):\n            number = number * 10 + j\n            if low <= number <= high:\n                result.append(number)\n    return sorted(result)\n```\n    \n    The algorithm starts iterating from 1 to 9, representing the first digit of the possible sequential digits. Inside the outer loop, we initialize a new loop that starts at the next digit (i + 1). We keep adding the next digit to the number by multiplying it by 10 and then adding the digit. After each addition, we check if the number falls within the range [low, high]. If it does, we add it to our result list. Finally, we sort the resultant list and return it. The time complexity of the algorithm is O(n) where n is the range of [low, high]. The space complexity of the algorithm is O(1) as we are using a constant amount of additional space.\n    ",
        "tag": [
            "Enumeration"
        ]
    },
    {
        "thought_name": "Sort the People",
        "thought_question": "You are given an array of strings `names`, and an array `heights` that consists of **distinct** positive integers. Both arrays are of length `n`.\n\nFor each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person.\n\nReturn `names` _sorted in **descending** order by the people's heights_.",
        "thought_answer": "\n    ```python\ndef sort_names_by_height(names, heights):\n    name_height_pairs = sorted(zip(heights, names), reverse=True)\n    sorted_names = [pair[1] for pair in name_height_pairs]\n    return sorted_names\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximum Number of Non-overlapping Palindrome Substrings",
        "thought_question": "You are given a string `s` and a **positive** integer `k`.\n\nSelect a set of **non-overlapping** substrings from the string `s` that satisfy the following conditions:\n\n*   The **length** of each substring is **at least** `k`.\n*   Each substring is a **palindrome**.\n\nReturn _the **maximum** number of substrings in an optimal selection_.\n\nA **substring** is a contiguous sequence of characters within a string.",
        "thought_answer": "\n    ```python\ndef maxPalindromesSubstrings(s, k):\n    n = len(s)\n    if n < k:\n        return 0\n    count = 0\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = True\n            elif s[i] == s[j]:\n                dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]\n            else:\n                dp[i][j] = False\n            if j - i + 1 >= k and dp[i][j]:\n                count += 1\n                i = j\n                break\n    return count\n```\n    \n    To solve this problem, we can use dynamic programming. We use a 2D boolean array `dp`, where `dp[i][j]` will be `true` if the string from index `i` to `j` is a palindrome.\n\nThe main idea of the algorithm is to iterate through the string 's' and for each position, we find the longest palindrome substring starting at that position. If it is longer than or equal to length 'k' we count it and move to the next non-overlapping position. Otherwise, we continue to check the next position.\n\nHere is the procedure for each programming language:\n\n1. If `s.length < k`, there cannot be a palindrome substring of length at least k, and we return 0.\n2. Initialize a 2D boolean `dp` array with dimensions `n x n`.\n3. Loop through the string `s` in reverse order (from end to start) using index `i`. This allows us to find the longest palindrome substring starting at the current position.\n4. For each `i`, find the longest palindrome substring starting at that position using another loop with an index `j`. Here, we continuously check if the substring from position `i` to `j` is a palindrome using our `dp` array.\n5. If the current palindrome substring length (`j - i + 1`) is at least `k` and `dp[i][j]` is `true`, increment the count, and update i to j to avoid overlapping substrings.\n6. Return count.\n\nThis approach has a time complexity of O(n^2) and space complexity of O(n^2), where n is the length of string s.\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Average Value of Even Numbers That Are Divisible by Three",
        "thought_question": "Given an integer array `nums` of **positive** integers, return _the average value of all even integers that are divisible by_ `3`_._\n\nNote that the **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer.",
        "thought_answer": "\n    ```python\ndef average_even_divisible_by_three(nums):\n    total = 0\n    count = 0\n    for num in nums:\n        if num % 2 == 0 and num % 3 == 0:\n            total += num\n            count += 1\n    return total // count if count > 0 else 0\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Partition Labels",
        "thought_question": "You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn _a list of integers representing the size of these parts_.",
        "thought_answer": "\n    ```python\ndef partition_labels(s):\n    last = {c:i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n    return ans\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ",
        "tag": [
            "Hash Table",
            "Two Pointers",
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Shortest Subarray to be Removed to Make Array Sorted",
        "thought_question": "Given an integer array `arr`, remove a subarray (can be empty) from `arr` such that the remaining elements in `arr` are **non-decreasing**.\n\nReturn _the length of the shortest subarray to remove_.\n\nA **subarray** is a contiguous subsequence of the array.",
        "thought_answer": "\n    ```python\ndef findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    left, right = 0, n - 1\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n    if left == n - 1:\n        return 0\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n    result = min(n - left - 1, right)\n    i, j = 0, right\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n    return result\n```\n    \n    The algorithm starts by finding the longest non-decreasing subarray from both ends (left and right) of the array. If the left index reaches the end of the array, it means the array is already non-decreasing and we can return 0.\n\nThen, we initialize the result as the minimum of the remaining subarray lengths on the left side and the right side. We use two pointers i and j starting from the left index and the right index, respectively.\n\nWe iterate through the array and compare the values of arr[i] and arr[j]. If arr[i] <= arr[j], it means the subarray from i to j can be non-decreasing, so we update the result with the minimum length of this subarray. If arr[i] > arr[j], we increment j.\n\nWhen the loop finishes, the result is the length of the shortest subarray to remove to make the remaining elements non-decreasing.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Stack",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Plus One",
        "thought_question": "You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_.",
        "thought_answer": "\n    ```python\ndef plusOne(digits: List[int]) -> List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n\n    digits.insert(0, 1)\n    return digits\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Lonely Pixel II",
        "thought_question": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels and an integer target, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position `(r, c)` where:\n\n*   Row `r` and column `c` both contain exactly `target` black pixels.\n*   For all rows that have a black pixel at column `c`, they should be exactly the same as row `r`.",
        "thought_answer": "\n    ```python\ndef findBlackPixel(picture, target):\n    m, n = len(picture), len(picture[0])\n    rows = [0] * m\n    cols = [0] * n\n    rowCounts = {}\n    for i in range(m):\n        row = \"\"\n        for j in range(n):\n            if picture[i][j] == 'B':\n                rows[i] += 1\n                cols[j] += 1\n            row += picture[i][j]\n        if rows[i] == target:\n            rowCounts[row] = rowCounts.get(row, 0) + 1\n    ans = 0\n    for row, count in rowCounts.items():\n        if count == target:\n            for j in range(n):\n                if row[j] == 'B' and cols[j] == target:\n                    ans += count\n    return ans\n```\n    \n    1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels).\n    ",
        "tag": []
    },
    {
        "thought_name": "Optimal Partition of String",
        "thought_question": "Given a string `s`, partition the string into one or more **substrings** such that the characters in each substring are **unique**. That is, no letter appears in a single substring more than **once**.\n\nReturn _the **minimum** number of substrings in such a partition._\n\nNote that each character should belong to exactly one substring in a partition.",
        "thought_answer": "\n    ```python\ndef min_substrs(s: str) -> int:\n    seen = set()\n    count = 0\n    for c in s:\n        if c in seen:\n            count += 1\n            seen.clear()\n        seen.add(c)\n    return count + int(bool(seen))\n```\n    \n    The algorithm iterates through the characters of the input string `s`. It uses a set `seen` to store the unique characters encountered so far in the current substring. When a character is found that already exists in the set, we increment the `count` and clear the set. This indicates that a new unique substring should start. \n\nAt the end, if there are still characters left in the `seen` set, it means there is one last unique substring, so we add 1 to the count.\n\nThe time complexity of this algorithm is O(N) where N is the length of the input string, since we iterate through the input string once, and set operations (add, clear, etc.) take constant time on average.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Handshakes That Don't Cross",
        "thought_question": "You are given an **even** number of people `numPeople` that stand around a circle and each person shakes hands with someone else so that there are `numPeople / 2` handshakes total.\n\nReturn _the number of ways these handshakes could occur such that none of the handshakes cross_.\n\nSince the answer could be very large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef numberOfWays(numPeople: int) -> int:\n    MOD = 1000000007\n    dp = [0] * (numPeople // 2 + 1)\n    dp[0] = 1\n    for i in range(1, numPeople // 2 + 1):\n        for j in range(1, i + 1):\n            dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD\n    return dp[numPeople // 2]\n```\n\n    \n    The problem can be solved using dynamic programming. We can use dp[i] to represent the number of different ways i pairs of people can perform handshakes without crossing. We initialize dp[0] to 1 as there is one way to perform no handshakes.\n\nNow, we iterate from 1 to numPeople/2 inclusive. In each iteration, we consider one pair of people at a time. Suppose there are i pairs of people and the current pair to be considered is j. Then, the remaining pairs of people can be divided into two groups - one having j - 1 pairs and the other having i - j pairs. Thus, we can calculate dp[i] by using the previous values of dp[]. Specifically, dp[i] is updated as follows:\ndp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;\n\nFinally, we return dp[numPeople / 2].\n    ",
        "tag": []
    },
    {
        "thought_name": "Count of Matches in Tournament",
        "thought_question": "You are given an integer `n`, the number of teams in a tournament that has strange rules:\n\n*   If the current number of teams is **even**, each team gets paired with another team. A total of `n / 2` matches are played, and `n / 2` teams advance to the next round.\n*   If the current number of teams is **odd**, one team randomly advances in the tournament, and the rest gets paired. A total of `(n - 1) / 2` matches are played, and `(n - 1) / 2 + 1` teams advance to the next round.\n\nReturn _the number of matches played in the tournament until a winner is decided._",
        "thought_answer": "\n    ```python\ndef numberOfMatches(n: int) -> int:\n    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "tag": [
            "Math",
            "Simulation"
        ]
    },
    {
        "thought_name": "Longest Substring with At Most Two Distinct Characters",
        "thought_question": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_.",
        "thought_answer": "\n    ```python\ndef lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "tag": []
    },
    {
        "thought_name": "Two Sum Less Than K",
        "thought_question": "Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`.",
        "thought_answer": "\n    ```python\ndef max_sum_under_k(nums, k):\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Best Time to Buy and Sell Stock",
        "thought_question": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.",
        "thought_answer": "\n    ```python\ndef maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Minimum Number of Operations to Convert Time",
        "thought_question": "You are given two strings `current` and `correct` representing two **24-hour times**.\n\n24-hour times are formatted as `\"HH:MM \"`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.\n\nIn one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation **any** number of times.\n\nReturn _the **minimum number of operations** needed to convert_ `current` _to_ `correct`.",
        "thought_answer": "\n    ```python\ndef minimum_operations(current: str, correct: str) -> int:\n    ch, cm = map(int, current.split(':'))\n    th, tm = map(int, correct.split(':'))\n    ct = ch * 60 + cm\n    tt = th * 60 + tm\n\n    operations = 0\n    while ct < tt:\n        if tt - ct >= 60:\n            ct += 60\n        elif tt - ct >= 15:\n            ct += 15\n        elif tt - ct >= 5:\n            ct += 5\n        else:\n            ct += 1\n\n        operations += 1\n\n    return operations\n```\n\n    \n    The approach to solving this problem is fairly straightforward. First, we parse the input strings 'current' and 'correct' into hours and minutes. We then calculate the total minutes for both 'current' (ct) and 'correct' (tt).\n\nWe initialize a variable `operations` tokeep track of the minimum number of operations needed.\n\nUsing a while loop, we check if ct is smaller than tt indicating that we still need to perform operations. In each iteration, we choose the largest operation possible (60, 15, 5, or 1 minute(s)) based on the difference between tt and ct. After performing the operation, we increment the operations counter.\n\nThe final result is the value of the `operations` counter at the end of the loop.\n    ",
        "tag": [
            "String",
            "Greedy"
        ]
    },
    {
        "thought_name": "Valid Triangle Number",
        "thought_question": "Given an integer array `nums`, return _the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle_.",
        "thought_answer": "\n    ```python\ndef triangleNumber(nums: list) -> int:\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count\n```\n    \n    1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "Validate IP Address",
        "thought_question": "Given a string `queryIP`, return `\"IPv4 \"` if IP is a valid IPv4 address, `\"IPv6 \"` if IP is a valid IPv6 address or `\"Neither \"` if IP is not a correct IP of any type.\n\n**A valid IPv4** address is an IP in the form `\"x1.x2.x3.x4 \"` where `0 <= xi <= 255` and `xi` **cannot contain** leading zeros. For example, `\"192.168.1.1 \"` and `\"192.168.1.0 \"` are valid IPv4 addresses while `\"192.168.01.1 \"`, `\"192.168.1.00 \"`, and `\"192.168@1.1 \"` are invalid IPv4 addresses.\n\n**A valid IPv6** address is an IP in the form `\"x1:x2:x3:x4:x5:x6:x7:x8 \"` where:\n\n*   `1 <= xi.length <= 4`\n*   `xi` is a **hexadecimal string** which may contain digits, lowercase English letter (`'a'` to `'f'`) and upper-case English letters (`'A'` to `'F'`).\n*   Leading zeros are allowed in `xi`.\n\nFor example, \"`2001:0db8:85a3:0000:0000:8a2e:0370:7334 \"` and \"`2001:db8:85a3:0:0:8A2E:0370:7334 \"` are valid IPv6 addresses, while \"`2001:0db8:85a3::8A2E:037j:7334 \"` and \"`02001:0db8:85a3:0000:0000:8a2e:0370:7334 \"` are invalid IPv6 addresses.",
        "thought_answer": "\n    ```python\ndef validateIP(queryIP):\n    ipv4_parts = queryIP.split('.')\n    ipv6_parts = queryIP.split(':')\n\n    if len(ipv4_parts) == 4:\n        if is_valid_ipv4(ipv4_parts):\n            return \"IPv4\"\n    elif len(ipv6_parts) == 8:\n        if is_valid_ipv6(ipv6_parts):\n            return \"IPv6\"\n\n    return \"Neither\"\n\ndef is_valid_ipv4(parts):\n    for part in parts:\n        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):\n            return False\n\n        if not part.isdigit() or int(part) < 0 or int(part) > 255:\n            return False\n\n    return True\n\ndef is_valid_ipv6(parts):\n    for part in parts:\n        if not part or len(part) > 4:\n            return False\n\n        for ch in part:\n            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):\n                return False\n\n    return True\n```\n    \n    The algorithm checks if the given `queryIP` is an IPv4 or IPv6, then proceeds as follows:\n\n1. For IPv4, we split the input by dots '.' and validate if there are exactly 4 parts. Each part should be a string with length between 1 and 3, and should not have leading zeros. We then check if each character of the part is a digit and if the integer value of the part is between 0 and 255 inclusive.\n\n2. For IPv6, we split the input by colons ':' and validate if there are exactly 8 parts. Each part should be a string with length between 1 and 4. We then check if each character of the part is a hexadecimal digit (0-9, a-f or A-F).\n\nIf the given `queryIP` passes either of the above validations, it is considered a valid IPv4 or IPv6 address. Otherwise, it is considered \"Neither\".\n    ",
        "tag": [
            "String"
        ]
    },
    {
        "thought_name": "Largest Rectangle in Histogram",
        "thought_question": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.",
        "thought_answer": "\n    ```python\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ]
    },
    {
        "thought_name": "Number of Valid Words for Each Puzzle",
        "thought_question": "With respect to a given `puzzle` string, a `word` is _valid_ if both the following conditions are satisfied:\n\n*   `word` contains the first letter of `puzzle`.\n*   For each letter in `word`, that letter is in `puzzle`.\n    *   For example, if the puzzle is `\"abcdefg \"`, then valid words are `\"faced \"`, `\"cabbage \"`, and `\"baggage \"`, while\n    *   invalid words are `\"beefed \"` (does not include `'a'`) and `\"based \"` (includes `'s'` which is not in the puzzle).\n\nReturn _an array_ `answer`_, where_ `answer[i]` _is the number of words in the given word list_ `words` _that is valid with respect to the puzzle_ `puzzles[i]`.",
        "thought_answer": "\n    ```python\ndef find_num_of_valid_words(words, puzzles):\n    result = []\n    for puzzle in puzzles:\n        count = 0\n        puzzle_set = set(puzzle)\n        for word in words:\n            if puzzle[0] in word:\n                if all(c in puzzle_set for c in word):\n                    count += 1\n        result.append(count)\n    return result\n```\n\n    \n    We iterate through each puzzle in the given puzzles array. Then, we create a set containing all the unique characters of the current puzzle, which will be used later for checking if a word is valid with respect to the puzzle. Afterward, for each word in the words array, we check if the first letter of the puzzle is in this word. If it is, we check if all the characters in the word are present in the puzzle set. If they are, we increment the count of the valid words for the current puzzle. Finally, we append the count to our result list and move on to the next puzzle. We do this for all the puzzles, and the result list is returned.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Trie"
        ]
    },
    {
        "thought_name": "Defanging an IP Address",
        "thought_question": "Given a valid (IPv4) IP `address`, return a defanged version of that IP address.\n\nA _defanged IP address_ replaces every period `\". \"` with `\"[.] \"`.",
        "thought_answer": "\n    ```python\ndef defangIPaddr(address: str) -> str:\n    return address.replace('.', '[.]')\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "tag": [
            "String"
        ]
    },
    {
        "thought_name": "4Sum",
        "thought_question": "Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n*   `0 <= a, b, c, d < n`\n*   `a`, `b`, `c`, and `d` are **distinct**.\n*   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**.",
        "thought_answer": "\n    ```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if cur_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]: left += 1\n                    while left < right and nums[right] == nums[right + 1]: right -= 1\n                elif cur_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ]
    },
    {
        "thought_name": "Integer Break",
        "thought_question": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_.",
        "thought_answer": "\n    ```python\ndef integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Longest Line of Consecutive One in Matrix",
        "thought_question": "Given an `m x n` binary matrix `mat`, return _the length of the longest line of consecutive one in the matrix_.\n\nThe line could be horizontal, vertical, diagonal, or anti-diagonal.",
        "thought_answer": "\n    ```python\ndef longestLine(mat):\n    rows, cols = len(mat), len(mat[0])\n    max_length = 0\n    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if mat[r][c] == 1:\n                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1\n                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1\n                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1\n                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1\n                max_length = max(max_length, max(dp[r][c]))\n\n    return max_length\n```\n\n    \n    The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array.\n    ",
        "tag": []
    },
    {
        "thought_name": "Gas Station",
        "thought_question": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**",
        "thought_answer": "\n    ```python\ndef can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Maximum Sum Obtained of Any Permutation",
        "thought_question": "We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both `starti` and `endi` are _0-indexed_.\n\nReturn _the maximum total sum of all requests **among all permutations** of_ `nums`.\n\nSince the answer may be too large, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef maxSumRangeQuery(nums, requests):\n    n = len(nums)\n    count = [0] * n\n    for request in requests:\n        count[request[0]] += 1\n        if request[1] + 1 < n:\n            count[request[1] + 1] -= 1\n    for i in range(1, n):\n        count[i] += count[i - 1]\n\n    nums.sort()\n    count.sort()\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + nums[i] * count[i]) % 1000000007\n    return ans\n```\n    \n    1. Create an empty frequency count array, `count`, of the same size as `nums`.\n2. Loop through the `requests` array to update our `count` array: increment the count value on the `start` index and decrement it on the `end + 1` index, if it is less than `n`.\n3. Starting from the second index of the `count` array, update each `count` element with the sum of the current element and the previous element, i.e., compute the prefix sum.\n4. Sort both the `nums` and `count` arrays in non-decreasing order.\n5. Calculate the summation of the product of pairwise elements of two sorted arrays, modulo 1e9+7, and store it in a variable called `ans`.\n6. Return the `ans` value.\n    ",
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Count Odd Numbers in an Interval Range",
        "thought_question": "Given two non-negative integers `low` and `high`. Return the _count of odd numbers between_ `low` _and_ `high` _(inclusive)_.",
        "thought_answer": "\n    ```python\ndef count_odds(low, high):\n    return (high - low) // 2 + (1 if low % 2 == 1 or high % 2 == 1 else 0)\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Previous Permutation With One Swap",
        "thought_question": "Given an array of positive integers `arr` (not necessarily distinct), return _the_ _lexicographically_ _largest permutation that is smaller than_ `arr`, that can be **made with exactly one swap**. If it cannot be done, then return the same array.\n\n**Note** that a _swap_ exchanges the positions of two numbers `arr[i]` and `arr[j]`",
        "thought_answer": "\n    ```python\ndef prevPermOpt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            break\n    return arr\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Number of Digit One",
        "thought_question": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.",
        "thought_answer": "\n    ```python\ndef countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Recursion"
        ]
    },
    {
        "thought_name": "Minimum Split Into Subarrays With GCD Greater Than One",
        "thought_question": "You are given an array `nums` consisting of positive integers.\n\nSplit the array into **one or more** disjoint subarrays such that:\n\n*   Each element of the array belongs to **exactly one** subarray, and\n*   The **GCD** of the elements of each subarray is strictly greater than `1`.\n\nReturn _the minimum number of subarrays that can be obtained after the split_.\n\n**Note** that:\n\n*   The **GCD** of a subarray is the largest positive integer that evenly divides all the elements of the subarray.\n*   A **subarray** is a contiguous part of the array.",
        "thought_answer": "\n    ```python\ndef min_arrays(nums):\n    def gcd(a, b):\n        return a if b == 0 else gcd(b, a % b)\n\n    total_gcd = nums[0]\n    for num in nums[1:]:\n        total_gcd = gcd(total_gcd, num)\n    \n    return 2 if total_gcd == 1 else 1\n```\n    \n    The algorithm first finds the total GCD (greatest common divisor) of all the elements in the array. If the total GCD is 1, that means the array can't be split into a single subarray and satisfy the condition of having a GCD greater than 1. In this case, the minimum number of subarrays required is 2. Otherwise, if the total GCD is greater than 1, the entire array can be considered as a single subarray meeting the condition, so the answer is 1. The gcd function is a helper function that computes the GCD of two integers using the Euclidean algorithm.\n    ",
        "tag": []
    },
    {
        "thought_name": "Lonely Pixel I",
        "thought_question": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position where the same row and same column don't have **any other** black pixels.",
        "thought_answer": "\n    ```python\ndef findLonelyPixel(picture):\n    m, n = len(picture), len(picture[0])\n    row, col = [0] * m, [0] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row[i] += 1\n                col[j] += 1\n                \n    lonely = 0\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:\n                lonely += 1\n                \n    return lonely\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "tag": []
    },
    {
        "thought_name": "Maximum Product Subarray",
        "thought_question": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Count Number of Bad Pairs",
        "thought_question": "You are given a **0-indexed** integer array `nums`. A pair of indices `(i, j)` is a **bad pair** if `i < j` and `j - i != nums[j] - nums[i]`.\n\nReturn _the total number of **bad pairs** in_ `nums`.",
        "thought_answer": "\n    ```python\ndef bad_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if j - i != nums[j] - nums[i]:\n                count += 1\n    return count\n```\n    \n    The algorithm iterates through all possible pairs of indices (i, j) in the given array `nums`, where i < j. For each pair, it checks if the condition `(j - i) != (nums[j] - nums[i])` is true. If it is, it increments the counter `count`. The algorithm has a nested loop structure and its time complexity is O(n^2). Finally, it returns the total count of bad pairs found.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Counting"
        ]
    },
    {
        "thought_name": "Set Mismatch",
        "thought_question": "You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.\n\nYou are given an integer array `nums` representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return _them in the form of an array_.",
        "thought_answer": "\n    ```python\ndef findErrorNums(nums):\n    result = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n        else:\n            result.append(index + 1)\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n            break\n    return result\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Sorting"
        ]
    },
    {
        "thought_name": "Maximum Number of Robots Within Budget",
        "thought_question": "You have `n` robots. You are given two **0-indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`.\n\nThe **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots.\n\nReturn _the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed_ `budget`.",
        "thought_answer": "\n    ```python\ndef max_consecutive_robots(charge_times, running_costs, budget):\n    n = len(charge_times)\n    max_robots = 0\n    for i in range(n):\n        max_charge = 0\n        running_sum = 0\n        for j in range(i, n):\n            max_charge = max(max_charge, charge_times[j])\n            running_sum += running_costs[j]\n            cost = max_charge + running_sum * (j - i + 1)\n            if cost <= budget:\n                max_robots = max(max_robots, j - i + 1)\n            else:\n                break\n    return max_robots\n```\n    \n    1. Initialize `maxRobots` as 0\n2. Iterate from the first robot to the last robot as the starting point (`i`)\n3. Initialize `maxCharge` as 0 (to store the maximum charge cost) and `runningSum` as 0 (to store the sum of running costs)\n4. Iterate from the starting point robot to the last robot (`j`)\n5. Update `maxCharge` and `runningSum`\n6. Calculate the total cost (`cost`) by `maxCharge + runningSum * (j - i + 1)`\n7. If the total cost is less than or equal to the budget, update `maxRobots` as the maximum of `maxRobots` and `j - i + 1`\n8. If the total cost exceeds the budget, break the inner loop\n9. Continue the outer loop\n10. Return `maxRobots` as the maximum number of consecutive robots that can be run within the budget.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Prefix Sum",
            "Monotonic Queue"
        ]
    },
    {
        "thought_name": "Non-negative Integers without Consecutive Ones",
        "thought_question": "Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones.",
        "thought_answer": "\n    ```python\ndef findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "tag": [
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Unique Paths",
        "thought_question": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.",
        "thought_answer": "\n    ```python\ndef uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ]
    },
    {
        "thought_name": "Single Element in a Sorted Array",
        "thought_question": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn _the single element that appears only once_.\n\nYour solution must run in `O(log n)` time and `O(1)` space.",
        "thought_answer": "\n    ```python\ndef singleNonDuplicate(nums):\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]\n```\n    \n    The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element.\n    ",
        "tag": [
            "Array",
            "Binary Search"
        ]
    },
    {
        "thought_name": "Target Sum",
        "thought_question": "You are given an integer array `nums` and an integer `target`.\n\nYou want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n\n*   For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `\"+2-1 \"`.\n\nReturn the number of different **expressions** that you can build, which evaluates to `target`.",
        "thought_answer": "\n    ```python\ndef findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n```\n\n    \n    The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array.\n    ",
        "tag": [
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Find the Index of the First Occurrence in a String",
        "thought_question": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.",
        "thought_answer": "\n    ```python\ndef strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "tag": [
            "Two Pointers",
            "String",
            "String Matching"
        ]
    },
    {
        "thought_name": "Longest Consecutive Sequence",
        "thought_question": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time.",
        "thought_answer": "\n    ```python\ndef longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Union Find"
        ]
    },
    {
        "thought_name": "Maximum Swap",
        "thought_question": "You are given an integer `num`. You can swap two digits at most once to get the maximum valued number.\n\nReturn _the maximum valued number you can get_.",
        "thought_answer": "\n    ```python\ndef maximumSwap(num):\n    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]\n                return int(\"\".join(num_str))\n\n    return num\n```\n    \n    1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input.\n    ",
        "tag": [
            "Math",
            "Greedy"
        ]
    },
    {
        "thought_name": "String to Integer (atoi)",
        "thought_question": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
        "thought_answer": "\n    ```python\ndef myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "tag": []
    },
    {
        "thought_name": "Richest Customer Wealth",
        "thought_question": "You are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the amount of money the `i​​​​​​​​​​​th​​​​` customer has in the `j​​​​​​​​​​​th`​​​​ bank. Return _the **wealth** that the richest customer has._\n\nA customer's **wealth** is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum **wealth**.",
        "thought_answer": "\n    ```python\ndef maximumWealth(accounts):\n    max_wealth = 0\n    for customer in accounts:\n        wealth = sum(customer)\n        max_wealth = max(max_wealth, wealth)\n    return max_wealth\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "tag": [
            "Array",
            "Matrix"
        ]
    },
    {
        "thought_name": "Frequency of the Most Frequent Element",
        "thought_question": "The **frequency** of an element is the number of times it occurs in an array.\n\nYou are given an integer array `nums` and an integer `k`. In one operation, you can choose an index of `nums` and increment the element at that index by `1`.\n\nReturn _the **maximum possible frequency** of an element after performing **at most**_ `k` _operations_.",
        "thought_answer": "\n    ```python\ndef maxFrequency(nums: List[int], k: int) -> int:\n    nums.sort()\n    n, i, s, max_freq = len(nums), 0, 0, 0\n\n    for j in range(n):\n        s += nums[j]\n        while s + k < nums[j] * (j - i + 1):\n            s -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n\n    return max_freq\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize variables `n` as the length of `nums`, `i` as 0, `sum` as 0, and `max_freq` as 0.\n3. Iterate through the sorted array with index `j`.\n   a. Add each element to the `sum`.\n   b. In a while loop, if `sum + k` is less than `nums[j] * (j - i + 1)`, subtract `nums[i]` from `sum`, and increment `i`.\n   c. Update the `max_freq` by taking the maximum of the current `max_freq` and `j - i + 1`.\n4. Return the final `max_freq` as the answer.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sliding Window",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Intersection of Three Sorted Arrays",
        "thought_question": "Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays.",
        "thought_answer": "\n    ```python\ndef arraysIntersection(arr1, arr2, arr3):\n    i, j, k = 0, 0, 0\n    result = []\n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:\n            result.append(arr1[i])\n            i, j, k = i + 1, j + 1, k + 1\n        else:\n            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:\n                i += 1\n            elif arr2[j] <= arr3[k]:\n                j += 1\n            else:\n                k += 1\n    return result\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "tag": []
    },
    {
        "thought_name": "Find the Derangement of An Array",
        "thought_question": "In combinatorial mathematics, a **derangement** is a permutation of the elements of a set, such that no element appears in its original position.\n\nYou are given an integer `n`. There is originally an array consisting of `n` integers from `1` to `n` in ascending order, return _the number of **derangements** it can generate_. Since the answer may be huge, return it **modulo** `109 + 7`.",
        "thought_answer": "\n    ```python\ndef findDerangement(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n```\n    \n    To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n.\n    ",
        "tag": []
    },
    {
        "thought_name": "Palindrome Removal",
        "thought_question": "You are given an integer array `arr`.\n\nIn one move, you can select a **palindromic** subarray `arr[i], arr[i + 1], ..., arr[j]` where `i <= j`, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal.\n\nReturn _the minimum number of moves needed to remove all numbers from the array_.",
        "thought_answer": "\n    ```python\ndef minimumMoves(arr):\n    def minRemovals(i, j):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        if dp[i][j] != -1:\n            return dp[i][j]\n\n        ans = minRemovals(i + 1, j) + 1\n        for k in range(i + 1, j + 1):\n            if arr[i] == arr[k]:\n                ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j))\n        dp[i][j] = ans\n        return ans\n\n    dp = [[-1] * len(arr) for _ in range(len(arr))]\n    return minRemovals(0, len(arr) - 1)\n```\n    \n    The algorithm uses a dynamic programming approach by storing results from subproblems in the `dp` array. This reduces the number of computations required. It uses a helper function `minRemovals` to recursively compute results for subproblems.\n\n1. If `i` is greater than `j`, the subarray is empty, and no moves are needed, so return 0.\n2. If `i` is equal to `j`, the subarray has one element, which is always a palindrome, so return 1.\n3. If the current subarray has been solved before (i.e., `dp[i][j] != -1`), return the precomputed result.\n4. Initialize a variable `ans` with the value of removing subarray[i] itself and finding the remaining moves for the rest of the subarray.\n5. Loop through each element in the subarray and check for elements that are equal to the first element (arr[i]). For each matching element, find the moves using the helper function for the subarrays arr[i+1...k-1] and arr[k+1...j]. Update `ans` to the minimum of the current value of `ans` and the sum of moves found for the subarrays.\n6. Save the result in the `dp` array and return `ans`.\n7. Finally, call helper function with the initial subarray and return the result.\n    ",
        "tag": []
    },
    {
        "thought_name": "Number of Smooth Descent Periods of a Stock",
        "thought_question": "You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.\n\nA **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.\n\nReturn _the number of **smooth descent periods**_.",
        "thought_answer": "\n    ```python\ndef num_smooth_descent_periods(prices):\n    result = 0\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] == prices[i - 1] - 1:\n            count += 1\n        else:\n            count = 0\n        result += count + 1\n    return result + 1\n```\n    \n    This algorithm iterates through the `prices` array, starting at index 1. At each index `i`, it checks if the current price is equal to the previous price minus 1. If this condition is true, it means that the two prices form a smooth descent pair and `count` is incremented. If the condition is not met, it means that the path is broken, so `count` is reset to 0. The result is incremented by `count + 1` at each step, and finally incremented by 1 at the end to account for the first day in the period. The time complexity is O(n), where n is the length of the prices array.\n    ",
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Longest Repeating Character Replacement",
        "thought_question": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn _the length of the longest substring containing the same letter you can get after performing the above operations_.",
        "thought_answer": "\n    ```python\ndef characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "K-Similar Strings",
        "thought_question": "Strings `s1` and `s2` are `k`**\\-similar** (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`**\\-similar**.",
        "thought_answer": "\n    ```python\ndef kSimilarity(s1: str, s2: str) -> int:\n    k = 0\n    temp = list(s1)\n\n    for i in range(len(temp)):\n        if temp[i] != s2[i]:\n            j = i + 1\n            while temp[j] != s2[i] or s2[j] == temp[j]:\n                j += 1\n            temp[i], temp[j] = temp[j], temp[i]\n            k += 1\n\n    return k\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "tag": [
            "String",
            "Breadth-First Search"
        ]
    },
    {
        "thought_name": "Minimum Swaps to Group All 1's Together",
        "thought_question": "Given a binary array `data`, return the minimum number of swaps required to group all `1`'s present in the array together in **any place** in the array.",
        "thought_answer": "\n    ```python\ndef minSwaps(data):\n    ones = sum(data)\n    cur_ones, max_ones = 0, 0\n    for i, d in enumerate(data):\n        cur_ones += d\n        if i >= ones:\n            cur_ones -= data[i - ones]\n        max_ones = max(max_ones, cur_ones)\n    return ones - max_ones\n```\n\n    \n    First, count the number of ones in the data array. Then, use a sliding window of length equal to the count of ones to keep a running sum of ones in the window. Keep track of the maximum number of ones found in any window. The minimum number of swaps required to group all ones together equals the total number of ones minus the maximum number of ones found in any window.\n    ",
        "tag": []
    },
    {
        "thought_name": "Task Scheduler II",
        "thought_question": "You are given a **0-indexed** array of positive integers `tasks`, representing tasks that need to be completed **in order**, where `tasks[i]` represents the **type** of the `ith` task.\n\nYou are also given a positive integer `space`, which represents the **minimum** number of days that must pass **after** the completion of a task before another task of the **same** type can be performed.\n\nEach day, until all tasks have been completed, you must either:\n\n*   Complete the next task from `tasks`, or\n*   Take a break.\n\nReturn _the **minimum** number of days needed to complete all tasks_.",
        "thought_answer": "\n    ```python\ndef min_days_to_complete_tasks(tasks, space):\n    task_last_complete = {}\n    days = 0\n\n    for task in tasks:\n        if task in task_last_complete:\n            passed_days = days - task_last_complete[task]\n            if passed_days < space:\n                days += space - passed_days\n        days += 1\n        task_last_complete[task] = days\n\n    return days\n```\n    \n    The algorithm uses a hash table to keep track of the last completed day for each task type. It iterates through the given `tasks`, and for each task, it calculates the number of days passed since the last completion of the same task type. If the passed days are less than the required `space`, we add the difference to the current `days` count, simulating taking breaks until the task can be performed again. Finally, we increment the days count, as well as updating the last completed day of the task type in the hash table. The algorithm returns the total number of days needed to complete all tasks.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Simulation"
        ]
    },
    {
        "thought_name": "Last Substring in Lexicographical Order",
        "thought_question": "Given a string `s`, return _the last substring of_ `s` _in lexicographical order_.",
        "thought_answer": "\n    ```python\ndef lastSubstring(s: str) -> str:\n    maxIndex = 0\n    curIndex = 1\n    while curIndex < len(s):\n        i = 0\n        while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]:\n            i += 1\n        if curIndex + i == len(s):\n            break\n        if s[maxIndex + i] < s[curIndex + i]:\n            maxIndex = curIndex\n        curIndex += 1\n    return s[maxIndex:]\n```\n    \n    The algorithm initializes two indices, `maxIndex` and `curIndex`, both starting at the beginning of the string. We use a while loop to scan the input string until `curIndex` reaches the end.\n\nInside the loop, we check if both substrings - made with the current `maxIndex` and current `curIndex` - are lexicographically equal. If they are, we increment the \"equality\" index, `i`, until they are no longer equal or the end of the string is encountered. If the endIndex (curIndex + i) reaches the string's length, the loop ends since it's the end of the string.\n\nOtherwise, we compare `s[maxIndex + i]` and `s[curIndex + i]`. If `s[curIndex + i]` is lexicographically greater, we update `maxIndex` to the value of `curIndex`. Then, increment `curIndex`.\n\nFinally, we return the last lexicographically greater substring using the `maxIndex`.\n\nThe complexity of this solution is O(N) where N is the length of the input string.\n    ",
        "tag": [
            "Two Pointers",
            "String"
        ]
    },
    {
        "thought_name": "Increment Submatrices by One",
        "thought_question": "You are given a positive integer `n`, indicating that we initially have an `n x n` **0-indexed** integer matrix `mat` filled with zeroes.\n\nYou are also given a 2D integer array `query`. For each `query[i] = [row1i, col1i, row2i, col2i]`, you should do the following operation:\n\n*   Add `1` to **every element** in the submatrix with the **top left** corner `(row1i, col1i)` and the **bottom right** corner `(row2i, col2i)`. That is, add `1` to `mat[x][y]` for all `row1i <= x <= row2i` and `col1i <= y <= col2i`.\n\nReturn _the matrix_ `mat` _after performing every query._",
        "thought_answer": "\n    ```python\ndef apply_queries(n, queries):\n    mat = [[0] * n for _ in range(n)]\n\n    for query in queries:\n        for i in range(query[0], query[2] + 1):\n            for j in range(query[1], query[3] + 1):\n                mat[i][j] += 1\n\n    return mat\n```\n    \n    The algorithm simply initializes an n x n matrix filled with zeroes, then iterates through the `queries` list, and for each query, updates the elements in the submatrix as described in the problem statement by incrementing them by 1 in a nested loop. After the updates are made to the matrix, it is returned as the output.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Smallest Even Multiple",
        "thought_question": "Given a **positive** integer `n`, return _the smallest positive integer that is a multiple of **both**_ `2` _and_ `n`.",
        "thought_answer": "\n    ```python\ndef smallest_multiple(n):\n    return n if n % 2 == 0 else n * 2\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "tag": [
            "Math",
            "Number Theory"
        ]
    },
    {
        "thought_name": "Palindromic Substrings",
        "thought_question": "Given a string `s`, return _the number of **palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.",
        "thought_answer": "\n    ```python\ndef countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ",
        "tag": [
            "String",
            "Rolling Hash",
            "Hash Function"
        ]
    },
    {
        "thought_name": "Contiguous Array",
        "thought_question": "Given a binary array `nums`, return _the maximum length of a contiguous subarray with an equal number of_ `0` _and_ `1`.",
        "thought_answer": "\n    ```python\ndef findMaxLength(nums):\n    counts = {0: -1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counts:\n            max_len = max(max_len, i - counts[count])\n        else:\n            counts[count] = i\n    return max_len\n```\n    \n    This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Spiral Matrix",
        "thought_question": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.",
        "thought_answer": "\n    ```python\ndef spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Construct Smallest Number From DI String",
        "thought_question": "You are given a **0-indexed** string `pattern` of length `n` consisting of the characters `'I'` meaning **increasing** and `'D'` meaning **decreasing**.\n\nA **0-indexed** string `num` of length `n + 1` is created using the following conditions:\n\n*   `num` consists of the digits `'1'` to `'9'`, where each digit is used **at most** once.\n*   If `pattern[i] == 'I'`, then `num[i] < num[i + 1]`.\n*   If `pattern[i] == 'D'`, then `num[i] > num[i + 1]`.\n\nReturn _the lexicographically **smallest** possible string_ `num` _that meets the conditions._",
        "thought_answer": "\n    ```python\ndef findSmallestNum(pattern: str) -> str:\n    num = \"123456789\"\n    i = 0\n    while i < len(pattern):\n        if pattern[i] == 'D':\n            j = i\n            while j < len(pattern) and pattern[j] == 'D':\n                j += 1\n            num = num[:i] + num[i:j+1][::-1] + num[j+1:]\n            i = j\n        else:\n            i += 1\n    return num[:len(pattern) + 1]\n```\n    \n    The algorithm first initializes the `num` string to contain digits from 1 to 9. It then iterates through the `pattern` string. If it encounters a `'D'` character, it finds the stretch of consecutive `'D'` characters and reverses the corresponding stretch of numbers in `num`. If the character is `'I'`, it does nothing and moves to the next index. Finally, it returns the substring of `num` from index 0 to index `pattern.length()`, which is the result according to the provided conditions.\n    ",
        "tag": [
            "String",
            "Backtracking",
            "Stack",
            "Greedy"
        ]
    },
    {
        "thought_name": "Sum of Digits in the Minimum Number",
        "thought_question": "Given an integer array `nums`, return `0` _if the sum of the digits of the minimum integer in_ `nums` _is odd, or_ `1` _otherwise_.",
        "thought_answer": "\n    ```python\ndef sum_of_digits(nums):\n    min_val = min(nums)\n    digit_sum = sum(int(digit) for digit in str(min_val))\n    return 1 if digit_sum % 2 == 0 else 0\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "tag": []
    },
    {
        "thought_name": "Minimized Maximum of Products Distributed to Any Store",
        "thought_question": "You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type.\n\nYou need to distribute **all products** to the retail stores following these rules:\n\n*   A store can only be given **at most one product type** but can be given **any** amount of it.\n*   After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store.\n\nReturn _the minimum possible_ `x`.",
        "thought_answer": "\n    ```python\ndef minimum_maximum(n, quantities):\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x\n```\n\n    \n    - Calculate the sum of all products to be distributed.\n- Calculate an initial estimate for x by dividing the total number of products by the number of stores.\n- Initialize a remaining_stores variable to store the stores that have not been assigned products yet.\n- Iterate through each product type:\n  - Decrease remaining_stores by the number of stores needed to distribute the current product type with the current value of x.\n  - If remaining_stores becomes negative, it means x is too small. Recalculate x using the current remaining_stores and start over with remaining_stores equal to the number of stores.\n- Return x when there's no need for further adjustment.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Greedy"
        ]
    },
    {
        "thought_name": "Hexspeak",
        "thought_question": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`.",
        "thought_answer": "\n    ```python\ndef to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Kth Largest Element in an Array",
        "thought_question": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity.",
        "thought_answer": "\n    ```python\ndef findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "tag": [
            "Array",
            "Divide and Conquer",
            "Sorting",
            "Heap (Priority Queue)",
            "Quickselect"
        ]
    },
    {
        "thought_name": "Spiral Matrix II",
        "thought_question": "Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.",
        "thought_answer": "\n    ```python\ndef generateMatrix(n: int) -> List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix\n```\n    \n    The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n^2. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled.\n    ",
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ]
    },
    {
        "thought_name": "Split a String Into the Max Number of Unique Substrings",
        "thought_question": "Given a string `s`, return _the maximum number of unique substrings that the given string can be split into_.\n\nYou can split string `s` into any list of **non-empty substrings**, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are **unique**.\n\nA **substring** is a contiguous sequence of characters within a string.",
        "thought_answer": "\n    ```python\ndef maxUniqueSplit(s, start=0, seen=None):\n    if seen is None:\n        seen = set()\n    if start == len(s):\n        return 0\n    maxUnique = -1\n    for i in range(start + 1, len(s) + 1):\n        sub = s[start:i]\n        if sub not in seen:\n            seen.add(sub)\n            unique = maxUniqueSplit(s, i, seen)\n            if unique != -1:\n                maxUnique = max(maxUnique, unique + 1)\n            seen.remove(sub)\n    return maxUnique\n```\n    \n    The algorithm is a recursive backtracking algorithm. We start at the beginning of the string and iteratively build substrings from the current starting position. If the substring is not already in the set of seen substrings, we add it to the set and continue the split process for the remaining part of the string. Then we remove the substring from the set of seen substrings and continue with the next possible substring. The base case is reached when we processed the entire string, in which case we return 0 as the initial value for the split count. The final result will be the maximum number of unique substrings found during the recursive process.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Backtracking"
        ]
    },
    {
        "thought_name": "Handling Sum Queries After Update",
        "thought_question": "You are given two **0-indexed** arrays `nums1` and `nums2` and a 2D array `queries` of queries. There are three types of queries:\n\n1.  For a query of type 1, `queries[i] = [1, l, r]`. Flip the values from `0` to `1` and from `1` to `0` in `nums1` from index `l` to index `r`. Both `l` and `r` are **0-indexed**.\n2.  For a query of type 2, `queries[i] = [2, p, 0]`. For every index `0 <= i < n`, set `nums2[i] = nums2[i] + nums1[i] * p`.\n3.  For a query of type 3, `queries[i] = [3, 0, 0]`. Find the sum of the elements in `nums2`.\n\nReturn _an array containing all the answers to the third type queries._",
        "thought_answer": "\n    ```python\ndef solve(nums1, nums2, queries):\n    res = []\n    for q in queries:\n        if q[0] == 1:\n            for i in range(q[1], q[2] + 1):\n                nums1[i] ^= 1\n        elif q[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * q[1]\n        elif q[0] == 3:\n            res.append(sum(nums2))\n    return res\n```\n\n    \n    The function goes through each query in `queries` and checks the type of the query.\n- For type 1 query, it iterates from the left index `l` to the right index `r` and flips the bits in `nums1` by XORing them with 1.\n- For type 2 query, it updates the `nums2` array by adding the multiplication of `nums1[i]` and `p` to `nums2[i]` for each i in the range of `nums1`.\n- For type 3 query, it calculates the sum of the elements in `nums2` and adds it to the `res` list.\n\nFinally, the function returns the `res` list.\n    ",
        "tag": [
            "Array",
            "Segment Tree"
        ]
    },
    {
        "thought_name": "Find the Array Concatenation Value",
        "thought_question": "You are given a **0-indexed** integer array `nums`.\n\nThe **concatenation** of two numbers is the number formed by concatenating their numerals.\n\n*   For example, the concatenation of `15`, `49` is `1549`.\n\nThe **concatenation value** of `nums` is initially equal to `0`. Perform this operation until `nums` becomes empty:\n\n*   If there exists more than one number in `nums`, pick the first element and last element in `nums` respectively and add the value of their concatenation to the **concatenation value** of `nums`, then delete the first and last element from `nums`.\n*   If one element exists, add its value to the **concatenation value** of `nums`, then delete it.\n\nReturn _the concatenation value of the `nums`_.",
        "thought_answer": "\n    ```python\ndef concatenationValue(nums):\n    value = 0\n    while nums:\n        n = len(nums)\n        if n == 1:\n            value += nums[0]\n            nums.pop()\n        else:\n            value += int(str(nums[0]) + str(nums[-1]))\n            nums.pop(0)\n            nums.pop()\n    return value\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "tag": [
            "Array",
            "Two Pointers",
            "Simulation"
        ]
    },
    {
        "thought_name": "Longest Substring Without Repeating Characters",
        "thought_question": "Given a string `s`, find the length of the **longest** **substring** without repeating characters.",
        "thought_answer": "\n    ```python\ndef length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Difference Between Element Sum and Digit Sum of an Array",
        "thought_question": "You are given a positive integer array `nums`.\n\n*   The **element sum** is the sum of all the elements in `nums`.\n*   The **digit sum** is the sum of all the digits (not necessarily distinct) that appear in `nums`.\n\nReturn _the **absolute** difference between the **element sum** and **digit sum** of_ `nums`.\n\n**Note** that the absolute difference between two integers `x` and `y` is defined as `|x - y|`.",
        "thought_answer": "\n    ```python\ndef difference_between_element_and_digit_sum(nums):\n    element_sum = sum(nums)\n    digit_sum = sum(sum(int(digit) for digit in str(num)) for num in nums)\n    return abs(element_sum - digit_sum)\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Left and Right Sum Differences",
        "thought_question": "Given a **0-indexed** integer array `nums`, find a **0-indexed** integer array `answer` where:\n\n*   `answer.length == nums.length`.\n*   `answer[i] = |leftSum[i] - rightSum[i]|`.\n\nWhere:\n\n*   `leftSum[i]` is the sum of elements to the left of the index `i` in the array `nums`. If there is no such element, `leftSum[i] = 0`.\n*   `rightSum[i]` is the sum of elements to the right of the index `i` in the array `nums`. If there is no such element, `rightSum[i] = 0`.\n\nReturn _the array_ `answer`.",
        "thought_answer": "\n    ```python\ndef get_answer(nums):\n    n = len(nums)\n    left_sum, right_sum, answer = [0] * n, [0] * n, [0] * n\n\n    for i in range(1, n):\n        left_sum[i] = left_sum[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_sum[i] = right_sum[i + 1] + nums[i + 1]\n\n    for i in range(n):\n        answer[i] = abs(left_sum[i] - right_sum[i])\n\n    return answer\n```\n\n    \n    We create three arrays of the same length as `nums` called `leftSum`, `rightSum`, and `answer`. \n\nWe then iterate over the `nums` array starting from 1 and populate the `leftSum` array with the sums of elements to the left of the index i.\n\nSimilarly, we iterate over the `nums` array in reverse order (starting from the second last element) and populate the `rightSum` array with the sums of elements to the right of the index i.\n\nFinally, we iterate over the `leftSum` and `rightSum` arrays and compute the absolute difference between the corresponding elements, storing the result in the `answer` array.\n    ",
        "tag": [
            "Array",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Convert Integer to the Sum of Two No-Zero Integers",
        "thought_question": "**No-Zero integer** is a positive integer that **does not contain any `0`** in its decimal representation.\n\nGiven an integer `n`, return _a list of two integers_ `[a, b]` _where_:\n\n*   `a` and `b` are **No-Zero integers**.\n*   `a + b = n`\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.",
        "thought_answer": "\n    ```python\ndef no_zero_integers(n: int):\n    for a in range(1, n):\n        if '0' not in str(a) and '0' not in str(n - a):\n            return [a, n - a]\n    return [0, 0]  # never gets here\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Sparse Matrix Multiplication",
        "thought_question": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.",
        "thought_answer": "\n    ```python\ndef multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "tag": []
    },
    {
        "thought_name": "Merge Operations to Turn Array Into a Palindrome",
        "thought_question": "You are given an array `nums` consisting of **positive** integers.\n\nYou can perform the following operation on the array **any** number of times:\n\n*   Choose any two **adjacent** elements and **replace** them with their **sum**.\n    *   For example, if `nums = [1,2,3,1]`, you can apply one operation to make it `[1,5,1]`.\n\nReturn _the **minimum** number of operations needed to turn the array into a **palindrome**_.",
        "thought_answer": "\n    ```python\ndef minOperations(nums):\n    n = len(nums)\n    i, j = 0, n - 1\n    operations = 0\n\n    while i < j:\n        if nums[i] == nums[j]:\n            i += 1\n            j -= 1\n        elif nums[i] < nums[j]:\n            nums[i + 1] += nums[i]\n            i += 1\n            operations += 1\n        else:\n            nums[j - 1] += nums[j]\n            j -= 1\n            operations += 1\n\n    return operations\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "tag": []
    },
    {
        "thought_name": "Largest Substring Between Two Equal Characters",
        "thought_question": "Given a string `s`, return _the length of the longest substring between two equal characters, excluding the two characters._ If there is no such substring return `-1`.\n\nA **substring** is a contiguous sequence of characters within a string.",
        "thought_answer": "\n    ```python\ndef maxLengthBetweenEqualCharacters(s: str) -> int:\n    result = -1\n    char_map = {}\n\n    for i, c in enumerate(s):\n        if c not in char_map:\n            char_map[c] = i\n        else:\n            result = max(result, i - char_map[c] - 1)\n\n    return result\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "tag": [
            "Hash Table",
            "String"
        ]
    },
    {
        "thought_name": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "thought_question": "Given an array `nums` and an integer `target`, return _the maximum number of **non-empty** **non-overlapping** subarrays such that the sum of values in each subarray is equal to_ `target`.",
        "thought_answer": "\n    ```python\ndef maxNonOverlapping(nums, target):\n    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n    return count\n```\n    \n    We use the prefix sum to cumulatively store the sum of the array until the current position. On each iteration, we calculate the sum of elements and then check if the (current sum - target) exists in the prefix sum hashmap. If it exists, it means we have a subarray that sums to the target, so we update our count. We also make sure to only consider non-overlapping subarrays by storing the current max count in the hashmap.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Greedy",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Number of Closed Islands",
        "thought_question": "Given a 2D `grid` consists of `0s` (land) and `1s` (water). An _island_ is a maximal 4-directionally connected group of `0s` and a _closed island_ is an island **totally** (all left, top, right, bottom) surrounded by `1s.`\n\nReturn the number of _closed islands_.",
        "thought_answer": "\n    ```python\ndef closedIsland(grid):\n    def dfs(grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return False\n\n        if grid[i][j] == 1:\n            return True\n\n        grid[i][j] = 1\n\n        up = dfs(grid, i - 1, j)\n        down = dfs(grid, i + 1, j)\n        left = dfs(grid, i, j - 1)\n        right = dfs(grid, i, j + 1)\n\n        return up and down and left and right\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0 and dfs(grid, i, j):\n                count += 1\n\n    return count\n```\n\n    \n    The algorithm uses Depth-first Search (DFS) to traverse islands of 0s (land). If the DFS function returns false, then the current cell is on the edge and it is not a closed island. If the DFS function returns true, then the current cell is surrounded by 1s (water), and the current island is a closed island.\n\nFor each cell that contains a 0 (land), we call the DFS function to explore the island. If the DFS function returns true for all directions (up, down, left, and right), then it is a closed island. We increment the count for each closed island found.\n\nFinally, we return the total count of closed islands.\n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ]
    },
    {
        "thought_name": "Number of Islands II",
        "thought_question": "You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).\n\nWe may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [ri, ci]` is the position `(ri, ci)` at which we should operate the `ith` operation.\n\nReturn _an array of integers_ `answer` _where_ `answer[i]` _is the number of islands after turning the cell_ `(ri, ci)` _into a land_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
        "thought_answer": "\n    ```python\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:\n    def index(x: int, y: int) -> int:\n        return x * n + y\n    \n    def find(x: int) -> int:\n        if roots[x] != x:\n            roots[x] = find(roots[x])\n        return roots[x]\n\n    roots = [-1] * (m * n)\n    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    islandCount = 0\n    result = []\n\n    for i, j in positions:\n        idx = index(i, j)\n        if roots[idx] != -1:\n            result.append(islandCount)\n            continue\n        islandCount += 1\n        roots[idx] = idx\n        for dx, dy in dirs:\n            ni, nj = i + dx, j + dy\n            neighbor = index(ni, nj)\n            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:\n                root_neighbor = find(neighbor)\n                if idx != root_neighbor:\n                    roots[root_neighbor] = idx\n                    islandCount -= 1\n        result.append(islandCount)\n    return result\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "tag": []
    },
    {
        "thought_name": "Sum of Digits in Base K",
        "thought_question": "Given an integer `n` (in base `10`) and a base `k`, return _the **sum** of the digits of_ `n` _**after** converting_ `n` _from base_ `10` _to base_ `k`.\n\nAfter converting, each digit should be interpreted as a base `10` number, and the sum should be returned in base `10`.",
        "thought_answer": "\n    ```python\ndef sum_base(n: int, k: int) -> int:\n    s = 0\n    while n:\n        s += n % k\n        n //= k\n    return s\n```\n\n    \n    The algorithm is straightforward for converting a number from base 10 to base k and summing its digits. We use a while loop to repeatedly divide the number n by k, until n becomes 0. In each iteration, we add the remainder (n % k) to the sum, and update n by dividing it by k and taking the floor of the result. In the end, we return the sum.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Couples Holding Hands",
        "thought_question": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.",
        "thought_answer": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "tag": [
            "Greedy",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ]
    },
    {
        "thought_name": "Count Subarrays With Score Less Than K",
        "thought_question": "The **score** of an array is defined as the **product** of its sum and its length.\n\n*   For example, the score of `[1, 2, 3, 4, 5]` is `(1 + 2 + 3 + 4 + 5) * 5 = 75`.\n\nGiven a positive integer array `nums` and an integer `k`, return _the **number of non-empty subarrays** of_ `nums` _whose score is **strictly less** than_ `k`.\n\nA **subarray** is a contiguous sequence of elements within an array.",
        "thought_answer": "\n    ```python\ndef countSubarrays(nums: List[int], k: int) -> int:\n    n = len(nums)\n    left, right = 0, 0\n    sum_, count = 0, 0\n\n    while right < n:\n        sum_ += nums[right]\n        while sum_ * (right - left + 1) >= k:\n            sum_ -= nums[left]\n            left += 1\n        count += right - left + 1\n        right += 1\n\n    return count\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Minimum Cost to Make Array Equal",
        "thought_question": "You are given two **0-indexed** arrays `nums` and `cost` consisting each of `n` **positive** integers.\n\nYou can do the following operation **any** number of times:\n\n*   Increase or decrease **any** element of the array `nums` by `1`.\n\nThe cost of doing one operation on the `ith` element is `cost[i]`.\n\nReturn _the **minimum** total cost such that all the elements of the array_ `nums` _become **equal**_.",
        "thought_answer": "\n    ```python\ndef minCost(nums, cost):\n    ans = float(\"inf\")\n    base = min(nums)\n    \n    for target in range(base, base + 2):\n        local_res = 0\n        for i in range(len(nums)):\n            local_res += abs(nums[i] - target) * cost[i]\n        ans = min(ans, local_res)\n    \n    return ans\n```\n    \n    The algorithm starts by finding the minimum value present in the `nums` array. Then, it iterates through `target` values within the range `[base, base + 1]` because we only need to check the minimum value and potential next minimum value. For each possible `target`, calculate the local result by iterating through the elements in the `nums` array and multiplying the absolute difference between the current element and target by the corresponding cost element. Update the global minimum cost if the local result is smaller than the current global minimum.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Count Largest Group",
        "thought_question": "You are given an integer `n`.\n\nEach number from `1` to `n` is grouped according to the sum of its digits.\n\nReturn _the number of groups that have the largest size_.",
        "thought_answer": "\n    ```python\ndef countLargestGroup(n: int) -> int:\n    groups = [0] * 37\n    largest_group_size = 0\n    count_largest_groups = 0\n\n    for i in range(1, n + 1):\n        sum_of_digits = sum(map(int, str(i)))\n        groups[sum_of_digits] += 1\n        if groups[sum_of_digits] > largest_group_size:\n            largest_group_size = groups[sum_of_digits]\n            count_largest_groups = 1\n        elif groups[sum_of_digits] == largest_group_size:\n            count_largest_groups += 1\n\n    return count_largest_groups\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "tag": [
            "Hash Table",
            "Math"
        ]
    },
    {
        "thought_name": "Unique Paths II",
        "thought_question": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.",
        "thought_answer": "\n    ```python\ndef uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ]
    },
    {
        "thought_name": "Count Total Number of Colored Cells",
        "thought_question": "There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer `n`, indicating that you must do the following routine for `n` minutes:\n\n*   At the first minute, color **any** arbitrary unit cell blue.\n*   Every minute thereafter, color blue **every** uncolored cell that touches a blue cell.\n\nBelow is a pictorial representation of the state of the grid after minutes 1, 2, and 3.\n\nReturn _the number of **colored cells** at the end of_ `n` _minutes_.",
        "thought_answer": "\n    ```python\ndef number_of_colored_cells(n):\n    return n * n + (n - 1) * (n - 1)\n```\n    \n    For each minute, the boundary of colored cells expands outward in a square pattern. To get the total number of colored cells, we consider two squares - the inner square formed by the cells that were colored at minute n-1, and the outer square formed by the cells that were colored at minute n. \n\nThe inner square has dimensions (n-1)x(n-1), while the outer square has dimensions nxn. The number of colored cells is the sum of the areas of these two squares.\n\nWe compute this as `n * n + (n - 1) * (n - 1)`.\n    ",
        "tag": [
            "Math"
        ]
    },
    {
        "thought_name": "Minimum Number of Operations to Make Array Continuous",
        "thought_question": "You are given an integer array `nums`. In one operation, you can replace **any** element in `nums` with **any** integer.\n\n`nums` is considered **continuous** if both of the following conditions are fulfilled:\n\n*   All elements in `nums` are **unique**.\n*   The difference between the **maximum** element and the **minimum** element in `nums` equals `nums.length - 1`.\n\nFor example, `nums = [4, 2, 5, 3]` is **continuous**, but `nums = [1, 2, 3, 5, 6]` is **not continuous**.\n\nReturn _the **minimum** number of operations to make_ `nums` **_continuous_**.",
        "thought_answer": "\n    ```python\ndef min_operations(nums):\n    n = len(nums)\n    s = sorted(set(nums))\n    res = float('inf')\n    j = 0\n    \n    for i in range(len(s)):\n        while j < len(s) and s[j] <= s[i] + n - 1:\n            j += 1\n        res = min(res, n - (j - i))\n        \n    return res\n```\n    \n    The algorithm first finds and sorts the unique elements in the input array. Then, it performs a two-pointer iteration through the unique elements. The first pointer, `i`, iterates from the beginning to the end of the unique elements array. The second pointer, `j`, starts at the beginning and moves forward while the difference between the currently pointed elements and `n - 1` is not exceeded. The difference between the two pointers gives us the number of elements that are already continuous in the input array. The result is the minimum number of operations required to make the input array continuous. The algorithm updates the result as the min value between the previous result and `n - (j - i)` during the iterations.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sliding Window"
        ]
    },
    {
        "thought_name": "Battleships in a Board",
        "thought_question": "Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",
        "thought_answer": "\n    ```python\ndef countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "tag": [
            "Array",
            "Depth-First Search",
            "Matrix"
        ]
    },
    {
        "thought_name": "Longest Word in Dictionary",
        "thought_question": "Given an array of strings `words` representing an English Dictionary, return _the longest word in_ `words` _that can be built one character at a time by other words in_ `words`.\n\nIf there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n\nNote that the word should be built from left to right with each additional character being added to the end of a previous word.",
        "thought_answer": "\n    ```python\ndef longest_word(words):\n    built_words = set()\n    result = ''\n\n    for word in sorted(words):\n        if len(word) == 1 or word[:-1] in built_words:\n            if len(word) > len(result):\n                result = word\n            built_words.add(word)\n\n    return result\n```\n\n    \n    The algorithm starts by sorting the input list of words. Then, it initializes an empty set `built_words` to store the \"buildable\" words and an empty string `result` to keep track of the longest word found.\n\nFor each word in the sorted list, it checks if the word is buildable by having the length of 1 or its substring without the last character is in the set `built_words`. If the word is buildable, it compares its length with the current `result` and updates the `result` if the word is longer. It also adds the buildable word to the set `built_words`.\n\nAfter iterating through all the words in the list, it returns the longest buildable word found.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Trie",
            "Sorting"
        ]
    },
    {
        "thought_name": "Range Addition II",
        "thought_question": "You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.\n\nCount and return _the number of maximum integers in the matrix after performing all the operations_.",
        "thought_answer": "\n    ```python\ndef maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "tag": [
            "Array",
            "Math"
        ]
    },
    {
        "thought_name": "Maximum Length of Repeated Subarray",
        "thought_question": "Given two integer arrays `nums1` and `nums2`, return _the maximum length of a subarray that appears in **both** arrays_.",
        "thought_answer": "\n    ```python\ndef findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sliding Window",
            "Rolling Hash",
            "Hash Function"
        ]
    },
    {
        "thought_name": "Partition String Into Substrings With Values at Most K",
        "thought_question": "You are given a string `s` consisting of digits from `1` to `9` and an integer `k`.\n\nA partition of a string `s` is called **good** if:\n\n*   Each digit of `s` is part of **exactly** one substring.\n*   The value of each substring is less than or equal to `k`.\n\nReturn _the **minimum** number of substrings in a **good** partition of_ `s`. If no **good** partition of `s` exists, return `-1`.\n\n**Note** that:\n\n*   The **value** of a string is its result when interpreted as an integer. For example, the value of `\"123 \"` is `123` and the value of `\"1 \"` is `1`.\n*   A **substring** is a contiguous sequence of characters within a string.",
        "thought_answer": "\n    ```python\ndef min_partitions(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    idx = 0\n\n    while idx < n:\n        currentValue = 0\n        while idx < n and currentValue * 10 + int(s[idx]) <= k:\n            currentValue = currentValue * 10 + int(s[idx])\n            idx += 1\n\n        if currentValue == 0:\n            return -1\n        count += 1\n\n    return count\n```\n    \n    The algorithm goes through the input string `s` from left to right. We maintain a `currentValue` variable that will store the value of the substring we're currently generating. We also maintain an index `idx` variable to track the current position in the string `s`. \n\nWe loop through the string `s` with a while loop. In the inner while loop, we accumulate digits into `currentValue` until the combined value becomes larger than `k`. Once we reach the limit, we increment the `count` variable to represent a new partition and reset `currentValue`. If at any point we have `currentValue` as 0, it means that even a single digit is larger than `k`, so we return -1.\n\nOur algorithm continues in this manner, partitioning the string into substrings until we reach the end of the string `s`. The `count` variable keeps track of the minimum number of partitions in a good partition.\n    ",
        "tag": [
            "String",
            "Dynamic Programming",
            "Greedy"
        ]
    },
    {
        "thought_name": "Non-overlapping Intervals",
        "thought_question": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.",
        "thought_answer": "\n    ```python\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Sorting"
        ]
    },
    {
        "thought_name": "First Unique Character in a String",
        "thought_question": "Given a string `s`, _find the first non-repeating character in it and return its index_. If it does not exist, return `-1`.",
        "thought_answer": "\n    ```python\ndef firstUniqChar(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "tag": [
            "Hash Table",
            "String",
            "Queue",
            "Counting"
        ]
    },
    {
        "thought_name": "Maximum Product of Word Lengths",
        "thought_question": "Given a string array `words`, return _the maximum value of_ `length(word[i]) * length(word[j])` _where the two words do not share common letters_. If no such two words exist, return `0`.",
        "thought_answer": "\n    ```python\ndef maxProduct(words):\n    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n    \n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n    \n    return max_product\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "tag": [
            "Array",
            "String",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Decrease Elements To Make Array Zigzag",
        "thought_question": "Given an array `nums` of integers, a _move_ consists of choosing any element and **decreasing it by 1**.\n\nAn array `A` is a _zigzag array_ if either:\n\n*   Every even-indexed element is greater than adjacent elements, ie. `A[0] > A[1] < A[2] > A[3] < A[4] > ...`\n*   OR, every odd-indexed element is greater than adjacent elements, ie. `A[0] < A[1] > A[2] < A[3] > A[4] < ...`\n\nReturn the minimum number of moves to transform the given array `nums` into a zigzag array.",
        "thought_answer": "\n    ```python\ndef movesToMakeZigzag(nums):\n    even_moves, odd_moves = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else 1001\n        right = nums[i + 1] if i < len(nums) - 1 else 1001\n        min_value = min(left, right)\n        if nums[i] >= min_value:\n            if i % 2 == 0:\n                even_moves += nums[i] - min_value + 1\n            else:\n                odd_moves += nums[i] - min_value + 1\n    return min(even_moves, odd_moves)\n```\n    \n    The algorithm first initializes two counters: one for the number of moves for making a zigzag array starting at an even position, and another for starting at an odd position. Then, we iterate through the array and check the left and right neighbours of each element. If the current element is larger than or equal to any of its neighbours, we need to decrease it. The number of moves needed is the difference between the current element and the minimum adjacent value, plus one. Depending on the index of the element, we add the number of moves to the corresponding counter (even or odd). Finally, we return the minimum between the two counters.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Subarray Sums Divisible by K",
        "thought_question": "Given an integer array `nums` and an integer `k`, return _the number of non-empty **subarrays** that have a sum divisible by_ `k`.\n\nA **subarray** is a **contiguous** part of an array.",
        "thought_answer": "\n    ```python\ndef subarraysDivByK(nums, k):\n    prefix_sums_mod_k = [0] * k\n    prefix_sums_mod_k[0] = 1\n    running_sum = 0\n    count = 0\n    \n    for num in nums:\n        running_sum += num\n        mod = (running_sum % k + k) % k\n        count += prefix_sums_mod_k[mod]\n        prefix_sums_mod_k[mod] += 1\n    \n    return count\n```\n    \n    1. Initialize a list (or array) called `prefixSumsModK` with a size `k` and value 0. Set the first element of `prefixSumsModK` to 1.\n2. Initialize variables `runningSum` and `count` both equal to 0.\n3. Iterate through the input array `nums`.\n4. For each element, add it to `runningSum`.\n5. Calculate the modulus of `runningSum` divided by `k`. To ensure the result is positive, add `k` to the result and calculate the modulus again.\n6. Increment the count by the value at the index `mod` in the `prefixSumsModK` list.\n7. Increment the value at the index `mod` in the `prefixSumsModK` list.\n8. Return `count` after the loop.\n\nThis algorithm uses the prefix sum with mod k to efficiently count the subarrays with a sum divisible by k.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Number of Pairs Satisfying Inequality",
        "thought_question": "You are given two **0-indexed** integer arrays `nums1` and `nums2`, each of size `n`, and an integer `diff`. Find the number of **pairs** `(i, j)` such that:\n\n*   `0 <= i < j <= n - 1` **and**\n*   `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`.\n\nReturn _the **number of pairs** that satisfy the conditions._",
        "thought_answer": "\n    ```python\ndef count_pairs(nums1, nums2, diff):\n    n = len(nums1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                count += 1\n    return count\n```\n    \n    The algorithm uses a nested loop to iterate through all possible pairs `(i, j)` such that `0 <= i < j <= n - 1`. For each pair, it compares the difference in elements in `nums1` and `nums2` to check if it satisfies the given condition `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`. If the condition is satisfied, increment the count. In the end, return the count which holds the number of pairs that satisfy the conditions.\n    ",
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ]
    },
    {
        "thought_name": "Decode Ways",
        "thought_question": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
        "thought_answer": "\n    ```python\ndef numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "tag": [
            "String",
            "Dynamic Programming"
        ]
    },
    {
        "thought_name": "Count Items Matching a Rule",
        "thought_question": "You are given an array `items`, where each `items[i] = [typei, colori, namei]` describes the type, color, and name of the `ith` item. You are also given a rule represented by two strings, `ruleKey` and `ruleValue`.\n\nThe `ith` item is said to match the rule if **one** of the following is true:\n\n*   `ruleKey == \"type \"` and `ruleValue == typei`.\n*   `ruleKey == \"color \"` and `ruleValue == colori`.\n*   `ruleKey == \"name \"` and `ruleValue == namei`.\n\nReturn _the number of items that match the given rule_.",
        "thought_answer": "\n    ```python\ndef countMatches(items, ruleKey, ruleValue):\n    count = 0\n    index = {\"type\": 0, \"color\": 1, \"name\": 2}[ruleKey]\n    for item in items:\n        if item[index] == ruleValue:\n            count += 1\n    return count\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "tag": [
            "Array",
            "String"
        ]
    },
    {
        "thought_name": "Majority Element",
        "thought_question": "Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.",
        "thought_answer": "\n    ```python\ndef majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "tag": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Counting"
        ]
    },
    {
        "thought_name": "Shortest Distance to Target Color",
        "thought_question": "You are given an array `colors`, in which there are three colors: `1`, `2` and `3`.\n\nYou are also given some queries. Each query consists of two integers `i` and `c`, return the shortest distance between the given index `i` and the target color `c`. If there is no solution return `-1`.",
        "thought_answer": "\n    ```python\ndef shortestDistance(colors, queries):\n    result = []\n    positions = [[] for _ in range(3)]\n\n    for i, color in enumerate(colors):\n        positions[color - 1].append(i)\n\n    for query in queries:\n        index_positions = positions[query[1] - 1]\n\n        if not index_positions:\n            result.append(-1)\n        else:\n            dist = float('inf')\n\n            for pos in index_positions:\n                dist = min(dist, abs(pos - query[0]))\n\n            result.append(dist)\n\n    return result\n```\n    \n    The algorithm maintains a list with 3 inner lists (named `positions`), representing the positions where each color (`1`, `2`, or `3`) appear in the input list `colors`. \n\nFor each query, we get the index positions of the target color (query[1]) from the `positions` list. If there are no index positions, we append `-1` to our `result` list. Otherwise, we calculate the distance between each target color position and the index `i` given in the query by finding the absolute difference of their indices. We keep the minimum distance found, and append it to our `result` list.\n\nFinally, we return the `result` list containing the shortest distances for each query.\n    ",
        "tag": []
    },
    {
        "thought_name": "Candy",
        "thought_question": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_.",
        "thought_answer": "\n    ```python\ndef min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Maximum 69 Number",
        "thought_question": "You are given a positive integer `num` consisting only of digits `6` and `9`.\n\nReturn _the maximum number you can get by changing **at most** one digit (_`6` _becomes_ `9`_, and_ `9` _becomes_ `6`_)_.",
        "thought_answer": "\n    ```python\ndef maximum69Number(num: int) -> int:\n    num_str = list(str(num))\n    for i in range(len(num_str)):\n        if num_str[i] == '6':\n            num_str[i] = '9'\n            break\n    return int(''.join(num_str))\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "tag": [
            "Math",
            "Greedy"
        ]
    },
    {
        "thought_name": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "thought_question": "There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.",
        "thought_answer": "\n    ```python\ndef findTheCity(n, edges, distanceThreshold):\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res\n```\n\n    \n    The problem can be solved using Floyd-Warshall algorithm for finding shortest paths between all pairs of cities. First, we initialize an `n x n` distance matrix with a value larger than the maximum distance, and set the distance of each edge given in the input. The initial distance from each city to themselves is set to 0.\n\nThen we iteratively update the distance matrix using the Floyd-Warshall algorithm. To do this, we iterate over all pairs of cities (i, j), and for each pair, check if the distance through an additional city k is shorter than the current distance between i and j. If yes, we update the distance matrix entry to the shorter distance.\n\nAfter the algorithm is done, we iterate through each city and count the number of cities that are reachable within the distance threshold. If the number of reachable cities is smaller than or equal to the current smallest count, we update the smallest count and set the resulting city index to the current city index.\n\nFinally, we return the result city index.\n    ",
        "tag": [
            "Dynamic Programming",
            "Graph",
            "Shortest Path"
        ]
    },
    {
        "thought_name": "Decode XORed Permutation",
        "thought_question": "There is an integer array `perm` that is a permutation of the first `n` positive integers, where `n` is always **odd**.\n\nIt was encoded into another integer array `encoded` of length `n - 1`, such that `encoded[i] = perm[i] XOR perm[i + 1]`. For example, if `perm = [1,3,2]`, then `encoded = [2,1]`.\n\nGiven the `encoded` array, return _the original array_ `perm`. It is guaranteed that the answer exists and is unique.",
        "thought_answer": "\n    ```python\ndef decode(encoded):\n    n = len(encoded) + 1\n    total_xor = 0\n    \n    for i in range(1, n + 1):\n        total_xor ^= i\n\n    non_first_xor = 0\n    for i in range(1, n - 1, 2):\n        non_first_xor ^= encoded[i]\n\n    perm = [total_xor ^ non_first_xor]\n    for i in range(1, n):\n        perm.append(perm[-1] ^ encoded[i - 1])\n    \n    return perm\n```\n\n    \n    1. Calculate the XOR of all numbers from 1 to n, which is called `totalXor`.\n2. Calculate the XOR of all even indices of `encoded` array, which is called `nonFirstXor`.\n3. The first number in `perm` can be calculated as `totalXor ^ nonFirstXor`.\n4. Iterate through the array from 1 to n-1 to fill in the rest of the `perm` array. The value of `perm[i]` is calculated as `perm[i - 1] ^ encoded[i - 1]`.\n5. Return the `perm` array.\n    ",
        "tag": [
            "Array",
            "Bit Manipulation"
        ]
    },
    {
        "thought_name": "Super Washing Machines",
        "thought_question": "You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.",
        "thought_answer": "\n    ```python\ndef find_min_moves(machines):\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Decode String",
        "thought_question": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\n\nThe test cases are generated so that the length of the output will never exceed `105`.",
        "thought_answer": "\n    ```python\ndef decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "tag": [
            "String",
            "Stack",
            "Recursion"
        ]
    },
    {
        "thought_name": "Sum of All Odd Length Subarrays",
        "thought_question": "Given an array of positive integers `arr`, return _the sum of all possible **odd-length subarrays** of_ `arr`.\n\nA **subarray** is a contiguous subsequence of the array.",
        "thought_answer": "\n    ```python\ndef sumOddLengthSubarrays(arr):\n    sum = 0\n    n = len(arr)\n    for i in range(n):\n        oddSubarrays = ((i + 1) * (n - i) + 1) // 2\n        sum += arr[i] * oddSubarrays\n    return sum\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "tag": [
            "Array",
            "Math",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Ways to Make a Fair Array",
        "thought_question": "You are given an integer array `nums`. You can choose **exactly one** index (**0-indexed**) and remove the element. Notice that the index of the elements may change after the removal.\n\nFor example, if `nums = [6,1,7,4,1]`:\n\n*   Choosing to remove index `1` results in `nums = [6,7,4,1]`.\n*   Choosing to remove index `2` results in `nums = [6,1,4,1]`.\n*   Choosing to remove index `4` results in `nums = [6,1,7,4]`.\n\nAn array is **fair** if the sum of the odd-indexed values equals the sum of the even-indexed values.\n\nReturn the _**number** of indices that you could choose such that after the removal,_ `nums` _is **fair**._",
        "thought_answer": "\n    ```python\ndef numberOfFairs(nums):\n    even_sum = sum(nums[0::2])\n    odd_sum = sum(nums[1::2])\n    l_even = l_odd = count = 0\n    for i, num in enumerate(nums):\n        if i % 2 == 0:\n            even_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_even += num\n        else:\n            odd_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_odd += num\n    return count\n```\n    \n    1. First, find the sum of values at even indices and odd indices and store them in `even_sum` and `odd_sum` respectively.\n2. Iterate through the array with index `i`:\n   - If `i` is even, subtract the value at `i` from `even_sum`, check if `l_even` (sum of even values to the left of `i`) plus `odd_sum` equals `l_odd` (sum of odd values to the left of `i`) plus `even_sum`, and if yes, increment `count`. Then add the value at `i` to `l_even`.\n   - If `i` is odd, subtract the value at `i` from `odd_sum`, check if `l_even` plus `odd_sum` equals `l_odd` plus `even_sum`, and if yes, increment `count`. Then add the value at `i` to `l_odd`.\n3. Return `count` as the number of indices you could choose such that after the removal, nums is fair.\n    ",
        "tag": [
            "Array",
            "Prefix Sum"
        ]
    },
    {
        "thought_name": "Maximum Distance in Arrays",
        "thought_question": "You are given `m` `arrays`, where each array is sorted in **ascending order**.\n\nYou can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers `a` and `b` to be their absolute difference `|a - b|`.\n\nReturn _the maximum distance_.",
        "thought_answer": "\n    ```python\ndef maxDistance(arrays: List[List[int]]) -> int:\n    max_dist = 0\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    \n    for arr in arrays[1:]:\n        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n        \n    return max_dist\n```\n    \n    We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair.\n    ",
        "tag": [
            "Array",
            "Greedy"
        ]
    },
    {
        "thought_name": "Longest Substring with At Most K Distinct Characters",
        "thought_question": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_.",
        "thought_answer": "\n    ```python\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "tag": []
    },
    {
        "thought_name": "Count Substrings with Only One Distinct Letter",
        "thought_question": "Given a string `s`, return _the number of substrings that have only **one distinct** letter_.",
        "thought_answer": "\n    ```python\ndef count_letters(s: str) -> int:\n    count = 0\n    current = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current += 1\n        else:\n            count += (current * (current + 1)) // 2\n            current = 1\n\n    count += (current * (current + 1)) // 2\n    return count\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "tag": []
    }
]